---
title: Movil control strategy for models with memory terms 
description: In this tutorial, we show the numerical implementation of movil control strategy for two dimensional heat equation
date: 2019-10-30
author: [JesusO]
layout: pretutorial
matlab: MovilControlBlog
categories: [tutorial,WP05]
url_zip: assets/imgs/WP05/P0050/MovilControlBlog.zip
---

En este tutorial enseñaremos como implentar la estrategía del control interíor móvil para la ecuación del calor. En el ejemplo típico de control interior en la ecuación del calor se pretende llevar al sistema desde un estado inicial, $u_0$ hasta el estado nulo en todo el espacio, $\Omega$. Para ello se define una subconjunto, $\omega \in \Omega$, donde el control, $f(x,t)$ puede actuar, es decir que para puntos, $x \notin \omega$, el control es cero. Es conocido que la controlabilidad de la ecuación del calor para todo tiempo esta asegurada, sin embargo en el caso de la ecuación del calor con términos de memoria este resultado no es válido. 
 
$$
\label{eq1}
\begin{equation}
\begin{cases}
\begin{matrix}
  \dot{u} = \Delta u + f \chi_{\omega} \ & \ \textbf{x} \in \Omega & t \in [0,T] \\
  u(\textbf{x,t}) = 0    & \textbf{x} \in \partial \Omega  &  t \in [0,T] \\
  u(\textbf{x},0) = u_0  & \textbf{x} \in \Omega
\end{matrix}
\end{cases}
\end{equation}
$$

Donde $f$ es el control definido de solo en el subconjunto, $\omega \in \Omega$. 



<hr>
<table>
    <tr>
        <th>
          <center>
            <video controls width ="90%" src="{{site.url}}{{site.baseurl}}/assets/imgs/WP05/P0050/LQR_InteriorPoint_Heat_Equation.mp4"> </video>
          </center> 
        </th>
        <th>
          <center>
            <video controls width ="90%" src="{{site.url}}{{site.baseurl}}/assets/imgs/WP05/P0050/LQR_InteriorPoint_Heat_Equation_with_memory.mp4"> </video>
          </center> 
        </th>
    </tr>
    <tr>
        <th>
          <center>
              <b>Video 1:</b> Heat equation
          </center> 
        </th>
        <th>
          <center>
              <b>Video 2:</b>  Heat equation with memory
          </center> 
        </th>
    </tr> 
    <tr>
        <td  colspan="2">
          <center>
              Podemos ver la evolucion de dos modelos, con un región de control, $\X_{(a,b)}$, situado en la posición del elipsoide azul en la parte superior de la simulación. Podemos ver que el control LQR es eficaz para la ecuación del calor, sin embargo débil ante la presencia de término de memoria
          </center> 
        </td>
    </tr> 
</table>




 En problema donde el laplaciano, $\Delta$, es un laplaciano fracionario, $(-\Delta)^s$, la controlabilidad del sistema esta condicionada por la potencia, $s$; el control móvil puede ser útil. Esta estrategía puede recuperar la propiedad de controlabilidad del sistema. Este modelo se pueda iamginar como un fuente/sumidero móvil que se mueve a puntos estratégicos del espacio para estabilizar la temperatura del lugar. 

Por simplicidad, relizaremos la simulación con el laplaciano entero, sin embargo el control del laplaciano fraccionario se puede realizar de manera análoga.

Lo primero que deberemos definir es la función caracteristica del control, $\chi$ dependiente de un punto del espacio. Si trabajamos en coordenadas cartesianas podemos definir la función:

$$ W(x,a,b) = \Theta(x-a) + \Theta(x-b) \\  \{ a,b,x  \}\in \mathbb{R} \\ a>b \\$$

donde $\Theta(x)$ es la fución theta de heaviside. Un representación gráfica de $W(x,a,b)$ permiter reconocer a esta función con valor unidad entre los valores $a$ y $b$ y nulo fuera de ellos. 

<img src="{{site.url}}{{site.baseurl}}/assets/imgs/WP05/P0050/WTHETA.png" width="65%">

$$ \begin{cases} \dot{u}   = \Delta u + f\chi_{\omega(\textbf{d})}, \text{x} \in t \in [0,T]\\ \dot{\textbf{d}} = \textbf{v} \\ \dot{\textbf{v}} = \text{g} \\ \end{cases} $$

donde $u$ representa el estado 

$$
\frac{d}{dt}
    \begin{pmatrix}
      u \\
      \hline
      \textbf{d}  \\
      \hline
      \textbf{v}  \\
    \end{pmatrix}   
    =    \begin{pmatrix}
      \textbf{A}  & | &  -    & |   & - \\
      \hline
      -           & | & \textbf{0}  & | & \textbf{I}_2  \\
        \hline
      -           & | & \textbf{0} & | &\textbf{0} \\
    \end{pmatrix}
    \begin{pmatrix}
      u \\
      \hline
      \textbf{d}  \\
      \hline
      \textbf{v}  \\
    \end{pmatrix}       +    \begin{pmatrix}
      \textbf{B}(\textbf{d}) & | & -   \\
      \hline
      -          & | & \textbf{0}_2 \\
      \hline
      -          & | & \textbf{I}_2 \\
    \end{pmatrix}
    \begin{pmatrix}
      f \\
      \hline
      g
 
    \end{pmatrix}  
$$

```matlab
clear;


Ns = 8;
Nt = 5;
xline = linspace(-1,1,Ns);
yline = linspace(-1,1,Ns);

[xms,yms] = meshgrid(xline,yline);
```

## Bfunction

```matlab
xwidth = 0.35;
ywidth = 0.35;
B = @(xms,yms,xs,ys) WinWP05(xms,xs,xwidth).*WinWP05(yms,ys,ywidth);
Bmatrix =  @(xs,ys) diag(reshape(B(xms,yms,xs,ys),1,Ns^2));
```

```matlab
A = FDLaplacial2D(xline,yline);

Atotal = zeros(Ns^2+4,Ns^2+4);
Atotal(1:Ns^2,1:Ns^2) = A;

RumbaMatrixDynamics = [0 0 1 0; ...
                       0 0 0 1; ...
                       0 0 0 0; ...
                       0 0 0 0 ];

Atotal(Ns^2+1:end,Ns^2+1:end) = RumbaMatrixDynamics;
```


gaussian function in 2D

```matlab
gs = @(x,y,x0,y0,alpha) exp(-(x-x0).^2/alpha^2  - (y-y0).^2/alpha^2);

alpha = 0.1;
alphamid = 0.2;
%% We build the initial condition

U0 = + 2*gs(xms,yms,+0.25,+0.25,alpha) ...
     + 2*gs(xms,yms,+0.25,-0.25,alpha) ...
     + 2*gs(xms,yms,-0.25,-0.25,alpha);
```

```matlab
surf(xms,yms,U0);
```


![]({{site.url}}{{site.baseurl}}/assets/imgs/WP05/P0050/copiaRM_01.png)


```matlab
U0 = U0(:);
```

```matlab
T = 0.05;
tspan = linspace(0,T,Nt+1);
```

```matlab
Ysym = sym('Y',[Ns^2+4 1]);
Usym = sym('U',[Ns^2+2 1]);
FDT = @(t,X,U,Params) Atotal*X+ [Bmatrix(X(end-3),X(end-2))*U(1:end-2) ;0; 0; U(end-1:end)];

idynammics = pde(FDT,Ysym,Usym);
idynammics.mesh = {xline,yline};
idynammics.InitialCondition = [U0;0;0;0;0];
idynammics.Nt = Nt+1;
idynammics.FinalTime = T;
idynammics.Solver = @eulere;
%%
[~ , Xnum_free] = solve(idynammics);

Xnum_free = Xnum_free';
```

```matlab
opti = casadi.Opti();  %% CasADi optimization structure

%% ---- Input variables ---------
Xcas = opti.variable(Ns^2+4,Nt+1); %% state trajectory
Ucas = opti.variable(Ns^2+2,Nt+1);   %% control

%% ---- Dynamic constraints --------
Fcas = @(x,u) Atotal*x+ [Bmatrix(x(end-3),x(end-2))*u(1:end-2) ;0;0; u(end-1:end)]; %% dx/dt = f(x,u)

for k=1:Nt %% loop over control intervals
   %% Euler forward method
   x_next = Xcas(:,k) + (T/Nt)*Fcas(Xcas(:,k),Ucas(:,k));
   opti.subject_to(Xcas(:,k+1)==x_next); %% close the gaps
end

%% ---- State constraints --------
opti.subject_to(Xcas(:,1)==[U0;0.5;0.5; 0 ;0]);

HeatCas = Ucas(1:end-2,:);
Max = 1e4;
opti.subject_to(HeatCas(:) <= Max)
opti.subject_to(HeatCas(:) >= -Max)

%% ---- Optimization objective  ----------
beta = 1e-2;
%%Cost = (Xcas(1:end-4,Nt+1))'*(Xcas(1:end-4,Nt+1)) + beta*sum(sum((Ucas(1:end-2,:))'*(Ucas(1:end-2,:))));
Cost = (Xcas(1:end-4,Nt+1))'*(Xcas(1:end-4,Nt+1));

opti.minimize(Cost); %% minimizing L2 at the final time

%% ---- initial guesses for solver ---
opti.set_initial(Xcas, Xnum_free);
opti.set_initial(Ucas, 0);


%% ---- solve NLP              ------
p_opts = struct('expand',false);
s_opts = struct('acceptable_tol',1e3,'constr_viol_tol',1e-3,'compl_inf_tol',1e-3);
opti.solver('ipopt',p_opts,s_opts); %% set numerical backend
tic
sol = opti.solve();   %% actual solve
toc
```


```
This is Ipopt version 3.12.3, running with linear solver mumps.
NOTE: Other linear solvers might be more efficient (see Ipopt documentation).

Number of nonzeros in equality constraint Jacobian...:    23858
Number of nonzeros in inequality constraint Jacobian.:      768
Number of nonzeros in Lagrangian Hessian.............:      719

Total number of variables............................:      804
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:      408
Total number of inequality constraints...............:      768
        inequality constraints with only lower bounds:      384
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      384

iter    objective    inf_pr   inf_du lg(mu)  \vert\vertd\vert\vert  lg(rg) alpha_du alpha_pr  ls
   0  2.8698289e-02 5.00e-01 2.50e-04  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  3.9465117e-02 5.25e-02 1.03e-01  -1.0 1.00e+01  -4.0 9.89e-01 1.00e+00h  1
   2  2.6459139e-02 2.64e-08 2.73e-04  -1.0 2.35e+00  -4.5 9.91e-01 1.00e+00h  1
   3  2.4596415e-02 3.87e-08 5.99e-04  -1.0 4.38e+00  -5.0 1.00e+00 1.00e+00f  1
...
...
...

Number of Iterations....: 227

                                   (scaled)                 (unscaled)
Objective...............:   2.3074995023555472e-06    2.3074995023555472e-06
Dual infeasibility......:   4.8878051464110080e-08    4.8878051464110080e-08
Constraint violation....:   5.3675648722691441e-05    5.3675648722691441e-05
Complementarity.........:   1.9187414051909107e-06    1.9187414051909107e-06
Overall NLP error.......:   5.3675648722691441e-05    5.3675648722691441e-05


Number of objective function evaluations             = 375
Number of objective gradient evaluations             = 228
Number of equality constraint evaluations            = 375
Number of inequality constraint evaluations          = 375
Number of equality constraint Jacobian evaluations   = 228
Number of inequality constraint Jacobian evaluations = 228
Number of Lagrangian Hessian evaluations             = 227
Total CPU secs in IPOPT (w/o function evaluations)   =      6.393
Total CPU secs in NLP function evaluations           =      0.339

EXIT: Solved To Acceptable Level.
               t_proc [s]   t_wall [s]    n_eval
       nlp_f      0.00229      0.00226       375
       nlp_g        0.067       0.0428       375
  nlp_grad_f       0.0025      0.00251       229
  nlp_hess_l       0.0464       0.0411       227
   nlp_jac_g        0.202        0.175       229
      solver         7.02         5.23         1
Elapsed time is 5.290691 seconds.

```

```matlab
Xnum_with_control = sol.value(Xcas);
```

## interpolation in time

```matlab
AnimationMovilControl(Xnum_with_control,Xnum_free,tspan,xline,yline,Bmatrix)
```


![]({{site.url}}{{site.baseurl}}/assets/imgs/WP05/P0050/copiaRM_02.png)

