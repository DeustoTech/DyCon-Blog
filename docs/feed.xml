<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DyCon Blog</title>
    <description>Welcome to the web interface of DyCon Toolbox, the computational platform developed within the &lt;a href='https://cmc.deusto.eus/dycon/' target='_blank'&gt;ERC DyCon - Dynamic Control&lt;/a&gt; project.</description>
    <link>https://deustotech.github.io/DyCon-Blog/</link>
    <atom:link href="https://deustotech.github.io/DyCon-Blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 27 May 2019 12:39:18 +0200</pubDate>
    <lastBuildDate>Mon, 27 May 2019 12:39:18 +0200</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Optimal control of the obstacle problem</title>
        <description>asda
</description>
        <pubDate>Mon, 08 Jul 2019 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0031</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0031</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Rotors imbalance suppression by optimal control</title>
        <description>asda
</description>
        <pubDate>Mon, 08 Jul 2019 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0029</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0029</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Controllability to steady states of a reaction diffusion system and emergence of barriers.</title>
        <description>asda
</description>
        <pubDate>Fri, 05 Jul 2019 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0028</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0028</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Sparse sources identification through adjoint localization algorithm</title>
        <description>asda
</description>
        <pubDate>Fri, 14 Jun 2019 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0027</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0027</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Controllability of a Class of Infinite Dimensional Systems with Age Structure</title>
        <description>asda
</description>
        <pubDate>Fri, 07 Jun 2019 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0030</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0030</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>REVISION del post Finite element approximation of the 1-D fractional Poisson equation</title>
        <description>asda
</description>
        <pubDate>Fri, 07 Jun 2019 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0024</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0024</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Propagation of one and two-dimensional discrete waves under finite difference approximation</title>
        <description>asda
</description>
        <pubDate>Fri, 31 May 2019 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0023</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0023</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Controllability of the one-dimensional fractional heat equation under positivity constraints</title>
        <description>asda
</description>
        <pubDate>Fri, 31 May 2019 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0022</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0022</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Optimal strategies for guidance-by-repulsion model with IpOpt and AMPL</title>
        <description>A sample result



This video describes an optimal control steering red dots(evaders) to the position $(4,4)$, which is calculated by IpOpt with AMPL. See the post explaining IpOpt and AMPL for detailed description.

The guidance-by-repulsion model

Let $u_{ei}$ and $u_{dj}$ be the positions of the evaders $(i=1,\ldots,N)$ and drivers $(j=1,\ldots,M)$, respectively, in ${\mathbb R}^2$. We consider the following ODE system:







where $\kappa_j(t)$ is the control interface and the interaction functions are given by



In the dynamics, the evaders always get forced from all of the drivers, while the drivers wants to keep a stable distance ($f_d(1)-f_e(1)=0$). By choosing proper $\kappa_j(t)$, we wants to steer the evaders into a predetermined region.

The objective of the control is given by the cost function with the fixed final time $t_f&amp;gt;0$,



where $\delta_1$ is a regularization coefficient, $0.1$ in this post.

AMPL code for solving the optimal control problem

Let us explain an AMPL code step by step. First, we need to set relative parameters.
# GBR_fixedtime.mod

# This file solves the Guidance-by-repulsion model with 2 drivers and 16 evaders to 

# the target point [4;4] in a fixed final time T=10.

# Define the parameters of the problem

param pi      = 3.141592653589793238462643; 

param Nt      = 100;      # number of discretized points in time

param M_sqrt  = 4;        # sqrt of Number of evaders

param M_e     = M_sqrt^2; # Number of evaders

param M_d     = 2;        # Number of drivers

param T       = 10;

param M_kappa = 5;        # Bound on the control

# Target point

param uf1 = 4;
param uf2 = 4;


For the initial condition, we use uniform distribution of evaders in a square $[-1,1]\times[-1,1]$, and the drivers are in a circle with radius $5$.
# Initial values

param ue_zero {k in 1..M_e, j in 1..2};
for {k1 in 1..M_sqrt, k2 in 1..M_sqrt, j in 1..2} {
	let ue_zero[M_sqrt*(k1-1)+k2,1] := ((k1-1)/(M_sqrt-1))*2-1;
	let ue_zero[M_sqrt*(k1-1)+k2,2] := ((k2-1)/(M_sqrt-1))*2-1;
}
param ud_zero {l in 1..M_d, j in 1..2};
for {l in 1..M_d, j in 1..2} {
	let ud_zero[l,1] := 5*cos(2*pi/M_d*(l-1));
	let ud_zero[l,2] := 5*sin(2*pi/M_d*(l-1));
}

# State variables

var ue {k in 1..M_e, i in 0..Nt, j in 1..2};
var ve {k in 1..M_e, i in 0..Nt, j in 1..2};
var ud {l in 1..M_d, i in 0..Nt, j in 1..2};
var vd {l in 1..M_d, i in 0..Nt, j in 1..2};
var uec {i in 0..Nt, j in 1..2} = 1/M_e*(sum {k in 1..M_e} (ue[k,i,j]));

# initialize

subject to ue_init {k in 1..M_e, j in 1..2} : ue[k,0,j] = ue_zero[k,j];
subject to ud_init {l in 1..M_d, j in 1..2} : ud[l,0,j] = ud_zero[l,j];
subject to vd_init {k in 1..M_e, j in 1..2} : ve[k,0,j] = 0;
subject to ve_init {l in 1..M_d, j in 1..2} : vd[l,0,j] = 0;  
let {k in 1..M_e, i in 0..Nt, j in 1..2} ue[k,i,j] := ue_zero[k,j];
let {l in 1..M_d, i in 0..Nt, j in 1..2} ud[l,i,j] := ud_zero[l,j];
let {k in 1..M_e, i in 0..Nt, j in 1..2} ve[k,i,j] := 0;
let {l in 1..M_d, i in 0..Nt, j in 1..2} vd[l,i,j] := 0;   

For the initial guess, we also put the initial data for the whole timeline. If we don’t specify this, then the default values are zero, which can make redundant errors or iterations.

Now, we define the controls and cost.
# The control function

var kappa {l in 1..M_d, i in 0..Nt}, default 2.8;  
subject to kappa_bounds {l in 1..M_d, i in 0..Nt} : -M_kappa &amp;lt;= kappa[l,i] &amp;lt;= M_kappa;
# initial guess on control

let {l in 1..M_d, i in 0..Nt} kappa[l,i] := 2.8;

# The cost function

minimize cost: 
 1/M_e*(sum {k in 1..M_e} ((ue[k,Nt+1,1]-uf1)^2+(ue[k,Nt+1,2]-uf2)^2)) + 0.1/M_d/(Nt+1)*( sum {l in 1..M_d, i in 0..Nt} (( kappa[l,i]^2)) );

The dynamics need to be described in the form of restriction condition of states and control variables. In order to avoid divide-by-zero, we additionally put the restriction on the distance. Since our equation has unbounded interaction kernels, it is convenient to use Euler’s forward method. Backward or central method may result unexpected high velocities by closing to the infinite values.
# Restriction on distance

subject to distance {k in 1..M_e, l in 1..M_d, i in 0..Nt} :
		(ue[k,i,1]-ud[l,i,1])^2+(ue[k,i,2]-ud[l,i,2])^2 &amp;gt;= 0.001;
# Dynamics

subject to ue_dyn {k in 1..M_e, i in 0..Nt-1, j in 1..2} :
		(ue[k,i+1,j]-ue[k,i,j])*Nt/T = ve[k,i,j];
subject to ud_dyn {l in 1..M_d, i in 0..Nt-1, j in 1..2} :
		(ud[l,i+1,j]-ud[l,i,j])*Nt/T = vd[l,i,j];
subject to ve_dyn {k in 1..M_e, i in 0..Nt-1, j in 1..2} :
		(ve[k,i+1,j]-ve[k,i,j])*Nt/T = sum {l in 1..M_d} ( -2/((ud[l,i,1] - ue[k,i,1])^2+(ud[l,i,2] - ue[k,i,2])^2)*(ud[l,i,j] - ue[k,i,j]) )  - 2*ve[k,i,j];
subject to vd1_dyn {l in 1..M_d, i in 0..Nt-1} :
		(vd[l,i+1,1]-vd[l,i,1])*Nt/T = (-5.5/((ud[l,i,1] - uec[i,1])^2+(ud[l,i,2] - uec[i,2])^2)+10/(((ud[l,i,1] - uec[i,1])^2+(ud[l,i,2] - uec[i,2])^2)^2) -2)*(ud[l,i,1] - uec[i,1]) + kappa[l,i] * (-(ud[l,i,2]-uec[i,2])) - 2*vd[l,i,1];
subject to vd2_dyn {l in 1..M_d, i in 0..Nt-1} :
		(vd[l,i+1,2]-vd[l,i,2])*Nt/T = (-5.5/((ud[l,i,1] - uec[i,1])^2+(ud[l,i,2] - uec[i,2])^2)+10/(((ud[l,i,1] - uec[i,1])^2+(ud[l,i,2] - uec[i,2])^2)^2) -2)*(ud[l,i,2] - uec[i,2]) + kappa[l,i] * ((ud[l,i,1]-uec[i,1])) - 2*vd[l,i,2];

The next step is to solve and get the output. It is convenient to describe the parameters of the problem to visualize later.
# Solve with IpOpt

option solver ipopt;
option ipopt_options &quot;max_iter=20000 linear_solver=mumps hessian_approximation=limited-memory halt_on_ampl_error yes&quot;;
solve;
# Display solution

printf : &quot;%24.16e\n&quot;, T;
printf : &quot;%d\n&quot;, Nt;
printf : &quot;%d\n&quot;, M_d;
printf : &quot;%d\n&quot;, M_e;
printf : &quot;%24.16e\n&quot;, uf1;
printf : &quot;%24.16e\n&quot;, uf2;

printf {l in 1..M_d, i in 0..Nt} : &quot;%24.16e\n&quot;, kappa[l,i];
printf {k in 1..M_e, i in 0..Nt, j in 1..2} : &quot;%24.16e\n&quot;, ue[k,i,j];
printf {l in 1..M_d, i in 0..Nt, j in 1..2} : &quot;%24.16e\n&quot;, ud[l,i,j];
printf {k in 1..M_e, i in 0..Nt, j in 1..2} : &quot;%24.16e\n&quot;, ve[k,i,j];
printf {l in 1..M_d, i in 0..Nt, j in 1..2} : &quot;%24.16e\n&quot;, vd[l,i,j];
printf : &quot;End. \n&quot;;
end;



Finally, we used MATLAB to show the trajectories. After copying the result to a file ‘output.txt’, we read it with the following code.

fid= fopen('output.txt','r');            % Open out.txt
temp = fscanf(fid,'%f');
M_d = 2; M_e = 9; index1 = 1;
T = temp(index1); index1 = index1+1;
Nt = temp(index1); index1 = index1+1;
M_d = temp(index1); index1 = index1+1;
M_e = temp(index1); index1 = index1+1;
uf1 = temp(index1); index1 = index1+1;
uf2 = temp(index1); index1 = index1+1; index2 = index1+M_d*(Nt+1)-1;
kappa = temp(index1:index2); kappa = reshape(kappa, [Nt+1 M_d]); index1 = index2+1; index2 = index1+2*(Nt+1)*M_e-1;
ue = temp(index1:index2); ue = reshape(ue, [2 Nt+1 M_e]); index1 = index2+1; index2 = index1+2*(Nt+1)*M_d-1;
ud = temp(index1:index2); ud = reshape(ud, [2 Nt+1 M_d]); index1 = index2+1; index2 = index1+2*(Nt+1)*M_e-1;
ve = temp(index1:index2); ve = reshape(ve, [2 Nt+1 M_e]); index1 = index2+1; index2 = index1+2*(Nt+1)*M_d-1;
vd = temp(index1:index2); vd = reshape(vd, [2 Nt+1 M_d]); 
index2 == length(temp)      % Check the file is properly read.
tline = linspace(0,T,Nt+1);

fclose(fid);


%% Cost calculation

u_f = [uf1;uf2];
Final_Time = tline(end);
Final_Position = reshape(ue(:,end,:),[2 M_e]);
Final_cost = sum( (Final_Position(1,:) - u_f(1)).^2+(Final_Position(2,:) - u_f(2)).^2 )/M_e;
Running_cost = 0.001*trapz(tline,mean(kappa(:,1:M_d).^2,2))/M_d;

%% Visualize the trajectories

f1 = figure('position', [0, 0, 1000, 400]);
subplot(1,2,1)
hold on
for k = 1:M_d
	plot(ud(1,:,k),ud(2,:,k),'b--','LineWidth',1.3);
end
for l = 1:M_e
	plot(ue(1,:,l),ue(2,:,l),'r-','LineWidth',1.5);
end
xlabel('abscissa')
ylabel('ordinate')
title(['Position error = ', num2str(Final_cost)])
grid on


Then, one can get the following trajectories and optimal control solution.



subplot(1,2,2)
plot(tline,kappa','LineWidth',1.3);
xlabel('Time')
ylabel('Control \kappa(t)')
title(['Total Time = ',num2str(tline(end)),' and running cost = ',num2str(Running_cost)])
grid on



</description>
        <pubDate>Mon, 27 May 2019 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0026</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0026</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Reconstruction of traffic state using autonomous vehicles</title>
        <description>A coupled PDE-ODE model
We consider the following hybrid PDE-ODE model



Above, (1a) and (1b) consists  of  a  scalar  conservation proposed by Lighthill-Whitham-Richards law  modeling  the  evolution  of vehicular traffic. (1c) and (1d) represent the trajectory of autonomous vehicles.  stands for the density of cars and  the flux function  is defined by  with the average speed .

We assume that  is an unknown function and our goal is to find a time  at which it is possible to reconstruct the true density  between two autonomous vehicles based only on the measured local density of each autonomous vehicle.

We introduce the two following operators

   is the solution of (1a) at time  and at the position  with initial density 
   where  is the solution of (1) with initial data .



  
    
      
       
       
       
       
       
      
    
  
  
    
      Figure 1.1 -  if  and  if  with two autonomous vehicles positioned at  and .
       
       
       
       
       
      Figure 1.2 -  if  and  if  and  if  with two connected vehicles positioned at  and 
    
  


In Figure 1.1 and Figure 1.2, we construct two initial data  and  such that  and for every  , for every  , . Thus, there isn’t backward uniqueness from the trajectory of autonomous vehicles.


  
    
      
    
  
  
    
      Figure 1.3  if  and  if  with two autonomous vehicles positioned at $x=8$ and $x=12$ respectively
    
  


In Figure Figure 1.3, we cannot reconstruct the traffic state at any time using data collected by the two autonomous vehicles. Some additional conditions on the set of initial densities will be require.

Theorem Let  and we assume that for every , .  For every  there exists  such that for every  and  for almost every  we have 


The reconstruction time  is obtained using the notion of generalized characteristics and  has an implicit form.

Numerical simulations
In  Figure 2.1 and  Figure 2.2, we consider the example of two shocks with a fan of rarefaction shocks between the two shocks. A total of three AVs, denoted  by  ,  and  , are used to reconstruct the traffic state resulting in two regions of reconstruction between  and  , and between  and  . Specifically, the initial density  is defined as follows : $\rho_0(x) = 0.0938 $ for $ x\in (-\infty, 8] $, $\rho_0(x) = 0.9062$ for ,  for $x\in (10, 13]$ and $\rho_0(x) = 0.9062$ for .  ,  , and  start at  ,  , and  , respectively. The resulting traffic state solved using wave front tracking over the first 20 seconds is shown in Figure 2.1, while the reconstructed state between the AVs is shown in Figure 2.2. The time at which the reconstruction becomes valid is  between  and , and  between  and .


  
    
      
      
    
  
  
    
      Figure 2.1
      Figure 2.2
    
  


In  Figure 3.1 and Figure 3.2, one autonomous vehicle, denoted by  , is deployed on a ring. The initial density  is a -periodic function  defined as follows:   for  ,  for  . Since  and  are also  periodic functions, both trajectories plotted in red in  Figure 3.2  are  the ones of . The traffic state on the whole ring can be reconstructed after .


  
    
      
      
    
  
  
    
      Figure 3.1
      Figure 3.2
    
  


References
[1] T.Liard, B. Piccoli, R. Stern, D. Work. Traffic reconstruction using autonomous vehicles; submitted (2019)
</description>
        <pubDate>Fri, 24 May 2019 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0032</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/WP99-P0032</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
  </channel>
</rss>
