<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DyCon Blog</title>
    <description>Welcome to the web interface of DyCon Toolbox, the computational platform developed within the &lt;a href='https://cmc.deusto.eus/dycon/' target='_blank'&gt;ERC DyCon - Dynamic Control&lt;/a&gt; project.</description>
    <link>https://deustotech.github.io/DyCon-Blog/</link>
    <atom:link href="https://deustotech.github.io/DyCon-Blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 25 Mar 2019 10:54:35 +0100</pubDate>
    <lastBuildDate>Mon, 25 Mar 2019 10:54:35 +0100</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>An introduction to the moment method for optimal control problems for polynomial ODEs</title>
        <description>The aim of this note is to explain how one can solve an optimal control problem with the moment method. While the theory is collected in [1], we will explain how one is able to use the Globtipoly toolbox, which is a powerful toolbox able to solve many other problems. This toolbox is available in http://homepages.laas.fr/henrion/software/gloptipoly3/. A more detailed documentation is provided in this link, if you are insterested in other applications than the optimal control problem.

The use of this toolbox needs a proper installation either of Sedumi or the Mosek solvers, which are toolboxes instrumental to solve numerically SDP (Semidefinite Program) problems, i.e. optimization problems expressed with LMI (Linear Matrix Inequalities) constraints.

This note does not aim at explaining all the details of the toolbox Globtipoly, since there exists already the paper [2] which introduces really well the problem. It does not aim neither at introducing in details the moment framework developed by Jean Bernard Lasserre and Didier Henrion, which is much more general than the optimal control problem framework. In this note, we just give a simple example to explain how this method can be used in the context of optimal control (especially for ODEs). Thanks to the recent paper [3], we also think that this framework might also work for optimal control of PDEs.

FRAMEWORK

We focus on the following ordinary differential equations:



where $x$ belongs to a subset $X$ of $\mathbb{R}^n$ and $u$ to a subset $U$ of $\mathbb{R}^m$. We assume that $f$ is a polynomial of $x$ and $u$. Moreover, we assume that $X$ and $U$ can be written with finitely many polynomial inequalities. The Gloptipoly toolbox allows to solve the following kind of optimal control problem:



where $X_T$ is also a subset of $\mathbb{R}^n$ defined with finitely many polynomial inequalities and $l$ is also a polynomial in the variables $x$ and $u$.

A SIMPLER EXAMPLE AS A MOTIVATION

We focus on a specific example to make the reading of thenote easier. We have



$u\in\mathbb{R}$ and:



It is a simple chain of integrators, really well-known in automatic control theory. As described in [1], the related system can be equivalently rewritten as follows:



where $g$ is any test function in $C^1(X)$, $\mu_1(x)$ is a measure supported on a compact set $K_1$ representing the constraints on $x$ and $u$, $\mu_2(x)=$ is supported on a given compact set $K_2$ corresponding to performance requirements. For example $K_2 = 0$ indicates that state $x$ must reach the origin.

The approximation provided by Gloptipoly consists in reducing the class of test function $g$ to be polynomials, with maximal degree $d$. This maximal degree $d$ is the parameter of approximation of the program. As proved in [1], the higher the degree $d$ is, the better is the result of the approximation.

Our aim is to find the minimal time so that the trajectories of the system go to $0$. Obviously, this result is already known, but we provide this simple example to make clear the use of the Globtipoly toolbox

IMPLEMENTATION

Before going to the optimal control problem, some (easy) technical lines of command are necessary for Gloptipoly to work.

First, you have to add to the path the toolbox Globtipoly

untar('http://homepages.laas.fr/henrion/software/gloptipoly3/gloptipoly3.tar.gz')
addpath(genpath('gloptipoly3'))


Second, you have also to add to the path the toolbox Sedumi.

unzip('https://github.com/sqlp/sedumi/archive/master.zip')
addpath(genpath('sedumi-master'))


Then, you are ready to define the optimization problem.

x0 = [1; 1]; u0 = 0; %% initial conditions
d = 6; %% maximum degree of test function.


We compute the analytic minimum time. We want to know whether we are able to compute the good one with the toolbox Gloptipoly.

if x0(1) &amp;gt;= -(x0(2)^2-2)/2
tmin = 1+x0(1)+x0(2)+x0(2)^2/2;
elseif x0(1) &amp;gt;= -x0(2)^2/2*sign(x0(2))
tmin = 2*sqrt(x0(1)+x0(2)^2/2)+x0(2);
else
tmin = 2*sqrt(-x0(1)+x0(2)^2/2)-x0(2);
end


We define measures for constraints. In other words, we also define the vector field under consideration.

The command mpol in Globtipoly allows to define the variables under consideration. One can then define polynomials with respect to these variables.

The command meas allows to define a measure depending on several variables. Hence, when writing meas([x_1;u_1]), one is defining a measure depending on the variables x_1 and u_1.

mpol x1 2
mpol u1
m1 = meas([x1;u1]);


We now define a measure associated to $x_2$, which will be related to some performance requirement. Indeed, we will impose that this variable is dissipative.

mpol x2 2
m2 = meas(x2);


We then define the vector field.

f = [x1(2);u1];


We now define the test functions as polynomials, with maximal degree $d$. The command mmon in Globtipoly allows to define monomials up to an order $d$.

g1 = mmon(x1,d);
g2 = mmon(x2,d);


It is also necessary to assign the initial conditions, for the states as well for the control.

assign([x1;u1],[x0;u0]);
g0 = double(g1);


We define $K_1$ and $K_2$. The set $K_1$ is defined as: $K_1= \lbrace x_1,u_1 \in \mathbb{R}^2\mid x_1(2)\geq -1,: u_1^2\leq 1\rbrace$ and $K_2$ is defined as: $K_2 =\lbrace x_2\in\mathbb{R}\mid x_2^2\leq 0\rbrace$.

We have also to define the cost function of the problem under consideration. The one we are considering is quite simple and just reduces to being



In terms of functions, this means that you are minizing $x_1(t)$. This implies in particular that you are looking for the minimal time such that the trajectory $(x_1(t),x_2(t))$ will converge to $(0,0)$.

In other words, we are asking that the mass the measure $\mu_1$ is minimal.

Finally, we define also the differential equation with the polynomials truncated up to the order $d$. The command mom corresponds to the integral of polynomials against the suitable measure. For instance, for mom(g_2), one integrates the the polynomial g_2 against the measure $\mu_2$.

P = msdp(min(mass(m1)),... %%Definition of the cost function
u1^2 &amp;lt;= 1,... %% Definition of $K_1$
x1(2) &amp;gt;= -1,... %% Definition of $K_&amp;amp;$
x2'*x2 &amp;lt;= 0,... %% Definition of $K_2
mom(g2) - g0 == mom(diff(g1,x1)*f)); %% Definition of the dynamics.


GloptiPoly 3.8 of 15 December 2014
Define moment SDP problem
  Valid objective function
  Number of support constraints = 3
  Number of moment constraints = 28
Measure 1
  Degree = 6
  Variables = 3
  Moments = 84
Measure 2
  Degree = 6
  Variables = 2
  Moments = 28
Relaxation order = 3
Total number of moments = 112
Generate moment and support constraints
Generate moment SDP problem



The command msdp allows to define the problem and all the constraints. As written in [1], this means that you are transforming the problem on functions into a SDP (Semi-definite programming) problem.

Once you do that, one has to solve this SDP problem. The command msol allows to do that.

[status,obj] = msol(P);


GloptiPoly 3.8 of 15 December 2014
Solve moment SDP problem
*****************************************************
Calling SeDuMi
SeDuMi 1.32 by AdvOL, 2005-2008 and Jos F. Sturm, 1998-2003.
Alg = 2: xz-corrector, Adaptive Step-Differentiation, theta = 0.250, beta = 0.500
Put 28 free variables in a quadratic cone
eqs m = 112, order n = 59, dim = 766, blocks = 7
nnz(A) = 597 + 0, nnz(ADA) = 10192, nnz(L) = 5152
 it :     b*y       gap    delta  rate   t/tP*  t/tD*   feas cg cg  prec
  0 :            6.97E-01 0.000
  1 :  -4.85E+00 2.61E-01 0.000 0.3749 0.9000 0.9000  -0.46  1  1  7.9E+00
  2 :  -1.58E+01 1.08E-01 0.000 0.4124 0.9000 0.9000  -0.63  1  1  5.7E+00
  3 :  -1.60E+01 4.52E-02 0.000 0.4189 0.9000 0.9000   0.74  1  1  2.0E+00
  4 :  -7.27E+00 1.65E-02 0.000 0.3663 0.9000 0.9000   1.88  1  1  4.7E-01
  5 :  -4.16E+00 5.56E-03 0.000 0.3361 0.9000 0.9000   1.60  1  1  1.3E-01
  6 :  -3.52E+00 2.17E-03 0.000 0.3912 0.9000 0.9000   1.07  1  1  5.0E-02
  7 :  -3.37E+00 1.06E-03 0.000 0.4892 0.9000 0.9000   0.88  1  1  2.6E-02
  8 :  -3.24E+00 4.94E-04 0.000 0.4642 0.9000 0.9000   0.70  1  1  1.5E-02
  9 :  -3.17E+00 2.14E-04 0.000 0.4334 0.9000 0.9000   0.58  1  1  7.8E-03
 10 :  -3.12E+00 9.06E-05 0.000 0.4235 0.9000 0.9000   0.46  1  1  4.3E-03
 11 :  -3.08E+00 4.45E-05 0.000 0.4907 0.9000 0.9000   0.48  1  1  2.6E-03
 12 :  -3.05E+00 2.39E-05 0.000 0.5378 0.9000 0.9000   0.34  1  1  1.9E-03
 13 :  -3.02E+00 1.07E-05 0.000 0.4486 0.9000 0.9000   0.46  1  1  1.1E-03
 14 :  -2.98E+00 5.94E-06 0.000 0.5540 0.9000 0.9000   0.23  1  1  8.3E-04
 15 :  -2.95E+00 2.34E-06 0.000 0.3932 0.9000 0.9000   0.35  2  1  4.4E-04
 16 :  -2.91E+00 1.06E-06 0.000 0.4528 0.9000 0.9000   0.22  2  2  3.1E-04
 17 :  -2.88E+00 2.15E-07 0.000 0.2032 0.9000 0.7324   0.34  2  2  1.8E-04
 18 :  -2.84E+00 9.48E-08 0.000 0.4410 0.7706 0.9000   0.22  2  2  1.2E-04
 19 :  -2.82E+00 4.23E-08 0.000 0.4464 0.9000 0.9000   0.34  3  2  7.3E-05
 20 :  -2.78E+00 1.96E-08 0.000 0.4627 0.9000 0.9000   0.20  5  5  5.2E-05
 21 :  -2.76E+00 8.49E-09 0.000 0.4334 0.9000 0.9000   0.34  7  7  3.0E-05
 22 :  -2.73E+00 3.76E-09 0.000 0.4427 0.9000 0.9000   0.19  8  8  2.1E-05
 23 :  -2.70E+00 1.56E-09 0.000 0.4156 0.9000 0.9000   0.33 12 12  1.2E-05
 24 :  -2.67E+00 6.45E-10 0.000 0.4129 0.9000 0.9000   0.20 14 14  7.9E-06
 25 :  -2.66E+00 2.71E-10 0.000 0.4202 0.9000 0.9000   0.35 41 41  4.5E-06
Run into numerical problems.

iter seconds digits       c*x               b*y
 25      0.4   Inf -2.6569125651e+00 -2.6557155494e+00
\vertAx-b\vert =   9.3e-06, [Ay-c]_+ =   1.9E-06, \vertx\vert=  5.2e+03, \verty\vert=  4.9e+04

Detailed timing (sec)
   Pre          IPM          Post
6.598E-03    2.390E-01    7.343E-04    
Max-norms: \vert\vertb\vert\vert=1, \vert\vertc\vert\vert = 1,
Cholesky \vertadd\vert=1, \vertskip\vert = 7, \vert\vertL.L\vert\vert = 3155.
*****************************************************
Check feasibility (eps = 1.0000e-03):
  Marginally feasible SDP: residual = -5.0513e-07
Check Euclidean norm of solution (max = 1.0000e+06):
  Norm = 4.9305e+04
Check ranks of moments matrices (rel gap svd = 1.0000e-03):
  Measure 1
    Rank shift = 1
    Moment matrix of order  1 has size  4 and rank  4
    Moment matrix of order  2 has size 10 and rank 10
    Moment matrix of order  3 has size 20 and rank 20
  Measure 2
    Rank shift = 1
    Moment matrix of order  1 has size  3 and rank  1
  Rank conditions cannot ensure global optimality
Try to extract solutions (rel tol basis detection = 1.0000e-06):
  Measure 1
    Incomplete basis - no solution extracted
    Global optimality cannot be ensured
  Measure 2
    Maximum relative error = 0.0000e+00
    1 solution extracted
Inconsistent number of solutions amongst respective measures
No globally optimal solution could be extracted
Global optimality cannot be ensured



You display the minimal time and the lower bound of the cost functional.

disp(['Minimum time = ' num2str(tmin)]);
disp(['LMI ' int2str(d) ' lower bound = ' num2str(obj)])


Minimum time = 3.5
LMI 6 lower bound = 2.6557



For the initial condition x0 = [1 1] the exact minimum time is equal to 3.5. In table 1 of [2], a table is provided where you can see that when increasing $d$ the minimum time becomes closer and closer to the analytic one. We copy it in the note.

Conclusion

As noticed before, this note aimed at providing a quick course on how using the toolbox Gloptipoly toolbox to solve optimal control problem. The document [2] provides more examples, even for other kinds of optimization problem. Hence, we refer the interested reader to this document if he is interested in using this toolbox for other problems. Let us note moreover that this toolbox has been used to solve nonlinear hyperbolic PDEs, in the paper [3].

References

[1] J. B. Lasserre, D. Henrion, C. Prieur, and E. Trélat, Nonlinear optimal control via occupation measures and LMI-relaxations, SIAM J. Control Opt., vol. 47, 4, pp. 1643-1666, 2008.

[2] D. Henrion, J.B. Lasserre and J. Löfberg. GloptiPoly 3: moments, optimization and semidefinite programming. Optimization Methods &amp;amp; Software, 24(4-5), 761-779, 2009.

[3] S. Marx, T. Weisser, D. Henrion and J.B. Lasserre. A moment approach for entropy solutions to nonlinear hyperbolic PDEs arXiv preprint arXiv:1807.02306
</description>
        <pubDate>Mon, 04 Feb 2019 00:00:00 +0100</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0015-moment</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0015-moment</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Optimal control for inverted pendulum</title>
        <description>This tutorial aims to show how to build equations of motion, control system model and optimally stabilizing controllers for the inverted pendulum. This tutorial is a standard material in control engineering education. We first derive the equations of motion via Lagrange’s method using Symbolic Math Toolbox. Then, a linear control model is derived. The optimal controller is designed using linear quadratic regulator theory. Simulations are carried out for the inverted pendulum nonlinear model. In Appendix, finite horizon linear optimal control is shown by solving a differential Riccati equation.

A schematic of an inverted pendulum is shown below.



A pendulum is attached with a cart that moves horizontally due to the force $u$ without friction. The pendulum freely rotates around the pivot on the cart. It is assumed that the cart and pendulum move in the vertical plane. The masses of the pendulum and cart are $m$ and $M$, respectively, and the length of the pendulum is $2l$. The position of the cart is denoted by $x$ and the angle of the pendulum from the vertical axis is $\theta$.

syms t;
syms x dx theta dtheta;
syms M m l g;
syms Lgr Lgr_x Lgr_dx Lgr_theta Lgr_dtheta;


Derivation of equations of motion

The Lagrangian $L$ consists of the kinetic energy and potential energy, which is given by

Lgr = 1/2 * M*dx^2 + 2/3 * m*l^2*dtheta^2 + m*l*dx*dtheta*cos(theta)...
        + 1/2 *m*dx^2 - m*g*l*cos(theta);


Compute derivatives of Lagrangian

Lgr_x = diff(Lgr,x);
Lgr_dx = diff(Lgr,dx);
Lgr_theta = diff(Lgr,theta);
Lgr_dtheta = diff(Lgr,dtheta);

syms x_f(t) dx_f(t) theta_f(t) dtheta_f(t) Lgr_x_f Lgr_dx_f Lgr_theta_f Lgr_dtheta_f; %% _f means functionalized
dx_f(t)=diff(x_f,t);
dtheta_f=diff(theta_f,t);

Lgr_dx_f = subs(Lgr_dx,[x dx theta dtheta],[x_f dx_f theta_f dtheta_f])
Lgr_theta_f = subs(Lgr_theta,[x dx theta dtheta],[x_f dx_f theta_f dtheta_f])
Lgr_dtheta_f = subs(Lgr_dtheta,[x dx theta dtheta],[x_f dx_f theta_f dtheta_f])



Lgr_dx_f =

M*diff(x_f(t), t) + m*diff(x_f(t), t) + l*m*cos(theta_f(t))*diff(theta_f(t), t)


Lgr_theta_f =

g*l*m*sin(theta_f(t)) - l*m*sin(theta_f(t))*diff(theta_f(t), t)*diff(x_f(t), t)


Lgr_dtheta_f =

(4*m*diff(theta_f(t), t)*l^2)/3 + m*cos(theta_f(t))*diff(x_f(t), t)*l




Coumpute Lagrange’s equations of motion with external force $u$

syms Leq Eqn;
Leq = diff([Lgr_dx_f; Lgr_dtheta_f],t) - [Lgr_x; Lgr_theta_f];
syms Ddx Ddtheta u;
Leq = subs(Leq,[diff(x_f(t), t, t) , diff(theta_f(t), t, t) ],[Ddx, Ddtheta])-[u; 0];
Eqn = solve(Leq==0,[Ddx,Ddtheta]);


Construct state space equations of the first order equation

syms x1 x2 x3 x4 X;
X = [x1;x2;x3;x4];
subs(Eqn.Ddx, [x_f, diff(x_f(t),t), theta_f, diff(theta_f(t),t)], [x1, x2, x3, x4]);
subs(Eqn.Ddtheta, [x_f, diff(x_f(t),t), theta_f, diff(theta_f(t),t)], [x1, x2, x3, x4]);

syms Nsys
Nsys = [x2;...
        subs(Eqn.Ddx, [x_f, diff(x_f(t),t), theta_f, diff(theta_f(t),t)], [x1, x2, x3, x4]);...
        x4;...
        subs(Eqn.Ddtheta, [x_f, diff(x_f(t),t), theta_f, diff(theta_f(t),t)], [x1, x2, x3, x4])];

syms F;
F = subs(Nsys,u,0);


Construct linear model $\dot{x} = Ax+Bu$

syms Amat Bmat
Amat = subs(jacobian(F,X),[x1,x2,x3,x4],[0,0,0,0])
Bmat = diff(subs(Nsys,[x1,x2,x3,x4],[0,0,0,0]),u)



Amat =

[ 0, 1,                             0, 0]
[ 0, 0,            -(3*g*m)/(4*M + m), 0]
[ 0, 0,                             0, 1]
[ 0, 0, (3*(M*g + g*m))/(l*(4*M + m)), 0]


Bmat =

                0
      4/(4*M + m)
                0
 -3/(l*(4*M + m))




We will use the following physical parameters m = 0.3 [kg]; M = 0.8 [kg]; l = 0.25 [m]; g = 9.8 [m/s^2];

A = double(subs(Amat,[m M l g],[0.3 0.8 0.25 9.8]));
B = double(subs(Bmat,[m M l g],[0.3 0.8 0.25 9.8]));


LQR controller design

We design a linear feedback controller that minimizes the cost function



R = 1; Q = diag([1,1,1,1]);
[ricsol,cleig,K,report] = care(A,B,Q);

f_ctr = @(x) -K*x;
i_linear = @(t,x) A*x + B*f_ctr(x); %% closed loop systems

tspan = [0,10];
ini =[0,0,0.91,0]; %%1.1894299
[time, state] = ode45(i_linear,tspan, ini);
input_linear = f_ctr(state');


Simulations with linear and nonlinear models

Nsys_f = matlabFunction(Nsys); %% function of M,g,l,m,u,x2,x3,x4
i_nonlinear = @(t,x) Nsys_f(0.8,9.8,0.25,0.3,f_ctr(x),x(2),x(3),x(4));

[timen, staten] = ode45(i_nonlinear,tspan, ini);
input_nonlinear = f_ctr(staten');


clf
plot(time, state(:,1),'LineWidth',2)
hold on
plot(timen, staten(:,1),'LineWidth',2)
grid on
legend('Linear model', 'Nonlinear model')
title('Cart position [m]')




clf
plot(time, state(:,3),'LineWidth',2)
hold on
plot(timen, staten(:,3),'LineWidth',2)
grid on
legend('Linear model', 'Nonlinear model')
title('Pendulum angle [rad]')




clf
plot(time, input_linear,'LineWidth',2)
hold on;grid on
plot(timen, input_nonlinear,'LineWidth',2)
legend('Linear model','Nonlinear model')
title('Input response')




Appendix (finite interval optimal control with DRE )

rho = 0;
S = rho * eye(size(A,1));


Solve -dX/dt = XA + A’X - XBR^{-1}B’X +Q, X(T) = S (DRE)

tspan_ric = [10,0]; %% change horizon!
iniric = S(:);
i_ric = @(t,x) -f_dric(x, A, B * B.', Q);
opts = odeset('RelTol',1e-10,'AbsTol',1e-10);
[time_ric, X] = ode45(i_ric, tspan_ric, iniric, opts);
reshape(X(end,:),4,4)-ricsol %% Convergence check with sol of ARE



ans =

   1.0e-04 *

   -0.0103   -0.0124   -0.0358   -0.0065
   -0.0124   -0.0185   -0.0549   -0.0099
   -0.0358   -0.0549   -0.1639   -0.0295
   -0.0065   -0.0099   -0.0295   -0.0053




Construct feedback controller using interpolation of DRE sol

gain = zeros(length(X),size(A,1));
for i = 1:length(X)
    gain(i,:) = B' * reshape(X(i,:),size(A));
end
gain_t = @(t) interp1(time_ric,gain,t);
u_dr = @(t,x) -gain_t(t)*x;

tspan = sort(tspan_ric, 'ascend');
i_nonlinear_dre = @(t,x) Nsys_f(0.8,9.8,0.25,0.3,u_dr(t,x),x(2),x(3),x(4));
[timedn, statedn] = ode45(i_nonlinear_dre,tspan, ini);%%
input_dric=[];
for i = 1:length(timedn)
    input_dric(i) = u_dr(timedn(i),statedn(i,:)');
end


clf
plot(timedn, statedn(:,3),'LineWidth',2)
grid on
hold on
plot(timen, staten(:,3),'ro')
legend('control with DRE [10,0]', 'control with ARE')
title('Pendulum responses with nonlinear model')
hold off




plot(timedn,input_dric,'LineWidth',2)
hold on
plot(timen,input_nonlinear,'ro')
grid on
legend('input with ARE','input with DRE [10,0]')
title('input responses with nonlinear model')



</description>
        <pubDate>Mon, 04 Feb 2019 00:00:00 +0100</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0015-Pendulum</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0015-Pendulum</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Two Grids Filter Method for RPS Semi-Discretization</title>
        <description>This work is regarding solving 1-d wave equation using RPS semi-discretization method and analysis corresponding dispersion relation

Solving 1-d wave equation with RPS semi-discretization method Considering 1-d wave equation,



When $(u_0,u_1) \in H_0^1(0,1)\times L^2(0,1)$, it admits a unique solution $u(x,t) \in C^0([0,T],H_0^1(0,1)) \cap C^1([0,T],L^2(0,1))$. 	The energy of solution to \eqref{wave} $E(t)$



is time conserved .

With Hilbert Uniqueness Method, the exact controllability of \eqref{wave} is  equal to the observability of the adjoint \eqref{wave}, Observability of \eqref{wave} reads as: Given $T\geq 2$, there exist a positive constant $C(T)\geq 0$ such that



holds for every solution $u(x,t)$ to adjoint system \eqref{wave}

RPS semi-discretization of  weak variation formulation  of \eqref{wave} is written as



where $M_{i,j}:=\int_{-\infty}^{+\infty}\phi_i\phi_j dx$ and $R_{i,j}=\int_{-\infty}^{+\infty}\frac{d}{dx}\phi_i\frac{d}{dx}\phi_j dx $ and  the corresponding $\hat{A}(\omega)$ defined as



As for this problem, the rps basis $\phi_i(x)$ corresponding  $x_i$ is defined by



Set up uniform fine mesh and coarse mesh

h = 2^(-8); H=2^(-4); Nbasis=2/H-1;
n = 2/h; N=2/H;


Construct the stiffness matrix and massive matrix regarding p1 finite element on fine mesh and coarse mesh respectively

L = sparse([1:n+1,1:n,2:n+1],[1:n+1,2:n+1,1:n],[2*ones(1,n+1),-ones(1,2*n)]);
LL= sparse([1:N-1,1:N-2,2:N-1],[1:N-1,2:N-1,1:N-2],[2*ones(1,N-1),-ones(1,2*N-4)]);
M = sparse([1:n-1,1:n-2,2:n-1],[1:n-1,2:n-1,1:n-2],[2/3*h*ones(1,n-1),1/6*h*ones(1,2*n-4)]);
MM = sparse([1:N-1,1:N-2,2:N-1],[1:N-1,2:N-1,1:N-2],[2/3*H*ones(1,N-1),1/6*H*ones(1,2*N-4)]);
L=1/h*L;
LL=1/H*LL;


Construct the discrete energy $\vert-div(a\nabla \cdot)\vert$

temp = L(:,2:end-1);
boundary = L([1,end],2:end-1);
A = temp'*temp+100*(boundary')*boundary;


Matrix corresponding  pointwise constrains

B = eye(n-1,n-1);
B = B(H/h*[1:Nbasis],:);


Solve the rps basis by solving the optimization problems

Psi = zeros(n-1,Nbasis);
for i = 1:size(B,1)
ei = zeros(Nbasis,1);
ei(i,1) = 1;
Psi(:,i) = A\(B'*((B*inv(A)*B')\ei));
end


plot the basis and log scale of basis

clf
subplot(1,2,2);
plot(-1+h:h:1-h,log10(abs(Psi(:,16))));
subplot(1,2,1);
plot(-1:h:1,[0;Psi(:,16);0],'b');




Set up the time interval, time step, source term $f=0$

T=1;J=10000;f=zeros(length(A),1);


Set up the concentration parameter of inital data $\gamma$, frequency $\xi$ and generate fine grids $x$ and the initial data defined on them

gamma=H^(-1.8); xi=3/4*pi; x=-1+h:h:1-h;
ui=exp(-gamma*(x).^2/2).*cos(xi*x/H);
uti=-gamma*(x).*exp(-gamma*(x).^2/2).*cos(xi*x/H)-xi/H.*exp(-gamma*(x).^2/2).*sin(xi*x/H);


Solve the wave equation on fine mesh as a approximation of analytical solution, which will be used then as a reference of rps solution

[u,ut] =  ODEsolver(M,L(2:end-1,2:end-1),ui,uti,f,T,J,M);
[X,Y]=meshgrid(-1+h:h:1-h,0:T/J:T);
clf, pcolor(X,Y,u') ;shading interp ; colorbar;
title('finemesh solution')




Solve the wave equation on coarsemesh using RPS method

xc=x(H/h*[1:Nbasis]);
Mc=Psi'*M*Psi; Lc=Psi'*L(2:end-1,2:end-1)*Psi;
uci=exp(-gamma*(xc).^2/2).*cos(xi*xc/H);
utci=-gamma*(xc).*exp(-gamma*(xc).^2/2).*cos(xi*xc/H)-xi/H.*exp(-gamma*(xc).^2/2).*sin(xi*xc/H);
fc=zeros(length(Lc),1);
[uc,uct]=ODEsolver(Mc,Lc,uci,utci,fc,T,J,Mc);
clf, pcolor(X,Y,(Psi*uc)');shading interp ; colorbar;
title('coarsemesh solution with rps basis')




Solve the wave equation on coarsemesh using p1 fem

[uuc,uuct]=ODEsolver(MM,LL,uci,utci,fc,T,J,MM);
[XX,YY]=meshgrid(-1+H:H:1-H,0:T/J:T);
clf, pcolor(XX,YY,uuc'); shading interp ; colorbar;
title('coarsemesh solution with linear basis')




Plot the disperation relation of RPS-semi descretization

RPS semi-discretization of  weak variation formulation  of \eqref{wave} is written as



where $M_{i,j}:=\int_{-\infty}^{+\infty}\phi_i\phi_j dx$ and $R_{i,j}=\int_{-\infty}^{+\infty}\frac{d}{dx}\phi_i\frac{d}{dx}\phi_j dx $ and the corresponding $\hat{A}(\omega)$ defined as



Since there’s no explicit formulation for matrix $M$ and $R$, We can only calculate the fourier symbol of $M$ and $R$ numerically. Assuming the matrix $M$ is symmetric and toplitze and dimension $N$ of $M$ being a odd number, then fourier symbol of $M$   could be written as



For example, let $M$  be mass matrix corresponding p1 finite element semi-descretization. the fourier symbol of $M$ is



Construct the discrete $cos(i\omega h)$ with $\omega h$ sampled at 1000 points at interval $[0,2\pi]$

f = cell(N/2);
f{1} = @(x) 1;
for i =1:N/2-1
    f{i+1} = @(x)2*cos(i*x);
end
f = flip(f);

Matrix_cos=zeros(N/2,1000);
for i=1:N/2
    xx=linspace(0.1,2*pi,1000);
    Matrix_cos(i,:)=arrayfun(f{i},xx);
end


Calculate the fourier symbol of $M$ and $R$

M_symbol = 1/H*Mc(1/H,1:N/2)*Matrix_cos;
R_symbol = H*Lc(1/H,1:N/2)*Matrix_cos./xx.^2;


Plot the numerical phase velocity for sinusoidal solution and compare it with the ones for FDM and FEM

hold on
phaseVelocity = R_symbol.^(1/2)./M_symbol.^(1/2);
clf, plot(xx,phaseVelocity)
%% for p1 FEM
hold on
p1PhaseV = sin(xx/2)./xx*2.*(2/3+1/3*cos(xx)).^(-1/2);
plot(xx,p1PhaseV)
%% for FDM
hold on
fdmPhaseV = sin(xx/2)./xx*2;
plot(xx,fdmPhaseV)
%%
ax=gca; ax.XTick = ([ 0 1/2*pi 5/6*pi pi 2*pi]);
ax.XTickLabel =({'0','1/2\pi','5/6*\pi','\pi','2\pi'});
xlabel('\omega*H')
legend('RPS','P1 FEM','FDM')




Plot the numerical group velocity for sinusoidal solution and compare it with the ones for FDM and FEM

groupVelocity = diff(phaseVelocity)/((2*pi-0.1)/999).*xx(1:length(xx)-1)+phaseVelocity(1:length(xx)-1);
clf, plot(xx(1:length(groupVelocity)),groupVelocity)
%% for p1 FEM
hold on
p1GroupV = diff(p1PhaseV)/((2*pi-0.1)/999).*xx(1:length(xx)-1)+p1PhaseV(1:length(xx)-1);
plot(xx(1:length(xx)-1),p1GroupV)
%% for FDM
hold on
fdmGroupV = diff(fdmPhaseV)/((2*pi-0.1)/999).*xx(1:length(groupVelocity))+fdmPhaseV(1:length(groupVelocity));
plot(xx(1:length(groupVelocity)),fdmGroupV)
%% for ecact group velocity
hold on
plot(xx, ones(length(xx)),'LineStyle','--')
%%
ax=gca;
ax.XTick=([ 0 1/2*pi 5/6*pi pi 2*pi]);
ax.XTickLabel =({'0','1/2\pi','5/6*\pi','\pi','2\pi'});
ax.XLim=[0 pi];
xlabel('\omega*H')
legend('RPS','P1 FEM','FDM','exact')




Plot the numerical disperation relation Disperation relation for RPS semi-discretizaton

diperss = phaseVelocity.*xx;


clf
hold on
plot(xx,diperss)
%% for P1 FEM
hold on, plot(xx,2*sin(xx/2).*(2/3+1/3*cos(xx)).^(-1/2));
%% for FDM
hold on , plot(xx,2*sin(xx./2))
%% for exact one
hold on , plot(xx,xx,'LineStyle','--')
ax=gca;
ax.XTick=([ 0 1/2*pi 5/6*pi pi 2*pi]);
ax.XTickLabel =({'0','1/2\pi','5/6*\pi','\pi','2\pi'});
ax.XLim=[0 pi];
xlabel('\omega*H')
legend('RPS','P1 FEM','FDM','exact')




</description>
        <pubDate>Tue, 18 Dec 2018 00:00:00 +0100</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp04/P0002-Numerical-homogenizaton</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp04/P0002-Numerical-homogenizaton</guid>
        
        
        <category>tutorial</category>
        
        <category>WP04</category>
        
      </item>
    
      <item>
        <title>Stability analysis of Power Electronic Converters Connected to AC Grids</title>
        <description>We analyze the stability of a simplified system modeling two converters in parallel connected to an ideal grid (modelled by a voltage source) via line impedances.



Each of the converters is fed by a DC source and includes an $LC$ circuit at its output to filter the ripple introduced by the converter switching. Similarly, an $LR$ impedance is included after the $LC$ filter to model the characteristics of the line until the point of common connection (PCC). The grid in this case is modelled with an ideal voltage source $v_g$ with a series $LR$ impedance. In this context, $f$ subscript denotes filter and $o$ subscript denotes output of the inverter. The subscript %%g%% denotes that this variable is from the side of the grid.

The dynamics inside the system (e.g. how does the current in an inductor or the voltage in a capacitor evolve over time) is described by several differential equations describing the evolution of the state input vector. The model is then completed with the introduction of algebraic relations which link the previous equations by applying classical laws such as Kirchoff.

All these equations depend on some parameters characteristic of the physical model:


  
    $Rf_{1}$ and $Rf_{2}$: the filter resistors;
  
  
    $Lf_{1}$ and $Lf_{2}$: the inductances of the filter;
  
  
    $Cf_{1}$ and $Cf_{2}$: the capacitances;
  
  
    $Ro_{1}$ and $Ro_{2}$: the output resistors;
  
  
    $Lo_{1}$ and $Lo_{2}$: the output inductances;
  
  
    $Rg$: the grid resistor;
  
  
    $Lg$: the grid inductance.
  


The model is then written in the form $\dot{x} = Ax + Bu$, with





and $u = [Vdc_{1} Vdc_{2} V_{g}]$. here we defined



The stability of the system is discussed by studying the evolution of the eigenvalues of $A$ in dependence of the aforementioned parameters. Due to the size of the system and to the large number of parameters involved, this stability analysis needs to be addressed by means of fine computational tools.

clear


Variables composing the state vector

syms Ii1 Vo1 Io1 Ii2 Vo2 Io2 Ig


Parameters entering in the model

syms Ro1 Rf1 Lf1 Cf1 Lo1
syms Ro2 Rf2 Lf2 Cf2 Lo2
syms Rg Lg L
%% sustituimos numericamente excepto nRo1 syms m1 m2


Out of these parameters, we build the matrices $A$ and $B$ in symbolic form.

A = Amatrix();
B = Bmatrix();


We now want to study the evolution of the eigenvalues with respect to $\mathrm{Ro}_{1}$. Thus, we assign some fix value to all the others parameters

nRf1 = 1; nLf1 = 1; nCf1 = 1; nLo1 = 1;
nRo2 = 1; nRf2 = 1; nLf2 = 1; nCf2 = 1;
nLo2 = 1; nRg  = 1; nLg  = 1; nL = 1/nLo1 + 1/nLo2 ;


and we build the corresponding matrix $A$, which will depend only on $Ro_{1}$.

symbolic  = [Rf1, Lf1, Cf1, Lo1, ...
             Ro2,  Rf2, Lf2, Cf2, Lo2, ...
             Rg,   Lg,  L];

numerical = [nRf1, nLf1, nCf1, nLo1, ...
             nRo2,  nRf2, nLf2, nCf2, nLo2, ...
             nRg,   nLg,  nL];
nA = subs(A,symbolic,numerical)


 
nA =
 
[ -1,   -1,      0,  0,     0,    0,    0]
[  1,    0,     -1,  0,     0,    0,    0]
[  0,  1/2, -Ro1/2,  0,  -1/2,  1/2,  1/2]
[  0,    0,      0, -1,    -1,    0,    0]
[  0,    0,      0,  1,     0,   -1,    0]
[  0, -1/2,  Ro1/2,  0,   1/2, -1/2, -1/2]
[  0,  1/2, -Ro1/2,  0, Ro1/2, -1/2, -1/2]
 



Then, we convert it from symbolic to function_handle

funRo1 = matlabFunction(eig(nA));


Finally, we compute and plot the eigenvalues of this matrix $A$ and we analyze their evolution while varying $Ro_{1}$ in a given range.

nRo1 = -3:0.05:5;
eigenvalues = cell(1,length(nRo1));
index = 0;
for inRo1 = nRo1
    index = index + 1;
    %% in each iteration we replace in funRo1 a different value of the parameter
    eigenvalues{index} = funRo1(inRo1);
end


For each value of $Ro_{1}$, the eigenvalues are stored in a cell. For instance, these are the eigenvalues corresponding to $Ro_{1}=-3$

eigenvalues{1}



ans =

  -1.0000 + 0.0000i
   0.0000 + 0.0000i
  -0.5000 - 0.8660i
  -0.5000 + 0.8660i
   0.0000 + 0.0000i
   0.2500 - 0.6614i
   0.2500 + 0.6614i




We then use use the Matlab program “EingEvolution” that we specifically degsigned, in order to see the evolution of these eigenvalues. This is done through the command EingEvolution(autovalues,nRo1,'R_{o1}','Gif_evo_eig.gif').

Finally, we can plot the evolution of the eigenvalues as a function of $R_{o_1}$.



This procedure may be repeated for all the others parameters, thus obtaining a complete stability analysis of our model.

</description>
        <pubDate>Thu, 15 Nov 2018 00:00:00 +0100</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0011</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0011</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>LQR controller for stabilizing the linear population dynamics model</title>
        <description>In this tutorial, we will demonstrate how to design a LQR controller in order to stabilize the linear population dynamics model dependent on age and space



where $\beta$ and $\mu$ are respectively the fertility and mortality rate. The parameter $\lambda&amp;gt;0$ is an immigration term (or unstable term), $Q_{\omega}=(a,b)\times (a_1,a_2)\times (0,T)$ is the control domain with $(a,b)\subset (0,1)$ and $(a_1,a_2)\subset (0,A).$ Here $(a,b)=(0,1)$ and $(a_1,a_2)=(0,A)$ and we take $A=1$.

We need to reduce the PDE to the finite dimensional system of the form  where $A$ and $B$ are matrices, and



is the finite dimensional state vector.

Implementation

Construction of the matrix A. We suppose that $\lambda=\frac{1}{2}.$

clc; clear;
m=4;
n=9*m;


Matrix of birth Here we suppose that fertility rate $\beta$ equal to:



Here $\alpha=7$, $\gamma=5$, $v=3$, $a_1=\frac{A}{9}$

The density of new born individuals will be approximated by:



where $a_i$ is the age discretization.

A1=eye(n);
A2=zeros(n*n,n*n);
for j=m:7*m
    bj=(7*(j/n-1/9)^4*exp(-(j/n-1/9)/3)/(3^5*gamma(5)));
    A2(1:n,(j-1)*n+1:j*n)=bj*A1;
end
P=(25/n)*A2;


Discrerization of the second derivative in space and the derivative in age.

A3=diag(ones(n*n-n,1),-n);
B1=(1/n)*A3;
A4=(-2/(n*n)-1/n)*eye(n);
A5=diag(ones(n-1,1),1);
A6=diag(ones(n-1,1),-1);
B2=A4+(1/(n*n))*A5+(1/(n*n))*A6;
B3=kron(eye(n),B2);


Mortality matrix. The mortality rate $\beta(a)=\dfrac{1}{9(A-a)}$

S=zeros(n*n,n*n);
for j=1:n
    for i=1:n
        S((j-1)*n+i,(j-1)*n+i)=-1/(16*(1-((j*n)/(n*n+1))));
    end
end
A=P+B1+B3+S+(1/2)*eye(n*n);


Initial condition

We suppose that $y(x,a,0)=e^{-((a-3/10)^2/\sqrt{2}+100(x-4/10))}$

T=10;
Z0=zeros(n*n,1);
for i=1:n
    for j=1:n
        Z0((i-1)*n+j,1)=5*exp(-((i/n-3/10)^2)/sqrt(2))*exp(-(j/n-4/10)^2);
    end
end


Numerical solution without control and visualisation

f=@(t,Z) A*Z;
[t1,Z]=ode45(f,[0,T],Z0);
L=Z(256,:);
U=Z(512,:);
W=Z(1025,:);
J=reshape(L,n,n);
X=reshape(U,n,n);
Y=reshape(W,n,n);
F1=reshape(Z0,n,n);
V1=linspace(0,1,n+2);
V2=V1(1,2:n+1);
[V3,V4]=meshgrid(V2,V2);
figure;
surf(V3,V4,F1);
xlabel('age');
ylabel('space');
title('initial condition');




Here is the state y of the unstable system at time t=2,5.

figure;
surf(V3,V4,J);
xlabel('age');
ylabel('space');
title('state y of the unstable system at timte t=2,5');




Here is the state y of the unstable system at time t=5.

figure;
surf(V3,V4,X);
xlabel('age');
ylabel('space');
title('state y of the unstable system at time t=10');




Here is the state y of the unstable system at time t=10.

figure;
surf(V3,V4,Y);
xlabel('age');
ylabel('space');
title('state y of the unstable system at time t=10');




The control matrix B is constructed as follows:

B=eye(n*n);


We may now proceed with the optimal control strategy. For a continuous time linear system generated by the matrices $(A,B)$ and an infinite time horizon cost functional defined as



the feedback control law that minimizes the value of the cost is $u = -Kz$, where $K = R^{-1}B*P$ and $P$ is found by solving the continuous time algebraic Ricatti equation



R = eye(n*n); Q = eye(n*n);
H = blkdiag(A, -A');


LQR feedback control-Algebric Ricatti equation

[ricsol, cleig, K, report] = care(A, B, Q, R);
f_ctr = @(z) -K*z;


Numerical solution with LQR feedback control and visualisation

f_2=@(t,Z) A*Z+B*f_ctr(Z);
[t2,Z_ctr]=ode45(f_2,[0,T],Z0);
E=Z_ctr(256,:);
O=Z_ctr(512,:);
G=Z_ctr(1025,:);
G1=reshape(G,n,n);
N=reshape(E,n,n);
M=reshape(O,n,n);


Here is the stabilized state y of the system at the time t=2,5.

figure;
surf(V3,V4,N);
xlabel('age');
ylabel('space');
title('stabilized state of the system at time t=2,5');




Here is the stabilized state y of the system at time t=5.

figure;
surf(V3,V4,M);
xlabel('age');
ylabel('space');
title('stabilized state of the system at time t=5');




Here is the stabilized state y of the system at time t=10.

figure;
surf(V3,V4,G1);
xlabel('age');
ylabel('space');
title('stabilized state of the system at time t=10')




</description>
        <pubDate>Mon, 29 Oct 2018 00:00:00 +0100</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0010-Yacouba</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0010-Yacouba</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>The control on the Kuramoto model by handling one oscillator</title>
        <description>Define vector fields of ODE : Kuramoto control problem whose dynamics is



where we control the first oscillator,



in order to change the limit phase value to be 0.

We first define the system of ODEs in terms of symbolic variables.

clear all
clc

m = 10;  %% [m]: number of oscillators, which we may change later.

th = sym('th', [m,1]);  %% [th_i]: phases of oscillators, $\theta_i$
om = sym('om', [m,1]);  %% [om_i]: natural frequencies of osc., $\omega_i$
KK = sym('K',[m,m]); %% [Ki_j]: the coupling network matrix, $K_{i,j}$

syms Nsys;   %% [Nsys]: the vector fields of ODEs
thth = repmat(th,[1 m]);
Nsys = om + (1./m)*sum(KK.*sin(thth.' - thth),2);   %% Kuramoto interaction terms
syms u; %% [u]: One-dimensional control term
Nsys(1) = Nsys(1) + u;    %% For the first particle, we put the control term


%% latex(Nsys)


The system is as follows:



Linearized model and numerical data setting

We now construct the linearized system using Jacobian:

syms F; %% [F]: The system without control
F = subs(Nsys,u,0);

syms Amat Bmat; %% [Amat, Bmat]: Symbolic versions of the matrix A and B
th_eq = zeros(m,1); %% Evaluation of Jacobian is at equilibrium, [0;0;0;0].
Amat = subs(jacobian(F,th),th,th_eq);
Bmat = diff(subs(Nsys,th,th_eq),u);


Construction of numerical matrices $A$ and $B$:

We next set the physical parameters. Natural frequencies, however, we put them zero to apply linear-quadratic control model.

The coupling network matrix is set to be random near ones(m,m):

  KK_init = ones(m,m)+0.2*(2*(rand(m,m)-0.5));


and save it in the folder ‘functions/coupling.mat’.

om_init = zeros(m,1);
load('functions/coupling.mat','KK_init');

A = double(subs(Amat,[om,KK],[om_init,KK_init]));
B = double(subs(Bmat,[om,KK],[om_init,KK_init]));


Construction of the LQR controller and its evaluation

We design the LQR controller and solve it with linearized model.

The cost is only for the symmetric quadrature at $[0,0,0]$ since we want all of them to be 0.

R = 1; Q = diag(ones(m,1));
[ricsol,cleig,K,report] = care(A,B,Q);
K %% Present the feedback matrix



K =

  Columns 1 through 7

    0.6358    0.2930    0.2924    0.2829    0.2604    0.3013    0.2775

  Columns 8 through 10

    0.2777    0.2701    0.2713




Practically, any $K$ with positive elements can make the limit point to be 0, e.g., K=[1,1,1].

The initial condition is chosen on $[-0.55\pi,0.55\pi]$ by

  ini = 0.55*pi()*(2*(rand(m,1)-0.5));


which is stored in the functions folder, ‘functions/ini.mat’.

load('functions/ini.mat','ini'); %% Safe data

tspan = [0,10];


1) Simulate the nonlinear dynamics without any control: $u = 0$.

syms Isys_ori;
Isys_ori = subs(F,[om,KK],[om_init,KK_init]);
Isys_ori_ftn_temp = matlabFunction(Isys_ori,'Vars',{th});
Isys_ori_ftn = @(t,x) Isys_ori_ftn_temp(x);

[timenc, statenc] = ode45(Isys_ori_ftn,tspan, ini); %% Solve ODE with 'ode45'


2) Simulate the linear dynamics with CARE function

f_ctr = @(x) -K*x;

i_linear = @(t,x) A*x + B*f_ctr(x);

[time, state] = ode45(i_linear,tspan, ini);


3) Simulate the nonlinear dynamics with the same control

syms Isys;
Isys = subs(Nsys,[om,KK,u],[om_init,KK_init,(-K*th)]);
Isys_ftn_temp = matlabFunction(Isys,'Vars',{th});
Isys_ftn = @(t,x) Isys_ftn_temp(x);

[timen, staten] = ode45(Isys_ftn,tspan, ini);


Visualization

plot(timenc, statenc(:,1)/pi(),'-k','LineWidth',2) %% The first oscillator is black-colored.
hold on
plot(timenc, statenc(:,2:m)/pi(),'LineWidth',2)
grid on
xlabel('Time')
ylabel('Phases [\pi]') %% The unit is $\pi$.
title('Figure 1: Phases of the model without control')
hold off




clf
plot(time, state(:,1)/pi(),'-k','LineWidth',2)
hold on
plot(time, state(:,2:m)/pi(),'LineWidth',2)
grid on
xlabel('Time')
ylabel('Phases [\pi]')
title('Figure 2: Phases of the linearized model')
hold off




clf
plot(timen, staten(:,1)/pi(),'-k','LineWidth',2)
hold on
plot(timen, staten(:,2:m)/pi(),'LineWidth',2)
grid on
xlabel('Time')
ylabel('Phases [\pi]')
title('Figure 3: Phases of the Kuramoto model')
hold off




In Figure 1, the limit point is not zero since the mean value of initial phases is nonzero.

Figure 2 shows that the first oscillator keeps it phase above zero to make the final phases zero.

The nonlinear model has less decay then the linearized model, but goes to zero in Figure 3.

Failure of LQR control for large initial data

The initial data is from

ini2 = pi()*(2*(rand(m,1)-0.5));


which is uniformly distributed on $[-\pi,\pi]$. We expect the limit point to be separated in the real line with differences $2\pi$.

load('functions/ini2.mat','ini2'); %% Separated data

f_ctr = @(x) -K*x;

i_linear = @(t,x) A*x + B*f_ctr(x);

tspan = [0,20];
[time, state] = ode45(i_linear,tspan, ini2);

syms Isys;
Isys = subs(Nsys,[om,KK,u],[om_init,KK_init,(-K*th)]);
Isys_ftn_temp = matlabFunction(Isys,'Vars',{th});
Isys_ftn = @(t,x) Isys_ftn_temp(x);
[timen, staten] = ode45(Isys_ftn,tspan, ini2);

figure(4)
plot(time, state(:,1)/pi(),'-k','LineWidth',2)
hold on
plot(time, state(:,2:m)/pi(),'LineWidth',2)
grid on
xlabel('Time')
ylabel('Phases [\pi]')
title('Figure 4: Phases of the linearized model')
hold off

figure(5)
plot(timen, staten(:,1)/pi(),'-k','LineWidth',2)
hold on
plot(timen, staten(:,2:m)/pi(),'LineWidth',2)
grid on
xlabel('Time')
ylabel('Phases [\pi]')
title('Figure 5: Phases of the Kuramoto model')
hold off






We can see that $\theta_1$ does not tend to zero in Figure 5 since $K\times\Theta$ is near zero already. Linear feedback control is not enough, or too weak, for this setting.

</description>
        <pubDate>Mon, 29 Oct 2018 00:00:00 +0100</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0009-Dongnam</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0009-Dongnam</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Coupled transport equations and LQR control</title>
        <description>We consider the semilinear hyperbolic system



where $\lambda &amp;gt; 0$ and $u$ is the control. The stability and boundary stabilization of such 1D hyperbolic systems is studied in [1]. The aim of this tutorial is to semi-discretize in space this system of equations and design a stabilizing control by using the LQR method.

The above system linearized around $(y,v) = (0,0)$ has the form



We will first use the LQR method to design a stabilizing control for the semi-discretized linear system, and then this control will be applied to the semi-discretized semilinear system.

Space discretization

The intervall $(0,L)$ is divided in $n+1$ subintervals, of size $h_x := \frac{L}{n+1}$, by $n+2$ evenly spaced points $x_k = kh_x$. Hence, $x_0 = 0$ and $x_{n+1} = L$. We set $y_k(t) = y(x_k,t), \quad v_k(t) := v(x_k,t)$ and similarly for the inital conditions $y_k^0(t) = y^0(x_k)$ and $v_k^0(t) := v(x_k)$.

clear; clc;
L = 1; n = 30;
x = linspace(0, L, n+2);
hx = 1/(n+1);


The points where y and v are unknown are contained in x1 and x2 respectively, where x1 and x2 are defined below.

x1 = x(2:n+2);
x2 = x(1:n+1);


Finite differences for the space derivative give



and



The sign of $\lambda$ in each equation must be taken into account to choose the approximation of $\partial_x y$ and $\partial_x v$.

Let $d = 2(n+1)$ represent the dimension of the state space for the semi-discretized systems. Defining the state variable $z \colon (0,T) \mapsto \mathbb{R}^d$ by



the semilinear system writes as



and the linearized system writes as



d = 2*(n+1);


We pick the initial condition



y0 = sin(pi*x1)';
v0 = sin(pi*x2)';
z0 = zeros(d, 1); z0(1:n+1, 1) = y0; z0(n+2:d, 1) = v0;


We set values for $\lambda$, $c_1$ and $c_2$:

lambda = 1; c1 = 1; c2 = 1;


We consider the time parameters

T = 5;
nT = 70;
time = linspace(0, T, nT);


The matrix $A$ of size $d \times d$ is given by



where $A_{11}, A_{12}, A_{21}, A_{22}$, of size $(n+1)\times(n+1)$, are defined by



and



They are constructed as follows.

A = zeros(d, d);
%% Lower and upper extradiagonals:
ext_down_1 = zeros(1,2*n+1); ext_down_1(1,1:n) = lambda/hx*ones(1,n);
ext_down_2 = c2*ones(1,n);
ext_up_1 = zeros(1,2*n+1); ext_up_1(1,(n+2):(2*n+1)) = lambda/hx*ones(1,n);
ext_up_2 = zeros(1, n+1); ext_up_2(1, 1) = lambda/hx;
ext_up_3 = c1*ones(1,n);
%% We assemple:
A = A - lambda/hx*eye(d); A(n+2, n+2) = A(n+2, n+2) + c2;
A = A + diag(ext_up_1,1) + diag(ext_up_2, n+1) + diag(ext_up_3,n+2);
A = A + diag(ext_down_1,-1) + diag(ext_down_2, -n-2);


The matrix $B$ is of size $d \times 1$ and is given by



where $B_1, B_2$, of size $(n+1)\times 1$, are defined by



B= zeros(d, 1);
B(n+1, 1) = c1; B(d, 1) = lambda/hx;


The LQR method

We check that a LQR control can be computed for the semi-descretize linear system. To begin, we verify that $ (A,BB^\ast) $ is stabilizable (where $B^\ast$ denotes the transpose of $B$), meaning that $\text{rank}((sI-A) BB^\ast) = d$ for any eigenvalue $s$ of $A$ with a nonnegative real part.

disp('Stabilizability of (A, BB*):');
eA=eig(A);
not_stabilizable = 0;
for cpt=1:d
    if real(eA(cpt))&amp;gt;=0
        disp(cpt); disp(eA(cpt));

        M = zeros(d, 2*d);
        M(:, 1:d) = eA(cpt)*eye(d)-A;
        M(:, d+1:d*2) = B*(B');

        r = rank(M);
        if (r ~= d)
            not_stabilizable = not_stabilizable + 1;
        end
    end
end
if not_stabilizable == 0
    disp('stabilizable.');
else
    disp('not stabilizable.');
end


Stabilizability of (A, BB*):
    18

    0.3047

stabilizable.



Then, we verify that the eigenvalues of the Hamiltonian matrix



are not purely imzginary. Here, $Q$ is a matrix of size $d \times d$ to be chosen.

R = 1; Q = eye(d);
H = blkdiag(A, -A');
H(d+1: 2*d, 1:d) = -Q;
H(1:d, d+1: 2*d) = -B*(B');
eH = eig(H);
nb_imaginary_eig_val_hamiltonian = sum(real(eH) == 0);
disp('Number of eigenvalues of H on the imaginary axis:')
disp(nb_imaginary_eig_val_hamiltonian);


Number of eigenvalues of H on the imaginary axis:
     0




To finish, we verify that $(Q, A)$ is stabilizable, meaning that the rank of



is equal to $d$, for any eigenvalue $s$ of $A$ with a nonnegative real part.

disp('Detectability of (Q, A):');
not_detectable = 0;
for cpt=1:d
    if real(eA(cpt))&amp;gt;=0
        disp(cpt); disp(eA(cpt));

        J = zeros(2*d, d);
        J(1:d, :) = Q;
        J(d+1:d*2, :) = eA(cpt)*eye(d)-A;

        r = rank(J);
        if (r ~= d)
            not_detectable = not_detectable + 1;
        end
    end
end
if not_detectable == 0
    disp('detectable.');
else
    disp('not detectable.');
end


Detectability of (Q, A):
    18

    0.3047

detectable.



The LQR control is given by the matlab routine care(), as the application $t \mapsto -Kz(t)$. The matrix $K$, of size $m \times d$ is an output of care(), where $m$ is the dimention of the input space and is equal to one.

[ricsol, cleig, K, report] = care(A, B, Q, R);
f_ctr = @(z) -K*z;


Unstable and stabilized system’s solutions

u = 0;


We compute the solution to the linear system with a control equal to zero:

F1 = @(t,z) A*z + B*u;
[t1, Z1] = ode45(F1, time, z0);


The corresponding solutions $y$ and $v$ are displayed:

[X,Y] = meshgrid(t1, x1);
figure; surf(X, Y, Z1(:, 1:n+1)');
xlabel('time'); ylabel('space'); title('Solution y for unstable linear system');

[X,Y] = meshgrid(t1, x2);
figure; surf(X, Y, Z1(:, n+2:2*(n+1))');
xlabel('time'); ylabel('space'); title('Solution v for unstable linear system');






We compute the solution to the linear system with the feedback control:

F2 = @(t,z) A*z + B*f_ctr(z);
[t2, Z2] = ode45(F2, time, z0);


The corresponding solutions $y$ and $v$ are displayed:

[X,Y] = meshgrid(t2, x1);
figure; surf(X, Y, Z2(:, 1:n+1)');
xlabel('time'); ylabel('space'); title('Solution y for stabilized linear system');

[X,Y] = meshgrid(t2, x2);
figure; surf(X, Y, Z2(:, n+2:2*(n+1))');
xlabel('time'); ylabel('space'); title('Solution v for stabilized linear system');






We compute the solution to the semilinear system with the same feedback control as the one found for the linear system:

F3 = @(t,z) A*z + B*f_ctr(z) + [z(1:n,1).*z(n+3:d,1);z(n+1, 1)*f_ctr(z);z(n+2, 1)^2 ; z(1:n,1).*z(n+3:d,1)];
[t3, Z3] = ode45(F3, time, z0);


The corresponding solutions $y$ and $v$ are displayed:

[X,Y] = meshgrid(t3, x1);
figure; surf(X, Y, Z3(:, 1:n+1)');
xlabel('time'); ylabel('space'); title('Solution y for stabilized semilinear system');

[X,Y] = meshgrid(t3, x2);
figure; surf(X, Y, Z3(:, n+2:2*(n+1))');
xlabel('time'); ylabel('space'); title('Solution v for stabilized semilinear system');






We compare the euclidean norm of the preceding solutions:

y1_norm = sum(abs(Z1(:, 1:n+1)).^2, 2);
y2_norm = sum(abs(Z2(:, 1:n+1)).^2, 2);
v1_norm = sum(abs(Z1(:, n+2:2*(n+1))).^2, 2);
v2_norm = sum(abs(Z2(:, n+2:2*(n+1))).^2, 2);
y3_norm = sum(abs(Z3(:, 1:n+1)).^2, 2);
v3_norm = sum(abs(Z3(:, n+2:2*(n+1))).^2, 2);
norm1 = (y1_norm + v1_norm).^(1/2);
norm2 = (y2_norm + v2_norm).^(1/2);
norm3 = (y3_norm + v3_norm).^(1/2);
figure;
plot(t1, norm1, 'lineWidth', 2);
hold on;
plot(t2, norm2, 'lineWidth', 2);
plot(t3, norm3, 'lineWidth', 2);
legend('zero control, linear syst.', 'feedback control, linear syst.', 'feedback control, semilin. syst.');
xlabel('time');
ylabel('euclidean norm of z');
title('Euclidean norm of solutions across time');




References

[1] Bastin G., J.-M. Coron, Stability and boundary stabilization of 1-D Hyperbolic systems. 2016.

</description>
        <pubDate>Mon, 29 Oct 2018 00:00:00 +0100</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp05/P0008-Charlotte</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp05/P0008-Charlotte</guid>
        
        
        <category>tutorial</category>
        
        <category>WP05</category>
        
      </item>
    
      <item>
        <title>Stabilization of a collective behavior model</title>
        <description>clc;
clear;


Summary of example objective The goal of this tutorial is to use LQR theory applied to a model of collective behavior. The model choosen shares a formal structure with the semidiscretization of the semilinear 1d heat equation.

Consider $N$  agents $y_i$ for $i=1,…,N$, and let $y=(y_1,…,y_N)\in \mathbb{R}^N$.

The model considered is the following:

 where $A$ is a matrix of the form:



and $\vec{G}:\mathbb{R}^N\to\mathbb{R}^N$ is a non linear function of the form



where $G$ is a non-linear function, matrix $A$ models the interaction between agents. Agent $i$ changes its state according to the state of agent $i+1$ and $i-1$ in a linear way plus a non-linear effect that depends only on his state.

Note that the manifold



is invariant under $F$. Indeed, taking $x\in\mathcal{M}_N$ we have that



Therefore, the mean will follow the following 1-d dynamical system



Here we will consider that $G(0)=0$ and that $DG(0)&amp;gt;0$, we have an unstable critical point at 0. Let N=20,

N=2;
A=full(gallery('tridiag',N,1,-2,1));
A(1,1)=-1;
A(N,N)=-1;


and that



here $G$ is taken in the following form (and we compute also its derivative).

The non-linearity choosen is:

a=5;
c=0.20;
syms G(x);
syms DG(x);
G(x) = piecewise(x&amp;lt;=-a, -2*a*a*x*c-2*a*a*a*c, a&amp;lt;=x, -2*a*a*x*c+2*a*a*a*c, -a&amp;lt;x&amp;lt;a, -c*x*(x-a)*(x+a));
DG(x) = diff(G,x);
G=@(x)double(G(x));
DG = @(x)double(DG(x));

close all
figure(1)
fplot(G,[-10,10])
title('Plot of the non-linearity')
hold off
grid




The function field assigns an $N$ dimensional vector corresponding to the field for every point in $\mathbb{R}^N$, matrix $A$ and the nonlinear function $G$

F=@(t,y) field(A,G,y)



F =

  function_handle with value:

    @(t,y)field(A,G,y)




Now its the turn to define our cost functional. Our goal will be to stabilize the system in a critical point inside the manifold $\mathcal{M}_N$. Notice that, in particular $0$ is a critical point.

We will choose the matrix $Q$ in a way that the vector that defines $\mathcal{M}_N$ is an eigenvector of the matrix $Q$, we have seen that the manifold $\mathcal{M}_N$ is invariant under the flow. Our cost functional will take into account if we are not in this manifold.



We check that its eigenvalues are non-negative

Q=eye(N)-ones([N N])/N;
EigQ=eig(Q)



EigQ =

     0
     1




And we define $R$ being just the identity

R=eye(N);


Linearize arround the unstable equilibrium 0 and obtain the linearized system $\dot{y}=Ly$

p=0;
L=A+DG(p)*eye(N);


we set our control matrix B

B=eye(N);


One has to check the rank of the controllability matrix to see if we satisfy the Kalman rank condition

Co=ctrb(L,B);
rank=rank(Co)



rank =

     2




Once it is done, we are in the position of solving the algebraic Riccati equation

[ricsol,cleig,K,report] = care(L,B,Q);


Consider a time span and an initial datum

radius = 6
ini    = radius*(-0.5+rand(N,1))



radius =

     6


ini =

   -1.3855
    1.4941




the free dynamics would result

tspan = [0, 2];
[t,y] = ode45( F, tspan, ini);

figure(2)
for i=1:N-1
    plot(t, y(:,i));
    hold on;
end
plot(t, y(:,N))
title('Free dynamics')
hold off
grid




Now the LQ controller with the linear and the non-linear dynamics

u_lq = @(t,x) -K * x;


i_linear = @(t,x) L*x + B*u_lq(t,x);
[time, state] = ode45(i_linear,tspan, ini);

i_nonlinear = @(t,x)[F(t,x)+B*u_lq(t,x)];
[timen, staten] = ode45(i_nonlinear,tspan, ini);

figure(3)
for i=1:N-1
    plot(time, state(:,i),'LineWidth',2);
    hold on;
end
plot(time, state(:,N),'LineWidth',2)
grid on
title('LQR regulator on the linearized system')
hold off




[timen, staten] = ode45(i_nonlinear,tspan, ini);

figure(4)
for i=1:N-1
    plot(timen, staten(:,i),'LineWidth',2);
    hold on;
end
plot(timen, staten(:,N),'LineWidth',2)
grid on
title('LQR regulator on the non-linear dynamics')
hold off




</description>
        <pubDate>Sun, 28 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0014-Domenec</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0014-Domenec</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>LQR optimal control design for a coupled PDE-ODE system.</title>
        <description>In this tutorial, we will demonstrate how to design a LQR controller in order to stabilize the following linear coupled (hybrid) PDE-ODE system:



Similar systems may appear in the modelling of a variety physical phenomena, such as the melting of ice in a body of water [1] or fluid-structure interaction [2]. This particular system may be seen as a simplification of the well known one-phase Stefan problem. The stabilization and control of the former has been investigated in recent works by Krstic et al. (see [1] for example). The relationship between the considered system and the Stefan problem, as well as the control of the latter will be considered in a future tutorial.

When no forces are applied, a feature of the governing parabolic PDE is its possibility of generating unstable dynamics as $t \rightarrow \infty$. This phenomenon is due to the fact that the sign of the eigenvalues of the governing elliptic differential operator depends on the magnitude of the constant $\beta$. More precisely, as the differential operator has eigenvalues of the form $\mu_k = \beta - \lambda_k$, where $\lambda_k$ are the eigenvalues of the Dirichlet laplacian, taking $\beta &amp;gt; \lambda_1$ (the biggest among the $\lambda_k$) would yield such a result. We will thence implement a LQR optimal control strategy in order to stabilize the system.

We first need to reduce the PDE-ODE system  to a finite dimensional system of the form



where $A$ and $B$ are matrices, and



is the finite dimensional state vector.

We fix the parameters as follows: $T=1$, $\alpha=1$ and $\beta = 10$:

clc; clear;
T = 1;
nT = 100; nX = 20;
dt = T/nT; dx = 1/(nX+1);
x = linspace(0,1,nX+2);
Dir0 = 1; Dir1 = 0;
alpha = 1; beta = 10;


We begin the code by discretizing in space the parabolic PDE; this is done by finite differences:

Id = eye(nX);
Lapl = -2*Id + diag(ones(nX-1,1),-1) + diag(ones(nX-1,1),1);
A0 = alpha*1/dx^2*Lapl + beta*Id;


In fact, the finite difference discretization of the Dirichlet laplacian may also be done using the MATLAB routine delsq. We proceed similarly for the term $y_x(1,t)$ in the ODE, and assemble the complete matrix $A$:

A = zeros(nX+1,nX+1); A(2:nX+1,2:nX+1) = A0; A(1,2)=-1/dx;


The control matrix B is constructed as follows:

b = zeros(nX,1); b(1,1) = alpha*Dir0/dx^2; b(nX,1) = alpha*Dir1/dx^2;
B = zeros(nX+1,1);
B(1,1) = Dir0/dx;
B(2:nX+1,1) = b;


We may now proceed with the optimal control strategy. For a continuous time linear system generated by the matrices $(A,B)$ and an infinite time horizon cost functional defined as



the feedback control law that minimizes the value of the cost is $u = -Kz$, where $K = R^{-1}B*P$ and $P$ is found by solving the continuous time algebraic Ricatti equation



We check whether the constructed matrices fit in the framework of LQR. Namely, we first verify that the couple $(A, BB*)$ is stabilizable. This is done by checking if $\text{rank}[\lambda I - A, B] = d$ for any $\lambda \in \sigma(A)\cap \mathbb{R}_+$, where $d$ is the dimension of the state space.

eigs = eig(A);
for iter=1:nX+1
    if real(eigs(iter))&amp;gt;=0
        M = zeros(nX+1,2*(nX+1));
        M(:,1:nX+1) = eigs(iter)*eye(nX+1)-A; M(:,nX+2:2*(nX+1)) = B*(B');
        r_ = rank(M);
        stabilizable = (r_ == nX+1);
    end
end


Secondly, we check that the eigenvalues of the associated Hamiltonian matrix do not lie on the imaginary axis.

R = 1; Q = eye(nX+1);
H = blkdiag(A, -A');
H(nX+2: 2*(nX+1), 1:nX+1) = -Q; H(1:nX+1, nX+2: 2*(nX+1)) = -B*(B');
eigH = real(eig(H));
nb_im_eig = sum(eigH == 0);


Finally, we check if the pair $(Q, A)$ is detectable; the variable not_det should equal $0$ after the loop.

not_det = 0;
for iter_=1:nX+1
    if real(eigs(iter_))&amp;gt;=0
        M_ = zeros(2*(nX+1), nX+1);
        M_(1:nX+1, :) = Q; M_(nX+2:(nX+1)*2, :) = eigs(iter_)*eye(nX+1)-A;
        r_ = rank(M_);
        if (r_ ~= nX+1)
            not_det = not_det + 1;
        end
    end
end


We are now in a position to construct the LQR feedback control by solving the algebraic Ricatti equation. This is done by using the MATLAB Control Toolbox routine care:

[ricsol, cleig, K, report] = care(A, B, Q, R);
f_ctr = @(z) -K*z;


We now compare the uncontrolled (thence unstable) dynamics with the dynamics stabilized by the LQR feedback control. As initial datum for both systems, we pick $u_0(x) = \cos(\pi*x)$ and $s_0 = 0.1$.

x_int = x(1:nX);
y0 = cos(x_int*pi)';
z0 = zeros(nX+1,1); z0(1,1) = 0.1; z0(2:nX+1,1) = y0;


The free system is solved with the Dirichlet boundary condition $u(0,t) = 0.15$:

f1 = @(t,v) A*v + B*0.15;
[t1, z_free] = ode45(f1, linspace(0,T,nT), z0);
[X1,Y1] = meshgrid(t1,x_int);
surf(X1, Y1, z_free(:,2:nX+1)');
xlabel('Time');
ylabel('Space');
title('Unstable state y_{un} = y_{un}(t,x)')




Now we solve and visualize the controlled problem:

f2 = @(t,z) A*z + B*f_ctr(z);
[t2, z_ctr] = ode45(f2, linspace(0,T,nT), z0);
figure;
[X2,Y2] = meshgrid(t2,x_int);
surf(X2, Y2, z_ctr(:,2:nX+1)');
xlabel('Time');
ylabel('Space');
title('Stablilized state y_{st} = y_{st}(t,x)')




We also plot the corresponding solutions to the ODE:

figure;
plot(t1, z_free(:,1), 'Color', [0.8500, 0.3250, 0.0980], 'LineWidth', 1.5);
hold on;
plot(t2, z_ctr(:,1), 'Color', [0, 0.4470, 0.7410], 'LineWidth', 1.5);
legend('Unstable', 'Stabilized', 'Location', 'SouthWest');
xlabel('Time')
title('The state s')




As a final test of our results, we compare the $L^2(0,1)$-norms of both the controlled and uncontrolled state with respect to time.

norm_free = 1/nX*sum(z_free.^2,2).^0.5;
norm_ctr = 1/nX*sum(z_ctr.^2,2).^0.5;
figure;
plot(t1, norm_free, 'Color', [0.8500, 0.3250, 0.0980], 'LineWidth', 1.5);
hold on;
plot(t2, norm_ctr, 'Color', [0, 0.4470, 0.7410], 'LineWidth', 1.5);
legend('Unstable state', 'Stabilized state', 'Location', 'NorthWest');
xlabel('Time');
title('L^2 Norm');




References:

[1] Koga, Shumon and Diagne, Mamadou and Krstic, Miroslav. Output feedback control of the one-phase Stefan problem. 2016 IEEE 55th Conference on Decision and Control (CDC) (2016).

[2] Vazquez, Juan Luis and Zuazua, Enrique. Large time behavior for a simplified 1D model of fluid-solid interaction. Comm. Partial Differential Equations 28 (2003), no. 9-10, 1705-1738.

</description>
        <pubDate>Sun, 28 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp05/P0006</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp05/P0006</guid>
        
        
        <category>tutorial</category>
        
        <category>WP05</category>
        
      </item>
    
      <item>
        <title>Optimal control of a  graph evolving in discrete time</title>
        <description>In this tutorial we are going to show how to use MATLAB to control a discrete-time dynamical system that models the interactions between the nodes of a graph. The control policy will minimize a discrete linear quadratic regulator.

Let us consider a graph G that consists on $N$ nodes $x_i\in\mathbb{R}$, $i={1,2,…,N}$ that evolve in discrete time steps according to the following equation:



where $\gamma &amp;gt; 0$ is a coupling parameter.

We can simplify this equation by using the Perron matrix $P$ of the graph, this matrix is defined as $P = I - \gamma L$, where $L$ is the Laplacian of the graph and $I$ is the identity matrix. Let $x$ be $[x_1,…,x_N]^T$, the vector of states of the nodes. Moreover, we may add a control



to drive the states of the nodes to a desired state.



were $B$ and $C$ are two fixed matrices and $y\in\mathbb{R}^S$ are the observed states of $1\leq S\leq N$ nodes.

We aim to design a control policy ${u[k]}_{k=0,1,…}$ such that minimizes the following functional $J(x,u)$ while stabilizing the system.



where $Q$ and $R$ are semidefinite positive and definite positive matrices respectively. We can choose these two matrices in order to penalize aggressive or slow controls. To do so, we will use MATLAB’s control system toolbox.

Finally, we will add a reference term in the control so that we can drive the system into a desired state.

For instance, let us consider the coupling parameter

gamma = 0.1;


We define now a connected and bidirected graph G. Let E be the edges of the graph. We will define this set as a 2-column matrix and then we create the graph G.

E = [1, 2; 1, 3; 2, 4; 2, 5; 3, 4; 4, 5; 4, 6; 6, 7; 7, 8];
E = table(E,'VariableNames',{'EndNodes'});
G = graph(E);


This is our graph

plot(G, 'LineWidth', 2, 'EdgeColor', 'r', 'MarkerSize', 10)
title('Graph representation', 'FontSize', 16)




N is the size of the graph, that is to say, the number of nodes.

N = numnodes(G);


We compute the number of neighbours of each node

connectivities = degree(G);


We check whether the graph is connected or not, if not, we must choose a different graph.

if max(conncomp(G)) &amp;gt; 1
    print('Generate a new graph')
end


In this example the considered graph is connected.

We compute the Perron matrix of $G$.

P = eye(N) - gamma * laplacian(G);


We can see that the system tends to reach a consensus, that is to say, if no control is applied to the system, it evolves to a steady state in which all the nodes have the same state.

We define the initial state $x_0$

x_0 = [1, 5, 0, 4, 3, 1, 7, 3]';


The mean of $x_0$ is 3

mean(x_0)



ans =

     3




The states of the nodes will evolve to the mean of the states at the initial time. We let the system evolve for 150 iterations.

itmax = 150;
x = zeros(N, itmax + 1);
x(:,1) = x_0;
for k = 1:itmax
    x(:,k + 1) = P * x(:,k);
end


clf
hold on
for k = 1:N
    plot(0:itmax,x(k,:),'LineWidth',2)
end
legend('Node 1','Node 2','Node 3','Node 4','Node 5','Node 6','Node 7','Node 8')
title('Graph evolution without control','FontSize',16)
xlabel('Iterations','FontSize',16)
ylabel('States of the nodes','FontSize',16)




As stated before, we can see in this figure that the system naturally reaches consensus.

Recall that the system dynamics can be written as



for any $k =0,1,…$.

We want to find a control $u$ such that the system stabilizes to the zero state.

We proceed to define matrices B and C:

B = eye(N);
C = eye(N);
%% We can check whether the system is controllable
if rank(ctrb(P,B)) &amp;lt; N
    print('it is not controllable!')
end
%% In this case, it is controllable.


We choose the matrices $Q$ and $R$ by using Bryson and Ho’s criterium.

Q_diag = 1 / max(x_0.^2) * ones(1, N);
R_diag = 1 / 5^2 * ones(1, N);
Q = diag(Q_diag);
R = diag(R_diag);


We can use now the function dlqr (discrete linear quadratic regulator) to find the feedback control $u = -K_{f} x[k]$ that minimizes the functional $J(x,u)$.

[Kf, ~] = dlqr(P, B, Q, R);


Now we can stabilize the system by using the feedback control that we have just computed

itmax = 20;
x = zeros(N, itmax + 1);
x(:,1) = x_0;
for k = 1:itmax
    x(:,k + 1) = (P - B * Kf) * x(:,k);
end


clf
hold on

for k = 1:N
    plot(0:itmax,x(k,:),'LineWidth',2)
end
legend('Node 1','Node 2','Node 3','Node 4','Node 5','Node 6','Node 7','Node 8')
title('Graph stabilization','FontSize',16)
xlabel('Iterations','FontSize',16)
ylabel('States of the nodes','FontSize',16)




We can see that the system is stabilized fast. One can tune the stabilization speed by choosing matrices $Q$ and $R$ in a smart way.

Now, we are about to add a reference term to the control to drive the system to a desired state. For instance, we can drive the system into the reference state

r = (1:N)';


We add a reference term to the control that is proportional to the reference r, $u[k] = -K_{f}x[k] + K_{r}r$. We can use linear algebra to compute the matrix $K_{r}$ in terms of the system matrices.

Kr = -(C * (P - B * Kf - eye(N))^(-1) * B)^(-1);


We drive the system to the reference state.

itmax = 20;
x = zeros(N, itmax + 1);
x(:,1) = x_0;
for k = 1:itmax
    x(:,k + 1) = (P - B * Kf) * x(:,k) + B * Kr * r;
end


clf
hold on
for k = 1:N
    plot(0:itmax,x(k,:),'LineWidth',2)
end
legend('Node 1','Node 2','Node 3','Node 4','Node 5','Node 6','Node 7','Node 8')
title('Controlled graph','FontSize',16)
xlabel('Iterations','FontSize',16)
ylabel('States of the nodes','FontSize',16)




Assume now that we can control only the node 1 and we want to drive the node 8 to the reference state r = 1. Can we do it? Let’s see.

B = zeros(N, 1);
B(1) = 1;
C = zeros(1, N);
C(8) = 1;
if rank(ctrb(P,B)) &amp;lt; N
    print('it is not controllable!')
end


It is controllable.

Q_diag = 1 / max(x_0.^2) * ones(1, N);
R_diag = 1 / 5^2;
Q = diag(Q_diag);
R = diag(R_diag);
[Kf, ~] = dlqr(P, B, Q, R);
Kr = -(C * (P - B * Kf - eye(N))^(-1) * B)^(-1);
r = 1;
itmax = 200;
x = zeros(N, itmax + 1);
x(:,1) = x_0;
for k = 1:itmax
    x(:,k + 1) = (P - B * Kf) * x(:,k) + B * Kr * r;
end


clf
hold on
for k = 1:N
    plot(0:itmax,x(k,:),'LineWidth',2)
end
legend('Node 1','Node 2','Node 3','Node 4','Node 5','Node 6','Node 7','Node 8')
title('Driving node 8 to the state 1','FontSize',16)
xlabel('Iterations','FontSize',16)
ylabel('States of the nodes','FontSize',16)




As we can see, the node 8 is driven to the state 1 by achieving consensus in all the states of the graph.

References

[1]: R. Olfati-Saber, J. A. Fax, and R. M. Murray, &quot;Consensus and cooperation in networked multi-agent systems&quot;. Proc. IEEE. vol. 95, pp. 215&amp;#150;233, Jan. 2007.
[2]: K. J. &amp;Aring;str&amp;ouml;m, and R. M. Murray, &quot;Feedback Systems: An Introduction for Scientists and Engineers&quot;. Princeton University Press, 2008, Princeton, NJ.
</description>
        <pubDate>Fri, 26 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0001</link>
        <guid isPermaLink="true">https://deustotech.github.io/DyCon-Blog/tutorial/wp99/P0001</guid>
        
        
        <category>tutorial</category>
        
        <category>WP99</category>
        
      </item>
    
  </channel>
</rss>
