<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Welcome to the web interface of DyCon Toolbox, the computational platform developed within the <a href='https://cmc.deusto.eus/dycon/' target='_blank'>ERC DyCon - Dynamic Control</a> project.">
	<link rel='shortcut icon' type='image/png' href='/DyCon-Blog/favicon.png' />

  <title>
    typo - DyCon Blog
    
  </title>

  <link rel="canonical" href="https://deustotech.github.io/DyCon-Blog/typo">

  <!-- Bootstrap Core CSS -->
  <link rel="stylesheet" href="https://deustotech.github.io/DyCon-Blog/css/bootstrap.min.css">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="https://deustotech.github.io/DyCon-Blog/css/clean-blog.css">

   <!-- Adjust Colors -->
  <link rel="stylesheet" href="https://deustotech.github.io/DyCon-Blog/colorscheme.css">

  <!-- Pygments Github CSS -->
  <link rel="stylesheet" href="https://deustotech.github.io/DyCon-Blog/css/syntax.css">


  <script src="https://deustotech.github.io/DyCon-Blog/lib/js/libgif.js "></script>
  <script src="https://deustotech.github.io/DyCon-Blog/lib/js/rubbable.js "></script>


  <!-- Google Fonts Raleway -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,700" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
	<!-- MathJax -->
  <script type="text/x-mathjax-config">
	MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    },
		TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      },
      extensions: ["AMSmath.js", "AMSsymbols.js"],
      Macros:{
        norm: ["|| #1 ||",1],
        abs: ["| #1 |",1],
        hdots: "...",
        RR: "\\mathbb{R}",
        ffl: ["(d_x^2)^{#1}",1],
        ccs: "c_{1,s}",
        kernel: ["|x-y|^{#1}",1],
        ue: ["#1^{\\epsilon}",1]
      }
    },
    CommonHTML: {
      styles: {
        "@font-face /* vec */ ": {
          "font-family": "MJX-VEC",
          src: [
            "url(data:application/x-font-woff;charset=utf-8;base64,",
            "d09GRgABAAAAAARMAA0AAAAABiQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEMAAAABwA",
            "AAAccRGLqUdERUYAAAQMAAAAJAAAACgANAAmT1MvMgAAAaAAAABJAAAAYFc5gfFjbWFwAAACAAAA",
            "AEYAAAFKQxjlbWdhc3AAAAQEAAAACAAAAAj//wADZ2x5ZgAAAlQAAACUAAAAlIQU9HBoZWFkAAAB",
            "MAAAADAAAAA2C748e2hoZWEAAAFgAAAAHgAAACQFXQDqaG10eAAAAewAAAAUAAAAFAYvAE9sb2Nh",
            "AAACSAAAAAwAAAAMACgAcm1heHAAAAGAAAAAHQAAACAASQAmbmFtZQAAAugAAADxAAAB5uwlD0hw",
            "b3N0AAAD3AAAACgAAAA34M9aEXjaY2BkYGAA4uOfgq7G89t8ZeBmfgEUYbga+icNTssClVxnOgXk",
            "cjAwgUQBdqEMW3jaY2BkYGBu+feBgYHxCwMQMF5nYGRABawAcaQESgAAeNpjYGRgYGBlUGZgYgAB",
            "EMnIABJzAPMZAAZZAHAAAAB42mNgYSxn/MLAysDA1MW0h4GBoQdCMz5gMGRkAooysDEzwAAjECvA",
            "OAFprikMBxgUFCcxt/z7wMDA3MIoAFUDAwoMjACD8Qv5AAAAAfQAMgAAAAABTQAAAPoAAAH0AB14",
            "2mNgYGBmgGAZBkYGEHAB8hjBfBYGDSDNBqQZGZgYFBQn/f8P5IPp/4/vFUHVAwEjGwOcw8gEJJgY",
            "UAEjxIrhDACLGwmnAAAAAAAUABQAFAAUAEoAAgAyAAABwgIVAAMABwAAMxEhESUhESEyAZD+ogEs",
            "/tQCFf3rMgGxAAEAHQIEAdcCygAiAAABNDYzMhcWFxYXFhUUBgcGBw4DIyImNTQ3IycmNTQ3ISYB",
            "eQsJBwUFBQofCwYLKyACBwMGBAcNL6urDQ0BZxgCtggMBQQPJRQHCwkGBhYpAgkCAgsJEygBCQoH",
            "DSYAeNqVjrGKwkAURe/EGBBUrG12CishMrFQcDuLsAi26YMOmsIMxAh+hN8i+CF+gd+y4B3zttjC",
            "woHhncu7774HoI8rFP5eIKzQw5dwgAjfwi2McBEO6bkLtzHAr3CEnhrTqcKOpDasMCQ1HKCLWLiF",
            "HyyFQ3puwm1oPIQjDFXfR62Ro8YeK9YzMlhsqB0qtvJ6v8rPmd3Uzkv2tihwwoHCbosTa0pryYH0",
            "NbKjRWPB/z626Se8dsY/hSHPGeTKOnXVzuqF/reYOoln8dQk80+u9b0KR97rD9Rc4xdNXtVQI7PV",
            "sXClNiaZGGP0B+FPMN1KMAAAAHjaY2BiAIP/zQxGDNgAKxAzMjAxMDMycSUWFeWXF2WmZ5QAAGh5",
            "BhgAAAAB//8AAnjaY2BkYGDgA2IJBgUgycTAyMDMwAIkWcA8BgZGCAYACgIAWwAAAAEAAAAAxmW3",
            "ygAAAADVVeemAAAAANVV7Dg=) format('woff')"
          ].join('')
        },
        ".MJX-VEC": {
          "font-family": "MJX-VEC"
        }
      }
    }
  });
  MathJax.Hub.Register.StartupHook("CommonHTML Jax Ready", function () {
    var MML = MathJax.ElementJax.mml;
    var fixCombiningChar = MML.mo.prototype.CHTMLfixCombiningChar;
    MML.mo.Augment({
      CHTMLfixCombiningChar: function (node) {
        if (node.textContent === '\u20D7') {
          //
          //  Safari makes combining characters into non-combining ones when
          //  they don't have anything to combine with; replace \vec arrow
          //  with a non-combining one so all browsers get the same thing
          //
          node = node.firstChild;
          node.firstChild.nodeValue = "\u2192";
          node.className = "mjx-char MJX-VEC";
          node.style.marginLeft = "-.5em";
          node.style.paddingTop = ".45em";
        } else {
          fixCombiningChar.call(this,node);
        }
      }
    });
  });
	</script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.4.13/d3.min.js" type="text/javascript"></script>-->

    <!-- jQuery -->
	<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

	<!-- Bootstrap Core JavaScript -->
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>

	<!-- Custom Theme JavaScript -->
  <script src="https://deustotech.github.io/DyCon-Blog/js/clean-blog.min.js "></script>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-128123935-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-128123935-3');
  </script>
  <!-- End Google Analytics -->



  <!-- marKdown editor -->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.css">
  <script src="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.js"></script>
</head>

<body>
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <!-- <a class="navbar-brand" href="/DyCon-Blog/">
                 <img src="https://deustotech.github.io//DyCon-Blog//assets/logo_DyCon.png">
            </a> -->
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/DyCon-Blog/">Home</a>
                </li>
                
                
                    
                        
                    
                <li>
                    <a href="/DyCon-Blog/projects/posts">Documentation</a>
                </li>
                
                    
                <li>
                    <a href="/DyCon-Blog/projects/authors">Authors</a>
                </li>
                
                <li>
                        <a href="https://deustotech.github.io/DyCon-Blog/projects/search.byWP">Sitemap</a>
                </li>
                <li>
                        <a href="http://cmc.deusto.eus/">Chair of Computational Mathematics</a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;This code needs the installation of CasADi 3.4.5: &lt;a href="https://web.casadi.org/get/"&gt;https://web.casadi.org/get/&lt;/a&gt;&lt;/p&gt;
</code></pre></div></div>

<p>The objectives of this post are twofold, one is to introduce CasADi (with IpOpt) to simulate optimal control problem, and the other is to introduce the concept of the structural controllability, as an example, for the 2D heat equation.</p>

<h1 id="controllability-of-the-2d-heat-equation">Controllability of the 2D heat equation</h1>

<p>In this post, we simulate structural controllability for the two-dimensional heat equation. First, we start with the finite difference scheme of the 2D Heat equation and the control on one boundary of the square domain $[0,1]^2$.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} \displaystyle\frac{dz_{i,j}}{dt} = (N+1)^2(z_{i+1,j}+z_{i-1,j}+z_{i,j+1}+z_{i,j-1}-4z_{i,j}) + u_{i,j}\delta(i-1), & i,j = 1,\ldots,N,~ t \in (0,T) \\ z_{i,j}(t) = 0, & i = 0, N+1, ~\text{or}~ j=0, N+1,~ t \in (0,T) \\ z_{i,j}(0)=z^0_{i,j}, & i,j=1,\ldots,N. \end{cases} %]]></script>

<p>A similar problem has been treated in another <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/WP03-P0022">DyCon Blog post</a> using AMPL and IpOpt, which deals with the one-dimensional fractional heat equation under positivity constraints. Here we use CasADi and IpOpt in Matlab language.</p>

<p>We will consider the problem of steering the initial datum:</p>

<script type="math/tex; mode=display">z^0_{i,j} = \sin(\pi x_i)\sin(\pi y_j),\quad x_i = i/(N+1) \quad\text{and}\quad y_j = j/(N+1).</script>

<p>to the final target $(1.5 \cdot \bar z_{i,j}(T))$, where $\bar z_{i,j}(T)$ is a reference solution from $z^0_{i,j}$ without control.</p>

<h2 id="problem-formulation">Problem formulation</h2>

<p>Parameters for the problem:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">%% Space discretization for 1D</span>
<span class="n">Nx</span> <span class="o">=</span> <span class="n">N_size</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span> <span class="c1">%% Space discretization for 2D</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">%% Time discretization</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c1">%% Final time</span>

<span class="c1">%% Discretization of the Space</span>
<span class="n">xline_</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="p">[</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">xline_</span><span class="p">,</span><span class="n">xline_</span><span class="p">);</span>
<span class="nb">xline</span> <span class="o">=</span> <span class="n">xline_</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">[</span><span class="n">xms</span><span class="p">,</span><span class="n">yms</span><span class="p">]</span>   <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="nb">xline</span><span class="p">,</span><span class="nb">xline</span><span class="p">);</span>

<span class="n">dx</span> <span class="o">=</span> <span class="nb">xline</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="nb">xline</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">%% Initial data</span>
<span class="n">Y0_2d</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="p">);</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span>
    <span class="k">for</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span>
        <span class="n">Y0_2d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="nb">xline</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="nb">pi</span><span class="p">)</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="nb">xline</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="nb">pi</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="n">Y0</span> <span class="o">=</span> <span class="n">Y0_2d</span><span class="p">(:);</span>


<span class="c1">%% Definition of the dynamics : Y' = AY+BU</span>
<span class="n">B</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span> <span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span><span class="p">)</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N_size</span><span class="p">);</span> <span class="c1">%% control for i=1,...,N_size.</span>

<span class="n">A1_mat</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">A2_mat</span> <span class="o">=</span> <span class="nb">spdiags</span><span class="p">([</span><span class="n">A1_mat</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">A1_mat</span> <span class="n">A1_mat</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">],</span> <span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">I_mat</span>  <span class="o">=</span> <span class="nb">speye</span><span class="p">(</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">A_mat</span>  <span class="o">=</span> <span class="nb">kron</span><span class="p">(</span><span class="n">I_mat</span><span class="p">,</span><span class="n">A2_mat</span><span class="p">)</span><span class="o">+</span><span class="nb">kron</span><span class="p">(</span><span class="n">A2_mat</span><span class="p">,</span><span class="n">I_mat</span><span class="p">);</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">A_mat</span><span class="p">;</span> <span class="c1">%% A: Discrete Laplacian in 2D with uniform squared mesh</span>

<span class="c1">%% Discretization of the time : we need to check CFL condition to change 'Nt'.</span>
<span class="n">tline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%%uniform time mesh</span>

<span class="n">dt</span> <span class="o">=</span> <span class="n">tline</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">tline</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>The interactions between nodes (grid points) can be displayed as follows:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">options_plot_graphs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">'DisplayName'</span><span class="p">,</span><span class="s1">'off'</span><span class="p">,</span><span class="s1">'NodeColor'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">'ArrowSize'</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="s1">'MarkerSize'</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="s1">'NodeLabel'</span><span class="p">,{}};</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="nb">digraph</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="s1">'XData'</span><span class="p">,</span><span class="n">xms</span><span class="p">(:)</span><span class="s1">','</span><span class="n">YData</span><span class="s1">',yms(:)'</span><span class="p">,</span><span class="n">options_plot_graphs</span><span class="p">{:});</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xms</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="n">yms</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'b.'</span><span class="p">,</span><span class="s1">'MarkerSize'</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span> <span class="c1">%% Blue dots are controlled nodes</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x-axis'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'y-axis'</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span><span class="o">.^</span><span class="mi">2</span>
    <span class="nb">text</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">XData</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">YData</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mf">0.02</span><span class="p">,</span> <span class="nb">num2str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s1">'FontSize'</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></div></div>

<p><img style="width:70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_01.png" /></p>

<center><p>Fig 1. The interaction network of 'A_mat'. The controlled nodes are colored blue.</p></center>

<p>Now we may simulate the reference trajectory without control.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">%% Simulation of the uncontrolled trajectory</span>
<span class="n">M</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">/</span><span class="n">dx</span><span class="o">.^</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">/</span><span class="n">dx</span><span class="o">.^</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">B</span><span class="p">;</span>

<span class="n">Y</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

<span class="n">Y</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Y0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">%% loop over time intervals</span>
   <span class="c1">%% Crank-Nicolson method without control</span>
   <span class="n">Y</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">M</span><span class="p">\</span><span class="n">L</span><span class="o">*</span><span class="n">Y</span><span class="p">(:,</span><span class="n">k</span><span class="p">);</span>
<span class="k">end</span>
<span class="n">YT</span> <span class="o">=</span> <span class="n">Y</span><span class="p">(:,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

<span class="n">ratio</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">;</span>
<span class="n">Y1</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">*</span><span class="n">YT</span><span class="p">;</span> <span class="c1">%% Target data</span>

<span class="nb">clf</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">;</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Z</span><span class="p">,</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">)];</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">;</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Z</span><span class="p">,</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">)];</span>
<span class="n">jsurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">jsurf</span><span class="o">.</span><span class="n">Parent</span><span class="o">.</span><span class="n">Color</span> <span class="o">=</span> <span class="s1">'none'</span><span class="p">;</span>
<span class="nb">lightangle</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">({</span><span class="s1">'Initial Condition'</span><span class="p">,</span><span class="s1">'Final Data'</span><span class="p">})</span>
</code></pre></div></div>

<p><img style="width:70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_02.png" /></p>
<center><p>Fig 2. The initial condition and the final data of uncontrolled dynamics.</p></center>

<h2 id="optimization-problem">Optimization problem</h2>

<p>From now on, we use CasADi to consider an exact control problem.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">opti</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Opti</span><span class="p">();</span>  <span class="c1">%% CasADi function</span>

<span class="c1">%% ---- Input variables ---------</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% state trajectory</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">%% control</span>

<span class="c1">%% ---- Dynamic constraints --------</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">%% loop over control intervals</span>
   <span class="c1">%% Crank-Nicolson method : this helps us to boost the optimization</span>
   <span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">X</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span> <span class="n">L</span><span class="o">*</span><span class="n">X</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">U</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">U</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)));</span>
<span class="k">end</span>

<span class="c1">%% ---- State constraints --------</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">X</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">Y0</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">X</span><span class="p">(:,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">Y1</span><span class="p">);</span>

<span class="c1">%% ---- Optimization objective  ----------</span>
<span class="n">Cost</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">U</span><span class="o">.^</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="p">/</span><span class="n">Nt</span><span class="p">));</span>
<span class="n">opti</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">Cost</span><span class="p">);</span> <span class="c1">%% minimizing L2 over time</span>

<span class="c1">%% ---- initial guesses for solver ---</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">%% ---- solve NLP              ------</span>
<span class="n">p_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'expand'</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
<span class="n">s_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'max_iter'</span><span class="p">,</span><span class="mi">10000</span><span class="p">);</span> <span class="c1">%% iteration limitation</span>

<span class="n">opti</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="s1">'ipopt'</span><span class="p">,</span><span class="n">p_opts</span><span class="p">,</span><span class="n">s_opts</span><span class="p">);</span> <span class="c1">%% set numerical backend</span>
<span class="nb">tic</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">solve</span><span class="p">();</span>   <span class="c1">%% actual solve</span>
<span class="nb">toc</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is Ipopt version 3.12.3, running with linear solver mumps.
NOTE: Other linear solvers might be more efficient (see Ipopt documentation).

Number of nonzeros in equality constraint Jacobian...:     2752
Number of nonzeros in inequality constraint Jacobian.:        0
Number of nonzeros in Lagrangian Hessian.............:       84

Total number of variables............................:      420
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:      352
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  0.0000000e+00 6.69e-02 0.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.6511358e+02 6.66e-16 7.31e-07  -2.5 8.68e+01    -  1.00e+00 1.00e+00h  1
   2  1.6511358e+02 6.66e-16 2.39e-12  -8.6 5.47e-09    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 2

                                   (scaled)                 (unscaled)
Objective...............:   1.6511358437684962e+02    1.6511358437684962e+02
Dual infeasibility......:   2.3874235921539366e-12    2.3874235921539366e-12
Constraint violation....:   6.6613381477509392e-16    6.6613381477509392e-16
Complementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00
Overall NLP error.......:   4.0210221040688533e-13    2.3874235921539366e-12


Number of objective function evaluations             = 3
Number of objective gradient evaluations             = 3
Number of equality constraint evaluations            = 3
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 3
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 2
Total CPU secs in IPOPT (w/o function evaluations)   =      0.822
Total CPU secs in NLP function evaluations           =      0.000

EXIT: Optimal Solution Found.
               t_proc [s]   t_wall [s]    n_eval
       nlp_f      1.9e-05      1.9e-05         3
       nlp_g     0.000103     0.000105         3
  nlp_grad_f      3.7e-05      3.4e-05         4
  nlp_hess_l      1.4e-05      1.3e-05         2
   nlp_jac_g     0.000185     0.000195         4
      solver         1.09        0.676         1
Elapsed time is 0.757156 seconds.

</code></pre></div></div>

<h2 id="post-processing">Post-processing</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Sol_x</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">X</span><span class="p">);</span> <span class="c1">%% solved controlled trajectory</span>
<span class="n">Sol_u</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">U</span><span class="p">);</span> <span class="c1">%% solved control function</span>

<span class="nb">clf</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Sol_x</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">jsurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">*</span><span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="nb">plot3</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'k*'</span><span class="p">)</span>

<span class="n">jsurf</span><span class="o">.</span><span class="n">Parent</span><span class="o">.</span><span class="n">Color</span> <span class="o">=</span> <span class="s1">'none'</span><span class="p">;</span>
<span class="nb">lightangle</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>

<span class="nb">legend</span><span class="p">({</span><span class="s1">'Controlled final data'</span><span class="p">,</span><span class="s1">'Uncontrolled final data'</span><span class="p">,</span><span class="s1">'Target'</span><span class="p">})</span>
</code></pre></div></div>

<p><img style="width:70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_03.png" /></p>

<center><p>Fig 3. The final data of controlled and uncontrolled dynamics. The controlled data coinside with the target points.</p></center>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">%% Free and controlled dynamics in animation</span>

<span class="n">Result_ref</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% displaying variable</span>
<span class="n">Result_ref</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,:),[</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>

<span class="n">Result_con2d</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% displaying variable</span>
<span class="n">Result_con2d</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Sol_x</span><span class="p">(:,:),[</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="c1">%% Free dynamics</span>
<span class="n">fig</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="n">isurf2</span><span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="k">end</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Free dynamics'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Target'</span><span class="p">,</span><span class="s1">'Solution'</span><span class="p">)</span>
<span class="nb">zlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="nb">pause</span><span class="p">;</span>
<span class="k">for</span> <span class="n">it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span>
   <span class="n">isurf</span><span class="o">.</span><span class="n">ZData</span> <span class="o">=</span>  <span class="n">Result_ref</span><span class="p">(:,:,</span><span class="n">it</span><span class="p">);</span>
    <span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1">%% Controlled dynamics</span>
<span class="nb">clf</span>
<span class="n">fig</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="n">isurf2</span><span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="k">end</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">Result_con2d</span><span class="p">(:,:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Controlled dynamics'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Target'</span><span class="p">,</span><span class="s1">'Solution'</span><span class="p">)</span>
<span class="nb">zlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="nb">pause</span><span class="p">;</span>
<span class="k">for</span> <span class="n">it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span>
   <span class="n">isurf</span><span class="o">.</span><span class="n">ZData</span> <span class="o">=</span>  <span class="n">Result_con2d</span><span class="p">(:,:,</span><span class="n">it</span><span class="p">);</span>
    <span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<table>
   <tr>
      <th>
         <center><video controls="" width="95%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_04-c.mp4"></video></center>
      </th>
      <th>
        <center><video controls="" width="95%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_05-c.mp4"> </video></center>
      </th>
   </tr>
</table>

<center><p><b>Fig 4-5.</b> Animations for the free and controlled dynamics. The target surface is also drawn in both dynamics, where free dynamics goes below than the target.</p></center>

<h1 id="structural-controllability-of-the-2d-heat-equation">Structural controllability of the 2D heat equation</h1>

<p>For the second part, we simulate another linear system to check the structural controllability of the 2D heat equation. It is known that its interacting <a href="https://en.wikipedia.org/wiki/Network_controllability">network is structurally controllable</a> by one sole node.</p>

<p>The following matrix ‘AS_mat’ links the nodes in a line, for example, 1-2-3-6-5-4-7-8-9 for $N=3$, which is a part of interactions in ‘A_mat’:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AC_mat</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">N_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="n">N_size</span><span class="o">-</span><span class="mi">2</span>
    <span class="n">AC_mat</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">AC_mat</span><span class="p">,</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">N_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">AC_mat</span><span class="p">(</span><span class="k">end</span><span class="p">,</span><span class="k">end</span><span class="o">-</span><span class="n">N_size</span><span class="p">)</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">N_size</span><span class="o">==</span><span class="mi">2</span>
        <span class="k">break</span>
    <span class="k">end</span>
    <span class="n">AC_mat</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">AC_mat</span><span class="p">,</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">N_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">AC_mat</span><span class="p">(</span><span class="k">end</span><span class="o">-</span><span class="n">N_size</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="k">end</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">N_size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="k">end</span>
<span class="k">if</span> <span class="nb">length</span><span class="p">(</span><span class="n">AC_mat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">N_size</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">AC_mat</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">AC_mat</span><span class="p">,</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">N_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">AC_mat</span><span class="p">(</span><span class="k">end</span><span class="p">,</span><span class="k">end</span><span class="o">-</span><span class="n">N_size</span><span class="p">)</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="k">end</span>

<span class="n">AS_mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">AC_mat</span> <span class="o">+</span> <span class="n">AC_mat</span><span class="o">'</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">Nx</span><span class="p">);</span>

<span class="n">options_plot_graphs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">'DisplayName'</span><span class="p">,</span><span class="s1">'off'</span><span class="p">,</span><span class="s1">'NodeColor'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">'ArrowSize'</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="s1">'MarkerSize'</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="s1">'NodeLabel'</span><span class="p">,{}};</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="nb">digraph</span><span class="p">(</span><span class="n">AS_mat</span><span class="p">),</span><span class="s1">'XData'</span><span class="p">,</span><span class="n">xms</span><span class="p">(:)</span><span class="s1">','</span><span class="n">YData</span><span class="s1">',yms(:)'</span><span class="p">,</span><span class="n">options_plot_graphs</span><span class="p">{:});</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x-axis'</span><span class="p">);</span><span class="nb">ylabel</span><span class="p">(</span><span class="s1">'y-axis'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xms</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">yms</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'b.'</span><span class="p">,</span><span class="s1">'MarkerSize'</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span> <span class="c1">%% Blue dots are controlled nodes</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span><span class="o">.^</span><span class="mi">2</span>
    <span class="nb">text</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">XData</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">YData</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mf">0.02</span><span class="p">,</span> <span class="nb">num2str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s1">'FontSize'</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">end</span>

<span class="nb">title</span><span class="p">(</span><span class="s1">'Network'</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
</code></pre></div></div>

<p><img style="width:70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_06.png" /></p>

<center><p>Fig 6. The interaction network of the new matrix 'AS_mat'. The controlled nodes are colored blue.</p></center>

<p>Since the 1D heat equation is controllable, ‘AS_mat’ is controllable by one node. However, it gets more and more difficult as the number of nodes increases, since it has different scale with the standard 1D heat equation. The length of the 1D domain grows as $N$ since it eventually become space filling curve in $[0,1]^2$.</p>

<p>Note also that ‘AS_mat’ has the nonzero elements in the positions that ‘A_mat’ has. By deleting several interactions of ‘A_mat’, ‘AS_mat’ is now exactly controllable with smaller controlled nodes. This is the idea of the structural controllability in the network system, called ‘network control’.</p>

<h2 id="problem-formulation-1">Problem formulation</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">N_size</span><span class="o">.^</span><span class="mi">2</span><span class="o">*</span><span class="n">AS_mat</span><span class="p">;</span>
<span class="c1">%% Y' = AY + BU</span>

<span class="n">T</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">tline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%%uniform time mesh</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">tline</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">tline</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">%% Simulation of the uncontrolled trajectory</span>
<span class="n">M</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">/</span><span class="n">dx</span><span class="o">.^</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">/</span><span class="n">dx</span><span class="o">.^</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">B</span><span class="p">;</span>

<span class="n">Y</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Y</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Y0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">%% loop over time intervals</span>
   <span class="c1">%% Crank-Nicolson method without control</span>
   <span class="n">Y</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">M</span><span class="p">\</span><span class="n">L</span><span class="o">*</span><span class="n">Y</span><span class="p">(:,</span><span class="n">k</span><span class="p">);</span>
<span class="k">end</span>
<span class="n">YT</span> <span class="o">=</span> <span class="n">Y</span><span class="p">(:,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Y1</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">*</span><span class="n">YT</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="optimization-problem-in-casadi">Optimization problem in CasADi</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">opti</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Opti</span><span class="p">();</span>  <span class="c1">%% CasADi function</span>

<span class="c1">%% ---- Input variables ---------</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% state trajectory</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">%% control</span>

<span class="c1">%% ---- Dynamic constraints --------</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">%% loop over control intervals</span>
   <span class="c1">%% Crank-Nicolson method</span>
   <span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">X</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span> <span class="n">L</span><span class="o">*</span><span class="n">X</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">U</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">U</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)));</span>
<span class="k">end</span>

<span class="c1">%% ---- State constraints --------</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">X</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">Y0</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">X</span><span class="p">(:,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">Y1</span><span class="p">);</span>

<span class="c1">%% ---- Optimization objective  ----------</span>
<span class="n">Cost</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">U</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="p">/</span><span class="n">Nt</span><span class="p">));</span> <span class="c1">%%1e3*dx^2*sum(sum((X(:,Nt+1)-Y1).^2))+;</span>
<span class="n">opti</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">Cost</span><span class="p">);</span> <span class="c1">%% minimizing L2 at the final time</span>

<span class="c1">%% ---- Initial guess ----</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">%% ---- solve NLP              ------</span>
<span class="n">p_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'expand'</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
<span class="n">s_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'max_iter'</span><span class="p">,</span><span class="mf">1e5</span><span class="p">);</span> <span class="c1">%% cut down the algorithm at the 1000-th iteration.</span>
<span class="n">opti</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="s1">'ipopt'</span><span class="p">,</span><span class="n">p_opts</span><span class="p">,</span><span class="n">s_opts</span><span class="p">);</span> <span class="c1">%% set numerical backend</span>
<span class="nb">tic</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">solve</span><span class="p">();</span>   <span class="c1">%% actual solve</span>
<span class="nb">toc</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is Ipopt version 3.12.3, running with linear solver mumps.
NOTE: Other linear solvers might be more efficient (see Ipopt documentation).

Number of nonzeros in equality constraint Jacobian...:     2852
Number of nonzeros in inequality constraint Jacobian.:        0
Number of nonzeros in Lagrangian Hessian.............:       31

Total number of variables............................:      527
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:      512
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  0.0000000e+00 1.04e-01 0.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  2.9522421e+04 1.33e-15 6.25e-02  -2.5 1.08e+03    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 1

                                   (scaled)                 (unscaled)
Objective...............:   2.9522420557910038e+04    2.9522420557910038e+04
Dual infeasibility......:   6.2500000000000000e-02    6.2500000000000000e-02
Constraint violation....:   1.3322676295501878e-15    1.3322676295501878e-15
Complementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00
Overall NLP error.......:   1.4002321948103652e-12    6.2500000000000000e-02


Number of objective function evaluations             = 2
Number of objective gradient evaluations             = 2
Number of equality constraint evaluations            = 2
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 2
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 1
Total CPU secs in IPOPT (w/o function evaluations)   =      0.516
Total CPU secs in NLP function evaluations           =      0.000

EXIT: Optimal Solution Found.
               t_proc [s]   t_wall [s]    n_eval
       nlp_f      6.2e-05      1.4e-05         2
       nlp_g     0.000212       0.0001         2
  nlp_grad_f      4.3e-05      2.9e-05         3
  nlp_hess_l      3.2e-05      3.3e-05         1
   nlp_jac_g     0.000147     0.000148         3
      solver        0.668        0.573         1
Elapsed time is 0.638270 seconds.
</code></pre></div></div>

<h2 id="post-processing-1">Post-processing</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Sol_x</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">X</span><span class="p">);</span> <span class="c1">%% solved controlled trajectory</span>
<span class="n">Sol_u</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">U</span><span class="p">);</span> <span class="c1">%% solved control</span>
<span class="c1">%%Sol_x = opti.debug.value(X);</span>
<span class="c1">%%Sol_u = opti.debug.value(U); %% final data if algorithm stops with error</span>

<span class="c1">%%</span>
<span class="nb">clf</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Sol_x</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">jsurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">*</span><span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="nb">plot3</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'k*'</span><span class="p">)</span>

<span class="n">jsurf</span><span class="o">.</span><span class="n">Parent</span><span class="o">.</span><span class="n">Color</span> <span class="o">=</span> <span class="s1">'none'</span><span class="p">;</span>
<span class="nb">lightangle</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>

<span class="nb">legend</span><span class="p">({</span><span class="s1">'Controlled final data'</span><span class="p">,</span><span class="s1">'Uncontrolled final data'</span><span class="p">,</span><span class="s1">'Target'</span><span class="p">})</span>
</code></pre></div></div>

<p><img style="width:70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_07.png" /></p>

<center><p>Fig 7. The initial condition and the final data of uncontrolled dynamics. It has a different structure compared to Fig 2.</p></center>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">%% Free and controlled dynamics in animation</span>

<span class="n">Result_ref</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% displaying variable</span>
<span class="n">Result_ref</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,:),[</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>

<span class="n">Result_con2d</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% displaying variable</span>
<span class="n">Result_con2d</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Sol_x</span><span class="p">(:,:),[</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>

<span class="n">fig</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="n">isurf2</span><span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="k">end</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Free dynamics'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Target'</span><span class="p">,</span><span class="s1">'Solution'</span><span class="p">)</span>
<span class="nb">zlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="nb">pause</span><span class="p">;</span>
<span class="k">for</span> <span class="n">it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span>
   <span class="n">isurf</span><span class="o">.</span><span class="n">ZData</span> <span class="o">=</span>  <span class="n">Result_ref</span><span class="p">(:,:,</span><span class="n">it</span><span class="p">);</span>
    <span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">%%</span>
<span class="nb">clf</span>

<span class="n">fig</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="n">isurf2</span><span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="k">end</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">Result_con2d</span><span class="p">(:,:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Controlled dynamics'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Target'</span><span class="p">,</span><span class="s1">'Solution'</span><span class="p">)</span>
<span class="nb">zlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="nb">pause</span><span class="p">;</span>
<span class="k">for</span> <span class="n">it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span>
   <span class="n">isurf</span><span class="o">.</span><span class="n">ZData</span> <span class="o">=</span>  <span class="n">Result_con2d</span><span class="p">(:,:,</span><span class="n">it</span><span class="p">);</span>
    <span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>
<table>
   <tr>
      <th>
         <center><video controls="" width="95%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_08-c.mp4"></video></center>
      </th>
      <th>
        <center><video controls="" width="95%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_09-c.mp4"> </video></center>
      </th>
   </tr>
</table>
<center><p><b>Fig 8-9.</b> Animations for the free and controlled dynamics. The target surface is also drawn in both dynamics, where free dynamics goes below than the target.</p></center>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;En este tutorial enseñaremos como implentar la estrategía del control interíor móvil para la ecuación del calor. En el ejemplo típico de control interior en la ecuación del calor se pretende llevar al sistema desde un estado inicial, $u_0$ hasta el estado nulo en todo el espacio, $\Omega$. Para ello se define una subconjunto, $\omega \in \Omega$, donde el control, $f(x,t)$ puede actuar, es decir que para puntos, $x \notin \omega$, el control es cero. Este problema se puede escribir como:&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior}
\begin{equation}
\begin{cases}
\begin{matrix}
  \dot{u} = \Delta u + f(x,t) \chi_{\omega} \ & \ \textbf{x} \in \Omega & t \in [0,T] \\
  u(\textbf{x,t}) = 0    & \textbf{x} \in \partial \Omega  &  t \in [0,T] \\
  u(\textbf{x},0) = u_0  & \textbf{x} \in \Omega
\end{matrix}
\end{cases}
\end{equation} %]]></script>

<p>Donde $f$ es el control definido de solo en el subconjunto, $\omega \in \Omega$.</p>

<p>Es conocido que la controlabilidad de la ecuación del calor para todo tiempo esta asegurada, sin embargo en el caso de la ecuación del calor con términos de memoria este resultado no es válido. En este caso, eligiremos un problema con un término de memoria: $\int_0^t u(x,\tau)d\tau$. De esta forma el problema se puede escribir como:</p>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior_memory}
\begin{equation}
\begin{cases}
\begin{matrix}
  \dot{u} = \Delta u + f(x,t) \chi_{\omega} + \int_0^t u(x,\tau) d\tau \ & \ \textbf{x} \in \Omega & t \in [0,T] \\
  u(\textbf{x,t}) = 0    & \textbf{x} \in \partial \Omega  &  t \in [0,T] \\
  u(\textbf{x},0) = u_0  & \textbf{x} \in \Omega
\end{matrix}
\end{cases}
\end{equation} %]]></script>

<p>Este resultado se puede vercuenado aplicamos un control LQR sobre ambos sistemas. El mínimo del funcional LQR en el primer sistema (Equation \ref{heatinterior}) estabiliza la dínamica mientras que el mínimo del funcional en el segundo caso queda muy lejos del equilibrio.</p>

<hr />

<table>
    <tr>
        <th>
          <center>
            <video controls="" width="90%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0011/LQR_InteriorPoint_Heat_Equation.mp4"> </video>
          </center> 
        </th>
        <th>
          <center>
            <video controls="" width="90%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0011/LQR_InteriorPoint_Heat_Equation_with_memory.mp4"> </video>
          </center> 
        </th>
    </tr>
    <tr>
        <th>
          <center>
              <b>Video 1:</b> LQR in Heat equation (Equation \ref{heatinterior})
          </center> 
        </th>
        <th>
          <center>
              <b>Video 2:</b>  LQR in Heat equation with memory (Equation \ref{heatinterior_memory})
          </center> 
        </th>
    </tr> 
    <tr>
        <td colspan="2">
          <center>
              Podemos ver la evolucion de dos modelos, con un región de control, $\chi_{\omega}$, situado en la posición del elipsoide azul en la parte superior de la simulación. Podemos ver que el control LQR es eficaz para la ecuación del calor, sin embargo débil ante la presencia de término de memoria
          </center> 
        </td>
    </tr> 
</table>

<p>En el articulo [1], se menciona la idea del control móvil de ….
….
….</p>

<h2 id="definición-del-función-característica-dependiente-del-espacio">Definición del función característica dependiente del espacio</h2>

<p>Nuestro objetivo en esta sección es la construcción de una función que dado un punto, $\textbf{x} \in \Omega$, devuelva la función carácteristica correspondiente. Para el diseño de la función $\chi_{\omega(t)}$, se ha decidido que ni el tamaño, ni la orientación de $\omega$ cambia en el tiempo. De esta forma, una vez fijados el tamaño en las dos direcciones del espacio y la forma del subconjunto, obtenemos una función que solo depende de un punto $x\in \Omega$.</p>

<p>En esta simulación crearemos el subconjunto como un cuadrado que puede moverse en $\Omega$. este cuadrado se puede construir con una función $W(x)$ definida de la siguiente manera.</p>

<script type="math/tex; mode=display">W(x,a,b) = \Theta(x-a) + \Theta(x-b) \\  \{ a,b,x  \}\in \mathbb{R} \\ a>b \\</script>

<p>donde $\Theta(x)$ es la fución theta de heaviside. Dado que la función $\Theta(x)$, tiene una aproximación analítica, la función $W(x,a,b)$ puede ser suavizada, detalle que será de vital importancia para que se pueda calcular el gradiente de la restrición asociada a la dinámica cunado realizamos el problema de control óptimo.</p>

<p>Un representación gráfica de $W(x,a,b)$ permiter reconocer a esta función con valor unidad entre los valores $a$ y $b$ y nulo fuera de ellos.</p>

<table>
  <tr>
    <th>
      <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0011/WTHETA.png" width="65%" />
    </th>
  </tr>
  <tr>
    <th>
      <center><b>Figure 1</b>: Representación gráfica de $W(x,a,b)$</center>
    </th>
  </tr>
</table>

<p>La generalización de esta función en dos dimensiones en inmediata,</p>

<script type="math/tex; mode=display">W_{2D}(x,y,x_{min},x_{max},y_{min},y_{max}) = W(x,x_{min},x_{max})*W(x,y_{min},y_{max})</script>

<p>De esta forma dado $(x_{min}, x_{max}, y_{min}, y_{max})$, obtenemos la función característica dependiente solo de la posición de un solo punto.</p>

<table>
  <tr>
    <th>
      <video controls="" width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0011/BMatrix_Motion.mp4"> </video>
    </th>
  </tr>
  <tr>
    <th>
      <center><b>Video 3: Representación gráfica de</b>  $W_{2D}$</center>
    </th>
  </tr>
</table>

<h2 id="construcción-de-la-dinámica">Construcción de la dinámica</h2>

<p>Para el sistema con memoria (Equation \ref{heatinterior_memory}), podemos introducir una nueva variable, $z(x,t)$ tal que:</p>

<script type="math/tex; mode=display">z(x) = \int_0^t u(x,\tau) d\tau \Rightarrow \dot{z} = u(x,t)</script>

<p>De esta manera el sistema con memoria se convierte en un sistema acoplado de PDEs:</p>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior_memory_z}
\begin{equation}
\begin{cases}
\begin{matrix}
  \dot{u} = \Delta u + f(x,t) \chi_{\omega} + z  &     \dot{z} = u        & \textbf{x} \in \Omega & t \in [0,T] \\
  u(\textbf{x,t}) = u_0                        &  z(\textbf{x,t}) = 0   & \textbf{x} \in \partial \Omega  &  t \in [0,T] \\
  u(\textbf{x},0) = 0                      &  z(\textbf{x},0) = 0   & \textbf{x} \in \Omega 
  \end{matrix}
\end{cases}
\end{equation} %]]></script>

<p>Dado que $\chi_{\omega}$ puede moverse, y ademas que queremos obtener la trayectoria óptima para el control móvil añadiremos al sistema una partícula que puede moverse en dos dimensiones, su posición vendrá denotada por, $\textbf{d} = (d_x,d_y)$, y su velocidad, $\textbf{v} = (v_x,v_y)$. Además añadiremos un control $\textbf{g}(t) = (g_x(t),g_y(t))$ que actuará como una fuerza que moverá el subconjunto $\chi_{\omega}$.</p>

<p>Entonces, el sistema total queda como:</p>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior_memory_z_all}
\begin{equation}
\begin{cases}
\begin{matrix}
  \dot{u} = \Delta u + f(x,t) \chi_{\omega(\textbf{d})} + z  &     \dot{z} = u        & \textbf{x} \in \Omega & t \in [0,T] \\
  u(\textbf{x,t}) = u_0                        &  z(\textbf{x,t}) = 0   & \textbf{x} \in \partial \Omega  &  t \in [0,T] \\
  u(\textbf{x},0) = 0                      &  z(\textbf{x},0) = 0   & \textbf{x} \in \Omega \\
    \dot{\textbf{d}} = \textbf{v} & \textbf{d}(0) = \textbf{d}_0    & t \in [0,T]\\
  \dot{\textbf{v}} = \textbf{g}(t)  & \textbf{v}(0) = \textbf{v}_0  & t \in [0,T]\\
  \end{matrix}
\end{cases}
\end{equation} %]]></script>

<h2 id="numerical-implementation">Numerical Implementation</h2>

<p>En este tutorial necesitaremos DyCon Toolbox, y CasADi. Dado que CasADi es una dependecia de DyCon Toolbox, podemos instalarlo de la siguiente forma</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">unzip</span><span class="p">(</span><span class="s1">'https://github.com/DeustoTech/DyCon-Computational-Platform/archive/master.zip'</span><span class="p">)</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="nb">cd</span><span class="p">,</span><span class="s1">'DyCon-toolbox-master'</span><span class="p">))</span>
<span class="n">StartDyconPlatform</span>
</code></pre></div></div>

<p>Podemos escribir la ecuación \ref{heatinterior_memory_z_all}, en su forma discreta:</p>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior_memory_z_all_discr}
\begin{equation}
\frac{d}{dt} \begin{bmatrix}\begin{array}{c|c}
\textbf{U} \\
\hline
\textbf{Z} \\
\hline
\textbf{D} \\
\hline
\textbf{V} \\
\end{array}
\end{bmatrix}
=
\begin{bmatrix}\begin{array}{c|c|c}
\mathcal{A} & \textbf{1} & \textbf{0} & \textbf{0} \\
\hline
\textbf{1} & \textbf{0}  & \textbf{0} & \textbf{0} \\
\hline
\textbf{0} & \textbf{0}  & \textbf{0} & \textbf{1} \\
\hline
\textbf{0} & \textbf{0}  & \textbf{0} & \textbf{0} \\
\end{array}
\end{bmatrix}
%%
\begin{bmatrix}\begin{array}{c|c}
\textbf{U} \\
\hline
\textbf{Z} \\
\hline
\textbf{D} \\
\hline
\textbf{V} \\
\end{array}
\end{bmatrix}
+
%%
\begin{bmatrix}\begin{array}{c|c}
\textbf{B}(\textbf{D})*\textbf{F}(t) \\
\hline
\textbf{0} \\
\hline
\textbf{0} \\
\hline
\textbf{G}(t) \\
\end{array}
\end{bmatrix}
\end{equation} %]]></script>

<p>Creamos las variables de mesh</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Create the mesh variables</span>
<span class="nb">clear</span><span class="p">;</span>
<span class="n">Ns</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="nb">xline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="p">);</span>
<span class="nb">yline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="p">);</span>
<span class="p">[</span><span class="n">xms</span><span class="p">,</span><span class="n">yms</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="nb">xline</span><span class="p">,</span><span class="nb">yline</span><span class="p">);</span>
</code></pre></div></div>

<p>Creamos la matriz A, que contiene el laplaciano en 2D y la dinámica del control movil</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span>  <span class="o">=</span> <span class="n">FDLaplacial2D</span><span class="p">(</span><span class="nb">xline</span><span class="p">,</span><span class="nb">yline</span><span class="p">);</span>

<span class="n">Atotal</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
<span class="c1">%</span>
<span class="n">Atotal</span><span class="p">(</span> <span class="mi">1</span><span class="p">:</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span>  <span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span> <span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
<span class="c1">%</span>
<span class="n">Atotal</span><span class="p">(</span> <span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span>   <span class="p">,</span>   <span class="mi">1</span>    <span class="p">:</span>  <span class="n">Ns</span><span class="o">^</span><span class="mi">2</span>   <span class="p">)</span>  <span class="o">=</span>  <span class="nb">eye</span><span class="p">(</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Atotal</span><span class="p">(</span>    <span class="mi">1</span>   <span class="p">:</span>  <span class="n">Ns</span><span class="o">^</span><span class="mi">2</span>    <span class="p">,</span> <span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span>  <span class="p">)</span>  <span class="o">=</span>  <span class="mi">50</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span> <span class="c1">% z = 50*y</span>

<span class="n">RumbaMatrixDynamics</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="k">...</span>
                       <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="k">...</span>
                       <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="k">...</span>
                       <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="p">];</span>

             
<span class="n">Atotal</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">RumbaMatrixDynamics</span><span class="p">;</span>
<span class="n">Atotal</span> <span class="o">=</span> <span class="nb">sparse</span><span class="p">(</span><span class="n">Atotal</span><span class="p">);</span>
</code></pre></div></div>

<p>Greamos la función $B(\textbf{d}) = B(x_d,y_d)$</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">%%</span>
<span class="c1">% We create the B() function </span>
<span class="n">xwidth</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
<span class="n">ywidth</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
<span class="n">B</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">xms</span><span class="p">,</span><span class="n">yms</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">)</span> <span class="n">WinWP05</span><span class="p">(</span><span class="n">xms</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">xwidth</span><span class="p">)</span><span class="o">.*</span><span class="n">WinWP05</span><span class="p">(</span><span class="n">yms</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">ywidth</span><span class="p">);</span>
<span class="n">Bmatrix</span> <span class="o">=</span>  <span class="o">@</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">)</span> <span class="p">[</span><span class="nb">diag</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="n">xms</span><span class="p">,</span><span class="n">yms</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span> <span class="p">;</span><span class="nb">zeros</span><span class="p">(</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="p">)];</span>
</code></pre></div></div>

<script type="math/tex; mode=display"></script>

<h2 id="optimal-control-problem">Optimal Control Problem</h2>

<script type="math/tex; mode=display">\min_{f(x,t),g(t)}  \int_{\Omega} ||u(x,T) ||^2dx \\</script>

<script type="math/tex; mode=display">% <![CDATA[
\text{subject to: }\begin{cases}
\begin{matrix}
  \dot{u} = \Delta u + f(x,t) \chi_{\omega(\textbf{d})} + z  &     \dot{z} = u        & \textbf{x} \in \Omega & t \in [0,T] \\
  u(\textbf{x,t}) = u_0                        &  z(\textbf{x,t}) = 0   & \textbf{x} \in \partial \Omega  &  t \in [0,T] \\
  u(\textbf{x},0) = 0                      &  z(\textbf{x},0) = 0   & \textbf{x} \in \Omega \\
    \dot{\textbf{d}} = \textbf{v} & \textbf{d}(0) = \textbf{d}_0    & t \in [0,T]\\
  \dot{\textbf{v}} = \textbf{g}(t)  & \textbf{v}(0) = \textbf{v}_0  & t \in [0,T]\\
  \end{matrix}
\end{cases} %]]></script>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">opti</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Opti</span><span class="p">();</span>  <span class="c1">% CasADi optimization structure</span>

<span class="c1">% ---- Input variables ---------</span>
<span class="n">Ucas</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">% state trajectory</span>
<span class="n">Fcas</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">% control</span>

<span class="c1">% ---- Dynamic constraints --------</span>
<span class="n">dUdt</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="n">Atotal</span><span class="o">*</span><span class="n">u</span><span class="o">+</span> <span class="p">[</span><span class="n">Bmatrix</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="k">end</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span><span class="n">u</span><span class="p">(</span><span class="k">end</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">;</span> <span class="k">...</span>
                                         <span class="mi">0</span>                     <span class="p">;</span> <span class="k">...</span>
                                         <span class="mi">0</span>                     <span class="p">;</span> <span class="k">...</span>
                                     <span class="n">f</span><span class="p">(</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>                  <span class="p">;</span> <span class="k">...</span>
                                     <span class="n">f</span><span class="p">(</span><span class="k">end</span><span class="p">)</span>                    <span class="p">];</span> 

<span class="c1">% -----Euler backward method-------</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">% loop over control intervals</span>
   <span class="n">y_next</span> <span class="o">=</span> <span class="n">Ucas</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">T</span><span class="p">/</span><span class="n">Nt</span><span class="p">)</span><span class="o">*</span><span class="n">dUdt</span><span class="p">(</span><span class="n">Ucas</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">dUdt</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span> 
   <span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">Ucas</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">y_next</span><span class="p">);</span> <span class="c1">% close the gaps</span>
<span class="k">end</span>

<span class="c1">% ---- State constraints --------</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">Ucas</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="p">[</span><span class="n">Y0</span> <span class="p">;</span> <span class="mf">0.7</span> <span class="p">;</span> <span class="mf">0.7</span><span class="p">;</span> <span class="o">-</span><span class="mf">1.5</span> <span class="p">;</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">]);</span>

<span class="c1">% ---- Optimization objective  ----------</span>
<span class="n">Cost</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ucas</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">'*</span><span class="p">(</span><span class="n">Ucas</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>

<span class="n">opti</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">Cost</span><span class="p">);</span> <span class="c1">% minimizing L2 at the final time</span>

<span class="c1">% ---- initial guesses for solver ---</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">Ucas</span><span class="p">,</span> <span class="n">Unum_free</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">Fcas</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">% ---- solve NLP              ------</span>
<span class="n">p_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'expand'</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
<span class="n">s_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'acceptable_tol'</span><span class="p">,</span><span class="mf">1e-4</span><span class="p">,</span><span class="s1">'constr_viol_tol'</span><span class="p">,</span><span class="mf">1e-3</span><span class="p">,</span><span class="s1">'compl_inf_tol'</span><span class="p">,</span><span class="mf">1e-3</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="s1">'ipopt'</span><span class="p">,</span><span class="n">p_opts</span><span class="p">,</span><span class="n">s_opts</span><span class="p">);</span> <span class="c1">% set numerical backend</span>
<span class="nb">tic</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">solve</span><span class="p">();</span>   <span class="c1">% actual solve</span>
<span class="nb">toc</span>
</code></pre></div></div>

<p>Mvil Control</p>

<table>
<tr>
  <th>
    <center>
      <video controls="" width="90%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0011/MovilControl.mp4"> </video>
    </center>
  </th>
</tr>
<tr>
<th>
<center><b>Video 3</b></center>
</th>
</tr>
</table>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In this tutorial, we propose the Hum method to approximate numerically the control in a null controllability problem for a non linear population dynamics model structuring in age and spatial diffusion.&lt;/p&gt;
</code></pre></div></div>

<p>For given the positive function $F$, we consider the following Population Dynamics Model Structuring by age and spatial diffusion:</p>

<script type="math/tex; mode=display">% <![CDATA[
(1):\left\{ 
\begin{array}{ccc}
\partial_{t} y+\partial_{a}y-Δ y+\mu y&=\chi_{\Theta}V&\text{ in }\Omega\times(0,A)\times (0,T) ,\\ 
\dfrac{\partial y}{\partial \nu}&=0& \partial \Omega \times (0,A)\times (0,T)\\
y\left( x,0,t\right) &=F\left(\int_{0}^{A}\beta(a)yda\right) &\text{ in }  \Omega\times(0,T) \\
y\left(x,a,0\right)&=y_{0}&
\text{ in } \Omega\times(0,A).
\end{array}
\right. %]]></script>

<p>where, $\Omega$ is a boundary subset of $\mathbb{R}^{N}$, $A$ is the maximal age and $T&gt;0$ the final time. Also, $\Theta=\omega× (a_1,a_2)× (0,T),$ is the control support. Here, $\beta$ is the fertility rate depending also the age a, $\mu$ the mortality rate depending of the age a, $y_0$ the initial condition in $L^2(\Omega× (0,A)),$ $V$ is the control term and $y$ represent the density of the population of age $a$ at time $t$ and location $x∈ \Omega.$</p>

<p>We assume that the fertility rate $\beta$ and the mortality rate $\mu$ satisfy the demographic property:</p>

<script type="math/tex; mode=display">(H_1)=
\left\{
\begin{array}{c}
\mu(a)\geq 0 \text{ for every } a\in (0,A)\\
\mu\in L^{1}_{loc}(0,A)\quad \int_{0}^{A}\mu(a)da=+\infty
\end{array} \right.,</script>

<p>and</p>

<script type="math/tex; mode=display">(H_2)=\left\{
\begin{array}{ccc}
\beta(a)\geq 0\quad a.e \quad (0,A)\\
\beta(a)\in C^{1}([0,A])\\
	\beta(a)=0 \text{ } \forall a\in (0,\hat{a}) \text{ where } \hat{a}\in (0,A), \\
\end{array}
\right.</script>

<p>where</p>

<script type="math/tex; mode=display">% <![CDATA[
0≤ a_1<a_2≤ A \text{ and }  a_1≤ \hat{a}. %]]></script>

<p>The function $F,$ verify:</p>

<script type="math/tex; mode=display">(H_3)=
\left\{
\begin{array}{c}
F \quad \text{ positive, globally Lipchitz }\\
F(0)=0,\quad F \text{ continuous and differentiable in } 0.
\end{array} \right..</script>

<h1 id="numerical-simulations">Numerical Simulations</h1>

<p>In this part, the objective is to illustrate numerically the approximate null controllability of the nonlinear problem.</p>

<p>Indeed, we consider the following system:</p>

<script type="math/tex; mode=display">% <![CDATA[
(4):\left\{ 
\begin{array}{ccc}
\partial_{t} y+\partial_{a}y-\partial^{2}_{xx}y+\mu y&=\chi_{\Theta}V&\text{ in }(0,1)\times(0,A)\times (0,T) ,\\ 
y'(0)=y'(1)&=0& \text{ in } (0,A)\times (0,T)\\
y\left( x,0,t\right) &=F\left(\int_{0}^{A}\beta(a)yda\right) &\text{ in }  (0,1)\times(0,T) \\
y\left(x,a,0\right)&=y_{0}&
\text{ in } (0,1)\times(0,A).
\end{array}
\right. %]]></script>

<h3 id="discretization-and-simulation-of-uncontrolled-system">Discretization and simulation of uncontrolled system</h3>

<p>The idea in this part is to highlight the numerical simimulation of the nonlinear problem. The first parts is to reduce the PDE to the finite dimensional system of the form</p>

<script type="math/tex; mode=display">\dot{U_l}=A_lU_l+vectorF+BV,</script>

<p>where $A_l$ and $B$ are matrices, and</p>

<script type="math/tex; mode=display">\begin{pmatrix}
U_l(t) \\
V(t) \\
\end{pmatrix}</script>

<p>is the finite dimensional state and control vector. Here, VectorF is the contribution of the nonlinear part, which comes from births. So let’s consider the following system</p>

<script type="math/tex; mode=display">% <![CDATA[
(5):\left\{ 
\begin{array}{ccc}
\dfrac{\partial y}{\partial t}+\textbf{A}y+\mu y&=\chi_{\Theta}V&\text{ in }\Omega\times(0,A)\times (0,T) ,\\ 
\dfrac{\partial y}{\partial \nu}&=0& \partial \Omega \times (0,A)\times (0,T)\\
y\left( x,0,t\right) &=F\left(\int_{0}^{A}\beta(a)yda\right) &\text{ in }  \Omega\times(0,T) \\
y\left(x,a,0\right)&=y_{0}&
\text{ in } \Omega\times(0,A).
\end{array}
\right. %]]></script>

<p>where</p>

<script type="math/tex; mode=display">\textbf{A}y=\partial_{a}y-\partial^{2}_{xx}y.</script>

<p>To solve $(4)$, the space (dimension 1) and age discretization is performed with finite difference method on rectangular grid 
on $[0,L]\times [0,A]$. For a given rectangular grid $\mathcal{T}$ with vertex $(x_i,a_j)\quad 1\leq i\leq N,\quad 1\leq j\leq M$ and uniform step size (without loss of generality) $\Delta x$ in $x-$direction and $\Delta a$ in $a-$direction, we denote by  the diameter of the grid
The finite difference approximation of the diffusion term of the operator $\textbf{A}$ is given by</p>

<script type="math/tex; mode=display">\dfrac{\partial^2 y}{\partial x^2}(x_i,a_j,t)=\dfrac{y(x_{i+1},a_j,t)-2y(x_i,a_j,t)+y(x_{i-1},a_j,t)}{(\Delta x)^2}.</script>

<p>The finite difference approximation of the aging term of the operator A is given by</p>

<script type="math/tex; mode=display">\dfrac{\partial y}{\partial a}(x_i,a_j,t)=\dfrac{y(x_{i},a_{j},t)-y(x_i,a_{j-1},t)}{\Delta a}.</script>

<p>Let $y_{i,j}(t)$ be the approximation of $y(x_i,a_j)$ and</p>

<script type="math/tex; mode=display">U_{l}(t) = (y_{i,j}(t))_{1\leq i\leq N,\quad 1\leq j\leq M}</script>

<p>where $y_{i,j}$ is at the position $i+j*(N-1)$ and $A_l$ the matrix of the mortality approximation, the diffusion approximation and the aging approximation.</p>

<h3 id="take-into-account-the-newborns">Take into account the newborns</h3>

<p>We denote by $\beta(a),$ the fertility rate, the newborn is given by:</p>

<script type="math/tex; mode=display">y(x,0,t)=F\left(\int_{0}^{A}\beta(a)y(x,a,t)da\right).</script>

<p>We approximate $\int_{0}^{A}\beta(a)y(x,a,t)da$ by</p>

<script type="math/tex; mode=display">\int_{0}^{A}\beta(a)y(x,a,t)da=(A/n)\sum_{j=1}^{n-1}\beta(a_j)y(x,a_j,t)+\dfrac{\beta(0)y(x,0,t)+\beta(A)y(x,A,t)}{2}.</script>

<p>Then</p>

<script type="math/tex; mode=display">y_{i,0}=A/n\sum_{k=1}^{n-1}\beta(a_k)y(x_i,a_k,t)+\dfrac{\beta(0)y(x_i,0,t)+\beta(A)y(x_i,A,t)}{2}\text{ for } i=1:n.</script>

<p>But as</p>

<script type="math/tex; mode=display">\dfrac{\partial y_{i,1}(t)}{\partial a}=\dfrac{y_{i,1}(t)-y_{i,0}(t)}{\Delta a}\text{ } i=1:n,</script>

<p>then</p>

<script type="math/tex; mode=display">\dfrac{\partial y_{i,1}(t)}{\partial a}=\dfrac{-A/n\sum_{k=1}^{n-1}\beta(a_k)y_{i,k}(t)+y_{i,1}(t)+\dfrac{\beta(0)y(x_i,0,t)+\beta(A)y(x_i,A,t)}{2}}{\Delta a}\quad i=1:n,</script>

<p>We create also the nonlinear vectorF from the births. Indeed, if we denote by</p>

<script type="math/tex; mode=display">(N_l)_{1\leq i\leq n*n;\leq j\leq n*n}</script>

<p>the matrix of the births,</p>

<script type="math/tex; mode=display">P_l=N_lU_l\quad where\quad  \left(\dfrac{A\sum_{k=1}^{n-1}\beta(a_k)y_{i,k}(t)+\dfrac{\beta(0)y(x_i,0,t)+\beta(A)y(x_i,A,t)}{2}}{n\Delta a}\right)_{1\leq i\leq n}=\left(P_l\right)_{1\leq i\leq n}\text{ } and \text{ } 
\left(P_l\right)_{n+1\leq i\leq n*n}=0</script>

<p>and we define the vectorF by:</p>

<script type="math/tex; mode=display">vectorF=F(N_lU_l).</script>

<p>The corresponding discrete system is given for a continuous initial solution $y_0$ by</p>

<script type="math/tex; mode=display">\dfrac{dU_l}{dt}=A_lU_l+vectorF\quad y(0)=y_0(x,a)</script>

<h3 id="example-1">Example 1</h3>

<h4 id="simulation-of-the-uncontrolled-system">Simulation of the uncontrolled system:</h4>

<p>For the simulation, we take $L=1,\text{ } A=10\text{, }\Delta x=1/54\quad \Delta a= 5/54$ and $T=40$. Moreover $F(t)=t\Phi(t)$ a Globally Lipchitz function where</p>

<script type="math/tex; mode=display">\Phi(t)=0.75\exp(-t)</script>

<p>The fertility $\beta$ is given by:</p>

<script type="math/tex; mode=display">% <![CDATA[
\beta(a) = 
 \begin{cases}
0 & \text { if } a<A/18 \\
 \frac{\alpha(a-5/18)^{\gamma-1}e^{-(a-5/18)/v}}{v^{\gamma}\Gamma(\gamma)}
\text{ if } A/18\leq a\leq 17A/18\\
 0 &\text{ if } a>17A/18.
  \end{cases} %]]></script>

<p>here $v=1$, $\gamma=5$, $\alpha=7$ and the mortality rate $\mu$ by</p>

<script type="math/tex; mode=display">\mu(a)=\dfrac{1}{10(A-a)}</script>

<hr />

<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/uncontrolled stat1.mp4" width="80%" controls=""></video>
</center>

<center><strong>Video 1.</strong> Evolution of the state of the uncontrolled system between t=0 and t=30 </center>

<p>We observe in this video the growth (aging) of news borns over time. We also notice the high birth rate of this population.</p>

<h2 id="construction-of-the-control-and-numerical-simulation">Construction of the control and numerical simulation</h2>

<p>We construct the control problem, which consists in minimizing the functional and we choose the classical Hum functional and the control matrix $B=\chi_{\Theta}$ where $\Theta=(x_1,x_2)\times (a_1,a_2)\times (0,T),$ and we suppose that $U_T$ is the desired state:</p>

<script type="math/tex; mode=display">J_{\epsilon}(U_l,V_l)=\dfrac{1}{\epsilon}\int_{0}^{A}\int_{0}^{L}\left(U_l(x,a,T)-U_T\right)^2dxda+\int_{0}^{T}\int_{a_1}^{a_2}\int_{x_1}^{x_2}V_{l}^{2}dxdadt.</script>

<p>Here $U_T=0.$<br />
The approximate null controllability become the minimization of  the functional $J,$ where $(U_l,V_l)$ verify the following system</p>

<script type="math/tex; mode=display">\dfrac{dU_l}{dt}=A_lU_l+vectorF+BV_l\quad U_l(0)=(y_0(x_i,a_j))_{1\leq i\leq N,1\leq j\leq M}</script>

<p>In this part the fertility $\beta$ is given by:</p>

<script type="math/tex; mode=display">% <![CDATA[
\beta(a) = 
 \begin{cases}
0 & \text { if } a<A/5 \\
 \frac{\alpha(a-/8)^{\gamma-1}e^{-(a-/8)/v}}{v^{\gamma}\Gamma(\gamma)}
\text{ if } A/5\leq a\leq 4A/5\\
 0 &\text{ if } a> 4A/5,
  \end{cases} %]]></script>

<p>here $v=1$, $\gamma=5$, $\alpha=7$
 and</p>

<script type="math/tex; mode=display">\mu(a)=\dfrac{1}{15(A-a)}</script>

<p>and $VectorF=(P_lU_l).^2$.This means that we consider that $F(t)=t^2$ which is globally lipchizt on a compact which is our case.</p>

<p>The system becomes:</p>

<script type="math/tex; mode=display">\dfrac{dU_l}{dt}=A_lU_l+(P_lU_l).^2+BV_l\quad U_l(0)=(y_0(x_i,a_j))_{1\leq i\leq N,1\leq j\leq M}.</script>

<h3 id="example-2">Example 2</h3>

<p>In this example, we take $ε=0.05$, $\Delta x=0.05$ and $\Delta a= 0.5$, with the initial condition</p>

<script type="math/tex; mode=display">y_0(x,a)=e^{-(10(a-3/10)^2+70(x-4/10))}</script>

<p>the following numerical results were obtained for $T=12$ and $\Delta t=120$.</p>

<p>Evolution of the control V between t=0 and t=12.</p>
<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/example2stat.mp4" width="80%" controls=""></video>
</center>
<center><strong>Video 2.</strong> Evolution of the state of controlled system between t=0 and t=12 </center>

<p>We notice that, with a control domain that takes into account the most populated part of the domain, the Hum method applied to the Casadi algorithm gives us an interesting approximative controllability result while maintaining the positivity of the density.
Evolution of the controlled state (density of the population) between t=0 and t=12.</p>
<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/example2cont.mp4" width="80%" controls=""></video>
</center>

<center><strong>Video 3.</strong> Evolution of the control function between t=0 and t=12 </center>

<h3 id="example-3">Example 3</h3>

<p>Here, we keep the same parameters of the Example 1 but we change the final time (here T=20) , and we take $\Delta x=1/18$, $Δ a=5/18$, $\epsilon=0.05$ the following numerical results were obtained:</p>
<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/videofinalc.mp4" width="80%" controls=""></video>
</center>
<center><strong>Video 4.</strong> Evolution of the state of the controlled system between t=0 and t=20 </center>

<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/ccc.mp4" width="80%" controls=""></video>
</center>

<center><strong>Video 4.</strong> Evolution of the state of the controlled system between t=0 and t=20 </center>

<h3 id="example-4">Example 4</h3>

<p>In this part we consider a smaller control domain. Indeed we take 
$\Theta =(0,2/5)\times(0,4)\times(0,T)$. 
In addition we also remove $\epsilon=0.001$ and $T=20.$ The rest is identical to the data of example 2.</p>

<p>We obtain the following numerical results:</p>

<p>Evolution of the control V between t=0 and t=20.</p>

<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/example4stat.mp4" width="80%" controls=""></video>
</center>

<center><strong>Video 4.</strong> Evolution of the state of the controlled system between t=0 and t=20 </center>

<p>Here although the result is acceptable, we notice that the state of the controlled system is negative for most of the time.<br />
Evolution of the controlled state (the density of the population) between t=0 and t=20.</p>

<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/example4cont.mp4" width="80%" controls=""></video>
</center>

<center><strong>Video 5.</strong> Evolution of the control function between t=0 and t=20 </center>
<p>We notice here that the solution to the final time tends to 0, but during the time of control much of the state of the system was negative.
We notice that numerically we have approximation and the positivity of the state, if the support of the control covers the most populated part of the domain (space, age).</p>

<p>However it should be noted that we could not take a positivity constraint in our simulations. It should be noted that we have better approximations when we do not consider the cost of control.</p>

<h2 id="references">References</h2>
<p>[1] Dycon Toolbox</p>

<p>[2] CasaDi toolbox</p>

<p>[3] Luca Gerardo-Giorda: NUMERICAL APPROXIMATION OF DENSITY DEPENDENT DIFFUSION IN AGE-STRUCTURED POPULATION DYNAMICS</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;En esta entrada veremos como podremos estimar  el sistema dinámico apartir de datos sobre la evolución de este sistema.&lt;/p&gt;
</code></pre></div></div>

<p>Lo primero que haremos es inspeccionar de que datos disponemos</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="nb">whos</span>
</code></pre></div></div>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Name</span>               <span class="n">Size</span>                  <span class="n">Bytes</span>  <span class="n">Class</span>     <span class="n">Attributes</span>

  <span class="n">solution</span>         <span class="mi">100</span><span class="n">x200x50</span>            <span class="mi">8000000</span>  <span class="nb">double</span>              
  <span class="n">tspan</span>              <span class="mi">1</span><span class="n">x200</span>                  <span class="mi">1600</span>  <span class="nb">double</span>    
</code></pre></div></div>
<p>En este caso tenemos 100 simulaciones de una ecuación diferencial</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h2 id="background-and-motivation"&gt;Background and motivation&lt;/h2&gt;
</code></pre></div></div>

<p>An idealized version of a MEMS device consists of <b>two conducting plates connected to an electric circuit</b>
(see Figure 1).
The upper plate is rigid and fixed while the lower one is elastic and fixed only at the boundary.
Initially the plates are parallel and at unit distance from each other.
When a voltage (difference of potential between the two plates) is applied, the lower
plate starts to bend and, if the voltage is large enough,
the lower plate eventually touches the upper one, conducting to the so-called <b> pull-in instability</b>. In the mathematical framework, this phenomenon is known as <b>quenching</b> or <b> touchdown</b>.
Such device can be used for instance as an actuator, a microvalve (the touching-down part closes the valve),
or a fuse.</p>

<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/fig6.png" alt="Figure 1: MEMS device" height="200" width="300" /> 
</figure>

<center>
<strong> Figure 1: </strong> Two-membrane MEMS device
</center>

<p>We consider a well-known <b>model for micro-electromechanical systems (MEMS)
with variable dielectric permittivity</b>, based on the following parabolic equation with singular nonlinearity:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{quenching problem}
\left\lbrace \begin{array}{rrl}
u_t - \Delta u = \dfrac{f(x)}{(1-u)^2}, & x\in \Omega, & t>0, \\
u = 0, & x\in \partial \Omega, & t>0, \\
u(0,x) = 0, & x \in \Omega, &
\end{array} \right.
\end{equation} %]]></script>

<p>where $\Omega$ is a smoothly bounded domain of $\mathbb{R}^2$ and 
<script type="math/tex">f\geq 0</script> is a Hölder continuous function in <script type="math/tex">\overline{\Omega}</script>.</p>

<p>In this mathematical model, the domain $\Omega$ represents the shape of the elastic plate in the horizontal direction, the solution $u=u(t,x)$ measures its vertical deflection,
while the function $f(x)$ is proportional to the constant voltage and characterizes the varying dielectric permittivity of the elastic plate.
We can write the permittivity profile $f$ as follows:</p>

<script type="math/tex; mode=display">f(x) = \lambda\dfrac{\varepsilon_0}{\varepsilon_1(x)},</script>

<p>where $\lambda&gt;0$ is the applied voltage, $\varepsilon_0&gt;0$ is the permittivity of the vacuum and $\varepsilon_1(x)$ is the dielectric permittivity of the material. 
As a key feature, in our model the permittivity of the elastic plate may be inhomogeneous,
and this can be used to trigger the properties of the device. 
We refer to <b>[1],[4],[5] and the references therein for the full details of the model derivation</b>.</p>

<p>It is well known that problem (\ref{quenching problem}) admits a unique maximal classical solution $u$.
We denote its maximal existence time by $T=T_f\in (0,\infty]$. Moreover,
under some largeness assumption on $f$, it is known that the maximum of $u$ reaches the value $1$
at a finite time, so that $u$ ceases to exist in the classical sense. This is what we call <b> touchdown in finite time</b> $T_f&lt;\infty$.
Actually, if we consider $f(x) = \lambda\dfrac{\varepsilon_0}{\varepsilon_1(x)}$,
it is well-known that there exists a positive $\lambda^\ast$, known as <b> pull-in voltage</b>, which depends on $\Omega$ and $\varepsilon_1(x)$, such that</p>

<p>$\bullet \quad $ If $\lambda&lt;\lambda^\ast$, then $T_f=\infty$ and the global classical solution converges to the minimal positive steady state.</p>

<p>$\bullet \quad $ If $\lambda&gt;\lambda^\ast$, then $T_f&lt;\infty$, and then touchdown occurs in finite time.</p>

<p>In the actual design of a MEMS device there are several issues that must be considered.
Typically, one of the design goals is to achieve the maximum possible stable steady-state with relatively small applied voltage $\lambda$.  Another consideration may be to increase the stable operating range of the device by increasing the pull-in voltage.
For other devices, such as micropumps and microvalves, where touchdown behavior is explicitly exploited,
<b>it is of interest to be able to localize the touchdown points</b>, or similarly, to be able to avoid touchdown in certain parts of the device.
Our approach to achieve this last goal is to consider a material with varying dielectric permittivity allowing us to localize the touchdown points by a suitable choice of the permittivity profile.</p>

<h2 id="results">Results</h2>

<p>We start by the definition of touchdown point.
A point $x = x_0$ is called a <i> touchdown</i> or <i> quenching point</i> if there exists a sequence ${(x_n , t_n )} \in \Omega\times (0, T)$ such that</p>

<script type="math/tex; mode=display">x_n\to x_0,\ \ t_n\uparrow T\ \ \hbox{and}\ \ u(x_n,t_n)\to 1 \ \hbox{as}\ n\to\infty.</script>

<p>The set of all such points is called the <i> touchdown</i> or <i> quenching set</i>, denoted by $\mathcal{T}=\mathcal{T}_f\subset\overline{\Omega}$.</p>

<p>We show in [2] that <b>touchdown can actually be ruled out in subregions of $\Omega$ 
where $f$ is positive but suitably small, below a positive threshold</b>.</p>

<p><b> Theorem 1:</b>
Let $\Omega\subset \mathbb{R}^n$ a smooth bounded domain and $f$ a function satisfying</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\left\lbrace \begin{array}{rrl}
&&T_f<\infty,\quad \|f\|_\infty\le M,\quad f\ge \mu\chi_B, \\
&&\hbox{where $M,\mu , r>0$ and $B\subset\Omega$ is a ball of radius $r$.}
\end{array} \right.
\end{equation*} %]]></script>

<p>There exists $\gamma_0&gt;0$ depending only on $\Omega,M,\mu,r$ such that:</p>

<p>(i) $\quad$ For any $x_0\in \Omega$, if $f(x_0) &lt;\gamma_0 {\hskip 1pt} \text{dist}^3 (x_0,\partial\Omega)$, then $x_0$ is not a touchdown point.</p>

<p>(ii) $\quad $ For any $\omega\subset\subset \Omega$, if $\displaystyle\sup_{x\in \overline{\Omega}\setminus \omega} f(x) &lt;
\gamma_0 {\hskip 1pt} \text{dist}^3(\omega,\partial\Omega)$, then the touchdown set 
 is contained in $\omega$.</p>

<p>Roughly speaking, the statement (i) in the above theorem allows one to rule out touchdown in an interior point by choosing a permittivity profile which is sufficiently small at that point, while statement (ii) allows to design devices producing touchdown inside any given subset of $\Omega$ by choosing a permittivity profile concentrated in that subset.</p>

<h3 id="numerical-simulation-1--no-touchdown-at-the-origin-">Numerical Simulation 1: <i> no touchdown at the origin </i></h3>

<p>In our first example, we consider a circular elastic plate of radius 1, that is $\Omega = B(0,1)\subset\mathbb{R}^2$.
It is well known that if the dielectric permittivity is constant, the unique touchdown point is the center of the disk.</p>

<p>As consequence of Theorem 1 (i), we can <b>prevent touchdown to occur at the origin</b> by choosing a permittivity profile $f$ such that $f(0)$ is sufficiently small.
Let’s assume that the applied voltage $\lambda$, together with the permittivity of the vacuum $\varepsilon_0$ and the permittivity of the material $\varepsilon_1$ are such that</p>

<script type="math/tex; mode=display">\lambda\dfrac{\varepsilon_0}{\varepsilon_1} = 8.</script>

<p>In this case, we might cover the center of the disk with a material with higher permittivity so that the value of $\varepsilon_1(x)$ in $B(0,1/4)$ is (for example) twice its value in $\Omega\setminus B(0,1/4)$.
That is, we consider the following permittivity profile:</p>

<script type="math/tex; mode=display">% <![CDATA[
f(x) = \left\lbrace \begin{array}{ll}
4 &  |x|< 0.25 \\
8 &  |x|\geq 0.25.
\end{array}\right. %]]></script>

<p>The following video represents the evolution of the elastic plate from the rest position to the pull-in instability.
For the numerical simulation we have applied an implicit Crank-Nicolson scheme in polar coordinates with number of meshpoint $N=100$ in the radial interval $[0,1]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo1.mp4">
</video>
</center>

<center>
<strong> Simulation 1: </strong>  Evolution of the elastic plate until pull-in instability (touchdown). The solution reaches the value 1 in a circumference and then, <b>touchdown is avoided at the center of the plate</b>.
In the schematic video, we remove the upper plate of the MEMS device in order to see the final profile of the solution.  
</center>

<h3 id="numerical-simulation-2--touchdown-near-a-prescribed-circumference-">Numerical Simulation 2: <i> touchdown near a prescribed circumference </i></h3>

<p>Let us suppose now that we want our system to touch down in a circumference of radius near $0.7$.
This time we can use Theorem 1 (ii). We will choose a <b>permittivity profile $f$ sufficiently concentrated near a circumference of radius $0.7$</b>. Consider for example:</p>

<script type="math/tex; mode=display">% <![CDATA[
f(x) = \left\lbrace \begin{array}{ll}
2 &  |x|< 0.65 \\
8 &  0.65\geq |x|\leq 0.75 \\
2 &  0.75< |x|.
\end{array}\right. %]]></script>

<p>The following video represents the evolution of the elastic plate from the rest position to the pull-in instability. 
In Figure 2 below, we plot the radial final touchdown profile.
For the numerical simulation we have applied an implicit Crank-Nicolson scheme in polar coordinates with number of meshpoint $N=100$ in the radial interval $[0,1]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo2.mp4">
</video>
</center>

<center>
<strong> Simulation 2: </strong>  Evolution of the elastic plate until pull-in instability (touchdown). The solution reaches the value 1 in a circumference of <b>radius near</b> $0.7$.
In the schematic video, we remove the upper plate of the MEMS device in order to see the final profile of the solution.  
</center>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/Ex2PlotFinalProfile.png" height="350" width="450" /></p>

<center>
<strong> Figure 2: </strong>  Plot of the <b> radial touchdown profile</b>. Observe that, as expected, touchdown occurs on a circumference of <b>radius between $0.65$ and $0.75$</b>. 
</center>

<h2 id="nontrivial-touchdown-sets">Nontrivial touchdown sets</h2>

<p>In view of Theorem 1,
it is a natural question whether such smallness conditions are actually necessary, 
or whether touchdown could be shown to occur only at or near the maximum points of the permittivity profile $f$.
In this connection, using stability properties of the touchdown set,
in [2] we construct radial ‘‘M’‘-shaped profiles giving rise to 
single-point touchdown at the origin.</p>

<h3 id="numerical-simulation-3">Numerical simulation 3:</h3>

<p>For this example, we have considered the following radial <b>M-shaped profile</b> in a disk of radius 1:</p>

<script type="math/tex; mode=display">f(x)=8-(1/4-|x|^2)^2, \qquad \text{for} \ |x|\in B(0,1).</script>

<p>For this profile, <b>the unique touchdown point is at the origin</b>, far away from the maxima of $f$.
Therefore, if we want to prevent touchdown at the origin, we need to choose a permittivity profile $f$ such that $f(0)$ is small enough (below a certain thershold).
For the numerical simulation we have applied an implicit Crank-Nicolson scheme in polar coordinates with number of meshpoint $N=100$ in the radial interval $[0,1]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo3.mp4">
</video>
</center>

<center>
<strong> Simulation 3: </strong>  Evolution of the elastic plate until pull-in instability (touchdown). Although we consider a ''M''-shaped permittivity profile, <b>the solution touches down only at the origin, far away from the maximum of $f$</b>.
In the schematic video, we remove the upper plate of the MEMS device in order to see the final profile of the solution.  
</center>

<h3 id="numerical-simulation-4">Numerical simulation 4:</h3>

<p>Another rather surprising example is the following <b>radially increasing profile</b>:</p>

<script type="math/tex; mode=display">f(x)= 8 + \dfrac{|x|^2}{4}.</script>

<p>For this example, <b>the unique touchdown point is the origin, which is actually the global minimum of </b> $f$. In [2], we give a rigorous proof of the existence of this kind of behaviors. It is based on a stability result of the touchdown set combined with the fact that single-point touchdown occurs for constant permittivity profiles.</p>

<p>For the numerical simulation we have applied an implicit Crank-Nicolson scheme in polar coordinates with number of meshpoint $N=100$ in the radial interval $[0,1]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo4.mp4">
</video>
</center>

<center>
<strong> Simulation 4: </strong>  Evolution of the elastic plate until pull-in instability (touchdown). Although the permittivity profile is radially increasing, <b> the unique touchdown point is the origin, the minimum point of $f$</b>.
In the schematic video, we remove the upper plate of the MEMS device in order to see the final profile of the solution.  
</center>

<h2 id="quantitative-results-in-1-dimension">Quantitative results in 1 dimension</h2>

<p>Motivated by practical considerations of MEMS design, our aim in [3] is to further investigate the 
touchdown localization problem
and to show that in one space dimension, where analytic computations can be made more precise,
one can obtain quite quantitative conditions.
Namely, <b>we look for a lower estimate of the ratio $\rho$ between $f$ and its maximum,
below which no touchdown occurs</b> on a subregion of $\Omega$.
Rather surprisingly, it turns out that, under suitable assumptions on $f$,
our methods yield values of
 the <b>threshold-ratio</b> $\rho$ which are not ‘‘small’’ but can actually be up to the order</p>

<script type="math/tex; mode=display">\rho\sim 0.3,</script>

<p>which could hence be quite appropriate for robust practical use.</p>

<p>In order to give good estimates of the  ratio $\rho$, we shall consider two typical situations, which roughly correspond to a <b>one-bump</b> or a <b>two-bump</b> shape for the profile $f$. 
 The touchdown is ruled out in a subinterval respectively located between a bump and 
an endpoint of $\Omega$, or between two bumps.
The idea behind this is that the plate can be covered with two dielectric materials, 
one with a high permittivity and the other with a lower permittivity. We then seek for a ratio between the two permittivities, allowing to rule out touchdown in the low permittivity region.</p>

<h3 id="reduction-to-a-finite-dimensional-optimization-problem">Reduction to a finite-dimensional optimization problem</h3>

<p>As a consequence of our method, the <b>threshold-ratio</b> $\rho$ <b> is rigorously obtained as the solution of a suitable finite-dimensional optimization problem</b>, with either three or four parameters. 
An advantage of our results is that they apply to large classes of configurations, so that detailed numerics need not be carried out to localize the touchdown set for particular cases.</p>

<p>For the precise statements of the results, as well as for a detailed study of the optimization problem and <b>numerical estimates of the threshold ratio</b>, we refer the lector to <b>[3]</b>.
The <b>Matlab codes to compute numerical estimates of the solution of the optimization problem</b> are availabe at the beginig of the page.</p>

<p>Here we give two concrete examples in order to illustrate 
the results.
The threshold ratio is obtained by a simple numerical procedure applied to the finite-dimensional optimization problem. 
<b>The following two figures represent some typical permittivity profiles</b> $f(x)$ and the localization of the corresponding touchdown sets
 in the one-bump and two-bump cases respectively. 
The touchdown sets are localized in a neighborhood of the bumps, represented by the fat lines.</p>

<center>
<img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/OneBumpProfile.PNG" width="65%" /> 
</center>

<center>
<strong> Figure 3:</strong> An illustration of the localization of thouchdown set for a <b>one-bump permittivity profile</b>.
Here, the figure represents the permittivity profile $f$ and <b> not </b> the profile of the solution.
</center>

<center>
<img img="" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/TwoBumpProfile.PNG" width="65%" />
</center>

<center>
<strong> Figure 4:</strong> An illustration of the localization of thouchdown set for a <b>two-bump permittivity profile</b>.
Here, the figure represents the permittivity profile $f$ and <b> not </b> the profile of the solution.
</center>

<h3 id="numerical-simulation-5">Numerical simulation 5:</h3>

<p>We give an example of a one-bump permittivity profile, similar to the one in Figure 3.
Although our result applies to a large class of profiles, here we consider, for computational simplicity, the following <b>bang-bang profile</b>:</p>

<script type="math/tex; mode=display">% <![CDATA[
f(x) = \left\lbrace\begin{array}{ll}
0.42 & x<-2 \\
2 & -2\leq x\leq 0 \\
0.42 & x>0.
\end{array}\right. %]]></script>

<p>The following video represents <b> the evolution of a 1-dimensional membrane</b>
with a one-bump permittivity profile $f$. 
For the numerical simulation we have applied an implicit Crank-Nicolson scheme with number of meshpoint $N=1000$ in the interval $[-6,6]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo5.mp4">
</video>
</center>

<center>
<strong> Simulation 5: </strong>  Evolution of the elastic 1-dimensional membrane until pull-in instability (touchdown). We see that <b>touchdown is localized in the region where $f$ is big</b> (see <b>Figure 3</b>).  
</center>

<h3 id="numerical-simulation-6">Numerical simulation 6:</h3>

<p>We give an example of a two-bump permittivity profile, similar to the one in Figure 4.
Although our result applies to a large class of profiles, here we consider, for computational simplicity,
the following bang-bang profile:</p>

<script type="math/tex; mode=display">% <![CDATA[
f(x) = \left\lbrace\begin{array}{ll}
0.42 & x<-1 \\
2 & -1\leq x\leq 1 \\
0.42 & 1<x<4 \\
2 & 4\leq x \leq 6 \\
0.42 & x > 6.
\end{array}\right. %]]></script>

<p>The following video represents <b> the evolution of a 1-dimensional membrane</b>
with a two-bump permittivity profile $f$.
For the numerical simulation we have applied an implicit Crank-Nicolson scheme with number of meshpoint $N=1000$ in the interval $[-10,10]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo6.mp4">
</video>
</center>

<center>
<strong> Simulation 6: </strong>  Evolution of the elastic 1-dimensional membrane until pull-in instability (touchdown). We see that <b>touchdown is localized in the region where $f$ is big</b> (see <b>Figure 4</b>).  
</center>

<h3 id="references">References</h3>

<p>[1] P. Esposito, N. Ghoussoub, Y. Guo, <i> Mathematical analysis of partial differential equations modeling electrostatic MEMS</i>. Courant Lecture Notes in Mathematics, 20. Courant Institute of Mathematical Sciences, New York; American Mathematical Society, Providence, RI, 2010. xiv+318 pp.</p>

<p>[2] C. Esteve, Ph. Souplet, <i> No touchdown at points of small permittivity and nontrivial touchdown sets for the MEMS problem</i>. Advances in Differential Equations, Vol 24, Number 7-8(2019), 465-500.</p>

<p>[3] C. Esteve, Ph. Souplet, <i> Quantitative touchdown localization for the MEMS problem with variable dielectric permittivity</i>. Nonlinearity} 31 4883 (2018).</p>

<p>[4] Ph. Laurençot, Ch. Walker, <i> Some singular equations modeling MEMS</i>. Bull. Amer. Math. Soc. 54 (2017), 437-479.</p>

<p>[5] J.A. Pelesko, D.H. Bernstein, <i> Modeling MEMS and NEMS</i>, Chapman Hall and CRC Press, 2002.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;The main objective of this blog is to explain numerically the difference between exponential and polynomial decay in term of energy and spectral properties. We Show also that system with polynomial decay are very  sensitive to the choice of initial data.&lt;/p&gt;
</code></pre></div></div>

<h2 id="model-problem">Model Problem</h2>

<p>We consider the numerical approximation of the following coupled thermoelastic wave models</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \label{eq1} \tag{1}  \left\{\begin{array}{llll}                       u_{tt}(x,t)- \Delta u(x,t)+\gamma\theta_x(x,t)=0\quad &in\;\Omega\times(0, \infty)\\ 		      \theta_{t}(x,t)-\Delta\theta(x,t)-\gamma u_{tx}(x,t) =0\quad &in\;\Omega\times(0, \infty)\\ 		      u(x,t)=0=\theta(x,t)\qquad &\text{on } \partial\Omega\times(0,\infty)\\ u(x,0)=u_{0}(x),\; u_{t}(x,0)=u_{1}(x),\; \theta(x,0)=\theta_{0}(x) \quad &on \;\Omega                      \end{array}                    \right. \end{equation} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \label{eq2} \tag{2}  \left\{\begin{array}{llll}                       u_{tt}(x,t)- \Delta u(x,t)+\gamma\theta(x,t)=0\quad &in\;\Omega\times(0, \infty)\\ 		      \theta_{t}(x,t)-\Delta\theta(x,t)-\gamma u_{t}(x,t) =0\quad &in\;\Omega\times(0, \infty)\\ 		      u(x,t)=0=\theta(x,t)\qquad &\text{on } \partial\Omega\times(0,\infty)\\ u(x,0)=u_{0}(x),\; u_{t}(x,0)=u_{1}(x),\; \theta(x,0)=\theta_{0}(x) \quad &on \;\Omega                      \end{array}                    \right. \end{equation} %]]></script>

<p>where $u(x,t)$ is the displacement (longitudinal or transverse, depending upon the application) at position $x$ along a bounded smooth domain $\Omega\subset\mathbb{R}$ and time $t$ , and $\theta(x,t)$ is the temperature deviation from the reference temperature at position $x$ and time $t$, $u_0(x)$, $v_0(x)$ and $\theta_0(x)$ are initial data in a suitable space. The small positive constant $\gamma$ is a thermo-mechanical coupling parameter and is generally small in comparison to 1. System (\ref{eq1}) differs from system $\eqref{eq2}$ at the coupling terms, where we have replaced the strong coupling ($\gamma\theta_x$ and $\gamma u_{tx}$) by a weak coupling ($\gamma\theta$ and $\gamma u_{t}$).</p>

<p>It is well known from literature that system (\ref{eq1}) and (\ref{eq2}) are respectively exponentially and polynomially stable, see [3,7] and [5,6,9].</p>

<p>In this post, we will show by numerical experiments, how the coupling terms affect quantitative and qualitative properties of thermoelastic systems (\ref{eq1}) and (\ref{eq2}). These results could be found in [8,10].</p>

<p>To do this, we consider a semi discretization version of both systems (\ref{eq1}) and (\ref{eq2}), obtained with finite element method, which has the following form</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq3} \tag{3}  (S_i)\left\{\begin{array}{ll}  z'_n(t)=A_{i,n} z_n(t),\quad t\geq 0,\;n\in\mathbb{N},\;i=1,2\\  z_n(0)=z_{n0},\;n\in\mathbb{N}\\ \end{array} \right. \end{equation}</script>

<p>where for all $n\in\mathbb{N}$, $z_n=(u_n,v_n,\theta_n)^T$ is the semi discrete solution, $z_{n0}$ is the discretized initial data, $A_{i,n}$ the discretized dynamic and the subscript $\cdot_i$ refers to system (\ref{eq1}) and (\ref{eq2}) with</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align} A_{i,n}=\left(\begin{matrix}                     0 & D_n & 0\\ 	       -D_n & 0 & -\gamma F_{i,n}\\ 		    0 & \gamma F_{i,n} & -D_n^2                    \end{matrix} \right),\quad i=1,2 \end{align} %]]></script>

<p>and $F_{2,n}=I_n$,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align} D_n=\left(\begin{matrix}                     1 &  & \\ 	        & \ddots &  \\ 		     &   & n                    \end{matrix} \right),\quad (F_{1,n})_{ij}=\left\{\begin{array}{ll}  -\frac{4}{\pi}\frac{ij}{i^2-j^2},\quad `i-j`=\text{odd},\\  0,\qquad\qquad\text{otherwise}. \end{array} \right. \end{align} %]]></script>

<h2 id="spectral-properties-of-thermoelastic-systems">Spectral properties of thermoelastic systems</h2>

<p>Figure 1 and Figure 2 show how the coupling terms affect the placement of eigenvalues of the dynamic $A_{n}$. In Figure 1, we see that a uniform distance between the eigenvalues and the imaginary axis is preserved, see Table 1. Another observation is that for fixed $n$, the eigenvalues of higher frequency modes, in particular, the one of the $n^{th}$ mode, are closer to the imaginary axis. Moreover, as the number of modes increases, these eigenvalues bend back towards the vertical line $\lambda=-\frac{\gamma^2}{2}$, a fact which has been already shown in [4]. Therefore, the corresponding spectral element approximation scheme preserves the property of exponential stability.</p>

<center> <strong>Table 1.</strong> Distance between $\sigma(A_{1,n})$ and the imaginary axis form the spectral element method</center>
<center>
<table align="center">
    <tr>
        <th>n</th>
        <th>$min \{ -Re(\Lambda),\Lambda \in \sigma(A_{1,n}) \}$</th>
    </tr>
    <tr>
        <th>8</th>
        <th>$8.9227x10^{-4}$</th>
    </tr>
    <tr>
        <th>16</th>
        <th>$8.9383x10^{-4}$</th>
    </tr>
    <tr>
        <th>24</th>
        <th>$8.9402x10^{-4}$</th>
    </tr>
    <tr>
        <th>32</th>
        <th>$8.9407x10^{-4}$</th>
    </tr>            
</table>
</center>
<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/fig1.png" alt="" /> Location of the complex eigenvalues of the matrix $A_{1,n}$ with the finite element method</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">error</span>
<span class="n">Nx</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">stabexpsem</span><span class="p">(</span><span class="n">Nx</span><span class="p">);</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Error using error
Not enough input arguments.

Error in tp1d0d1572_49d1_41a8_914f_f09a199a8ec3 (line 114)
error

</code></pre></div></div>

<p>In Figure 2, conversely to Figure 1 where a uniform distance between the eigenvalues and the imaginary axis is preserved, we observe that, as the number of modes increases, an asymptotic behaviour appears in the neighborhood of the imaginary axis at $\pm\infty$. This property is mainly related to systems with polynomial decay, see \cite{BEPS2006}.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/fig2.png" alt="" /> Location of the complex eigenvalues of the matrix $A_{2,n}$ with the finite</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Nx</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">stabpolysem</span><span class="p">(</span><span class="n">Nx</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="uniform-and-polynomial-decay-of-the-energy">Uniform and polynomial decay of the energy</h2>

<p>The discrete energy associated to system (\ref{eq3}) is given by</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq4} \tag{4} E_{i,n}(t)=\frac{1}{2}\sum_{j=1}^n\Big\{ \vert u_j(t)\vert^{2} + \vert v_j(t)\vert^{2}+ \vert \theta_j(t)\vert^{2}\Big\},\;i=1,2. \end{equation}</script>

<p>The discrete energy $E_{1,n}$ associated to system (ref{eq1}) decays exponentially to zero, see Figure 3, in the following sense: $\exists M,\alpha$ positive constants such that</p>

<script type="math/tex; mode=display">E_{1,n}(t)\leqslant Me^{-\alpha t}E_{1,n}(0),\;n\in\mathbb{N},\;t>0.</script>

<p>However, the introduction of the weak coupling term in system (ref{eq1}) has changed the dynamic and consequently the behavior of energy (\ref{eq4}). In this case, we say that system (\ref{eq2}) decays polynomially to zero, see Figure 4, in the following sense: $\exists M,\alpha$ positive constants such that</p>

<script type="math/tex; mode=display">E_{2,n}(t)\leqslant \frac{M}{t} \vert A_{2,n} z_{n0} \vert^2  ; n \in \mathbb{N},\;t>0.</script>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/exp.png" alt="" /> Exponential decay of $E_{1,n}(t)$</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/poly.png" alt="" /> Polynomial decay of $E_{2,n}(t)$</p>

<h2 id="effect-of-smoothness-of-the-initial-data-on-the-rate-of-decay-of-energy">Effect of smoothness of the initial data on the rate of decay of energy</h2>

<p>It has been shown theoretically, see [1,2], that the energy associated to system (\ref{eq2}) is very sensitive to the smoothness of its initial data. This fact, has been also observed numerically, see Figure 6. we use</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Nx</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">FinalTime</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="nb">mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Gamma</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">k</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>and we consider the following initial data</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">u0</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">pi</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
<span class="n">v0</span><span class="o">=</span><span class="nb">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">/</span><span class="nb">pi</span><span class="p">)</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="n">teta0</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<p>Through Figure 6, we notice that for $j = 1$, the approximate energy $E_{2,n}(t)$ decays to zero as the time $t$ increases. Moreover, we observe that the decay rate depends strongly on $j$. That is, when $j$ increases, initial data are very oscillating. We say in this case that the rate of decay of the discrete energy $E_{2,n}(t)$ is very sensitive to the choice of the initial data. However, the behavior of the energy assosiated to system (\ref{eq1}) remains indifferent to the smoothness of initial data when $n\to\infty$, see Figure 5.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/fig5.png" alt="" />  Exponential decay of $E_{1,n}(t)$</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/fig6.png" alt="" />  Polynomial decay of $E_{2,n}(t)$</p>

<h2 id="references">References</h2>

<p>[1] A. B' atkai, K.J. Engel, J. Pr"uss and R. Schnaubelt, Polynomial stability of operator semigroups, Math. Nachr. 279, pp.</p>

<p>[2] A. Borichev and Y. Tomilov, Optimal polynomial decay of functions and operator semigroups, Math. Ann., 347(2), pp.455-478, 2010.</p>

<p>[3] S. W. Hansen, Exponential energy decay in a linear thermoelastic rod. J. Math. Anal. Appli.,167, pp. 429-442, 1992.</p>

<p>[4] F.A. Khodja, A. Benabdallah, and D. Teniou, Stability of coupled systems, Abstr. Appl. Anal. Volume 1, Number 3, 327-340, 1996.</p>

<p>[5] F. A. Khodja, A. Benabdallah and D. Teniou, Dynamical stabilizers and coupled systems}, ESAIM Proceeding,2, pp. 253-262, 1997.</p>

<p>[6] F. A. Khodja, A. Bader and A. Benabdallah, Dynamic stabilization of systems via decoupling techniques, ESAIM: COCV,4,</p>

<p>[7] Z. Liu and S. Zheng, Exponential stability of semigroup associated with thermoelastic system, Quart. Appl. Math, 51, pp.535-545, 1993.</p>

<p>[8] Z. Y. Liu and S. Zheng, Uniform exponential stability and approximation in control of a thermoelastic system, SIAM J. Control Optim. 32, pp. 1226-1246, 1994.</p>

<p>[9] Z. Liu and B. Rao, Characterization of polynomial decay rate for the solution of linear evolution equation. Zeitschrift  angewandte Mathematik und Physik ZAMP,56, pp. 630-644, 2005.</p>

<p>[10] L. Maniar and S. Nafiri, Approximation and uniform polynomial stability of C_0-semigroups,ESAIM: COCV 22, pp. 208-235, 2016.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h2 id="asda"&gt;asda&lt;/h2&gt;


&lt;p&gt;In this tutorial, we present some aspects of the obstacle problem in the stationary (elliptic) and the evolutionary (parabolic) setting by means of numerical simulations, performed in &lt;code class="highlighter-rouge"&gt;FEniCS&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Matlab&lt;/code&gt;.&lt;/p&gt;
</code></pre></div></div>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/obstaclepb_1d.png" width="1000px" />
</center>
<center> <strong>Figure 1.</strong> The solution (blue) of the one-dimensional elliptic obstacle problem is superharmonic (concave down) and matches derivatives with the obstacle (black). 
</center>

<h2 id="1-mathematical-formulation"><em>1. Mathematical formulation</em></h2>

<h3 id="11-elliptic-problem">1.1. Elliptic problem</h3>
<p>Let $\Omega \subset \mathbb{R}^d$ be open, regular and bounded, let $\psi \in H^2(\Omega)$ (the <em>obstacle</em>) and $g \in H^1(\Omega)$ (boundary data) with $\psi \leq g$ on $\partial \Omega$ be given. We consider the functional</p>

<script type="math/tex; mode=display">\mathcal{F}_{\text{OB}}(u):= \frac12 \int_\Omega |\nabla u|^2 dx - \int_\Omega fu \, dx</script>

<p>where $f \in L^2(\Omega)$ is given, and the closed convex set</p>

<script type="math/tex; mode=display">\mathcal{K}^g_{\text{OB}} := \{ u \in H^1(\Omega): u - g \in H^1_0(\Omega), \, u \geq \psi \, \text{ in } \, \Omega  \}.</script>

<p>The <strong>classical obstacle problem</strong> can be written as</p>

<script type="math/tex; mode=display">\min_{u \in \mathcal{K}^g_{\text{OB}}} \mathcal{F}_{\text{OB}}(u)</script>

<p>and admits a unique minimizer $\phi \in \mathcal{K}^g_{\text{OB}}$, which is also a solution of the <strong>variational inequality</strong></p>

<script type="math/tex; mode=display">\nabla \mathcal{F}_{\text{OB}}(\phi) \cdot (v-\phi) \geq 0 \quad \text{ for every } \quad v \in \mathcal{K}^g_{\text{OB}}.</script>

<p>The terminology “<em>obstacle problem</em>” comes from the physical origin of the model $-$ the solution $\phi$ represents the equilibrium position of an elastic membrane, which is constrained to lie above an obstacle (given by the graph of the function $\psi$).</p>

<p><strong>Notation:</strong>  The notation</p>

<script type="math/tex; mode=display">\nabla \mathcal{F}_{\text{OB}}(\phi)\cdot\zeta</script>

<p>designates the Gateaux derivative ($L^2$-gradient) of the functional ${F}_{\text{OB}}$ at the point $\phi$ in the direction $\zeta$; in occurence,</p>

<script type="math/tex; mode=display">\nabla \mathcal{F}_{\text{OB}}(\phi)\cdot\zeta = (\nabla \phi, \nabla \zeta)_{L^2(\Omega)}-(f, \zeta)_{L^2(\Omega)}-(g,\zeta)_{L^2(\partial \Omega)}</script>

<p>Most of the regularity theory for the obstacle problem has been developed for the model case $\Delta \psi=-1$. We refer to [3,4] for a detailed presentation. 
For simplicity of the presentation, let us thus assume for a moment that $f \equiv -1$ and $\psi \equiv 0$. Choosing appropriate test functions bring us from the variational inequality for $\phi$ to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
\Delta \phi = 1 	&\text{ in }  \{\phi>0\}  \\
\phi \geq 0 &\text{ in } \Omega \\
\phi = |\nabla \phi| = 0 &\text{ on } \partial \{\phi>0\} \\
\phi = g &\text{ on } \partial \Omega.
\end{cases} %]]></script>

<p>The set ${ \phi=0 }$ is called <em>contact set</em>, while $\partial { \phi&gt;0 }$ is the <em>free boundary</em>.</p>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/esol_matlab_1.png" width="600px" />
<center> <strong>Figure 2.</strong> The solution $\phi$ to the elliptic obstacle problem just above. The <strong>obstacle</strong> is equal to 0 (<strong>gray plane</strong>), and the free boundary (boundary of the contact set between the membrane and the obstacle) is displayed in red, projected just below. </center>
</center>

<p><strong>Remark:</strong> At this point, we may see why solving the elliptic obstacle problem is different to just solving the Poisson equation for $\phi$ in a subdomain of $\Omega$ and setting $\phi=\psi$ elsewhere. Indeed, solving the latter problem does not guarantee that we would have</p>

<script type="math/tex; mode=display">|\nabla (\phi-\psi)| =0</script>

<p>along the boundary.</p>

<h3 id="12-parabolic-problem">1.2. Parabolic problem</h3>

<p>The parabolic counterpart onsists in finding $u \in H^1(]0, +\infty[; L^2(\Omega))\cap L^2(]0,+\infty[; H^2(\Omega) \cap \mathcal{K}^g_{\text{OB}})$ satisfying</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
	\big(\, u'(t), v-u(t) \big)_{L^2(\Omega)} + 
	\nabla \mathcal{F}_{\text{OB}}(u(t))\cdot (v-u(t)) \geq 0 &\text{ for every } v \in \mathcal{K}^g_{\text{OB}}, \, t>0 \\
	u(0, x) = u_0 \in \mathcal{K}^g_{\text{OB}}.
\end{cases} %]]></script>

<p>The name “<em>parabolic obstacle problem</em>” for the above system <strong>may be misleading</strong>. 
While the mathematical formulation is similar, the physical interpretation of the elliptic and parabolic problem is different. In the parabolic setting, seeing $\psi$ as a physical obstacle in space is not correct. Rather, one should interpret $\psi$ as a <em>barrier</em> for the temperature $u$. More accurately, we are dealing with a parabolic variational inequality with an obstacle-type constraint.</p>

<p>The function $\psi$ may be time-dependent, but for simplicity we omit this case.</p>

<center>
<table>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/parabolic_free_dome.gif" width="600px" /></th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/steady_dome.png" width="600px" /></th>
</tr>
</table>
</center>
<center> <strong>Figure 3.</strong> Here $\psi(x)=3*\sqrt{(1-x^2)}$ in $(-1,1)$ (black) is a barrier for the evolving solution (blue). The initial data coincides with $\psi$ on (-1.5, 1.5). We observe that the contact set $\{ u = \psi \}$ changes (gets smaller) as time grows. There is also matching of normal derivatives on the contact points (i.e. the free boundary). 
Finally, the solution of the parabolic problem (left, blue) converges to that of the elliptic problem (right, red) for large time, as seen below.   </center>

<center>
<table>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/terrain_rotate.gif" width="600px" /></th>
</tr>
</table>


</center>
<center><strong>Figure 4.</strong> The solution to the parabolic problem with Dirichlet boundary condition =1. The <strong>obstacle</strong> is given by the <strong>"three towers"</strong>. The free boundary (boundary of the contact set with the obstacle) is projected on a plane below in red. It is seen that the source term $-1$ acts as a gravity force pushing the membrane towards the obstacle. We moreover observe a convergence to the equilibrium position (see also the section below). </center>

<p>For $\psi \equiv 0$ and $f\equiv-1$ (or more generally $f + \Delta \psi = -1$), a manifestation of the parabolic variational inequality above is as a “weak form” of the one-phase Stefan problem (see [3,4]). In this setting, we may pass from the variational inequality to the equivalent problem with <strong>two boundary conditions</strong> at the free boundary</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
	u_t - \Delta u = -1 &\text{ in } \quad \{ u(t)>0\} \times ]0, +\infty[ \\
	u \geq 0 &\text{ in } \quad \Omega \times ]0, +\infty[ \\
	u = |\nabla u| = 0 &\text{ on } \quad \partial \{ u(t)>0 \} \times ]0, +\infty[\\
	u = g &\text{ on } \quad  \partial \Omega \times ]0, +\infty[ \\
	u = u_0 &\text{ on } \quad \Omega \times \{ t = 0\}
\end{cases} %]]></script>

<p>This is an overdetermined problem, which means that the <em>free boundary/the contact set ${u=0}$ has to change with time</em> to ensure that both BC hold for every time. The evolution of the contact set may be observed in the numerics of Figures 3,4,5.</p>

<p><strong>Remark:</strong> $\quad$
As for the elliptic problem, solving the above parabolic problem is different to just solving the heat equation for $u$ in a subdomain of $\Omega$ and setting $u$ elsewhere, with a Dirichlet boundary condition. Indeed, solving the latter problem does not guarantee that we would have $|\nabla u|= 0$ along the boundary.</p>

<p><strong>Remark:</strong> $\quad$
While in Figure 3 the contact set is shrinking does not disappear, it may happen that the contact set vanishes (depending on the magnitude of the boundary data $g$, the support of the initial data $u_0$, and if present, the source term $f$).</p>

<h3 id="13-relationship-between-both-problems">1.3. Relationship between both problems</h3>

<p>In the recent paper [5], it is shown that the solution $u(t)$ to the parabolic variational inequality converges to the solution $\phi$ of the elliptic probelem in $H^1(\Omega)$ norm as $t\rightarrow \infty$ with exponential rate. This is done by means of new techniques including a so-called constrained Lojaseiwicz inequality.</p>

<p>We may observe this convergence numerically in Figures 4 and 5. In both cases, we work in the ball $B_2$, with boundary data $g\equiv 0.8$, barrier $\psi\equiv 0$ and 
initial datum supported outside $B_{1.5}$.</p>

<p><strong>The one-dimensional case:</strong></p>

<table>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/parabolic_free_0.gif" width="600px" /></th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/steady_0.png" width="600px" /></th>
</tr>
</table>

<center><strong>Figure 5.</strong> The solution of the parabolic problem (left, blue) converges to that of the elliptic problem (right, red) as time increases. We again see that the contact set $\{ u = 0\}$ changes with time. </center>

<p><strong>The two-dimensional case:</strong></p>
<center>
<table>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/state.gif" width="600px" /></th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/interface.gif" width="600px" /></th>
</tr>
</table>


</center>
<center><strong>Figure 6.</strong> We see that as time increases, the contact region $\{ u = 0\}$ (white patch) gets smaller. In terms of the Stefan problem, the white patch represents the ice temperature. Ice is melting as time increases, but does not fully melt, because the support of the initial data is too small and the temperature on the boundary is not high enough.  </center>

<table>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/finger_rotate.gif" width="600px" /></th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/esol_matlab_1.png" width="600px" /></th>
</tr>
</table>

<center><strong>Figure 7.</strong> In this figure, the obstacle is set to zero, and we consider Dirichlet boundary conditions $=0.8$ on the fixed boundary. We see that even when considering initial data which are not an equilibrum membrane position (but do satisfy the obstacle condition), as time increases, the solution of the parabolic problem (<strong>left</strong>) converges to that of the elliptic problem (<strong>right</strong>)  </center>

<h2 id="2-numerical-implementation">2. <em>Numerical implementation</em></h2>

<h3 id="21-possible-strategies">2.1. Possible strategies</h3>

<p>A common approach for proving the well-posedness and $W^{2,p}$ regularity for variational inequalities is a technique called penalization, which consists of approximating by a sequence of semilinear equations [8]. For any $\epsilon&gt;0$, we will consider</p>

<script type="math/tex; mode=display">u' - \Delta u + \frac{1}{\epsilon} (u-\psi)_{-} = f \quad \text{ in } \quad \Omega \times ]0,\infty[</script>

<p>to approximate the parabolic problem, and remove $u’$ and time dependence for the elliptic one. As $\epsilon\rightarrow0$, the solution $u_\epsilon$ of the above equation converges to the variational inequality.  Here</p>

<script type="math/tex; mode=display">\beta_\epsilon(u) = \frac{1}{\epsilon}(u)_- = \frac{1}{\epsilon}\min \{u, 0 \}</script>

<p>may be replaced by another penalty function, for instance $\beta_\epsilon(u) = -\exp(-u/\epsilon)$.</p>

<p>The approximated problem is relatively simple to implement numerically. We may use finite elements (say $P1$ elements) to discretize in space, and time-stepping (Euler implicit for instance) to discretize in time.</p>

<p>There are other ways to solve the variational inequality after discretizing in space and time (using one’s favorite metood). One which is popular in the literature for the elliptic problem is the <em>primal dual active set</em> method, which we will present in a future post.</p>

<h3 id="22-code">2.2. Code</h3>

<h4 id="i-elliptic-problem">i). Elliptic problem.</h4>

<p>Let us start by solving the two-dimensional elliptic problem from Figure 4.</p>

<p>The <code class="highlighter-rouge">fenics</code> module [1] contains all of the necessary finite element tools for the space discretization of PDEs.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">obstacles</span> <span class="kn">import</span> <span class="n">dome</span>
<span class="kn">from</span> <span class="nn">mshr</span> <span class="kn">import</span> <span class="n">mesh</span>
</code></pre></div></div>
<p>It is advantageous to regularize the “kink” appearing in penalty function (the negative part of a function) in view of using a Newton method for solving the nonlinear problem</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">smoothmax</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span> 
	<span class="k">return</span> <span class="n">conditional</span><span class="p">(</span><span class="n">gt</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span> <span class="n">r</span><span class="o">-</span><span class="n">eps</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">conditional</span><span class="p">(</span><span class="n">lt</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span><span class="p">)))</span>
</code></pre></div></div>
<p>We mesh the domain $B_2$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">25</span><span class="p">)</span>
</code></pre></div></div>

<p>$P1$ elements are used for the FEM spaces (but one may easily choose higher order in the definition of V).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">"CG"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>		
<span class="n">eps</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">))</span>
</code></pre></div></div>

<p>Using the symbolic expressions of <code class="highlighter-rouge">FEniCS</code>, we define the variational formulation of the penalized PDE, which we write in the form $F(w)=0$:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="s">"on_boundary"</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">eps</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">smoothmax</span><span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="o">+</span><span class="n">psi</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</code></pre></div></div>

<p>We solve the nonliner problem with the command <code class="highlighter-rouge">solve</code>, which makes use of a Newton method to solve the nonlinear equation $F(w)=0$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span>
</code></pre></div></div>

<p>We visualise in <code class="highlighter-rouge">ParaView</code> by storing the solution in .vtk format using:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vtkel = File("output/el.pvd")
vtkel &lt;&lt; w
</code></pre></div></div>

<h4 id="ii-parabolic-problem">ii). Parabolic problem.</h4>

<p>We set $T=2$, use $100$ subdivisions and set</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dt</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="mi">100</span>
</code></pre></div></div>

<p>This part only differs by the presence of a time-loop. We define the initial datum in a separate class:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">indata</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mf">1.95</span><span class="p">:</span>
			<span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">elif</span> <span class="mf">1.95</span> <span class="o">&lt;=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mf">1.95</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mf">1.95</span><span class="p">)</span><span class="o">*</span><span class="mf">0.8</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.8</span>
</code></pre></div></div>

<p>Repeating as in the elliptic case up to defining the variational form, we now set the inital datum (interpolating the expression onto the FEM space) and time:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">un</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">indata</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>
<p>We set up the time loop:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vtksol = File("output/popsol.pvd")
for n in range(num_steps):
    t+=dt
    solve(F==0, u, bcs=bc)
    vtksol &lt;&lt; (u, t)
    un.assign(u) 
</code></pre></div></div>

<h2 id="optimal-control"><em>Optimal Control</em></h2>

<p>We will now briefly present the implementation of an optimal control strategy for the elliptic and parabolic problems. We will make use of the penalized problems where $\epsilon&gt;0$ is small (of the order $10^{-8}$). This strategy has been succesfully applied in [8].</p>

<h3 id="31-elliptic-problem">3.1. Elliptic problem</h3>

<p>Given a target $\phi_d$ and a regularization parameter $\delta&gt;0$ (we usually use $\delta = 10^{-2}$), we seek to minimize</p>

<script type="math/tex; mode=display">J(u) = \frac12 \|\phi-\phi_d \|_{L^2(\Omega)}^2 + \frac{\delta}{2} \| u \|^2_{L^2(\Omega)}</script>

<p>subject to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
	-\Delta \phi + \frac{1}{\epsilon} (\phi-\psi)_- = f+u &\text{ in } \Omega \\
	\phi = g &\text{ on } \partial \Omega.
\end{cases} %]]></script>

<p>For simplicity of the presentation, we will consider</p>

<script type="math/tex; mode=display">f\equiv-1</script>

<script type="math/tex; mode=display">g\equiv0\</script>

<script type="math/tex; mode=display">\psi(x) = \sqrt{(1-|x|^2)_+}</script>

<p>on the domain $\Omega = [-2,2]^2$. The target is the function $\phi_d(x) = \frac12(\cos(x_1)+\cos(x_2))$.</p>

<p>The uncontrolled solution of the elliptic obstacle problem in this case is:</p>

<table>
<tr>
	<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/elliptic_zero_dome.png" width="600px" />
	</th>
	<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/obstacle.png" width="600px" />
	</th>
</tr>
</table>

<center><strong>Figure 8.</strong> For comparison with the controlled problem, we show also the solution to the free elliptic problem with the "dome" like obstacle given on the right. </center>

<p>The <code class="highlighter-rouge">FEniCS</code> optimization code will have the effect of obtaining the following results.</p>

<table>
<tr>
	<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/opt_state.png" width="600px" />
	</th>
	<th>
	<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/obstacle.png" width="600px" />
	</th>
</tr>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/target.png" width="600px" />
</th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/opt_control.png" width="600px" />
</th>
</tr>
</table>

<center>


</center>
<center><strong>Figure 9.</strong> The optimal state (<strong>top left</strong>) can be seen to be above the obstacle (<strong>top right</strong>), and is very much alike the shape of the target (<strong>bottom left</strong>). Finally, the optimal control is given (<strong>bottom right</strong>). </center>

<p>Let us present the numerical implementation. After importing the <code class="highlighter-rouge">dolfin_adjoint</code> optimization module [2], we make use of the code for simulating the uncontrolled problem. A “tape” of the forward model is built. This tape is used to drive the optimization by repeatedly solving the forward model and the adjoint model for varying control inputs.</p>

<p>Defining the objective functional to be minimized:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delta</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">)</span>
<span class="n">j</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">w</span><span class="o">-</span><span class="n">wd</span><span class="p">,</span> <span class="n">w</span><span class="o">-</span><span class="n">wd</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">delta</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>	
<span class="n">m</span> <span class="o">=</span> <span class="n">Control</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</code></pre></div></div>

<p>Writing the state $y$ as the output of the solution map corresponding to the input $m$, one sees that the objective functional depends only on the control:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">J</span> <span class="o">=</span> <span class="n">ReducedFunctional</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>									
</code></pre></div></div>

<p>We run the optimization, based on a conjugate-gradient method:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">u_opt</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">"method"</span><span class="o">=</span><span class="s">"CG"</span><span class="p">})</span>
</code></pre></div></div>

<p>The tape is modified such that the initial guess for y (to be used in the Newton solver in the forward problem) is set to y_opt.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y_opt</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">block_variable</span><span class="o">.</span><span class="n">saved_output</span>
<span class="n">Control</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">y_opt</span><span class="p">)</span>
</code></pre></div></div>

<p>The algorithm converged after 8 iterations, and the value of the functional at the final iteration is $0.0967$.</p>

<h3 id="32-the-parabolic-problem">3.2. The parabolic problem</h3>

<p>Given a final time $T&gt;0$, a target $u_d$ and a regularization parameter $\delta&gt;0$, we seek to minimize</p>

<script type="math/tex; mode=display">J(u) = \frac12 \|u(T)-u_d \|_{L^2(\Omega)}^2 + \frac{\delta}{2} \| v \|_{L^2(\Omega)}</script>

<p>subject to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
	u'-\Delta u + \frac{1}{\epsilon} (u)_- = f+v &\text{ in } \Omega \times (0, T) \\
	u = g &\text{ on } \partial \Omega \times (0, T) \\
	u = u_0 &\text{ in } \Omega \times \{ t = 0 \}
\end{cases} %]]></script>

<p>For simplicity of the presentation, we will consider the same setting as in Figure 3, namely $f\equiv-1\,$,  $g\equiv0.8\,$, on the domain $\Omega = [-2,2]$. The target temperature is $u_d(x) = 0.8$. This would correspond to “melting”, as this target is never equal to zero, thus has no contact set. We would thus expect the action of the control $v$ to lift-up $u$ from $0$ and thus the contact set (and free boundary) to vanish.</p>

<p>We appeal to <code class="highlighter-rouge">DyCon-Toolbox</code> [9] for the numerical implementation of this problem. <code class="highlighter-rouge">DyCon-Toolbox</code> is an efficient and easy to use solver for nonlinear control problems.</p>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/ocpop.gif" width="900px" />
<center><strong>Figure 10.</strong> The optimal state (left, red), starting from an initial datum with a non-empty contact set (left, blue) and the optimal control (red, right). </center>
</center>

<p>The action and magnitude of the control ensures that the solution to the parabolic problem will lift-off from the initial contact set. 
For comparison, we recall that the uncontroled free dynamics have a very different behavior:</p>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/parabolic_free_0.gif" width="600px" />
</center>

<center><strong>Figure 11.</strong> The uncontrolled free dynamics of the parabolic obstacle problem in 1 dimension, where the obstacle is zero. </center>

<p>We begin by symbolically defining the time variable:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">t</span>
</code></pre></div></div>

<p>We discretize the interval $[-2, 2]$:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">70</span><span class="p">;</span>
<span class="n">xi</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="n">xf</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">xline</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">xf</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">xline</span> <span class="o">=</span> <span class="n">xline</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>We define symbolically (as in <code class="highlighter-rouge">FEniCS</code>) the state vector $Y$ and control vector $U$:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Y</span> <span class="o">=</span> <span class="n">SymsVector</span><span class="p">(</span><span class="s">'y'</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">SymsVector</span><span class="p">(</span><span class="s">'u'</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
</code></pre></div></div>
<p>We discretize by finite differences, and define the semilinear penalty term:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alpha</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">;</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-2</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">FDLaplacian</span><span class="p">(</span><span class="n">xline</span><span class="p">);</span>

<span class="n">F</span>  <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="n">NonLinearTerm</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">alpha</span><span class="p">);</span>
<span class="n">dF</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="n">DiffNonLinearTerm</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">alpha</span><span class="p">);</span>
</code></pre></div></div>

<p>We may define the parabolic problem to be solved.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dx</span> <span class="o">=</span> <span class="n">xline</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">xline</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Y_t</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">Params</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">Y</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">epsilon</span><span class="o">*</span><span class="n">F</span><span class="p">(</span><span class="o">-</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">U</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="mf">0.8</span><span class="p">;</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="mf">0.8</span><span class="p">];</span>
<span class="n">Dyn</span> <span class="o">=</span> <span class="n">pde</span><span class="p">(</span><span class="n">Y_t</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">U</span><span class="p">);</span>
</code></pre></div></div>
<p>We set the mesh, and other relevant parameters such as the final time and initial data. We consider the same data as in the free problem.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Dyn</span><span class="o">.</span><span class="n">mesh</span>   <span class="o">=</span> <span class="n">xline</span><span class="p">;</span>
<span class="n">Dyn</span><span class="o">.</span><span class="n">Solver</span> <span class="o">=</span> <span class="o">@</span><span class="n">ode23</span><span class="p">;</span>
<span class="n">Dyn</span><span class="o">.</span><span class="n">Nt</span>     <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>
<span class="n">Dyn</span><span class="o">.</span><span class="n">FinalTime</span>        <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
<span class="n">Dyn</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="n">InitialConditionFcn</span><span class="p">(</span><span class="n">xline</span><span class="p">);</span>
</code></pre></div></div>

<p>We now compute the necessary Jacobian matrices.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Dyn</span><span class="o">.</span><span class="n">Derivatives</span><span class="o">.</span><span class="n">Control</span><span class="o">.</span><span class="n">Num</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">Params</span><span class="p">)</span> <span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="n">Dyn</span><span class="o">.</span><span class="n">Derivatives</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">Num</span>   <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">Params</span><span class="p">)</span> <span class="n">A</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">epsilon</span><span class="o">*</span><span class="n">dF</span><span class="p">(</span><span class="o">-</span><span class="n">Y</span><span class="p">);</span>
</code></pre></div></div>

<p>We may solve the free problem over the given time interval. We recall that we have used finite differences to discretize in space (but finite elements can be used as well in more complicated settings), and the underlying solve command solves the system of ODEs by means of some Runge-Kutta scheme.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">tspan</span><span class="p">,</span><span class="n">Ysolution</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">Dyn</span><span class="p">);</span>
<span class="n">figure</span>
<span class="n">surf</span><span class="p">(</span><span class="n">Ysolution</span><span class="p">)</span>
</code></pre></div></div>
<p>Having solved the free dynamics, we are now in a position to solve the optimal control problem:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">YT</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="nb">xline</span><span class="o">'</span><span class="p">;</span>
<span class="nb">beta</span> <span class="o">=</span> <span class="n">dx</span><span class="o">^</span><span class="mi">4</span><span class="p">;</span>
<span class="n">Psi</span>  <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="n">YT</span> <span class="o">-</span> <span class="n">Y</span><span class="p">)</span><span class="o">.'*</span><span class="p">(</span><span class="n">YT</span> <span class="o">-</span> <span class="n">Y</span><span class="p">);</span>
<span class="n">L</span>    <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">U</span><span class="p">)</span>  <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="n">YT</span> <span class="o">-</span> <span class="n">Y</span><span class="p">)</span><span class="o">.'*</span><span class="p">(</span><span class="n">YT</span> <span class="o">-</span> <span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="k">...</span>
                 <span class="nb">beta</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="nb">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">U</span><span class="o">.'*</span><span class="n">U</span><span class="p">);</span>
<span class="n">OCP</span> <span class="o">=</span> <span class="n">Pontryagin</span><span class="p">(</span><span class="n">Dyn</span><span class="p">,</span><span class="n">Psi</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
<span class="n">U0</span> <span class="o">=</span> <span class="o">-</span><span class="nb">ones</span><span class="p">(</span><span class="n">Dyn</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span><span class="n">Dyn</span><span class="o">.</span><span class="n">ControlDimension</span><span class="p">);</span>
<span class="n">U0</span> <span class="o">=</span> <span class="n">GradientMethod</span><span class="p">(</span><span class="n">OCP</span><span class="p">,</span><span class="n">U0</span><span class="p">,</span><span class="s1">'Graphs'</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span><span class="s1">'EachIter'</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">'DescentAlgorithm'</span><span class="p">,</span><span class="o">@</span><span class="n">AdaptativeDescent</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="references">References:</h2>

<p>[1] The FEniCS Project Version 1.5
M. S. Alnaes, J. Blechta, J. Hake, A. Johansson, B. Kehlet, A. Logg, C. Richardson, J. Ring, M. E. Rognes and G. N. Wells
Archive of Numerical Software, vol. 3, 2015.</p>

<p>[2] Patrick E. Farrell, David A. Ham, Simon W. Funke and Marie E. Rognes (2013). Automated derivation of the adjoint of high-level transient finite element programs, SIAM Journal on Scientific Computing 35.4, pp. C369-C393. doi:10.1137/120873558. arXiv:1204.5577</p>

<p>[3] Figalli A. (2018), Free boundary regularity in obstacle problems 
Journées EDP 2018, to appear.</p>

<p>[4] Figalli, A. (2018), Regularity of interfaces in phase transitions via obstacle problems 
Proceedings ICM 2018, to appear.</p>

<p>[5] Colombo M. and Spolaor, L. and Velichkov, B. (2018), On the asymptotic behavior of the solutions to parabolic variational inequalities, ArXiV preprint.</p>

<p>[6] Borjan Geshkovski (2018). Obstacle Problems: Theory and Applications. Master Thesis.</p>

<p>[7] Hintermüller M. and Kopacka I., A smooth penalty approach and a nonlinear multigrid algorithm for elliptic MPECs. Computational Optimization and Applications, 50(1):111–145, 2011.</p>

<p>[8] D. Kinderlehrer and G. Stampacchia. An introduction to variational inequalities and their applications. Volume 31 of Classics in Applied Mathematics. SIAM, 2000.</p>

<p>[9] DyCon-Toolbox, https://deustotech.github.io/dycon-toolbox-documentation/.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;Consider a rotor rotating around a fixed axis. Because of wear and damage, the mass distribution is not homogeneous. This leads to dangerous vibrations in the rotation. A prototypical example can be a wind turbine, affected by misalignment of the blades and/or mass imbalance of the hub and blades [2].&lt;/p&gt;
</code></pre></div></div>

<p>In order to compensate the imbalance, two balancing heads are mounted at the endpoints of the axle, as in figure <a href="#1">1</a>. Each balancing head is made of two masses free to rotate.</p>

<p>Our goal is to determine the optimal movement of the balancing masses to minimize the vibrations. Control theoretical techniques are employed. For further details, see [6].
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/spindlegrinder8mod.png" alt="" /></p>
<center id="1"> Figure <a href="#1">1</a>: representation of the rotor and the balancing. The balancing heads are located at the endpoints of the spindle. The four balancing masses (two for each balancing head) are drawn in red. </center>

<p>Consider a rotor-fixed reference frame $(O;(x,y,z))$. Figures <a href="#1">1</a> and <a href="#2">2</a> show a front view of the device and a scheme of the balancing heads. 
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/rotorfront.png" alt="" /></p>
<center id="2">Figure <a href="#2">2</a>: front view of the system made of rotor and balancing device. </center>
<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/angles.png" alt="" /></p>
<center id="3">Figure <a href="#3">3</a>: scheme of one balancing head. The balancing masses $(m_i,P_{i,1})$ and $(m_i,P_{i,2})$ are drawn in red. The bisector of the angle generated by $\overset{\longrightarrow}{OP_{i,1}}$ and $\overset{\longrightarrow}{OP_{i,2}}$ is the dashed line. The *intermediate* angle $\alpha_i$ is represented in <a href="#3">3</a>(A), while the *gap* angle $\gamma_i$ is depicted in <a href="#3">3</a>(B). The angles $\alpha_i$ and $\gamma_i$ give the position of the balancing masses in each balancing head. </center>

<p>We consider two planes</p>

<script type="math/tex; mode=display">\pi_1:= \left\{z=-a\right\} \quad \text{and} \quad \pi_2 :=  \left\{z=b\right\},\quad a,b,\geq 0</script>

<p>orthogonal to the rotation axis $z$. The balancing device (see figures <a href="#1">1</a> and <a href="#2">2</a>) is made of two heads lying in each of these planes.</p>

<p>The heads are fixed to the rotor and rotate with it. In particular, $\alpha_i$ and $\gamma_i$ are defined with respect to the rotor-fixed reference frame $(O;(x,y,z))$.</p>

<p>Each head is made of a pair of balancing masses, which are free to rotate orthogonally to the rotation axis $z$.</p>

<p>Namely, we have</p>
<ul>
  <li>two mass-points $(m_1,P_{1,1})$ and $(m_1,P_{1,2})$ lying on $\pi_1$ at distance $r_1$ from the axis $z$, i.e., in the reference frame $(O;(x,y,z))$</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
P_{1,1;x}=&r_1\cos(\alpha_1-\gamma_1)\\
P_{1,1;y}=&r_1\sin(\alpha_1-\gamma_1)\\
P_{1,1;z}=&-a,\\
\end{cases}
\hspace{0.3 cm}\text{and}\hspace{0.3 cm}
\begin{cases}
P_{1,2;x}=&r_1\cos(\alpha_1+\gamma_1)\\
P_{1,2;y}=&r_1\sin(\alpha_1+\gamma_1)\\
P_{1,2;z}=&-a;\\

\end{cases} %]]></script>

<ul>
  <li>two mass-points $(m_2,P_{2,1})$ and $(m_2,P_{2,2})$ lying on $\pi_2$ at distance $r_2$ from the axis $z$, namely, in the reference frame $(O;(x,y,z))$</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
		P_{2,1;x}=&r_2\cos(\alpha_2-\gamma_2)\\
		P_{2,1;y}=&r_2\sin(\alpha_2-\gamma_2)\\
		P_{2,1;z}=&b,\\
		\end{cases}
		\hspace{0.3 cm}\text{and}\hspace{0.3 cm}
		\begin{cases}
		P_{2,2;x}=&r_2\cos(\alpha_2+\gamma_2)\\
		P_{2,2;y}=&r_2\sin(\alpha_2+\gamma_2)\\
		P_{2,2;z}=&b.\\
		
		\end{cases} %]]></script>

<p>For any $i=1,2$, let $b_i$ be the bisector of the angle generated by $\overset{\longrightarrow}{OP_{i,1}}$ and $\overset{\longrightarrow}{OP_{i,2}}$ (see figure <a href="#3">3</a>). The <em>intermediate</em> angle $\alpha_i$ is the angle between the $x$-axis and the bisector $b_i$, while the <em>gap</em> angle $\gamma_i$ is the angle between $\overset{\longrightarrow}{OP_{i,1}}$ and the bisector $b_i$.</p>

<p>The imbalance is modelled by a resulting force $F$ and a momentum $N$ orthogonal to the rotation axis. In the rotor-fixed reference frame $(O;(x,y,z))$, set $P_1 :=  (0,0,-a)$, $P_2 :=  (0,0,b)$, $F :=  (F_x,F_y,0)$ and $N :=  (N_x,N_y,0)$. By imposing the equilibrium condition on forces and momenta, the force $F$ and the momentum $N$ can be decomposed into a force $F_1$ exerted at $P_1$ contained in plane $\pi_1$ and a force $F_2$ exerted at $P_2$ contained in $\pi_2$.</p>

<p>In each plane, we generate a force to balance the system, by moving the balancing masses:</p>
<ul>
  <li>in the plane $\pi_1$, we compensate $F_1$ by the centrifugal force:</li>
</ul>

<script type="math/tex; mode=display">B_1=m_1r_1\omega^2\left(\cos(\alpha_1-\gamma_1)+\cos(\alpha_1+\gamma_1),\sin(\alpha_1-\gamma_1)+\sin(\alpha_1+\gamma_1)\right);</script>

<ul>
  <li>in the plane $\pi_2$, we compensate $F_2$ by the centrifugal force:</li>
</ul>

<script type="math/tex; mode=display">B_2=m_2r_2\omega^2\left(\cos(\alpha_2-\gamma_2)+\cos(\alpha_2+\gamma_2),\sin(\alpha_2-\gamma_2)+\sin(\alpha_2+\gamma_2)\right);</script>

<p>The overall imbalance of the system is then given by the resulting forces in $\pi_1$ and $\pi_2$,</p>

<script type="math/tex; mode=display">F_{ris,1}=B_1+F_1</script>

<p>and</p>

<script type="math/tex; mode=display">F_{ris,2}=B_2+F_2,</script>

<p>respectively.</p>

<p>The overall imbalance on the system made of rotor and balancing device is measured by the imbalance indicator</p>

<script type="math/tex; mode=display">G=\|B_1+F_1\|^2+\|B_2+F_2\|^2.</script>

<p>Our task is to find a control strategy such that</p>
<ul>
  <li>the balancing masses move from their initial configuration $\Phi_0$ to a final configuration $\overline{\Phi}$, where the imbalance is compensated;</li>
  <li>the imbalance and velocities should be kept small during the correction process.</li>
</ul>

<p>We address the minimization problem</p>

<script type="math/tex; mode=display">\min_{\Phi\in\mathscr{A}} \frac{1}{2}\int_0^{\infty} \left[\|\Phi'\|^2+{\beta}Q(\Phi)\right] dt,\hspace{0.6 cm}(M)</script>

<p>where $Q(\Phi) :=  G(\Phi)-\inf G$ and</p>

<script type="math/tex; mode=display">\mathscr{A} :=  \left\{\Phi\in H^1_{loc}((0,+\infty);\mathbb{T}^4) \hspace{0.3 cm} \big| \hspace{0.3 cm} \Phi(0)=\Phi_0,\hspace{0.3 cm}and\hspace{0.3 cm}L(\Phi,\Phi')\in L^1(0,+\infty)\right\},</script>

<p>with <script type="math/tex">H^1_{loc}((0,+\infty);\mathbb{T}^4) :=  \cap_{T>0}H^1(0,T;\mathbb{T}^4)</script>.</p>

<p>The theoretical analysis of the above problem is in [6]. The existence of the optimum is proved. The stabilization of the optimal trajectories towards steady optima is proved in any condition.</p>

<h1 id="simulation">Simulation</h1>

<p>In order to perform some numerical simulations, we firstly discretize our cost functional and then we run AMPL-IPOpt to minimize the resulting discretized functional.</p>

<p>For the purpose of the numerical simulations, it is convenient to rewrite the cost functional as</p>

<script type="math/tex; mode=display">{K}\left(\psi,\Phi\right)  :=  \int_0^{\infty}\frac12 \|\Phi'\|^2+Q\left(\Phi\right)dt,</script>

<p>subject to the state equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
\Phi'=\psi\hspace{0.6 cm} &t\in (0,+\infty)\\
\Phi(0)=\Phi_0.\\
\end{cases} %]]></script>

<h2 id="discretization">Discretization</h2>
<p>Choose $T$ sufficiently large and $Nt \in \mathbb{N} \setminus {0,1}$. Set</p>

<script type="math/tex; mode=display">\Delta t :=  \frac{T}{Nt-1}.</script>

<p>The discretized state is <script type="math/tex">(\Phi_i)_{i=0, ... ,Nt-1}</script> , whereas the discretized control (velocity) is $(\psi_{i})_{i=0, … ,Nt-2}$. The discretized functional then reads as</p>

<script type="math/tex; mode=display">\begin{equation}\label{functional}
{K_d}\left(\psi,\Phi\right)  :=  \Delta t\sum_{i=0}^{Nt-1}\left[\frac12 \|\psi_i\|^2+Q\left(\Phi_i\right)\right],
\end{equation}</script>

<p>subject to the state equation</p>

<script type="math/tex; mode=display">\frac{\Phi_i-\Phi_{i-1}}{\Delta t}=\psi_{i-1},\hspace{0.3 cm}i=1, ... ,Nt-1,\hspace{0.6 cm}\text{(D)}</script>

<h2 id="execution">Execution</h2>

<p>The discretized minimization problem is</p>

<script type="math/tex; mode=display">\text{minimize}\hspace{0.3 cm}{K_d},\hspace{0.3 cm}\text{subject to (D)}.</script>

<p>We address the above minimization problem by employing the interior-point optimization routine IPOpt (see [3,4]) coupled with AMPL [1], which serves as modelling language and performs the automatic differentiation. The interested reader is referred to [8, Chapter 9] and [7] for a survey on existing numerical methods to solve an optimal control problem.</p>

<p>In figures <a href="#4">4</a>, <a href="#5">5</a>, <a href="#6">6</a> and <a href="#7">7</a>, we plot the computed optimal trajectory for \eqref{functional}, with initial datum $\Phi_0=\left(\alpha_{0,1},\gamma_{0,1};\alpha_{0,2},\gamma_{0,2}\right) :=  \left(2.6,0.6, 2.5,1.5\right)$. We choose $F$, $N$ and $m_i$. The exponential stabilization proved in [6] emerges. 
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/optstabilalpha1.png" alt="" /></p>
<center id="4">Figure <a href="#4">4</a>: intermediate angle $\alpha_1$ versus time. </center>
<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/optstabilgamma1.png" alt="" /></p>
<center id="5">Figure <a href="#5">5</a>: gap angle $\gamma_1$ versus time. </center>
<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/optstabilalpha2.png" alt="" /></p>
<center id="6"> Figure <a href="#6">6</a>: intermediate angle $\alpha_2$ versus time. </center>
<p>In figure <a href="#8">8</a>, we depict the imbalance indicator versus time along the computed trajectories. As expected, it decays to zero exponentially.
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/optstabilgamma2.png" alt="" /></p>
<center id="7">Figure <a href="#7">7</a>: gap angle $\gamma_2$ versus time. </center>
<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/systemresponse.png" alt="" /></p>
<center id="8"> Figure <a href="#8">8</a>: system response. </center>

<p></p>
<video controls="" width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP02/P0004/rotor.mp4"></video>
<center> Figure <a href="#9">9</a>: We represent the evolution in time of the rotor vibrations.
In the uncontrolled case, the balancing device does not act. In the controlled case, our balancing strategy suppress the vibrations. </center>

<h1 id="references">References:</h1>
<p>[1] Robert Fourer, David M Gay, and Brian W Kernighan. A modeling language for mathematical programming. Management Science, 36(5):519{554, 1990.</p>

<p>[2] Mike Jeffrey, Michael Melsheimer, and Jan Liersch. Method and system for determining an imbalance of a wind turbine rotor, September 11 2012. US Patent 8,261,599.</p>

<p>[3] Andreas Waechter, Carl Laird, F Margot, and Y Kawajir. Introduction to ipopt: A tutorial for downloading, installing, and using ipopt. Revision, 2009.</p>

<p>[4] Andreas Waechter and Lorenz T Biegler. On the implementation of an interior-point lterline-search algorithm for large-scale nonlinear programming. Mathematical programming, 106(1):25{57, 2006.</p>

<p>[6] Matteo Gnuffi, Dario Pighin and Noboru Sakamoto. Rotors imbalance suppression by optimal control. Preprint.</p>

<p>[7] Noboru Sakamoto and Arjan J van der Schaft. Analytical approximation methods for the stabilizing solution of the Hamilton-Jacobi equation. IEEE Transactions on Automatic Control, 53(10):2335{2350, 2008.</p>

<p>[8] Emmanuel Trélat. Contrôle optimal : théorie et applications
Mathématiques Concrètes. Vuibert, Paris, 2005. available
online:
https://www.ljll.math.upmc.fr/trelat/chiers/livreopt2.pdf.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In [1], we discuss several aspects of wave propagation in a computational framework. In particular, we consider the following one-dimensional wave equation&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{main_eq_1d}
\begin{cases}
\partial_t^2u - \partial_x^2u = 0, & (x,t)\in (-1,1)\times (0,T)
\\
u(-1,t)=0=u(1,t), & t\in(0,T)
\\
u(x,0) = u^0(x), \quad \partial_t u(x,0) = u^1(x), & x\in(-1,1),
\end{cases}
\end{equation} %]]></script>

<p>and we discuss the propagation properties of its finite-difference solutions on uniform and non-uniform grids, by establishing comparisons with the usual behavior of the continuos waves.</p>

<p>Our approach is based on the study of the propagation of high-frequency Gaussian beam solutions (that is, solutions originated from highly concentrated and oscillating initial data), both in continuous and
discrete media.</p>

<p>Roughly speaking, the idea at the basis of this techniques is that the energy of Gaussian beam solutions propagates along bi-characteristic rays, which are obtained from the Hamiltonian system associated to the
symbol of the operator under consideration.</p>

<p>At the continuous level of equation \eqref{main_eq_1d}, these mentioned rays are straight lines and travel with a uniform velocity.</p>

<p>On the other hand, the finite difference space semi-discretization of \eqref{main_eq_1d} may introduce different dynamics, with a series of unexpected propagation properties at high frequencies. For instance, one can generate spurious solutions traveling at arbitrarily small velocities which, therefore, show lack of propagation in space.</p>

<p>In addition, the introduction of a non-uniform mesh for the discretization may generate further pathologies such as <em>internal
reflections</em>, meaning that the waves change direction without hitting the boundary.</p>

<p>In order to illustrate these mentioned pathological phenomena, we perform simulations on a uniform space-mesh of $N$ points and mesh-size $h=2/(N+1)$</p>

<script type="math/tex; mode=display">\mathcal G_h :=\Big\{x_j:= − 1 + jh, \; \; j = 0,\ldots,N + 1\Big\}</script>

<p>and on two non-uniform ones produced by applying to $\mathcal G_h$ the transformations</p>

<script type="math/tex; mode=display">g_1(x):=\tan\left(\frac \pi4 x\right) \quad \text{or} \quad g_2(x):=2\sin\left(\frac \pi6 x\right).</script>

<p>Moreover, the initial data are constructed starting from the following Gaussian profile</p>

<script type="math/tex; mode=display">G_\gamma(x):= e^{-\frac \gamma2(x-x_0)^2}e^{i\frac{\xi_0x}{h}}, \quad x_0\in(-1,1),\;\xi_0\in(0,2\pi),\;\gamma>0.</script>

<h2 id="low-frequency-simulations">Low frequency simulations</h2>

<p>We present in <strong>Figure 1</strong> our simulations for low-frequency solutions of \eqref{main_eq_1d}. In particular, we considered initial position and frequency $(x_0,\xi_0)=(0,\pi/4)$ and a time horizon $T=5s$.</p>

<p>In this case, the numerical solutions behave basically like the continuous ones: they start traveling to the left along the straight characteristic line $x+t$ and, after having hit the boundary, they reflect following the Descartes-Snell’s law and continue propagating, this time to the right along the other branch of the characteristic ($x−t$).</p>

<h2><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig1.png" alt="" /></h2>
<p><strong>Figure 1</strong>. Numerical solutions of \eqref{main_eq_1d} with $(x_0,\xi_0)=(0,\pi/4)$ on uniform and non-uniform meshes.</p>

<h2 id="high-frequency-simulations">High frequency simulations</h2>

<p>When increasing the frequency, the situation changes and we encounter several interesting phenomena and pathologies:</p>

<p>• The so-called <em>umklapp</em> or <em>U-process</em>, also known as <em>internal reflection</em>, consisting in the reflection of waves without touching only one or both the endpoints of the space interval. This phenomenon is typical for the semi-discretization of high-frequecncy solutions of \eqref{main_eq_1d} on non-uniform meshes, which may produce waves oscillating in the interior of the computational domain and reflecting without touching the boundary (see <strong>Figure 2</strong> - middle) or touching the boundary only at one of the endpoints (see <strong>Figure 2</strong> - right).</p>

<h2 id="-1"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig2.png" alt="" /></h2>
<p><strong>Figure 2</strong>. Numerical solutions of \eqref{main_eq_1d} with $(x_0,\xi_0)=(1/2,\pi)$ on uniform and non-uniform meshes.</p>

<p>• Non-propagating waves, corresponding to equilibrium (fixed) points on the phase diagram (see <strong>Figure 3</strong>).</p>

<h2 id="-2"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig2.png" alt="" /></h2>
<p><strong>Figure 3</strong>. Numerical solutions of \eqref{main_eq_1d} with $(x_0,\xi_0)=(0,\pi)$ on uniform and non-uniform meshes.</p>

<p>These phenomena are related with the particular nature of the discrete group velocity which, in the finite difference setting, is given by</p>

<script type="math/tex; mode=display">\omega(\xi) = \cos\left(\frac \xi2\right)</script>

<p>and vanishes for $\xi = (2k+1)\pi$, $k\in\mathbb{Z}$. Moreover, they can be understood by looking at the phase portrait of the hamiltonian system associated to the finite difference semi-discretization of \eqref{main_eq_1d} (see <strong>Figure 4</strong>).</p>

<h2 id="-3"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/phase_portrait.png" alt="" /></h2>
<p><strong>Figure 4</strong>. Phase portrait of the Hamiltonian system for the numerical wave equation corresponding to the and the grid transformation $g_1$ (left) and $g_2$ (right).</p>

<p>In particular, the solutions displayed in <strong>Figure 2</strong> correspond to
trajectories which remain always in the red area of these phase portraits, while <strong>Figure 3</strong> shows solutions starting from the equilibrium point $(0,\pi)$ (the green one in <strong>Figure 4</strong>)</p>

<p>Notice that, for the grid transformation $g_1$, this equilibrium point is a center (stable) while it is a saddle (unstable) for the grid transformation $g_2$. For this reason, in the first case the non-propagating wave remains concentrated along the vertical ray, while in the second case the wave presents more very dispersive features.</p>

<h2 id="two-dimensional-simulations">Two-dimensional simulations</h2>

<p>Analogous phenomena can be detected also in the case of the finite-difference semi-discretization of the two-dimensional wave equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{main_eq_2d}
\begin{cases}
\partial_t^2u - \Delta u = 0, & (x,y,t)\in (-1,1)^2\times (0,T)
\\
u(-1,y,t)=0=u(1,y,t), & (y,t)\in(-1,1)\times(0,T)
\\
u(x,-1,t)=0=u(x,1,t), & (x,t)\in(-1,1)\times(0,T)
\\
u(x,y,0) = u^0(x,y), \quad \partial_t u(x,y,0) = u^1(x,y), & (x,y)\in(-1,1)^2.
\end{cases}
\end{equation} %]]></script>

<p>Also in this case, we perform simulations on  a uniform mesh of $N$ points both in the $x$ and $y$ direction and mesh-sizes $h_x=2/(N+1)=h_y$</p>

<script type="math/tex; mode=display">\mathcal G_h :=\Big\{(x_j,y_k):= (- 1 + jh_x,-1+kh_y) \; \; j,k = 0,\ldots,N + 1\Big\}</script>

<p>and on two non-uniform ones produced by applying to $\mathcal G_h$ the transformations $g_1$ and $g_2$ above introduced.</p>

<p>Moreover, the initial data are constructed once again starting from a Gaussian profile:</p>

<script type="math/tex; mode=display">G_\gamma(x,y):= e^{-\frac \gamma2\big[(x-x_0)^2+(y-y_0)^2\big]}e^{i\big(\frac{\xi_0x}{h_x}+\frac{\eta_0y}{h_y}\big)}, \quad (x_0,y_0)\in(-1,1)^2,\;(\xi_0,\eta_0)\in(0,2\pi)^2,\;\gamma>0.</script>

<p>Then, it can be observed in <strong>Video 1</strong> that, as for the one-dimensional case, at low frequencies the solution remains concentrated and propagates along straight characteristics which reach the boundary, where there is reflection according to the Descartes-Snell’s law. This independently on whether we use a uniform or a non-uniform mesh.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig1_1.mp4" alt="" /></p>

<video controls="" width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig1_1.mp4">
</video>

<hr />

<p><strong>Video 1</strong>. Numerical solutions of \eqref{main_eq_2d} with $(x_0,y_0,\xi_0,\eta_0)=(0,0,\pi/4,\pi/4)$ on uniform and non-uniform meshes.</p>

<p>Nevertheless, increasing the frequencies similar phenomena as in the one-dimensional case show up. For instance, on the non-uniform mesh corresponding to the transformation $g_1$, we observe the so-called
<em>rodeo effect</em>, according to which, waves that should propagate along straight lines are trapped along closed circles (<strong>Video 2</strong> - middle).</p>

<video controls="" width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig2_2.mp4">
</video>
<hr />

<p><strong>Video 2</strong>. Numerical solutions of \eqref{main_eq_2d} with $(x_0,y_0,\xi_0,\eta_0)=(0,\tan(\arccos(\sqrt[4]{1/2},\pi/2,\pi)$ on uniform and non-uniform meshes.</p>

<p>Finally, waves starting from the point $(x_0,y_0,\xi_0,\eta_0)=(0,0,\pi,\pi)$, which is an equilibrium for the phase Hamiltonian system, cannot move, and remain trapped around the point $(0,0)$ in the physical plane for any time (see <strong>Video 3</strong>).</p>

<video controls="" width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig3_3.mp4">
</video>
<hr />

<p><strong>Video 3</strong>. Numerical solutions of \eqref{main_eq_2d} with $(x_0,y_0,\xi_0,\eta_0)=(0,0,\pi,\pi)$ on uniform and non-uniform meshes.</p>

<h2 id="conclusions">Conclusions</h2>

<p>Summarizing, our analysis shows that the finite-difference semi-discretization of one and two-dimensional waves may modify the dynamics of the continuous model. In particular, as a result of the accumulation of the local effects introduced by the heterogeneity of the employed grid, numerical high-frequency solutions can bend in a singular and unexpected manner. Moreover, this phenomenon has to be added to the well known numerical dispersion effect, producing the high-frequency discrete group velocity to vanish, even in uniform grids.
Our results constitute a warning both for adaptivity and for the treating of control and inverse problems. In broad terms, the goal of adaptivity is to refine a mesh on the support of the solution, keeping it coarse where the solution has little oscillations and energy. Our analysis shows that, in this context, adaptivity has to be performed with some attention. Indeed, if one is not careful enough when refining the mesh, they can be produced spurious effects due to the fact that waves feel the fictitious numerical boundaries that are generated when the grid passes from fine to coarse. Finally, our results are also a signal that the dangers of uniform meshes in the study of numerical control and inverse problems (already observed in [2]) may be enhanced when the mesh is non-uniform. In more details, the heterogeneity of the grid may introduce added trapping effects, which need to be avoided in
order to prove convergence in the context of controllability, stabilization or inversion algorithms.</p>

<h2 id="references">References</h2>

<p>[1] U. Biccari, A. Marica and E. Zuazua, <em>Propagation of one and two-dimensional discrete waves under finite difference approximation</em>. Submitted</p>

<p>[2] E. Zuazua, <em>Propagation, observation, control and numerical approximation of waves</em>. SIAM Rev. 47, 2 (2005), 197-243.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h2 id="model-problem"&gt;Model Problem&lt;/h2&gt;
</code></pre></div></div>

<p>We consider the numerical approximation of the inverse problem for the linear advection-diffusion equation,</p>

<script type="math/tex; mode=display">\begin{equation}\label{modeleq} \begin{cases} \partial_t u - d \Delta u + v \nabla \cdot u = 0, \  \  \textbf{x}  \in \Omega, t \in [0,T],\\ u(\textbf{x},t) = 0,  \  \  \textbf{x}  \in \partial \Omega, t \in [0,T],\\ u(\textbf{x},0) = u_0(\textbf{x}), \  \  \textbf{x}  \in \Omega,\\ \end{cases} \end{equation}</script>

<p>with $d$ being the diffusivity of the material and $v$ the direction of the advection.</p>

<p>Given a final time $T&gt;0$ and a target function $u^\ast$ the aim is to identify the initial condition $u_0$ such that the solution, at time $t=T$, reaches the target $u^*$ or gets as close as possible to it. We assume that the initial condition $u_0$ is characterized as a combined set of sparse sources. This means that $u_0$ is a linear combination of unitary deltas with certain and possibly different weights, i.e:</p>

<script type="math/tex; mode=display">\begin{align} u_0 = \sum_{i=1}^{l} \alpha_i \delta(x_i). \end{align}</script>

<p>We formulate the inverse problem using optimal control techniques. In particular, we consider the minimization of the following functional:</p>

<script type="math/tex; mode=display">\begin{align} J(u_0) := J(u(\cdot,0)) = \frac{1}{2} \int_{\Omega} (u(\cdot, T) - u^*)^2 d \Omega + \tau \int_{\Omega} \vert u(\cdot,0) \vert d \Omega. \end{align}</script>

<h2 id="space-and-time-discretization">Space and time discretization</h2>

<p>Letting $\textbf{u} : [0, T] \rightarrow \mathbb{R}^s$ where $s$ is the number of grid points on $\Omega$, we can write a general finite element (FE) discretization of the diffusion–advection equation in \eqref{modeleq} in a compact form as:</p>

<script type="math/tex; mode=display">\begin{align} \textbf{M} \dot{\textbf{u}}(t) + d \textbf{A} \textbf{u}(t) + v \textbf{V} \textbf{u}(t) = 0. \end{align}</script>

<p>In order to get a time discretized version of the previous equation, we apply implicit Euler method with stepsize $\Delta t := T/N$ where $N$ is the total number of time steps. The numerical approximations to the solution are given by the vectors $\textbf{u}^n \approx \textbf{u}(t_n) \in \mathbb{R}^s$ with respect to the index $n=i\Delta t$ for $i=1,2,..,N$. Therefore, the fully discrete version of model equation is as follows,</p>

<script type="math/tex; mode=display">\begin{align} (\textbf{M} + d \Delta t \textbf{A} + v \Delta t \textbf{V}) \textbf{u}^{n+1} = \textbf{M} \textbf{u}^n. \end{align}</script>

<h2 id="adjoint-algorithm-for-sparse-source-identification">Adjoint Algorithm for sparse source identification</h2>

<p>The algorithm to be presented in this work for the sparse source identification of the linear diffusion-advection equation based on the adjoint methodology consists of two steps. Firstly, we use the adjoint methodology to identify the locations of the sources. Secondly, a least squares fitting is applied to find the corresponding intensities of the sources.</p>

<p>We have considered here a two-dimensional example with several sources to be identified in a multi-model environment. This means that the left half ($\Omega_1 = [0,1] \times [0,1]$) and the right half ($\Omega_2 = [1,2] \times [0,1]$) of the domain are modelled with different equations. In particular, the heat equation is used on $\Omega_1$ and the diffusion–advection equation is used on $\Omega_2$.</p>

<p>The initialization parameters look as follows:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span> <span class="c1">%% space discretization points in y-direction</span>
<span class="n">dx</span><span class="o">=</span><span class="mi">1</span><span class="p">/(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% mesh size</span>
<span class="n">t0</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">%% initial time</span>
<span class="n">tf</span><span class="o">=</span><span class="mf">0.1</span><span class="p">;</span> <span class="c1">%% final time</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="c1">%% time discretization points</span>
<span class="n">dt</span><span class="o">=</span><span class="p">(</span><span class="n">tf</span><span class="o">-</span><span class="n">t0</span><span class="p">)/</span><span class="n">n</span><span class="p">;</span> <span class="c1">%% stepsize</span>
<span class="n">TOL</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">;</span> <span class="c1">%% stopping tolerance</span>

<span class="n">d1</span><span class="o">=</span><span class="mf">0.05</span><span class="p">;</span> <span class="c1">%% diffusivity of the material on the left sudomain</span>
<span class="n">d2</span><span class="o">=</span><span class="mf">0.05</span><span class="p">;</span> <span class="c1">%% diffusivity of the material on the left sudomain</span>

<span class="c1">%% advection components</span>
<span class="n">vx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">vy</span><span class="o">=-</span><span class="mi">3</span><span class="p">;</span>

<span class="n">tau</span><span class="o">=</span><span class="n">dx</span><span class="o">^</span><span class="mi">4</span><span class="p">;</span> <span class="c1">%% regularization parameter</span>
<span class="n">epsilon</span><span class="o">=</span><span class="mf">0.1</span><span class="p">;</span> <span class="c1">%% stepsize of the gradient descent method</span>
</code></pre></div></div>

<p>We now compute the FE discretization matrices $M$, $A$ and $V$ that are respectively the mass matrix, the stiffness matrix and the advection matrix. For the FE discretization we assume equidistant structured meshes. In particular we use triangular elements and the classical pyramidal test functions are employed.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">M</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">V</span><span class="p">]</span> <span class="o">=</span> <span class="n">computeFEmatrices</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">,</span><span class="n">vx</span><span class="p">,</span><span class="n">vy</span><span class="p">);</span> <span class="c1">%% Compute FE discretization matrices</span>
</code></pre></div></div>

<p>A reference initial condition is chosen and we compute using the FE discretization specified above and implicit Euler in time its corresponding final state at time $T$. This final state will be considered the initial data of the inverse problem to be solved and we name it the target function $u^*$ as mentioned previously.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">U0_ref</span> <span class="o">=</span> <span class="n">initial_deltas</span><span class="p">(</span><span class="n">N</span><span class="p">);</span> <span class="c1">%% computes reference initial condition</span>

<span class="p">[</span><span class="n">U_target</span><span class="p">,</span><span class="n">u_target</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_target</span><span class="p">(</span><span class="n">U0_ref</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">V</span><span class="p">);</span> <span class="c1">%% Compute target distribution</span>
</code></pre></div></div>

<p>We now call the algorithm that estimates the initial condition $u_0$ using as a initial data the target function $u^*$. As mentioned before, this algorithm consists of two steps.</p>

<p>Firstly, the classical adjoint methodology that minimizes the functional $J(u_0)$ subject to the diffusion-advection equation is used. The iterative optimization algorithm employed is the classical gradient descent method. However, although this iterative procedure finds quite accurately the locations of the sources, it does not recover the sparse character of the initial condition. This is not suprising because the recovered initial data comes from solving the adjoint problem which is basically a diffusive process that smoothes out its state. Consequently, a second procedure is needed to project the obtained non sparse initial condition into the set of admissible sparse solutions.</p>

<p>As the initial condition $u_0$ is assumed to be a linear combination between the locations and the intensities, once we have fixed the locations using the adjoint methodology we can solve a least squares problem to get the remaining intensities. We assemble a matrix $\textbf{L} \in \mathbb{R}^{s \times l}$ where at each column we have the forward solution for a single unitary delta placed at each of the locations already identified. We then solve the following linear system of equations for the vector of unknowns $\alpha = (\alpha_1, \alpha_2, …, \alpha_l)^T$:</p>

<script type="math/tex; mode=display">\begin{align} \textbf{L}^T \textbf{L} \alpha = \textbf{L}^T u^*, \end{align}</script>

<p>to find the intensities vector $\alpha$.</p>

<p>Adjoint algorithm for sparse source identification (algorithm 4)</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">U0</span> <span class="o">=</span> <span class="n">SparseIdentification</span><span class="p">(</span><span class="n">u_target</span><span class="p">,</span><span class="n">TOL</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">epsilon</span><span class="p">,</span><span class="n">tau</span><span class="p">);</span>
</code></pre></div></div>

<p>Finally, the final state at $T$ is computed using as a initial condition the estimated sparse sources identified with our algorithm.</p>

<p>Compute final state with the recovered initial condition</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">UF</span><span class="p">,</span><span class="n">u_final</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_target</span><span class="p">(</span><span class="n">U0</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">V</span><span class="p">);</span>
</code></pre></div></div>

<p>We can see the evolution recovered</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0005/evolution.gif" alt="" /></p>

<p>We now visualize the numerical results. Plots on the left side show the reference initial solution and the given target. Similarly, plots on the right side show the recovered initial condition and the distribution at the final time $T$ produced by the recovered initial sources.</p>

<p>One can observe the difference between the two models (the heat equation on $\Omega_1$ and the diffusion-advection on $\Omega_2$) in the two figures at the bottom where the initial sources on $\Omega_2$ move downwards at the same time as they dissipate while the initial sources on $\Omega_1$ only dissipate without displacement.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xplot</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span> <span class="c1">%% space grid w.r.t component x</span>
<span class="n">yplot</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span> <span class="c1">%% space grid w.r.t component y</span>
<span class="c1">%%</span>
<span class="nb">figure</span><span class="p">(</span><span class="s1">'unit'</span><span class="p">,</span><span class="s1">'norm'</span><span class="p">,</span><span class="s1">'pos'</span><span class="p">,[</span><span class="mf">0.25</span> <span class="mf">0.1</span> <span class="mf">0.5</span> <span class="mf">0.8</span><span class="p">])</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">U0_ref</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="nb">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Reference initial state (front view)'</span><span class="p">)</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">U0</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="nb">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Recovered initial state (front view)'</span><span class="p">)</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">pcolor</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">U0_ref</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="nb">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Reference initial state (above view)'</span><span class="p">)</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">pcolor</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">U0</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="nb">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Recovered initial state (above view)'</span><span class="p">)</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">pcolor</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">U_target</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="nb">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Given target u^*'</span><span class="p">)</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="nb">pcolor</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">UF</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="nb">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Recovered final state'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0005/copiaRM_01.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;  Infinite dimensional dynamical systems coupling age structuring with diffusion appear naturally in  population dynamics, medicine or epidemiology. A by now classical example is the Lotka-Mckendrick system with spatial diffusion. The  aim of this blog is to study contaollability properties of such age structured models in an unified manner. 
</code></pre></div></div>
<p>&lt;/p&gt;</p>

<p>
Let $A : \mathcal{D}(A) \to X$  be the generator of a $C^0$ semigroup $\mathbb{S}$ on the Hilbert space $X$ and let $U$ be
another Hilbert space. Both $X$ and $U$ will be identified with their duals. Let $B$ be a (possibly unbounded) linear operator
from $U$ to $X$, which is supposed to be an admissible control operator for  $\mathbb{S}$.
In the examples we have in mind, the above spaces and operators describe the dynamics of a system without age structure.
In particular, $X$ is the state space and $U$ is the control space.
The corresponding age structured system is obtained by first extending these spaces to
\begin{equation} \label{input-space}
\mathcal{X} = L^{2}(0,a_{\dagger}; X), \quad \mathcal{U} = L^{2}(0,a_\dagger;U).
\end{equation} 
where $a_\dagger&gt;0$ denotes the maximal age individuals can attain. Let $p(t) \in \chi$ be the distribution density of the
individuals with respect to age $a\geqslant 0$ and at some time $t \geqslant 0.$  Then the abstract version of the Lotka-McKendrick
system to be considered in this paper writes:
 \begin{equation} \label{eq:main}
\begin{cases}
\displaystyle \frac{\partial p}{\partial t} + \frac{\partial p}{\partial a} - A p  + \mu(a) p =  \mathcal{\chi}_{(a_{1},a_{2})} B u, &amp; t \geqslant 0, a \in (0,a_\dagger), \\
\displaystyle p(t,0)  = \displaystyle \int_{0}^{a_\dagger} \beta(s) p(t,s) \; {\rm d}s, &amp; t \geqslant 0, \\
\displaystyle p(0,a) = p_{0},
\end{cases}
\end{equation} 
where $\mathcal{\chi}$ is the characteristic function of the interval $(a_{1}, a_{2})$ with
$0 \leqslant a_{1} &lt; a_{2} \leqslant a_\dagger$ and $p_{0}$ is the initial population density.
In the above system, the positive function $\mu:[0,a_\dagger] \to \mathbb{R}_{+}$ denotes the
natural mortality rate of individuals of age $a.$ We denote by $\beta: [0,a_\dagger] \to \mathbb{R}_{+}$
the positive function describing the fertility rate at age $a.$ We assume that the fertility rate $\beta$ a
nd the mortality rate $\mu$ satisfy the conditions
<ul style="list-style: none;">
<li>(H1) $\beta \in L^\infty[0, a_\dagger], \; \beta \geqslant 0$ for almost every $a \in [0,a_\dagger].$</li>
<li>(H2) $\mu \in L^1_{loc}[0, a_\dagger], \; \mu \geqslant 0$ for almost every $a \in [0,a_\dagger].$</li>
<li>(H3) $\displaystyle \int_0^{a_\dagger} \mu(a) \ {\rm d} a = \infty.$</li>
</ul>

Before we state our result, let us introduce the notion of null controllability of the pair $(A,B).$
<div class="definition">
We say that a pair $(A,B)$ is null-controllable in time $\tau,$ if for every $z_{0} \in X$ there exists a control $u \in L^{2}(0,\tau,U)$ such that, the solution of the system
\begin{equation*}
\dot z(t) = A z(t) + Bu(t) \quad t \in [0,\tau], \qquad z(0) = z_{0},
\end{equation*}
satisfies $z(\tau) = 0.$
</div>

We prove the following result
<div class="theorem">
Assume that  $\beta$ and $\mu$ satisfy the conditions (H1)-(H3) above. Moreover,
suppose that the fertility rate $\beta$ is such that
\begin{equation} \label{eq:beta}
\beta(a)= 0 \mbox{ for all } a \in (0,a_{b}),
\end{equation}
for some $a_b\in (0,a_\dagger)$ and that $a_1 &lt; a_b$.
Let us assume that the pair $(A,B)$ is null controllable in arbitrary time. 
Then for every $\tau &gt; a_{1} + a_{\dagger}-a_{2}$ and for every $p_{0} \in \chi$ there exists  a control $v \in L^{2}(0,\tau;\mathcal{U})$ such that the solution $p$ of \eqref{eq:main} satisfies
\begin{equation}
p(\tau,a) = 0 \mbox{ for all }  a \in (0,a_\dagger).
\end{equation} 
 </div>

It is well known that null controllability is equivalent to final state observability of the adjoint system
(see for instance [4, Section 11.2]). The adjoint of the above system reads as
\begin{equation} \label{eq:adj}
\begin{cases}
\displaystyle \frac{\partial q}{\partial t} - \frac{\partial p}{\partial a} - A^* p  + \mu(a) p - \beta(a) q(t,0) =  0, &amp; t \geqslant 0, a \in (0,a_\dagger), \\
\displaystyle q(t,a_\dagger)  = 0, &amp; t \geqslant 0, \\
\displaystyle q(0,a) = q_{0},
\end{cases}
\end{equation} 
where $A^*$ is the adjoint of  $A.$  In order to prove Theorem 1, it is enough to prove the following
<div class="theorem">
 Let us assume the hypothesis of Theorem 1. Then for every $\tau &gt; a_1 + a_\dagger - a_2$ there exists $k_\tau &gt; 0$ such that
 the solution $q$ of \eqref{eq:adj} satishfies
 \begin{equation} \label{eq:est-adj}
 \int_0^{a_\dagger} \|q(\tau, a)\|^2_X \ da  \leqslant k_\tau^2 \int_0^\tau \int_{a_1}^{a_2} \left\|B^*q(t,a) \right\|^2_U \ da dt, \qquad \qquad (q_0 \in \mathcal{X}).
 \end{equation}
 </div>
Let us give an idea of the proof. We combine characteristics method with final state observability of the pair $(A^*, B^*).$ For siplicity
in the presentation, let us assume that $\mu = 0,$ $a_1 = 0,$ $a_2 &lt; a_b$ and $\tau = 2a_\dagger.$
The detail proof of Theorem 1, in a slightly more general case, can be found in [3]. Integrating along the characteristic lines,
it is not very difficult to see that
\begin{equation*}
q(t,a) = \int_{t + a - a_\dagger}^{t} e^{(t-s)A^*} \beta(a+ \tau - s) q(s, 0) \ ds, \qquad t &gt; a_\dagger. 
\end{equation*}
Therefore,
\begin{equation} \label{est0}
\int_0^{a_\dagger} \|q(\tau, a)\|^2_X \ da \leqslant C \int_{a_\dagger}^\tau \left\|q(t,0) \right\|^2_X \ dt. 
\end{equation}
Thus to prove \eqref{eq:est-adj}, we need to estimate the right hand side of the above estimate. We now make use of the condition
\eqref{eq:beta}.  Note that, due to this condition, $q$ satisfies
\begin{equation} \label{eq:adj-2}
\displaystyle \frac{\partial q}{\partial t} - \frac{\partial q}{\partial a} - A^* p  + \mu(a) p =  0,  \quad  t \geqslant 0, a \in (0,a_2).
\end{equation}
For a.e. $t \in (a_\dagger, \tau),$ we define $w(s) = q(s, t- s),$ $s \in (t - a_2, t).$ Then $w$ solves
\begin{equation*}
\displaystyle \frac{\partial w}{\partial s} - A^* w = 0, \quad s \in (t - a_2, t). 
\end{equation*}
Since the pair $(A, B)$ is null controllable in any time, or equivalently the pair $(A^*, B^*)$ is final-state observable in any
time, there exists a constant
$C &gt; 0,$ depending only on $a_2, A$ and $B$  such that
\begin{equation*}
\left\| w(t) \right\|_{X}^2 \leqslant C \int_{t-a_2}^t \left\| B^* w(s) \right\|^2_U \ ds. 
\end{equation*}
Coming back to $q$ and integrating over $[a_\dagger, \tau]$ with respect to $t,$ we have that
\begin{equation}
\int_{a_\dagger}^\tau \|q(t,0)\|^2_X \ dt \leqslant \int_{0}^\tau \int_{0}^{a_2} \left\|B^* q(t,a)\right\|^2  \ da dt. 
\end{equation}
Combining the above estimate together with \eqref{est0}, we get \eqref{eq:est-adj}. In the two figures below, we ilustrate the
estimate of $q(t,0)$ and the final-state observability of $q$ in the general case.
</p>

<table>
  <tr>
   <th>
     <figure>
  <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/trace-bis.jpg" alt="trace" style="width:95%" />
  <figcaption> Fig.1 - An ilustration of the estimate of $q(t,0).$ We apply final state observability of $(A^*, B^*)$ along
  the characteristics. Since we want to estimate $q(t,0),$ we consider the trajectory $\gamma(s) = (t-s,s),$
  $s \leqslant t \leqslant \tau$ (or equivalently the backward characteristics starting from $(t,0).$) </figcaption>
</figure>
    </th>
<th>
    <figure>
  <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/finalTh2.jpg" alt="final" style="width:85%" />
  <figcaption> Fig.2 - An illustration of the final-state observability at time $\tau &gt; a_1 + a_\dagger - a_2$: For
  $ a \in (0,a_2 - \varepsilon)$ (blue region) the backward characteristics starting from $t = \tau$ enters the
  observation domain.  For $a \in (a_2 - \varepsilon, a_\dagger)$, the backward characteristics (green region)
  hits the line $a = a_\dagger$, gets renewed by the renewal condition $\beta(a)q(t,0)$ and then enters the observation
  domain (purple region).</figcaption>
</figure> 
 </th>
 </tr>
 </table>

<h2 id="Examples">Examples</h2>
<p>We consider two examples :  1) The classical Lotka-McKendrick system and 2) Lotka-Mckendrick system with diffusion.</p>
<p>
 1) <em> The classical Lotka-McKendrick system </em>: Let us choose $X = \mathbb{R},$ $A=0$ and $B=1.$ Then the system \eqref{eq:main} reduces
 to  classical Lotka-McKendrick system. By Theorem 1, this system is null controllable in time $\tau &gt; a_1 + a_\dagger - a_2.$ A
 similar result was obtained in [1]. 
</p>

<p>
 2) <em> The Lotka-McKendrick system with spatial diffusion </em> : Let $\Omega$ be a smooth bounded domain in $\mathbb{R}^3$ and
 $\omega \subseteq \Omega.$ Let us consider 
 \begin{equation*}
 X = L^2(\Omega), \quad A = \Delta , \quad \mathcal{D}(A) =
 \left\{ f \in H^2(\Omega) \mid \displaystyle \frac{\partial f}{\partial n} = 0\right\}, \quad B = \chi_{\omega}.
 \end{equation*}
 This corresponds to the Lotka-McKendrick model with spatial diffusion ([2]). It is known that, the pair $(A, B)$ or equivalently
 the heat equation with localized interior control, is null controllable in any time. Thus we can apply Theorem 1 to conclude that
 the system is null controllable in time $\tau &gt; a_1 + a_\dagger - a_2.$
 </p>
<p> Several other applications can be found in [3].</p>

<h2 id="NS">Numerical Simulations</h2>
<p> We now present some numerical siimulations of the controlled trajectory.  We shall consider the case  $A = 0$
and $B = 1,$ i.e the classical Lotka-McKendrick system. We also consider the case $a_1 = 0$ and $a_2 = a_{\dagger} =4,$ i.e., the control
acts everywhere with respect to age variable. We present numerical simulations in the following two scenarios : 1) null controllabilty,
2) controllability to a steady state.
<h4 id="NS">Null Controllability</h4>
By Theorem 1 we know that system (1) is null controllable in any time. In the following
video, we see the evolution of unctrolled trajectory and controlled trajectories to zero  with controllability time $t=2$ and $t =5.$ </p>
<video style="display:block; margin: 0 auto;;width:80%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/Video-Null.mp4" type="video/mp4" />
  </video>

<p>
 We now plot the control functions. In the following two videoes, we see the evolution of the control
 functions at controllability time $t = 2$ and $t =5$
 respectively.
</p>

<table>
  <tr>
   <th>
    <video style="display:block; margin: 0 auto;width:100%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/control-1.mp4" type="video/mp4" />
  </video>
    </th>
   &nbsp; &nbsp; 
<th>
   <video style="display:block; margin: 0 auto;width:100%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/control-2.mp4" type="video/mp4" />
  </video>
 </th>
 </tr>
 </table>
<h4 id="NS">Controllability to a steady state</h4>
<p> If we choose $\beta$ and $\mu$ such that $R = \int_0^{a_\dagger} \beta(a) e^{-\int_0^r \mu(r) \ dr } da = 1,$ then
$p_s(a) = \alpha e^{-\int_0^r \mu(r) \ dr }$ with $\alpha \in (0,\infty)$ is a steady state to the system (1) with zero steady control.
Thus we can control to these trajectories also. In the following example, we have chosen $a_{\dagger} = 4,$ $a_b = 1,$ $\alpha = 1.25$ and
\begin{equation*}
\beta(a) = \begin{cases}
0 &amp; \mbox{ if } a \in [0,1), \\
\frac{1}{3}e^{.05 a^2} &amp;  \mbox{ if } a \in [1,4],
\end{cases}
\qquad
\mu(a) = .1 a.
\end{equation*}
In this case we can verify that $R=1$ and $p_s(a) = 1.25 e^{-.05 a^2}.$ As before we take control everywhere, thus the system is
controllable to the trajectory $p_s(a)$ in any time.  In the following video,
we see the evolution of unctrolled trajectory and controlled trajectories to the steady state $p_s(a)$ with
controllability time $t=2$ and $t =5.$
</p>
<video style="display:block; margin: 0 auto;width:80%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/Video-SS.mp4" type="video/mp4" />
  </video>
<p> As before, in the following two videos we see the evolution of the control functions at time $t =2$ and $t=5$ respectively. </p>

<p>
<table>
  <tr>
   <th>
    <video style="display:block; margin: 0 auto;;width:100%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/control-3.mp4" type="video/mp4" />
  </video>
    </th>
   &nbsp; &nbsp; 
<th>
   <video style="display:block; margin: 0 auto;;width:100%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/control-4.mp4" type="video/mp4" />
  </video>
 </th>
 </tr>
 </table>

</p>

<h2 id="references">References</h2>
<p> [1] D. Maity, <em> On the Null Controllability of the Lotka-Mckendrick System,</em> Submitted. </p>
<p> [2] D. Maity, M. Tucsnak and E. Zuazua, <em> Controllability and positivity constraints in population dynamics with age
structuring and diffusion </em>, Journal de Math&eacute;matiques Pures et Appliqu&eacute;s. In press, 10.1016/j.matpur.2018.12.006.</p>

<p> [3] D. Maity, M. Tucsnak and E. Zuazua, <em> Controllability of a Class of Infinite Dimensional
Systems with Age Structure</em>. Submitted.</p>

<p> [4] M. Tucsnak and G. Weiss, <em> Observation and control for operator semigroups, </em>  
Birkh&auml;user Advanced Texts: Basler Lehrbu&uuml;cher. [Birkh&auml;user Advanced Texts: Basel Textbooks], Birkh&auml;user Verlag, Basel, 2009. </p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;We describe here a Finite Element algorithm for the approximation of the one-dimensional fractional Laplacian $(-d_x^2)^s$ on the interval $(-L,L)$, $L&amp;gt;0$ and for the numerical resolution of the following fractional Poisson equation&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{Fl_Poisson}
\begin{cases}
(-d_x^2)^s u = f, & x\in (-L,L)
\\
u = 0, & x\in(-L^L)^c=: \mathbb{R}\setminus (-L,L.)
\end{cases}
\end{equation} %]]></script>

<p>This algorithm has also been emploied in [2,3] for the numerical controllability of fractional parabolic problems (see our previous entries in the <strong>DyCon Blog</strong>, <a href="https://deustotech.github.io/DyCon-Blog//tutorial/wp03/P0001">WP3_P0001</a> and <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/WP03-P0022">WP3_P0022</a>).</p>

<p>We recall that the fractional Laplacian is defined, for all $s\in(0,1)$ and any function $u$ regular enough, as the following singular integral</p>

<script type="math/tex; mode=display">(-d_x^2)^s u(x) := c_s \,P.V.\,\int_{\mathbb{R}} \frac{u(x)-u(y)}{|x-y|^{1+2s}}\,dy,</script>

<p>with $c_s$ an explicit normalization constant given by</p>

<script type="math/tex; mode=display">c_s = \frac{s2^{2s}\Gamma\left(\frac{1+2s}{2}\right)}{\sqrt{\pi}\Gamma(1-s)},</script>

<p>$\Gamma$ being the usual Euler Gamma function.</p>

<p>The starting point of the FE method is the definition of a bilinear form associated to the fractional Laplace operator $(-d_x^2)^s$ and the introduction of the variational formulation corresponding to the elliptic problem \eqref{Fl_Poisson}.</p>

<p>This variational formulation is given as follows: find $u\in H_0^s(-L,L)$ such that the identity</p>

<script type="math/tex; mode=display">\begin{equation}\label{variational}
a(u,v) = \int_{-L}^L fv\,dx
\end{equation}</script>

<p>is satisfied for any function $v\in H_0^s(-L,L)$. In \eqref{variational}, with $H_0^s(-L,L)$ we indicate the space</p>

<script type="math/tex; mode=display">H_0^s(-L,L):=\Big\{ u\in H^s(\mathbb{R})\;:\; u=0\;in\; (-L,L)^c\Big\},</script>

<p>$H^s(\mathbb{R})$ being the usual fractional Sobolev space. Moreover, the bilinear form</p>

<script type="math/tex; mode=display">a: H_0^s(-L,L)\times H_0^s(-L,L)\to \mathbb{R}</script>

<p>is defined as</p>

<script type="math/tex; mode=display">a(u,v) = \frac{c_s}{2}\int_{\mathbb{R}}\int_{\mathbb{R}} \frac{(u(x)-u(y))(v(x)-v(y))}{|x-y|^{1+2s}}\,dxdy.</script>

<p>Let us describe how, starting from the above bilinear form, we can obtain our FE approximation. For simplicity, in what follows we will take $L=1$, although the methodology remains the same for any real $L&gt;0$.</p>

<p>Let us take a uniform partition of the interval $(-1,1)$ as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
-1 = x_0<x_1<\ldots <x_i<x_{i+1}<\ldots<x_{N+1}=1\,, %]]></script>

<p>with $x_{i+1}=x_i+h$, $i=0,\ldots N$. We call $\mathfrak{M}$ the mesh composed by the points ${x_i\,:\, i=1,\ldots,N}$, while the set of the boundary points is denoted $\partial\mathfrak{M}:={x_0,x_{N+1}}$.</p>

<p>Now, define $K_i:=[x_i,x_{i+1}]$ and consider the discrete space</p>

<script type="math/tex; mode=display">\begin{equation}\label{Vh}
V_h :=\Big\{v_h\in H_0^s(-1,1)\,\big|\, \left. v_h\,\right|_{K_i}\in \mathcal{P}^1\Big\},
\end{equation}</script>

<p>where $\mathcal{P}^1$ is the space of the continuous and piece-wise linear functions. Hence, we approximate \eqref{variational} with the following discrete problem: find $u_h\in V_h$ such that</p>

<script type="math/tex; mode=display">\frac{c_s}{2} \int_{\mathbb{R}}\int_{\mathbb{R}}\frac{(u_h(x)-u_h(y))(v_h(x)-v_h(y))}{|x-y|^{1+2s}}\,dxdy = \int_{-1}^1 fv_h\,dx,</script>

<p>for all $v_h\in V_h$. If now we indicate with</p>

<script type="math/tex; mode=display">\big\{\phi_i\big\}_{i=1}^N</script>

<p>a basis of $V_h$, it will be sufficient that the above equality is satisfied for all the functions of the basis, since any element of $V_h$ is a linear combination of them. Therefore the problem takes the following form</p>

<script type="math/tex; mode=display">\begin{equation}\label{WFD}
\frac{c_s}{2} \int_{\mathbb{R}}\int_{\mathbb{R}}\frac{(u_h(x)-u_h(y))(\phi_i(x)-\phi_i(y))}{|x-y|^{1+2s}}\,dxdy = \int_{-1}^1 fv_h\,dx,\;\;\; i=1,\ldots,N.
\end{equation}</script>

<p>Clearly, since $u_h\in V_h$, we have $u_h(x) = \sum_{j=1}^N u_j\phi_j(x)$, where the coefficients $u_j$ are, a priori, unknown. In this way, \eqref{WFD} is reduced to solve the linear system $\mathcal A_h u=F$, where the stiffness matrix $\mathcal A_h\in \mathbb{R}^{N\times N}$ has components</p>

<script type="math/tex; mode=display">\begin{equation}\label{stiffness_nc}
a_{i,j}=\frac{c_s}{2} \int_{\mathbb{R}}\int_{\mathbb{R}}\frac{(\phi_i(x)-\phi_i(y))(\phi_j(x)-\phi_j(y))}{|x-y|^{1+2s}}\,dxdy,
\end{equation}</script>

<p>while the vector $F\in\mathbb{R}^N$ is given by $F=(F_1,\ldots,F_N)$ with</p>

<script type="math/tex; mode=display">F_i = \langle f,\phi_i\rangle_{L^2(-1,1)} = \int_{-1}^1 f\phi_i\,dx,\;\;\; i=1,\ldots,N.</script>

<p>Moreover, the basis</p>

<script type="math/tex; mode=display">\big\{\phi_i\big\}_{i=1}^N</script>

<p>that we will employ is the classical one in which each $\phi_i$ is the tent function with $supp(\phi_i)=(x_{i-1},x_{i+1})$ and verifying $\phi_i(x_j)=\delta_{i,j}$. In particular, for $x\in{x_{i-1},x_i,x_{i+1}}$ the $i^{th}$ function of the basis is explicitly defined as (see <strong>Figure 1</strong>)</p>

<script type="math/tex; mode=display">\begin{equation}\label{basis_fun}
\phi_i(x)= 1-\frac{|x-x_i|}{h}.
\end{equation}</script>

<h2><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/basis_function.png" alt="" /></h2>
<p><strong>Figure 1</strong>. Basis function $\phi_i$ on its support $(x_{i-1},x_{i+1})$.</p>

<p>We now start building the stiffness matrix $\mathcal A_h$ approximating the fractional Laplacian. This will be done in three steps, since the values of the matrix can be computed differentiating among three well defined regions: the upper triangle, corresponding to $j\geq i+2$, the upper diagonal corresponding to $j=i+1$ and the diagonal, corresponding to $j=i$. In each of these regions the intersections among the support of the basis functions are different, thus generating different values of the bilinear form.</p>

<p>We present below an abridged explanation of how to compute the entries of $\mathcal{A}_h$. Complete details may be found in [2].</p>

<h2 id="step-1-jgeq-i2"><strong>Step 1</strong>: $j\geq i+2$</h2>

<p>In this case we have $supp(\phi_i)\cap supp(\phi_j) =\emptyset$ (see also <strong>Figure 2</strong>). Hence, \eqref{stiffness_nc} is reduced to computing only the integral</p>

<script type="math/tex; mode=display">\begin{equation}\label{elem_noint_app}
a_{i,j}=-2 \int_{x_{j-1}}^{x_{j+1}}\int_{x_{i-1}}^{x_{i+1}}\frac{\phi_i(x)\phi_j(y)}{|x-y|^{1+2s}}\,dxdy.
\end{equation}</script>

<h2 id="-1"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/phi1.png" alt="" /></h2>
<p><strong>Figure 2</strong>. Basis functions $\phi_i(x)$ and $\phi_j(x)$ for $j\geq i + 1$. The supports are disjoint.</p>

<p>Taking into account the definition of the basis function \eqref{basis_fun}, the integral \eqref{elem_noint_app} becomes</p>

<script type="math/tex; mode=display">a_{i,j}=-2 \int_{x_{j-1}}^{x_{j+1}}\int_{x_{i-1}}^{x_{i+1}}\frac{\left(1-\frac{|x-x_i|}{h}\right)\left(1-\frac{|y-x_j|}{h}\right)}{|x-y|^{1+2s}}\,dxdy.</script>

<p>Let us introduce the following change of variables:</p>

<script type="math/tex; mode=display">\begin{equation}\label{CV}
\frac{x-x_i}{h}=\hat{x},\;\;\; \frac{y-x_j}{h}=\hat{y}.
\end{equation}</script>

<p>Then, rewriting (with some abuse of notations since there is no possibility of confusion) $\hat{x}=x$ and $\hat{y}=y$, we get</p>

<script type="math/tex; mode=display">a_{i,j}=-2h^{1-2s} \int_{-1}^1\int_{-1}^1\frac{(1-|x\,|\,)(1-|y\,|\,)}{|x-y+i-j\,|^{1+2s}}\,dxdy.</script>

<p>This integral can be computed explicitly, and we obtain</p>

<script type="math/tex; mode=display">a_{i,j} = - h^{1-2s}\,\frac{4(k+1)^{3-2s} + 4(k-1)^{3-2s}-6k^{3-2s}-(k+2)^{3-2s}-(k-2)^{3-2s}}{2s(1-2s)(1-s)(3-2s)}.</script>

<p>Notice that, when $s=1/2$, both the numerator and the denominator of the expression above are zero. In this case, the value of $a_{i,j}$ can be obtained by taking the limit $s\to 1/2$ and we get</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{l}
a_{i,j} &= -4 (k+1)^2\log(k+1) -4(k-1)^2\log(k-1)+6k^2\log(k)
\\[10pt]
&+(k+2)^2\log(k+2) +\;(k-2)^2\log(k-2)
\end{array} %]]></script>

<p>if $k\neq 2$ and</p>

<script type="math/tex; mode=display">a_{i,i+2} = 56\ln(2)-36\ln(3).</script>

<h2 id="step-2-j-i1"><strong>Step 2</strong>: $j= i+1$</h2>
<p>This is the most cumbersome case, since it is the one with the most interactions between the basis functions (see <strong>Figure 3</strong>).</p>

<h2 id="-2"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/phi2.png" alt="" /></h2>
<p><strong>Figure 3</strong>. Basis functions $\phi_i(x)$ and $\phi_{i+1}(x)$. In this case, the intersection of the supports is the interval $[x_i,x_{i+1}]$.</p>

<p>Using the symmetry of the integral with respect to the bisector $y=x$, we have</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{ll}
a_{i,i+1} &= \displaystyle\int_{\mathbb{R}}\int_{\mathbb{R}}\frac{(\phi_i(x)-\phi_i(y))(\phi_{i+1}(x)-\phi_{i+1}(y))}{|x-y|^{1+2s}}\,dxdy
\\[15pt]
&= \displaystyle\int_{x_{i+1}}^{+\infty}\int_{x_{i+1}}^{+\infty} \ldots\,dxdy + 2\int_{x_{i+1}}^{+\infty}\int_{x_i}^{x_{i+1}} \ldots\,dxdy + 2\int_{x_{i+1}}^{+\infty}\int_{-\infty}^{x_i} \ldots\,dxdy
\\[15pt]
&\quad + \displaystyle\int_{x_i}^{x_{i+1}}\int_{x_i}^{x_{i+1}} \ldots\,dxdy + 2\int_{x_i}^{x_{i+1}}\int_{-\infty}^{x_i} \ldots\,dxdy + \int_{-\infty}^{x_i}\int_{-\infty}^{x_i} \ldots\,dxdy
\\[15pt]
&:= Q_1 + Q_2 + Q_3 + Q_4 + Q_5 + Q_6.
\end{array} %]]></script>

<p>Also in this case, the terms $Q_i$, $i=1,\ldots,6$, can be computed explicitely, by noticing also the following facts:</p>

<ol>
  <li>$Q_1=Q_6=0$ since $\phi_i = 0$ on the domain of integration.</li>
  <li>$Q_2=Q_5$ due to symmetry.</li>
</ol>

<p>Then, the elements $a_{i,i+1}$ are given by the sum $2Q_2+Q_3+Q_4$ and we have</p>

<script type="math/tex; mode=display">% <![CDATA[
a_{i,i+1} = \begin{cases}
\displaystyle h^{1-2s}\frac{3^{3-2s}-2^{5-2s}+7}{2s(1-2s)(1-s)(3-2s)}, & \displaystyle s\neq \frac{1}{2}
\\[15pt]
9\ln 3-16\ln 2, & \displaystyle s=\frac{1}{2}.
\end{cases} %]]></script>

<h2 id="step-3-j-i"><strong>Step 3</strong>: $j= i$</h2>
<p>As a last step, we fill the diagonal of the matrix $\mathcal A_h$, which collects the values corresponding to $\phi_i(x)=\phi_j(x)$ (see <strong>Figure 4</strong>).</p>

<h2 id="-3"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/phi4.png" alt="" /></h2>
<p><strong>Figure 4</strong>. Basis functions $\phi_i(x)=\phi_j(x)$.</p>

<p>In this case, we have</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{ll}
a_{i,i} &= \displaystyle\int_{\mathbb{R}}\int_{\mathbb{R}}\frac{(\phi_i(x)-\phi_i(y))^2}{|x-y|^{1+2s}}\,dxdy
\\[15pt]
& = \displaystyle\int_{x_{i+1}}^{+\infty}\int_{x_{i+1}}^{+\infty} \ldots\,dxdy + 2\int_{x_{i+1}}^{+\infty}\int_{x_{i-1}}^{x_{i+1}} \ldots\,dxdy + \int_{x_{i+1}}^{+\infty}\int_{-\infty}^{x_{i-1}} \ldots\,dxdy 
\\[15pt]
& \quad\displaystyle+ \int_{x_{i-1}}^{x_{i+1}}\int_{x_{i-1}}^{x_{i+1}} \ldots\,dxdy + 2\int_{-\infty}^{x_{i-1}}\int_{x_{i-1}}^{x_{i+1}} \ldots\,dxdy + + \int_{-\infty}^{x_{i-1}}\int_{x{i+1}}^{+\infty} \ldots\,dxdy 
\\[15pt]
& \quad\displaystyle +  \int_{-\infty}^{x_{i-1}}\int_{-\infty}^{x_{i-1}} \ldots\,dxdy := R_1 + R_2 + R_3 + R_4 + R_5 + R_6 + R_7.
\end{array} %]]></script>

<p>Once again, the terms $R_i$, $i=1,\ldots,7$ can be computed explicitely, by taking also into account that $R_1=R_3=R_6=R_7=0$ because the corresponding integration domains are all away from the support of the basis functions.</p>

<p>The result of these computations gives the values</p>

<script type="math/tex; mode=display">% <![CDATA[
a_{i,i} = \begin{cases}
\displaystyle h^{1-2s}\,\frac{2^{3-2s}-4}{s(1-2s)(1-s)(3-2s)}, & \displaystyle s\neq\frac{1}{2}
\\
\\
8\ln 2, & \displaystyle s=\frac{1}{2}.
\end{cases} %]]></script>

<h2 id="step-4-building-of-mathcal-a_h">Step 4: building of $\mathcal A_h$</h2>

<p>Summarizing, we have the following values for the elements of the stiffness matrix $\mathcal{A}_h$: for $s\neq 1/2$</p>

<script type="math/tex; mode=display">% <![CDATA[
a_{i,j} =  -h^{1-2s} \begin{cases}
\displaystyle \,\frac{4(k+1)^{3-2s} + 4(k-1)^{3-2s}-6k^{3-2s}-(k+2)^{3-2s}-(k-2)^{3-2s}}{2s(1-2s)(1-s)(3-2s)}, &  \displaystyle k=j-i,\,k\geq 2
\\
\\
\displaystyle\frac{3^{3-2s}-2^{5-2s}+7}{2s(1-2s)(1-s)(3-2s)}, & \displaystyle j=i+1
\\
\\
\displaystyle\frac{2^{3-2s}-4}{s(1-2s)(1-s)(3-2s)}, & \displaystyle j=i.
\end{cases} %]]></script>

<p>For $s=1/2$, instead, we have</p>

<script type="math/tex; mode=display">% <![CDATA[
a_{i,j} = \begin{cases}
-4(j-i+1)^2\log(j-i+1)-4(j-i-1)^2\log(j-i-1)
\\
\;\;\;+6(j-i)^2\log(j-i)+(j-i+2)^2\log(j-i+2)+(j-i-2)^2\log(j-i-2), &  \displaystyle j> i+2
\\
\\
56\ln(2)-36\ln(3), & \displaystyle j= i+2.
\\
\\
\displaystyle 9\ln 3-16\ln 2, & \displaystyle j=i+1
\\
\\
\displaystyle 8\ln 2, & \displaystyle j=i.
\end{cases} %]]></script>

<h1 id="numerical-results">Numerical results</h1>

<p>We present the numerical simulations corresponding to the algorithm previously described.</p>

<p>First of all, we test numerically the accuracy of our method for the resolution of the elliptic equation \eqref{Fl_Poisson} by applying it to the following problem</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{poisson}
\begin{cases}
(-d_x^2)^s u = 1, & x\in(-1,1)
\\
u\equiv 0, & x\in(-1,1)^c.
\end{cases}
\end{equation} %]]></script>

<p>In this particular case, the unique solution $u$ can be computed exactly and it is given by</p>

<script type="math/tex; mode=display">\begin{equation}\label{real_sol}
  u(x)=\frac{2^{-2s}\sqrt{\pi}}{\Gamma\left(\frac{1+2s}{2}\right)\Gamma(1+s)}\Big(1-x^{\,2}\Big)^s\cdot\chi_{(-1,1)},  
\end{equation}</script>

<p>where $\chi_{(-1,1)}$ indicates the characteristic function of the interval $(-1,1)$.</p>

<p>The solution of \eqref{poisson} in the case  $s=0.1$ and $N=50$ is computed with the following script which emploies the function <strong>FEFractionalLaplacian.m</strong> ginving the FE discretization of $(-d_x^2)^s$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">f</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">Phi</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">1</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">F</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">h</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">xx</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">)</span><span class="o">+</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">B1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">.*</span><span class="p">(</span><span class="n">Phi</span><span class="p">((</span><span class="n">xx</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">))/</span><span class="n">h</span><span class="p">));</span>
    <span class="n">F</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">)/</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">B1</span><span class="p">);</span> 
<span class="k">end</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">FEFractionalLaplacian</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">A</span><span class="p">\</span><span class="n">F</span><span class="p">;</span>
</code></pre></div></div>

<p>In <strong>Figure 5</strong>, we show a comparison for different values of $s$ between the exact solution \eqref{real_sol} and the computed numerical approximation.</p>

<h2 id="-4"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/solution.png" alt="" /></h2>
<p><strong>Figure 5</strong>. Real and numerical solution.</p>

<p>One can notice that when $s=0.1$ (and also for other small values of s), the computed solution is to a certain extent different from the exact solution. Notwithstanding, it is well-known that the notion of trace is not defined for the spaces $H^s(-1,1)$ with $s\leq 1/2$. Hence, it is somehow natural that we cannot expect a point-wise convergence in this case.</p>

<p>Furthermore, the accuracy of our algorithm is validated by a simple error analysis.</p>

<p>The computation of the error in the space $H_0^s(-1,1)$ can be readily done by using the definition of the bilinear form, namely</p>

<script type="math/tex; mode=display">\|u-u_h\|_{H_0^s(-1,1)}^2 =a(u-u_h,u-u_h) =a(u,u-u_h) =\int_{-1}^1f(x)\left(u(x)-u_h(x)\right)dx</script>

<p>where have used the orthogonality condition $a(v_h,u-u_h)=0$ for all $v_h \in V_h$.</p>

<p>For this particular test, since $f\equiv 1$ in $(-1,1)$, the problem is therefore reduced to</p>

<script type="math/tex; mode=display">\|u-u_h\|_{H^s_0(-1,1)}=\left(\int_{-1}^1\left( u(x)-u_h(x) \right)\,dx\right)^{1/2}</script>

<p>where the right-hand side can be easily computed, since we have the closed formula</p>

<script type="math/tex; mode=display">\int_{-1}^1u\,dx= \frac{\pi}{2^{2s}\Gamma(s+\frac{1}{2})\Gamma(s+\frac{3}{2})}</script>

<p>and the term corresponding to $\int_{-1}^1u_h$ can be carried out numerically. Moreover, we have the following convergence result.</p>

<p><strong>Theorem</strong> [2] For the solution $u$ of \eqref{WFD} and its FE approximation $u_h$ given by \eqref{WFD}, if $h$ is sufficiently small, the following estimates hold</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{ll}
\|u-u_h\|_{H^s_0(-1,1)}\leq \mathcal{C} h^{1/2}|\!\ln h|\,\|f\|_{C^{1/2-s}(-1,1)}, &\text{if}\quad s<1/2,
\\[15pt]
\|u-u_h\|_{H^s_0(-1,1)}\leq \mathcal{C} h^{1/2} |\!\ln h|\, \|f\|_{L^\infty(-1,1)},&\text{if}\quad  s=1/2 
\\[15pt]
\displaystyle\|u-u_h\|_{H^s_0(-1,1)}\leq \tfrac{\mathcal{C}}{2s-1} h^{1/2} \sqrt{|\!\ln h|}\, \|f\|_{C^\beta(-1,1)},& \text{if} \quad s>1/2,\;\;\beta>0
\end{array} %]]></script>

<p>where $\mathcal{C}$ is a positive constant not depending on $h$.</p>

<p>In <strong>Figure 6</strong>, we present the computational errors evaluated for different values of $s$ and $h$, which can be obtained with the following function.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="p">[</span><span class="n">h</span><span class="p">,</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_fl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">f</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">Phi</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">1</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">F</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">h</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">xx</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">)</span><span class="o">+</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">B1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">.*</span><span class="p">(</span><span class="n">Phi</span><span class="p">((</span><span class="n">xx</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">))/</span><span class="n">h</span><span class="p">));</span>
    <span class="n">F</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">)/</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">B1</span><span class="p">);</span> 
<span class="k">end</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">FEFractionalLaplacian</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">A</span><span class="p">\</span><span class="n">F</span><span class="p">;</span>
<span class="n">val</span> <span class="o">=</span> <span class="nb">pi</span><span class="p">/(</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="nb">gamma</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="nb">gamma</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mf">1.5</span><span class="p">));</span>
<span class="n">valnum</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">sol</span><span class="p">);</span>
<span class="n">e</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">val</span><span class="o">-</span><span class="n">valnum</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="-5"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/error.png" alt="" /></h2>
<p><strong>Figure 6</strong>. Computational error in logarithmic scale in terms for different values of $s$.</p>

<p>The rates of convergence shown are of order (in $h$) of $1/2$, and this convergence rate is maintained also for small values of $s$. This confirms the accuracy of our approximation. In particular, the behavior shown in <strong>Figure 6</strong> is not in contrast with the known theoretical results.</p>

<h2 id="references">References</h2>

<p>[1] G. Acosta, F. Bersetche and J. P. Borthagaray, <em>A short FE implementation for a 2d homogeneous Dirichlet problem of a Fractional Laplacian</em>. Comput. Math. Appl., Vol. 74, No. 4 (2017), pp. 784-816.</p>

<p>[2] U. Biccari and V. Hernández-Santamarı́a, <em>Controllability of a one-dimensional fractional heat equation: theoretical and
numerical aspects</em>. IMA J. Math. Control. Inf, to appear, 2018.</p>

<p>[3] U. Biccari, M. Warma and E. Zuazua, <em>Controllability of the one-dimensional fractional heat equation under positivity constraints</em>. Submitted.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;The aim of this tutorial is to give a numerical method for solving an age structured virus model.&lt;/p&gt;
</code></pre></div></div>

<h2 id="introduction">Introduction</h2>

<p>The virus infection mathematical models are proposing and studying for a long time (see for example C.L. Althaus, R.J. DE Boer [1] and F. Brauer, C. Castillo-Chavez [2]. In particular case of an HIV infection model (see for P. W. Nelson and al. [6]), the corresponding model is usually divided into three classes called  uninfected cells, $T$,  infected cells, $i$ and free virus particles, $V$.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/Schema.png" alt="" /></p>

<p>schematic representation of HIV dynamic.</p>

<p>We refer the reader to [4] and [5] for more general class on nonlinear incidence rates that take into account the saturation phenomenon.</p>

<p>We consider an age-structured HIV infection model with a very general nonlinear infection function</p>

<script type="math/tex; mode=display">\begin{equation} \label{A} \left \{ \begin{array}{lll} T'(t)=A- \mu T(t)-f(T(t),V(t)) \;\;\ t \geq 0,\\ i_t(t,a)+i_a(t,a)=-\delta(a) i(t,a), \\ V'(t)=\int_0^{\infty} p(a)i(t,a)da-\mu_cV(t), \end{array} \right. \end{equation}</script>

<p>with the boundary and initial conditions</p>

<script type="math/tex; mode=display">\begin{equation} \begin{cases} i(t,0)=f(T(t),V(t)), \\ T(0)=T_0\geq 0, \quad  V(0)=V_0 , \quad i(0,.)=i_0(.)\in L_{+}^{1}(\mathbb{R}^{+}). \end{cases} \end{equation}</script>

<p>We denote by</p>

<script type="math/tex; mode=display">\Pi(a)=e^{-\int_0^a\delta(\theta)d\theta}, \qquad  N=\int_0^{\infty}p(a)\Pi(a)da.</script>

<p>The number $R_0$ represents the expected number of secondary infections produced by a single infected cell during its lifetime,</p>

<script type="math/tex; mode=display">R_0=\frac{N}{c}\dfrac{\partial f}{\partial V}(\frac{A}{d},0).</script>

<p>The complete global stability analysis for the system (\ref{A}) has been studied in [4]. The system (\ref{A}) admits at most two equilibrium, from Theorem 3.1 and Theorem 5.2 in [4], we obtain the following result:</p>

<ul>
  <li>
    <p>If $R_0 \leqslant 1$, the disease free equilibrium $E_0=(\frac{A}{\mu},0,0)$ is globally asymptotically stable.</p>
  </li>
  <li>
    <p>If $R_0&gt;1$, the positive infection equilibrium $E^{\ast}=(T^\ast,i^\ast,V^\ast)$ is globally asymptotically stable.</p>
  </li>
</ul>

<h2 id="numerical-method">Numerical method</h2>

<p>We consider the Beddington-Deangelis function $f$  defined by</p>

<script type="math/tex; mode=display">f(T, V)=  \frac{\beta T V}{1+ \alpha_1 S+ \alpha_2 V}.</script>

<p>In this case, the basic reproduction number ${\cal R}_0$  is given by</p>

<script type="math/tex; mode=display">R_0 = \displaystyle \frac{N}{\mu_c} \frac{A \beta }{\mu + \alpha_1}.</script>

<p>Where $\pi(a)=\exp^{-\int_{0}^{a} \delta (s) ds}$ and $N=\int_{0}^{\infty} p(a) \pi(a) da$.</p>

<p>The numerical method to solve this system of equation is based on the upwind method for solving hyperbolic partial differential equation, (see [3]) called also the FTBS method (Forward-Time-Backward-Space), has first-order accuracy in both space and time. The CFL condition is necessary for the stability of numerical solutions. The ODEs are solving by explicit Euler method.</p>

<p>we use a grid with points $(x_j,t_n)$ defined by</p>

<script type="math/tex; mode=display">a_j=j\Delta a, \qquad j=0,...,N,  \qquad t_n=n\Delta t, \qquad n=0,...,M.</script>

<p>with age step $\Delta a$ and time step $\Delta t$. Denoting, respectively, by $T^n$, $i^n_j$ and $V^n$  the numerical approximation of $T(t_n)$, $i(t_n,a_j)$ and $V(t_n)$, moreover,</p>

<p><script type="math/tex">\left(  \frac{\partial i}{\partial t} \right)_n \simeq \frac{i^{n+1}_j-i^n_{j}}{\Delta t}, \qquad \left(  \frac{\partial i}{\partial a} \right)_j \simeq \frac{i^n_j-u^n_{j-1}}{\Delta a}.</script> we thus obtain the difference scheme of hyperbolic PDE</p>

<script type="math/tex; mode=display">i^{n+1}_j=(1-\lambda) i^n_j +\lambda i^n_{j-1}+ \Delta t \delta(a_j) i^n_j, \quad n=0,...,M-1, \text{ and } j=0,...,N.</script>

<p>with $\lambda = \frac{\Delta t}{\Delta a}$. We fix the following values of parameters</p>

<script type="math/tex; mode=display">A_0=2, \qquad \mu=0.04\qquad \mu_c=0.5 \qquad \text{and} \qquad \delta =0.4,</script>

<p>with the initial conditions</p>

<script type="math/tex; mode=display">T_0=20, \qquad  V_0=5 \qquad \text{and} \qquad i_0(a)=4 e^{-0.3 a}.</script>

<p>The functions $p$ is given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*} p(a)=\left\{ \begin{array}{lll} 0, & \text{ if } a\leq \tau_1, \\ 0.4, & \text{ if } a> \tau_1, \end{array} \right. \end{equation*} %]]></script>

<p>We change the values of $\tau_1$ in order to have $R_0 \leq 1$ or to have $R_0 &gt; 1$.  If we choose $ \tau_1 = 3 $ then $ R_0 = 0.5417 &lt; 1 $,</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/SIV.png" alt="" /> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/Infected.png" alt="" /></p>

<p>And if we choose $ \tau_1 = 0.5 $ then $ R_0 = 1.4216 &gt; 1 $,</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/SIVend.png" alt="" /> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/Infectedend.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clear</span> <span class="nb">all</span><span class="p">,</span><span class="nb">close</span> <span class="nb">all</span>
<span class="n">a1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">a2</span><span class="o">=</span><span class="mi">60</span><span class="p">;</span>
<span class="n">Tf</span><span class="o">=</span><span class="mi">300</span><span class="p">;</span>
<span class="n">I0</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="mi">4</span><span class="o">*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.3</span><span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="n">T0</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span>
<span class="n">V0</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
<span class="n">A0</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.02</span><span class="p">;</span> <span class="n">muc</span><span class="o">=</span><span class="mf">0.4</span><span class="p">;</span>
<span class="nb">beta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">;</span>
<span class="n">alpha1</span><span class="o">=</span><span class="mf">0.1</span><span class="p">;</span>
<span class="n">alpha2</span><span class="o">=</span><span class="mf">0.2</span><span class="p">;</span>
<span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">;</span>
<span class="n">fct</span><span class="o">=@</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">beta</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)/(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha1</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">alpha2</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="n">N</span><span class="o">=</span><span class="mi">199</span><span class="p">;</span><span class="n">M</span><span class="o">=</span><span class="mi">1200</span><span class="p">;</span>
<span class="n">h</span><span class="o">=</span><span class="p">(</span><span class="n">a2</span><span class="o">-</span><span class="n">a1</span><span class="p">)/</span><span class="n">N</span><span class="p">;</span>
<span class="n">k</span><span class="o">=</span><span class="n">Tf</span><span class="p">/</span><span class="n">M</span><span class="p">;</span>
<span class="n">a</span><span class="o">=</span><span class="n">a1</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">h</span><span class="p">;</span>
<span class="n">ap</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">];</span>
<span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">M</span><span class="p">)</span><span class="o">*</span><span class="n">k</span><span class="p">;</span>
<span class="n">lambda</span><span class="o">=</span><span class="n">k</span><span class="p">/</span><span class="n">h</span><span class="p">;</span>
<span class="n">C</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="n">A</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">lambda</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">+</span><span class="n">lambda</span><span class="o">*</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>The reproduction number $R_0$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R0</span><span class="o">=</span><span class="n">tauxR</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="nb">beta</span><span class="p">,</span><span class="n">muc</span><span class="p">,</span><span class="n">mu</span><span class="p">,</span><span class="n">A0</span><span class="p">,</span><span class="n">alpha1</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
R0 =

    1.4216


</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">T0</span><span class="p">;</span>
<span class="n">V</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">V0</span><span class="p">;</span>
<span class="n">U</span><span class="o">=</span> <span class="n">I0</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">))</span><span class="o">'</span><span class="p">;</span>  <span class="c1">%% initial values</span>
<span class="n">Up</span><span class="o">=</span><span class="p">[</span><span class="n">fct</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span><span class="n">V0</span><span class="p">);</span> <span class="n">U</span><span class="p">];</span> <span class="c1">%% Initial value + Boundary condition</span>
<span class="n">Uf</span><span class="o">=</span><span class="n">Up</span><span class="p">;</span>

<span class="n">F</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="n">UI</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="p">);;</span>

<span class="k">for</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">M</span>
    <span class="n">Uold</span><span class="o">=</span><span class="n">U</span><span class="p">;</span>
      <span class="n">UI</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fct</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">V</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
    <span class="k">for</span> <span class="n">o</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="n">UI</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">UI</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">Uold</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="n">B</span><span class="o">=</span><span class="p">[</span><span class="n">lambda</span><span class="o">*</span><span class="n">fct</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">V</span><span class="p">(</span><span class="n">j</span><span class="p">))</span> <span class="p">;</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)];</span>
    <span class="n">F</span><span class="o">=-</span> <span class="n">delta</span><span class="o">*</span><span class="n">Uold</span> <span class="p">;</span>
    <span class="n">U</span><span class="o">=</span><span class="n">A</span><span class="o">*</span><span class="n">Uold</span><span class="o">+</span><span class="n">B</span><span class="o">+</span><span class="n">k</span><span class="o">*</span><span class="n">F</span><span class="p">;</span>
    <span class="n">val</span><span class="o">=</span><span class="nb">feval</span><span class="p">(</span><span class="o">@</span><span class="n">int</span><span class="p">,</span><span class="n">Uold</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">a</span><span class="p">);</span>
    <span class="n">T</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">T</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">A0</span><span class="o">-</span><span class="n">mu</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">fct</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">V</span><span class="p">(</span><span class="n">j</span><span class="p">)));</span>
    <span class="n">V</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">V</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">muc</span> <span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
    <span class="n">Up</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">Up</span><span class="o">=</span><span class="p">[</span><span class="n">fct</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">V</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span> <span class="n">U</span><span class="p">];</span>
    <span class="n">Uf</span><span class="o">=</span><span class="p">[</span><span class="n">Uf</span><span class="p">,</span><span class="n">Up</span><span class="p">];</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">[</span><span class="n">X</span> <span class="p">,</span> <span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span> <span class="n">ap</span> <span class="p">,</span><span class="n">t</span><span class="p">);</span>
 <span class="nb">mesh</span> <span class="p">(</span><span class="n">X</span> <span class="p">,</span> <span class="n">Y</span> <span class="p">,</span> <span class="n">Uf</span><span class="o">'</span><span class="p">)</span>
 <span class="nb">title</span><span class="p">(</span><span class="s1">'The evolution of solution i(t,a)'</span><span class="p">)</span>
 <span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Age'</span><span class="p">)</span>
 <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">)</span>
 <span class="nb">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
 <span class="nb">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">T</span><span class="s1">','</span><span class="n">b</span><span class="s1">',t,[UI UI(N+2)],'</span><span class="n">r</span><span class="s1">',t,V'</span><span class="p">,</span><span class="s1">'g'</span><span class="p">)</span>
 <span class="nb">legend</span><span class="p">(</span><span class="s1">'S(t)'</span><span class="p">,</span><span class="s1">'I(t)=\int i(t,a)da'</span><span class="p">,</span><span class="s1">'R(t)'</span><span class="p">)</span>
 <span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/copiaRM_01.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/copiaRM_02.png" alt="" /></p>

<h2 id="references">References</h2>

<p>[1]  R. J. De Boer C. L. Althaus. Dynamics of immune escape during hiv/siv infection, PloS Comput. Biol, 2008.</p>

<p>[2] F. Brauer and C. Castillo-Chavez. Mathematical Models in Population Biology and Epidemiology Springer, New York, 2000.</p>

<p>[3] L. Edsberg. Introduction to Computation and Modeling for Differential Equations, 2nd Edition. Wiley, 288 Pages, 2016.</p>

<p>[4] M. N. Frioui S. E. Miri, T. M. Touaoula. Unified lyapunov functional for an age-structured virus model with very general nonlinear infection response. J. Appl. Math. Comput, pages 1–27, 2017.</p>

<p>[5]  T. Kuniya J. Wang, R. Zhang.. Mathematical analysis for an age-structured hiv infection model with saturation infection rate, Elect. J. Diff. Eq, pages 1–19, 2015.</p>

<p>[6]  A. S. Perelson P. W. Nelson. Mathematical analysis of delay differential equation models of hiv-1 infection. Math. Biosc, 179, pages 73–94, 2002.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In [2], we analyzed the controllablity properties under non-negative control and state constraints of the following heat-like equation involving the fractional Laplacian on $(-1,1)$&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{frac_heat}
    \begin{cases}
        z_t+(-d_x^2)^s z = u\chi_{\omega}, & (x,t)\in (-1,1)\times(0,T)
        \\
        z = 0, & (x,t)\in (-1,1)^c\times(0,T)
        \\
        z(\cdot,0)=z_0, & x\in (-1,1).
    \end{cases}
\end{equation} %]]></script>

<p>In \ref{frac_heat}, $\omega\subset (-1,1)$ is the control region in which the distributed control $u$ acts. Moreover, we denote by $(-d_x^2)^s$ the fractional Laplace operator defined, for all $s\in(0,1)$, as the following singular integral</p>

<script type="math/tex; mode=display">(-d_x^2)^s z(x) := c_s \,P.V.\,\int_{\mathbb{R}} \frac{z(x)-z(y)}{|x-y|^{1+2s}}\,dy,</script>

<p>with $c_s$ an explicit normalization constant given by</p>

<script type="math/tex; mode=display">c_s = \frac{s2^{2s}\Gamma\left(\frac{1+2s}{2}\right)}{\sqrt{\pi}\Gamma(1-s)},</script>

<p>Gamma being the usual Euler Gamma function.</p>

<p>The main result we established are the following results:</p>

<ol>
  <li>
    <p>For any $s&gt;1/2$, there exists $T&gt;0$ such that the fractional heat equation \ref{frac_heat} is controllable to positive trajectories by means of a non-negative control $u\in L^\infty(\omega\times(0,T))$. Moreover, if the initial datum $z_0\geq 0$ is non-negative, we also have $z(x,t)\geq 0$ for every $(x,t)\in (-1,1)\times (0,T)$.</p>
  </li>
  <li>
    <p>If we define the minimal controllability time by</p>
  </li>
</ol>

<script type="math/tex; mode=display">\begin{align}
    T_{min}(z_0,\widehat{z}):= \inf\Big\{T>0:\exists\;\; 0\leq u\in L^\infty(\omega\times(0,T)) \\ \hspace{5cm} such\;that\; z(\cdot,0)=z_0\; and\; z(\cdot,T)=\widehat{z}(\cdot,T)\Big\},
\end{align}</script>

<p>we have $T_{min}&gt;0$.</p>

<ol>
  <li>For $T = T_{min}$, there exists a non-negative control $u\in \mathcal M(\omega\times(0,T_{min}))$, the space of Radon measures
on $\omega\times(0,T_{min})$, such that the corresponding solution $z$ of \ref{frac_heat} satisfies $z(x,T) = \widehat{z}(x,T)$ a.e.
in $(-1,1)$.</li>
</ol>

<p>These results extend to the fractional case the ones previously obtained by our team in the context of the linear and semi-linear heat equation (see our previous entries in the <strong>DyCon Blog</strong>, <a href="https://deustotech.github.io/DyCon-Blog//tutorial/wp03/P0001">WP3_P0001</a> and <a href="https://deustotech.github.io/DyCon-Blog//tutorial/wp03/P0002">WP3_P0002</a>).</p>

<p>In this post, we present some numerical development in order to find the minimal controllability time for the discretized
fractional heat equation with non-negative control constraint and to confirm our theoretical results.</p>

<p>In particular, we will consider the problem of steering the initial datum</p>

<script type="math/tex; mode=display">z_0(x) = \frac 12\cos\left(\frac \pi2 x\right)</script>

<p>to the target trajectroy $\widehat{z}$ solution of \ref{frac_heat} with initial datum</p>

<script type="math/tex; mode=display">\widehat{z}_0(x) = 6\cos\left(\frac \pi2 x\right)</script>

<p>and right-hand side $\widehat{u}\equiv 1$.</p>

<p>We choose $s=0.8$ and $\omega=(-0.3,0.8)\subset (-1,1)$ as the control region. The approximation of the minimal controllability time is obtained by solving the following constrained minimization problem.</p>

<script type="math/tex; mode=display">minimize\;T</script>

<p>subject to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
T>0
\\
z_t+(-d_x^2)^s z=u\chi_\omega, & a.\,e.\;in\; (-1,1)\times(0,T)
\\
z(\cdot,0)=z_0\geq 0, & a.\,e.\;in\; (-1,1)
\\
z\geq 0, & a.\,e.\;in\; (-1,1)\times(0,T)
\\
u\geq 0, & a.\,e.\;in\; \omega\times(0,T).
\end{cases} %]]></script>

<p>To solve this problem numerically, we employ the expert interior-point optimization routine <a href="https://github.com/coin-or/Ipopt">IpOpt</a> combined with automatic differentiation and the modeling language <a href="https://ampl.com/">AMPL</a>. The interest of using <strong>AMPL</strong> together with <strong>IpOpt</strong> is that the gradient of the cost function and the constraints is automatically generated. Solving problems with <strong>IpOpt</strong> and AMPL can be made online through the <a href="https://neos-server.org/neos/">NEOS</a> solvers.</p>

<p>To perform our simulations, we apply a FE method for the space discretization of the fractional Laplacian (see [1]) on a uniform space-grid</p>

<script type="math/tex; mode=display">x_i = -1 + \frac{2i}{N_x}, \quad i = 1,\ldots,N_x,</script>

<p>with $N_x=20$ . Moreover, we use an explicit Euler scheme for the time integration on the time-grid</p>

<script type="math/tex; mode=display">t_j = \frac{Tj}{N_t}, \quad j = 0,\ldots,N_t,</script>

<p>with $N_t$ satisfying the <strong>Courant-Friedrich-Lewy</strong> condition. In particular, we choose here $N_t=100$.</p>

<p>The AMPL code for solving this minimation problem is included below. In it, the matrices defining the dynamics are computed through specific functions implemented in <strong>Matlab</strong> and are given as parameters.</p>

<p>It is important to remark that we are interested in the controllability to the trajectory $\widehat{z}(\cdot,T)$ but, at the same time, $T$ is a variable in our code since it is the cost functional we aim to minimize. In view of that, our final target changes during the minimization process. Nevertheless this issue can be bypassed by taking advance of the linear nature of our equation and solving the <em>traslated</em> constrained minimization problem consisting in finding the minimial time for steering the inital datum $z_0-\widehat{z}_0$ by employing a control $u\geq\widehat{u}$ ($\widehat{z}_0$ and $\widehat{u}$ are the same given above).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Minimal time for the constrained controllability of the fractional heat equation.
</span>
<span class="c1"># 1: define the parameters
</span>
<span class="n">param</span> <span class="n">Nx</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>               <span class="c1"># number of spatial discretization points
</span>
<span class="n">param</span> <span class="n">Nt</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>              <span class="c1"># number of time discretization points
</span>
<span class="n">param</span> <span class="n">y0</span> <span class="p">{</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">};</span>            <span class="c1"># initial condition
</span>
<span class="n">param</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                <span class="c1"># target
</span>
<span class="n">param</span> <span class="n">dx</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">Nx</span><span class="p">;</span>             <span class="c1"># Space step
</span>
<span class="n">param</span> <span class="n">C</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                 <span class="c1"># Bound on the controls
</span>
<span class="n">param</span> <span class="n">A</span> <span class="p">{</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">};</span>       <span class="c1"># Stiffness or rigidity matrix
</span>
<span class="n">param</span> <span class="n">B</span> <span class="p">{</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">};</span>       <span class="c1"># Control matrix
</span>
<span class="n">param</span> <span class="n">M</span> <span class="p">{</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">};</span>       <span class="c1"># Mass matrix  
</span>
<span class="c1"># 2: define the variables
</span>
<span class="n">var</span> <span class="n">y</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">};</span>       <span class="c1"># State
</span><span class="n">var</span> <span class="n">u</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}</span><span class="o">&gt;=-</span><span class="n">C</span><span class="p">;</span>   <span class="c1"># Control
</span><span class="n">var</span> <span class="n">T</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span>                            <span class="c1"># Time horizon
</span><span class="n">var</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="n">Nt</span><span class="p">;</span>                        <span class="c1"># Time step
</span>
<span class="c1"># 3: define the data
</span>
<span class="n">data</span><span class="p">;</span>

<span class="c1"># Initial datum
</span>
<span class="n">param</span> <span class="n">y0</span><span class="p">:</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">20</span> <span class="p">:</span><span class="o">=</span>
<span class="mi">1</span> <span class="o">-</span><span class="mf">0.000000</span> <span class="o">-</span><span class="mf">0.905270</span> <span class="o">-</span><span class="mf">1.785847</span> <span class="o">-</span><span class="mf">2.617711</span> <span class="o">-</span><span class="mf">3.378170</span> <span class="o">-</span><span class="mf">4.046482</span> <span class="o">-</span><span class="mf">4.604416</span> <span class="o">-</span><span class="mf">5.036753</span> <span class="o">-</span><span class="mf">5.331701</span> <span class="o">-</span><span class="mf">5.481215</span> <span class="o">-</span><span class="mf">5.481215</span> <span class="o">-</span><span class="mf">5.331701</span> <span class="o">-</span><span class="mf">5.036753</span> <span class="o">-</span><span class="mf">4.604416</span> <span class="o">-</span><span class="mf">4.046482</span> <span class="o">-</span><span class="mf">3.378170</span> <span class="o">-</span><span class="mf">2.617711</span> <span class="o">-</span><span class="mf">1.785847</span> <span class="o">-</span><span class="mf">0.905270</span> <span class="o">-</span><span class="mf">0.000000</span><span class="p">;</span>

<span class="c1"># Stiffness or rigidity matrix A
</span>
<span class="n">param</span> <span class="n">A</span><span class="p">:</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">20</span> <span class="p">:</span><span class="o">=</span>
<span class="mi">1</span> <span class="o">-</span><span class="mf">5.551728</span> <span class="mf">2.242487</span> <span class="mf">0.359689</span> <span class="mf">0.077115</span> <span class="mf">0.033148</span> <span class="mf">0.017829</span> <span class="mf">0.010871</span> <span class="mf">0.007193</span> <span class="mf">0.005044</span> <span class="mf">0.003694</span> <span class="mf">0.002798</span> <span class="mf">0.002178</span> <span class="mf">0.001733</span> <span class="mf">0.001405</span> <span class="mf">0.001158</span> <span class="mf">0.000966</span> <span class="mf">0.000816</span> <span class="mf">0.000697</span> <span class="mf">0.000600</span> <span class="mf">0.000521</span>
<span class="o">...</span>
<span class="mi">20</span> <span class="mf">0.000521</span> <span class="mf">0.000600</span> <span class="mf">0.000697</span> <span class="mf">0.000816</span> <span class="mf">0.000966</span> <span class="mf">0.001158</span> <span class="mf">0.001405</span> <span class="mf">0.001733</span> <span class="mf">0.002178</span> <span class="mf">0.002798</span> <span class="mf">0.003694</span> <span class="mf">0.005044</span> <span class="mf">0.007193</span> <span class="mf">0.010871</span> <span class="mf">0.017829</span> <span class="mf">0.033148</span> <span class="mf">0.077115</span> <span class="mf">0.359689</span> <span class="mf">2.242487</span> <span class="o">-</span><span class="mf">5.551728</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Control matrix B
</span>
<span class="n">param</span> <span class="n">B</span><span class="p">:</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">20</span> <span class="p">:</span><span class="o">=</span>
<span class="mi">1</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span>
<span class="o">...</span>
<span class="mi">20</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Mass matrix M
</span>
<span class="n">param</span> <span class="n">M</span><span class="p">:</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">20</span> <span class="p">:</span><span class="o">=</span>
<span class="mi">1</span> <span class="mf">0.070175</span> <span class="mf">0.017544</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span>
<span class="o">...</span>
<span class="mi">20</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.017544</span> <span class="mf">0.070175</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 4: define the cost functional to minimize
</span>
<span class="n">minimize</span> <span class="n">cost</span><span class="p">:</span> <span class="n">T</span><span class="p">;</span>

<span class="c1"># 5: define the constraints
</span>
<span class="c1"># 5.a: dynamics y' = Ay + Bu, implemented through an Explicit Euler method.
</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">y_dyn</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">2.</span><span class="o">.</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">}:</span>
<span class="nb">sum</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="nb">sum</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">]);</span>

<span class="c1"># 5.b: homogeneous Dirichlet boundary conditions in -1 and 1.
</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">left_boundary</span>  <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}:</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">right_boundary</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}:</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1"># 5.c: initial condition.
</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">y_init</span> <span class="p">{</span><span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}:</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="c1"># 5.d: target.
</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">y_end1</span> <span class="p">{</span><span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}:</span> <span class="n">y</span><span class="p">[</span><span class="n">Nt</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1</span><span class="p">;</span>

<span class="c1"># 6: solve the problem with IpOpt
</span>
<span class="n">option</span> <span class="n">solver</span> <span class="n">ipopt</span><span class="p">;</span>
<span class="n">option</span> <span class="n">ipopt_options</span> <span class="s">"max_iter=100000 linear_solver=mumps hessian_approximation=exact halt_on_ampl_error yes"</span><span class="p">;</span>
<span class="n">solve</span><span class="p">;</span>

<span class="c1"># 7: print the results.
</span>
<span class="n">printf</span><span class="p">:</span> <span class="s">"T  = </span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">T</span><span class="p">;</span>
<span class="n">printf</span><span class="p">:</span> <span class="s">"Nx = </span><span class="si">%</span><span class="s">d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Nx</span><span class="p">;</span>
<span class="n">printf</span><span class="p">:</span> <span class="s">"Nt = </span><span class="si">%</span><span class="s">d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Nt</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}:</span> <span class="s">" </span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}:</span> <span class="s">" </span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">];</span>

<span class="n">end</span><span class="p">;</span>
</code></pre></div></div>

<p>Once the minimization is concluded, we save the results in a file “data.txt” and we use <strong>Matlab</strong> to reshape the solution and the control so to obtain two $N_x\times(N_t+1)$ matrices for the plots.</p>

<p>This can be done through the following script:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">close</span> <span class="nb">all</span>
<span class="c1">% Read the data from the external file data.txt</span>

<span class="n">fid</span><span class="o">=</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">'data.txt'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">);</span>
<span class="n">C</span> <span class="o">=</span> <span class="nb">fscanf</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="s1">'%f'</span><span class="p">,</span><span class="nb">Inf</span><span class="p">);</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Nx</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">4</span><span class="p">:(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Nx</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">C</span><span class="p">((</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Nx</span><span class="o">+</span><span class="mi">4</span><span class="p">:</span><span class="k">end</span><span class="p">);</span>
<span class="nb">fclose</span><span class="p">(</span><span class="n">fid</span><span class="p">);</span>

<span class="c1">% Reshape the state y and the control u into two Nx times Nt+1 matrices</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">u</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>From the reshaped solution and control, we can generate the plots. For instance, the m-file plot_control.m is the one generating <strong>Figure 2</strong> below.</p>

<p>The minimal time that we obtain from our minimization process is $T_{min}\simeq 0,2101$. Our simulations show that in this time horizon the fractional heat equation \ref{frac_heat} is controllable from the initial datum $z_0$ to the desired trajectory $\widehat{z}(\cdot,T)$ by maintaining the positivity of the solution (as it is expected since the initial datum is positive in $(-1,1)$, see <strong>Figure 1</strong>).</p>

<h2><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/evolution_tmin.gif" alt="GitHub Logo" /></h2>
<p><strong>Figure 1</strong>. Controllability of the fractional heat equation \ref{frac_heat}in the minimal time $T_{min}=0.2101$.</p>

<p>Moreover, as it is observed also in <strong>Figure 2</strong>, the control has an impulsional behavior.</p>

<h2 id="-1"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/deltas.png" alt="GitHub Logo" /></h2>
<p><strong>Figure 2</strong>. Minimal-time control. In the $(t,x)$ plane in blue the time $t$ varies from $t = 0$ (left) to $t = T_{min}$ (right).</p>

<p>This behavior of the control is not surprising. Indeed, as it was already observed in our previous works [3,4], the minimal-time controls are expected to be atomic measures, in particular linear combinations of Dirac deltas. Our simulations are thus consistent with the aforementioned papers.</p>

<p>The impulsional behavior of the control is then lost when extending the time horizon beyond $T_{min}$. This is shown in <strong>Figure 3</strong>, in which we display the behavior of the control steering the solution of the fractional heat equation \ref{frac_heat} from the initial datum $z_0$ to the target $\widehat{z}(\cdot,T)$ in the time horizon $T=0.4$.</p>

<h2 id="-2"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/disposition_tlarge.png" alt="GitHub Logo" /></h2>
<p><strong>Figure 3</strong>. Behavior of the control in time $T = 0.4$. The white lines delimit the control region $\omega = (-0.3, 0.8)$. The regions in which the control is active are marked in yellow. The atomic nature is lost.</p>

<p>This control has been computed by employing once again <strong>IpOpt</strong> for solving the following minimization problem:</p>

<script type="math/tex; mode=display">\min\;\|z(\cdot,T)-\widehat{z}(\cdot,T)\|_{L^2(-1,1)}</script>

<p>subject to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
z_t+(-d_x^2)^s z=u\chi_\omega, & a.\,e.\;in\; (-1,1)\times(0,T)
\\
z(x,0)=z_0\geq 0, & a.\,e.\;in\; (-1,1)
\\
z(x,t)\geq 0, & a.\,e.\;in\; (-1,1)\times(0,T)
\\
u(x,t)\geq 0, & a.\,e.\;in\; \omega\times(0,T).
\end{cases} %]]></script>

<p>As we can observe, the action of this control is now more distributed in $\omega$. Neverthelss, in accordance with our theoretical results, the equation is still controllable in the prescribed time horizon (see <strong>Figure 4</strong>)</p>

<h2 id="-3"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/evolution_tlarge.gif" alt="GitHub Logo" /></h2>
<p><strong>Figure 4</strong>. Controllability of the fractional heat equation \ref{frac_heat}in time $T = 0.4$. The atomic behavior of the control is lost.</p>

<p>Finally, we consider the case of a time horizon $T&lt;T_{min}$, in which constrained controllability is expected to fail. This time, we employ a classical conjugate gradient method implemented in the <a href="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/https://deustotech.github.io/dycon-toolbox-documentation/">DyCon Computational Toolbox</a> for solving the above optimization problem.</p>

<p>As before, we apply a FE method for the space discretization of the fractional Laplacian on a uniform space-grid with $N_x=20$ points and we use an explicit Euler scheme for the time integration on a time-grid with $N_t=100$ points. Furthermore, we choose a time horizon $T=0.15$, which is below the minimal controllability time $T_{min}$.</p>

<p>Our simulation then show that the solution of \ref{frac_heat} fails to be controlled. In fact, <strong>Figure 5</strong> shows that the state computed by employing the tools of the <a href="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/https://deustotech.github.io/dycon-toolbox-documentation/">DyCon Computational Toolbox</a> does not totally match the desired target in the time horizon prescribed.</p>

<h2 id="-4"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/evolution_tsmall.gif" alt="GitHub Logo" /></h2>
<p><strong>Figure 5</strong>. Evolution in the time interval $(0,0.15)$ of the solution of \ref{frac_heat} with $s = 0.8$ under the positivity control constraint $u\geq 0$. The equation is not controllable.</p>

<h2 id="references">References</h2>

<p>[1] U. Biccari and V. Hernández-Santamarı́a, <em>Controllability of a one-dimensional fractional heat equation: theoretical and
numerical aspects</em>. IMA J. Math. Control. Inf, to appear, 2018.</p>

<p>[2] U. Biccari, M. Warma and E. Zuazua, <em>Controllability of the one-dimensional fractional heat equation under positivity constraints</em>. Submitted.</p>

<p>[3] J. Loheac, E. Trélat, and E. Zuazua, <em>Minimal controllability time for the heat equation under unilateral state or control
constraints</em>. Math. Models Methods Appl. Sci., Vol. 27, No. 9 (2017), pp 1587-1644.</p>

<p>[4] D. Pighin and E. Zuazua, <em>Controllability under positivity constraints of semilinear heat equations</em>. Math. Control. Relat.
Fields, Vol. 8, No. 3,4 (2018), pp. 935-964.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3 id="a-sample-result"&gt;A sample result&lt;/h3&gt;
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0005/ds.gif" alt="Figure1" /></p>

<p>This video describes an optimal control steering red dots(evaders) to the position $(4,4)$, which is calculated by IpOpt with AMPL. See <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0002">the post explaining IpOpt and AMPL</a> for detailed description.</p>

<h3 id="the-guidance-by-repulsion-model">The guidance-by-repulsion model</h3>

<p>Let $u_{ei}$ and $u_{dj}$ be the positions of the evaders $(i=1,\ldots,N)$ and drivers $(j=1,\ldots,M)$, respectively, in ${\mathbb R}^2$. We consider the following ODE system:</p>

<script type="math/tex; mode=display">\ddot{u}_{dj} = -f_d(|u_{dj} - u_{ec}|)(u_{dj} - u_{ec}) - \nu \dot{u}_{dj} + \kappa_j(t) (u_{dj} - u_{ec})^\perp,\quad u_{ec} := \frac{1}{N}\sum_{k=1}^N u_{ek},</script>

<script type="math/tex; mode=display">\ddot{u}_{ei} =  - \frac{1}{M} \sum_{j=1}^M f_e(|u_{dj} - u_{ei}|)(u_{dj} - u_{ei}) - \nu \dot{u}_{ei}, \\</script>

<script type="math/tex; mode=display">u_{dj}(0) = u_{dj}^0,~ u_{ei}(0) = u_{ei}^0,~ \dot{u}_{dj}(0) = v_{dj}^0, ~ \dot{u}_{ei}(0) = v_{ei}^0,</script>

<p>where $\kappa_j(t)$ is the control interface and the interaction functions are given by</p>

<script type="math/tex; mode=display">f_d(r) = \frac{2}{r^2}-\frac{3}{r^4}+2,\quad f_e(r) = \frac{1}{r^2} \quad\text{and}\quad \nu = 2.</script>

<p>In the dynamics, the evaders always get forced from all of the drivers, while the drivers wants to keep a stable distance ($f_d(1)-f_e(1)=0$). By choosing proper $\kappa_j(t)$, we wants to steer the evaders into a predetermined region.</p>

<p>The objective of the control is given by the cost function with the fixed final time $t_f&gt;0$,</p>

<script type="math/tex; mode=display">J(\kappa_1(\cdot),\ldots,\kappa_M(\cdot)) = \frac{1}{N} \sum_{i=1}^N |u_{ei}(t_f) - u_f|^2 + \frac{\delta_1}{M} \sum_{k=1}^M \int_0^{t_f} |\kappa_k(t)|^2 dt,</script>

<p>where $\delta_1$ is a regularization coefficient, $0.1$ in this post.</p>

<h3 id="ampl-code-for-solving-the-optimal-control-problem">AMPL code for solving the optimal control problem</h3>

<p>Let us explain an AMPL code step by step. First, we need to set relative parameters.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># GBR_fixedtime.mod
</span>
<span class="c1"># This file solves the Guidance-by-repulsion model with 2 drivers and 16 evaders to 
</span>
<span class="c1"># the target point [4;4] in a fixed final time T=10.
</span>
<span class="c1"># Define the parameters of the problem
</span>
<span class="n">param</span> <span class="n">pi</span>      <span class="o">=</span> <span class="mf">3.141592653589793238462643</span><span class="p">;</span> 

<span class="n">param</span> <span class="n">Nt</span>      <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>      <span class="c1"># number of discretized points in time
</span>
<span class="n">param</span> <span class="n">M_sqrt</span>  <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>        <span class="c1"># sqrt of Number of evaders
</span>
<span class="n">param</span> <span class="n">M_e</span>     <span class="o">=</span> <span class="n">M_sqrt</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span> <span class="c1"># Number of evaders
</span>
<span class="n">param</span> <span class="n">M_d</span>     <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>        <span class="c1"># Number of drivers
</span>
<span class="n">param</span> <span class="n">T</span>       <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="n">param</span> <span class="n">M_kappa</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>        <span class="c1"># Bound on the control
</span>
<span class="c1"># Target point
</span>
<span class="n">param</span> <span class="n">uf1</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">param</span> <span class="n">uf2</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div></div>

<p>For the initial condition, we use uniform distribution of evaders in a square $[-1,1]\times[-1,1]$, and the drivers are in a circle with radius $5$.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Initial values
</span>
<span class="n">param</span> <span class="n">ue_zero</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">};</span>
<span class="k">for</span> <span class="p">{</span><span class="n">k1</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_sqrt</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_sqrt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">{</span>
	<span class="n">let</span> <span class="n">ue_zero</span><span class="p">[</span><span class="n">M_sqrt</span><span class="o">*</span><span class="p">(</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">k2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="p">((</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">M_sqrt</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">let</span> <span class="n">ue_zero</span><span class="p">[</span><span class="n">M_sqrt</span><span class="o">*</span><span class="p">(</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">k2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="p">((</span><span class="n">k2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">M_sqrt</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">param</span> <span class="n">ud_zero</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">};</span>
<span class="k">for</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">{</span>
	<span class="n">let</span> <span class="n">ud_zero</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">M_d</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">let</span> <span class="n">ud_zero</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">M_d</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1"># State variables
</span>
<span class="n">var</span> <span class="n">ue</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">};</span>
<span class="n">var</span> <span class="n">ve</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">};</span>
<span class="n">var</span> <span class="n">ud</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">};</span>
<span class="n">var</span> <span class="n">vd</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">};</span>
<span class="n">var</span> <span class="n">uec</span> <span class="p">{</span><span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">M_e</span><span class="o">*</span><span class="p">(</span><span class="nb">sum</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">}</span> <span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]));</span>

<span class="c1"># initialize
</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">ue_init</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ue_zero</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">ud_init</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span> <span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ud_zero</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">vd_init</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span> <span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">ve_init</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span> <span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
<span class="n">let</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n">ue_zero</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">let</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n">ud_zero</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">let</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">let</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</code></pre></div></div>
<p>For the initial guess, we also put the initial data for the whole timeline. If we don’t specify this, then the default values are zero, which can make redundant errors or iterations.</p>

<p>Now, we define the controls and cost.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The control function
</span>
<span class="n">var</span> <span class="n">kappa</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">},</span> <span class="n">default</span> <span class="mf">2.8</span><span class="p">;</span>  
<span class="n">subject</span> <span class="n">to</span> <span class="n">kappa_bounds</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}</span> <span class="p">:</span> <span class="o">-</span><span class="n">M_kappa</span> <span class="o">&lt;=</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">M_kappa</span><span class="p">;</span>
<span class="c1"># initial guess on control
</span>
<span class="n">let</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mf">2.8</span><span class="p">;</span>

<span class="c1"># The cost function
</span>
<span class="n">minimize</span> <span class="n">cost</span><span class="p">:</span> 
 <span class="mi">1</span><span class="o">/</span><span class="n">M_e</span><span class="o">*</span><span class="p">(</span><span class="nb">sum</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">}</span> <span class="p">((</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">uf1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">uf2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">/</span><span class="n">M_d</span><span class="o">/</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="nb">sum</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}</span> <span class="p">((</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span> <span class="p">);</span>
</code></pre></div></div>
<p>The dynamics need to be described in the form of restriction condition of states and control variables. In order to avoid divide-by-zero, we additionally put the restriction on the distance. Since our equation has unbounded interaction kernels, it is convenient to use Euler’s forward method. Backward or central method may result unexpected high velocities by closing to the infinite values.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Restriction on distance
</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">distance</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mf">0.001</span><span class="p">;</span>
<span class="c1"># Dynamics
</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">ue_dyn</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">Nt</span><span class="o">/</span><span class="n">T</span> <span class="o">=</span> <span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">ud_dyn</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">Nt</span><span class="o">/</span><span class="n">T</span> <span class="o">=</span> <span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">ve_dyn</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">Nt</span><span class="o">/</span><span class="n">T</span> <span class="o">=</span> <span class="nb">sum</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">}</span> <span class="p">(</span> <span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="p">((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="p">)</span>  <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">vd1_dyn</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">Nt</span><span class="o">/</span><span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">5.5</span><span class="o">/</span><span class="p">((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="o">/</span><span class="p">(((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">vd2_dyn</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">Nt</span><span class="o">/</span><span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">5.5</span><span class="o">/</span><span class="p">((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="o">/</span><span class="p">(((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
</code></pre></div></div>
<p>The next step is to solve and get the output. It is convenient to describe the parameters of the problem to visualize later.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Solve with IpOpt
</span>
<span class="n">option</span> <span class="n">solver</span> <span class="n">ipopt</span><span class="p">;</span>
<span class="n">option</span> <span class="n">ipopt_options</span> <span class="s">"max_iter=20000 linear_solver=mumps hessian_approximation=limited-memory halt_on_ampl_error yes"</span><span class="p">;</span>
<span class="n">solve</span><span class="p">;</span>
<span class="c1"># Display solution
</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">T</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%</span><span class="s">d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Nt</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%</span><span class="s">d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">M_d</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%</span><span class="s">d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">M_e</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uf1</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uf2</span><span class="p">;</span>

<span class="n">printf</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1..2</span><span class="p">}</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"End. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">end</span><span class="p">;</span>

</code></pre></div></div>

<p>Finally, we used MATLAB to show the trajectories. After copying the result to a file ‘output.txt’, we read it with the following code.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fid</span><span class="o">=</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">'output.txt'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">);</span>            <span class="c1">% Open out.txt</span>
<span class="n">temp</span> <span class="o">=</span> <span class="nb">fscanf</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="s1">'%f'</span><span class="p">);</span>
<span class="n">M_d</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">M_e</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">index1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">M_d</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">M_e</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">uf1</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">uf2</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="n">M_d</span><span class="o">*</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">kappa</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">:</span><span class="n">index2</span><span class="p">);</span> <span class="n">kappa</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span> <span class="p">[</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span> <span class="n">M_d</span><span class="p">]);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">M_e</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">ue</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">:</span><span class="n">index2</span><span class="p">);</span> <span class="n">ue</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">ue</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span> <span class="n">M_e</span><span class="p">]);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">M_d</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">ud</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">:</span><span class="n">index2</span><span class="p">);</span> <span class="n">ud</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">ud</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span> <span class="n">M_d</span><span class="p">]);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">M_e</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">ve</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">:</span><span class="n">index2</span><span class="p">);</span> <span class="n">ve</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">ve</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span> <span class="n">M_e</span><span class="p">]);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">M_d</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">vd</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">:</span><span class="n">index2</span><span class="p">);</span> <span class="n">vd</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">vd</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span> <span class="n">M_d</span><span class="p">]);</span> 
<span class="n">index2</span> <span class="o">==</span> <span class="nb">length</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>      <span class="c1">% Check the file is properly read.</span>
<span class="n">tline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

<span class="nb">fclose</span><span class="p">(</span><span class="n">fid</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">%% Cost calculation</span>

<span class="n">u_f</span> <span class="o">=</span> <span class="p">[</span><span class="n">uf1</span><span class="p">;</span><span class="n">uf2</span><span class="p">];</span>
<span class="n">Final_Time</span> <span class="o">=</span> <span class="n">tline</span><span class="p">(</span><span class="k">end</span><span class="p">);</span>
<span class="n">Final_Position</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">ue</span><span class="p">(:,</span><span class="k">end</span><span class="p">,:),[</span><span class="mi">2</span> <span class="n">M_e</span><span class="p">]);</span>
<span class="n">Final_cost</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">Final_Position</span><span class="p">(</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">-</span> <span class="n">u_f</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">Final_Position</span><span class="p">(</span><span class="mi">2</span><span class="p">,:)</span> <span class="o">-</span> <span class="n">u_f</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span> <span class="p">)/</span><span class="n">M_e</span><span class="p">;</span>
<span class="n">Running_cost</span> <span class="o">=</span> <span class="mf">0.001</span><span class="o">*</span><span class="nb">trapz</span><span class="p">(</span><span class="n">tline</span><span class="p">,</span><span class="nb">mean</span><span class="p">(</span><span class="n">kappa</span><span class="p">(:,</span><span class="mi">1</span><span class="p">:</span><span class="n">M_d</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))/</span><span class="n">M_d</span><span class="p">;</span>

<span class="c1">%% Visualize the trajectories</span>

<span class="n">f1</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">(</span><span class="s1">'position'</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">400</span><span class="p">]);</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">M_d</span>
	<span class="nb">plot</span><span class="p">(</span><span class="n">ud</span><span class="p">(</span><span class="mi">1</span><span class="p">,:,</span><span class="n">k</span><span class="p">),</span><span class="n">ud</span><span class="p">(</span><span class="mi">2</span><span class="p">,:,</span><span class="n">k</span><span class="p">),</span><span class="s1">'b--'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mf">1.3</span><span class="p">);</span>
<span class="k">end</span>
<span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">M_e</span>
	<span class="nb">plot</span><span class="p">(</span><span class="n">ue</span><span class="p">(</span><span class="mi">1</span><span class="p">,:,</span><span class="n">l</span><span class="p">),</span><span class="n">ue</span><span class="p">(</span><span class="mi">2</span><span class="p">,:,</span><span class="n">l</span><span class="p">),</span><span class="s1">'r-'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mf">1.5</span><span class="p">);</span>
<span class="k">end</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'abscissa'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'ordinate'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">([</span><span class="s1">'Position error = '</span><span class="p">,</span> <span class="nb">num2str</span><span class="p">(</span><span class="n">Final_cost</span><span class="p">)])</span>
<span class="nb">grid</span> <span class="n">on</span>
</code></pre></div></div>

<p>Then, one can get the following trajectories and optimal control solution.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0005/D2E16_figure.png" alt="Figure1" /></p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">tline</span><span class="p">,</span><span class="n">kappa</span><span class="s1">','</span><span class="n">LineWidth</span><span class="o">'</span><span class="p">,</span><span class="mf">1.3</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Control \kappa(t)'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">([</span><span class="s1">'Total Time = '</span><span class="p">,</span><span class="nb">num2str</span><span class="p">(</span><span class="n">tline</span><span class="p">(</span><span class="k">end</span><span class="p">)),</span><span class="s1">' and running cost = '</span><span class="p">,</span><span class="nb">num2str</span><span class="p">(</span><span class="n">Running_cost</span><span class="p">)])</span>
<span class="nb">grid</span> <span class="n">on</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0005/D2E16_control.png" alt="Figure2" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3 id="a-coupled-pde-ode-model"&gt;A coupled PDE-ODE model&lt;/h3&gt;
</code></pre></div></div>
<p>We consider the following hybrid PDE-ODE model</p>

<script type="math/tex; mode=display">% <![CDATA[
\left\{
\begin{array}{ll} 
    \partial_t \rho(t,x) + \partial_x (f(\rho(t,x)))=0, & (t,x)\in R^+\times R, \quad \quad \quad \quad \text{(1a)} \\ 
    \rho(0,x)=\rho_{0}(x), & x\in R,\quad \quad \quad \quad \quad \quad \quad \quad \,\text{(1b)}\\
    \dot y_i(t)=v (\rho(t,y_i(t)+))), & t\in R^+, i=1,\cdots,M,\quad \,   \, \, \,\text{(1c)}\\
    y_i(0)=y_0^i, & i=1,\cdots,M.\quad \, \quad \quad \quad \quad \text{(1d)}\\
\end{array}
\right. %]]></script>

<p>Above, (1a) and (1b) consists  of  a  scalar  conservation proposed by Lighthill-Whitham-Richards law  modeling  the  evolution  of vehicular traffic. (1c) and (1d) represent the trajectory of autonomous vehicles. <script type="math/tex">\rho</script> stands for the density of cars and  the flux function <script type="math/tex">f</script> is defined by <script type="math/tex">f(\rho)=\rho v(\rho)</script> with the average speed <script type="math/tex">v(\rho)=1-\rho</script>.</p>

<p>We assume that <script type="math/tex">\bar \rho_0</script> is an unknown function and our goal is to find a time <script type="math/tex">T</script> at which it is possible to reconstruct the true density <script type="math/tex">\rho</script> between two autonomous vehicles based only on the measured local density of each autonomous vehicle.</p>

<p>We introduce the two following operators</p>
<ul>
  <li><script type="math/tex">S_t(\rho_0)(x)</script> is the solution of (1a) at time <script type="math/tex">t</script> and at the position <script type="math/tex">x</script> with initial density <script type="math/tex">\rho_0</script></li>
  <li><script type="math/tex">\Gamma(\rho_0)=(\rho(\cdot,y_i(\cdot)\pm))_{i\in\{1,\cdots,M\}}</script> where <script type="math/tex">(\rho,y_i)</script> is the solution of (1) with initial data <script type="math/tex">\rho_0</script>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/shocksurj11.png" alt="" /></th>
      <th style="text-align: center"> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/shocksurj22.png" alt="" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Figure 1.1 - <script type="math/tex">\rho_0(x)=0.16</script> if <script type="math/tex">% <![CDATA[
x<1.33 %]]></script> and <script type="math/tex">\rho_0(x)=0.63</script> if <script type="math/tex">x>1.33</script> with two autonomous vehicles positioned at <script type="math/tex">y_0^1=0</script> and <script type="math/tex">y_0^2=3</script>.</td>
      <td style="text-align: center"> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>Figure 1.2 - <script type="math/tex">\rho_1(x)=0.16</script> if <script type="math/tex">% <![CDATA[
x<1 %]]></script> and <script type="math/tex">\rho_0(x)=0.47</script> if <script type="math/tex">% <![CDATA[
1<x<2 %]]></script> and <script type="math/tex">\rho_0(x)=0.63</script> if <script type="math/tex">% <![CDATA[
2<2 %]]></script> with two connected vehicles positioned at <script type="math/tex">y_0^1=0</script> and <script type="math/tex">y_0^2=3</script></td>
    </tr>
  </tbody>
</table>

<p>In Figure 1.1 and Figure 1.2, we construct two initial data <script type="math/tex">\rho_0</script> and <script type="math/tex">\rho_1</script> such that <script type="math/tex">\Gamma(\rho_0)=\Gamma(\rho_1)</script> and for every <script type="math/tex">% <![CDATA[
t < 2 %]]></script> , for every <script type="math/tex">x\in[y_1(t),y_2(t)]</script> , <script type="math/tex">S_T(\rho_0)(x) \neq S_T(\rho_1))(x)</script>. Thus, there isn’t backward uniqueness from the trajectory of autonomous vehicles.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/example2_sol.png" alt="" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Figure 1.3 <script type="math/tex">\rho_0(x)=1</script> if <script type="math/tex">% <![CDATA[
x<10 %]]></script> and <script type="math/tex">\rho_0(x)=0</script> if <script type="math/tex">x>10</script> with two autonomous vehicles positioned at $x=8$ and $x=12$ respectively</td>
    </tr>
  </tbody>
</table>

<p>In Figure Figure 1.3, we cannot reconstruct the traffic state at any time using data collected by the two autonomous vehicles. Some additional conditions on the set of initial densities will be require.</p>

<p><strong>Theorem</strong> Let <script type="math/tex">\bar \rho_0 \in BV(R,[0,1])\cap L^1(R)</script> and we assume that for every <script type="math/tex">x\in R</script>, <script type="math/tex">% <![CDATA[
0<\rho_{\min}\leq  \bar \rho_0(x) \leq \rho_{\max} %]]></script>.  For every <script type="math/tex">i\in \{1,\cdots,M-1\}</script> there exists <script type="math/tex">T_i>0</script> such that for every <script type="math/tex">\rho_0 \in \Gamma^{-1}(\Gamma(\bar \rho_0))</script> and  for almost every <script type="math/tex">x\in [y_i(T_i),y_{i+1}(T_i)]</script> we have 
<script type="math/tex">S_{T_i}(\rho_0)(x)= S_{T_i}(\bar \rho_0)(x)</script></p>

<p>The reconstruction time <script type="math/tex">T_i</script> is obtained using the notion of generalized characteristics and <script type="math/tex">T_i</script> has an implicit form.</p>

<h3 id="numerical-simulations">Numerical simulations</h3>
<p>In  Figure 2.1 and  Figure 2.2, we consider the example of two shocks with a fan of rarefaction shocks between the two shocks. A total of three AVs, denoted  by <script type="math/tex">AV_0</script> , <script type="math/tex">AV_1</script> and <script type="math/tex">AV_2</script> , are used to reconstruct the traffic state resulting in two regions of reconstruction between <script type="math/tex">AV_0</script> and <script type="math/tex">AV_1</script> , and between <script type="math/tex">AV_1</script> and <script type="math/tex">AV_2</script> . Specifically, the initial density <script type="math/tex">\rho_0</script> is defined as follows : $\rho_0(x) = 0.0938 $ for $ x\in (-\infty, 8] $, $\rho_0(x) = 0.9062$ for <script type="math/tex">x\in (8, 10]</script>, <script type="math/tex">\rho_0(x) = 0.2188</script> for $x\in (10, 13]$ and $\rho_0(x) = 0.9062$ for <script type="math/tex">x\in (13, \infty)</script>. <script type="math/tex">AV_0</script> , <script type="math/tex">AV_1</script> , and <script type="math/tex">AV_2</script> start at <script type="math/tex">x=5</script> , <script type="math/tex">x=9</script> , and <script type="math/tex">x=12</script> , respectively. The resulting traffic state solved using wave front tracking over the first 20 seconds is shown in Figure 2.1, while the reconstructed state between the AVs is shown in Figure 2.2. The time at which the reconstruction becomes valid is <script type="math/tex">T_{0} = 6.87</script> between <script type="math/tex">AV_0</script> and <script type="math/tex">AV_1</script>, and <script type="math/tex">T_{1} = 3.39</script> between <script type="math/tex">AV_1</script> and <script type="math/tex">AV_2</script>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/paper_example_3_real_sol 2.png" alt="" /></th>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/paper_example_3_reconstruction 2.png" alt="" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Figure 2.1</td>
      <td style="text-align: center">Figure 2.2</td>
    </tr>
  </tbody>
</table>

<p>In  Figure 3.1 and Figure 3.2, one autonomous vehicle, denoted by <script type="math/tex">AV_0</script> , is deployed on a ring. The initial density <script type="math/tex">\rho_0</script> is a <script type="math/tex">10</script>-periodic function  defined as follows:  <script type="math/tex">\rho_0(x) = 0.8125</script> for <script type="math/tex">x\in (0,2)</script> , <script type="math/tex">\rho_0(x) = 0.3125</script> for <script type="math/tex">x\in (2, 10)</script> . Since <script type="math/tex">\rho</script> and <script type="math/tex">y_0</script> are also <script type="math/tex">10</script> periodic functions, both trajectories plotted in red in  Figure 3.2  are  the ones of <script type="math/tex">AV_0</script>. The traffic state on the whole ring can be reconstructed after <script type="math/tex">T_{\max}=15.444</script>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/example_ring_sol.png" alt="" /></th>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/example_ring_reconstruction.png" alt="" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Figure 3.1</td>
      <td style="text-align: center">Figure 3.2</td>
    </tr>
  </tbody>
</table>

<h3 id="references">References</h3>
<p>[1] T.Liard, B. Piccoli, R. Stern, D. Work. <em>Traffic reconstruction using autonomous vehicles</em>; submitted (2019)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In this short tutorial, we explain how to use Riccati’s theory to solve an LQ control problem with targets.&lt;/p&gt;
</code></pre></div></div>

<p>We consider the optimal control problem:</p>

<script type="math/tex; mode=display">\min_{u\in L^2(0,T;\mathbb{R}^m)}J^{T}(u)=\frac12 \left[ \int_0^T  \vert u(t)-q(t) \vert ^2 dt+\beta\int_0^T  \vert C(x(t)-z(t))\vert ^2 dt+\gamma \vert D(x(T)-z(T))\vert ^2\right],</script>

<p>where:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} \frac{d}{dt}x(t)+Ax(t)=Bu(t)\hspace{0.6 cm} & t\in (0,T)\\ x(0)=x_0. \end{cases} %]]></script>

<p>In the above control problem, $A \in M_{n \times n}$, $B \in M_{n \times m}$, $C \in M_{r\times n}$ and $D\in M_{r\times n}$. The control $u:[0,T]\longrightarrow R^m$, while the state $x:[0,T]\longrightarrow R^n$. The control target is $q\in C^1([0,T];R^m)$ and the state target is $z\in C^1([0,T];R^n)$. $\beta\geq 0$ and $\gamma\geq 0$ are positive parameters.</p>

<p>By the Direct Methods in the Calculus of Variations and strict convexity, the above problem admits an unique optimal control $u^T$. The corresponding optimal state is denoted by $x^T$.</p>

<p>We compute the optimal pair (optimal control, optimal state) by using the well-known Riccati’s theory (see, for instance, [1, Lemma 2.6] and [2, section 4.3]).</p>

<p>For further details regarding the algorithm, we refer to <a href="a">href=”https://github.com/DeustoTech/RiccatiLQ/blob/master/RiccatiAlgorithm.pdf”</a> RiccatiAlgorithm <a href="/a">/a</a></p>

<p>Take</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
<span class="n">B</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">0</span><span class="p">];</span>
<span class="n">C</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">D</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">beta</span><span class="o">=</span><span class="mi">26</span><span class="p">;</span>
<span class="nb">gamma</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="mf">1.4</span><span class="p">;</span><span class="mf">1.4</span><span class="p">];</span>
<span class="n">q</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="n">z</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="nb">sin</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="nb">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)];</span>
<span class="n">T</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="n">Nt</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span>
</code></pre></div></div>

<p>We solve an LQ problem with the above data.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span> <span class="n">uopt</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">lqtarget</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="nb">beta</span><span class="p">,</span> <span class="nb">gamma</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span> <span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP02/P0003/copiaRM_01.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP02/P0003/copiaRM_02.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP02/P0003/copiaRM_03.png" alt="" /></p>

<p>Since the parameter $\beta$ is large enough and the control acts only on the first component of first equation</p>

<ul>
  <li>
    <p>the first component of the state is close to the target;</p>
  </li>
  <li>
    <p>the second component of the state is less close to the target;</p>
  </li>
  <li>
    <p>the control is far from its target.</p>
  </li>
</ul>

<p>The algorithm described in this guide can be employed to test the fulfillment of the turnpike property (see, for instance, [1] and [3]). In agreement with the theory, the turnpike effect is evident if:</p>

<ul>
  <li>
    <p>the targets are constants;</p>
  </li>
  <li>
    <p>$(A,B)$ is controllable;</p>
  </li>
  <li>
    <p>$(A,C)$ is observable, $\beta&gt;0$ and $\gamma=0$;</p>
  </li>
  <li>
    <p>the time horizon $T$ is large enough.</p>
  </li>
</ul>

<h1 id="references">References</h1>
<p>[1] Alessio Porretta and Enrique Zuazua, <em>Long time versus steady state optimal control</em>, SIAM Journal on Control and Optimization, 51 (2013).</p>

<p>[2] Emmanuel Trelat, control optimal: theory &amp; applications , Vuibert, 2008.</p>

<p>[3] Emmanuel Trelat and Enrique Zuazua, <em>The turnpike property in finite-dimensional nonlinear optimal control</em>, Journal of Differential Equations, 258 (2015).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;The aim of this tutorial is to give a numerical method for solving a partial differential equation with a constant delay.&lt;/p&gt;
</code></pre></div></div>

<h2 id="introduction">Introduction</h2>

<p>We consider the following one-dimentional reaction-diffusion equation with logistic production and delayed term,</p>

<script type="math/tex; mode=display">\frac{\partial u}{ \partial t} = D \frac{\partial^2 u}{\partial x^2} + r u( 1-u -  f(u_{\tau})),</script>

<p>this equation was suggested in [1] as a model of viral infection spreading in tissues. For the existence of solution and Global stability of the homogeneous in space equilibrium we refer the reader to [2]. Here, $u(x,t)$ is the concentration of virus with respect to the space variable $x$ and time $t$. The parameters $D$ and $r$ are respectively the diffusion coefficient and replication rate constant. The function $f(u_{\tau})$ describes the concentration of immune cells as a function of the virus concentration at time $t-\tau, u_{\tau}(x, t) = u(x, t - \tau)$.</p>

<h2 id="numerical-method">Numerical method</h2>

<p>We rewrite the one-dimentional reaction-diffusion equation with a constant time delay described above with Neumann boundary condition:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \begin{cases} \frac{\partial u}{ \partial t} = D \frac{\partial^2 u}{\partial x^2} + r u( 1-u -  f(u_{\tau})), & (x,t) \in (0,L) \times (0,T), \\ \frac{\partial u(x,t)}{ \partial n}=0, & x \in \{0,L\}, \quad t \in (0,T), \\ u(x,t)=u_0(x,t),     & (x,t) \in [0,L] \times [- \tau,0]. \end{cases} \label{equa1} \end{equation} %]]></script>

<p>where the delay $\tau$ is a positive constant. we use an implicit finite difference approximation for the diffusion term and classical approach of the resolution of delay equations.  let N and M denote the number of space steps and time steps with the notations $\Delta x= L/N$ and $\Delta t= T/M$, respectively.</p>

<p>The discretization of space $x_i$ and time $t_n$ are given by</p>

<script type="math/tex; mode=display">x_i=i\Delta x, \qquad i=0,...,N,</script>

<script type="math/tex; mode=display">t_n=n\Delta t, \qquad n=0,...,M.</script>

<p>Let $u^n_i$  be the approximation of the function $u$ at $(x,t)=(x_i,t_n)$, moreover,</p>

<script type="math/tex; mode=display">\left( \frac{\partial u}{ \partial t} \right)^{n+1}_i= \frac{u^{n+1}_i-u^{n}_i}{\Delta t}, \qquad \left( \frac{\partial^2 u}{ \partial x^2} \right)^{n+1}_i= \frac{u^{n+1}_{i+1}-2 u^{n+1}_i+u^{n+1}_{i-1}}{\Delta x},</script>

<p>We write the scheme of the equation (\ref{equa1}) at the point $u^n_i$,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} \frac{ u^{n+1}_i- u^n_i}{  \Delta t} = D \frac{u^{n+1}_{i+1}-2 u^{n+1}_i+u^{n+1}_{i-1}}{\Delta x} + r u^n_i( 1-u^n_i -  f(u^{n-k}_i)), & i=1,..,N-1, \quad n=0,..,M-1 \\ u^{n+1}_1=u^{n+1}_0, \quad u^{n+1}_{N}=u^{n+1}_{N-1} , & n=0,..,M-1, \\ u^{n-k}_i=u_0(x_i,t_n-\tau),     & i=0,..,N, \quad n=1,..,k.\\ \end{cases} %]]></script>

<p>Where, $u^{n-k}_i \approx u(x_i,t_n-\tau)$ is the delay variable and $k$ is determined by the equality $\tau= k \Delta t$. For simplicity of notation, we denote by $F^{n-k}_i := f(u^{n-k}_i)$ and $G^{n,k}_i:=r u^n_i( 1-u^n_i -  F^{n-k}_i)$, for $i=0,..,N-1, \quad n=1,..,k$ and $n=0,..,M-1$.</p>

<p>The simplest form of this expression is given as follows</p>

<script type="math/tex; mode=display">- \lambda u^{n+1}_{i+1} + (1+2\lambda) u^{n+1}_i - \lambda u^{n+1}_{i-1} = u^n_i + G^{n,k}_i, \text{ for } i=0,..,N-1,</script>

<p>where $\lambda= D \Delta t /(\Delta x)^2$.</p>

<p>Now, we can write the following semi-linear system with Neumann boundary condition</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*} \begin{array}{lll} \left( \begin{array}{ccccc} 1+\lambda 	&-\lambda	  &             &		\dots 		& 0		\\ -\lambda 		&1+2\lambda 	  		& -\lambda 	&    & 	\vdots	\\ \vdots		&\ddots       & \ddots		&       \ddots 		&	\\ &             &  -\lambda   &       1+2\lambda	& -\lambda	 \\ 0 & 		\dots		& 	&-\lambda	& 1+\lambda \end{array} \right) \left( \begin{array}{c} U_1 \\ U_2 \\ \vdots \\ \\ U_{N-2} \\ U_{N-1}	 . \end{array} \right)^{n+1} =  \left( \begin{array}{c} U_1 \\ U_2 \\ \vdots \\  \\  U_{N-2} \\ U_{N-1}	 .  \end{array} \right)^{n} +  \left( \begin{array}{c} G_1 \\ G_2 \\ \vdots \\ \\ G_{N-2} \\ G_{N-1}	 . \end{array} \right)^{n,k}


\end{array} \end{equation*} %]]></script>

<p>First, we fix the parametrs as follows $T=10$, $\tau=1$, $L=1$, $D=1$, $r=1$,</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clear</span> <span class="p">;</span>
<span class="nb">close</span> <span class="p">;</span>
<span class="nb">clc</span><span class="p">,</span>
<span class="nb">tic</span>
<span class="n">T</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="n">M</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span>
<span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">epsilon</span><span class="o">=</span><span class="mi">10</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">);</span>
<span class="n">D</span><span class="o">=</span><span class="mf">0.01</span><span class="p">;</span>
<span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">to</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="n">N</span><span class="o">=</span><span class="mi">200</span><span class="p">;</span>
<span class="n">dx</span><span class="o">=</span><span class="n">L</span><span class="p">/(</span><span class="n">N</span><span class="p">);</span>
<span class="n">dt</span><span class="o">=</span><span class="n">T</span><span class="p">/</span><span class="n">M</span><span class="p">;</span>
<span class="n">x</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="p">;</span>
<span class="n">lambda</span><span class="o">=</span><span class="n">dt</span><span class="o">*</span><span class="n">D</span><span class="p">/(</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
<span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">M</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">;</span>
</code></pre></div></div>

<p>The tridiagonal matrix with Neumann condition</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">D</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">lambda</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">-</span><span class="n">lambda</span><span class="o">*</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">lambda</span><span class="o">*</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">B</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="n">lambda</span><span class="p">;</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span> <span class="p">[</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="p">[</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="o">-</span><span class="n">lambda</span><span class="p">]];</span>
<span class="n">A</span><span class="o">=</span><span class="n">D</span><span class="o">+</span><span class="n">B</span><span class="p">;</span>
</code></pre></div></div>

<p>The initial function $u_0$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">U</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">U</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">u0</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">0</span><span class="p">);</span>
<span class="k">end</span>
<span class="nb">figure</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">U</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Initial function u_0(x)'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0007/copiaRM_01.png" alt="" /></p>

<p>The delay function $f(u_{\tau})$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="o">=@</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span> <span class="p">;</span>
<span class="n">Q</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span>
 <span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>   <span class="p">;</span>
<span class="k">end</span>

<span class="nb">figure</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'The function f'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0007/copiaRM_02.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Ut</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Fretard</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Uf</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Uf</span><span class="o">=</span><span class="n">U</span><span class="p">;</span>
</code></pre></div></div>

<p>We introduce the following test to get $u(x, t-\tau)$,</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span> <span class="o">=</span>        <span class="nb">figure</span><span class="p">;</span>
<span class="n">ax</span>  <span class="o">=</span> <span class="nb">axes</span><span class="p">(</span><span class="s1">'Parent'</span><span class="p">,</span><span class="n">fig</span><span class="p">,</span><span class="s1">'XLim'</span><span class="p">,[</span><span class="mi">0</span> <span class="n">L</span><span class="p">],</span><span class="s1">'YLim'</span><span class="p">,[</span><span class="mi">0</span> <span class="mf">1.1</span><span class="p">]);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XLabel</span><span class="o">.</span><span class="n">String</span> <span class="o">=</span> <span class="s1">'space'</span><span class="p">;</span>

<span class="c1">%%gif('pdedelay4.gif','frame',fig,'DelayTime',1)</span>
<span class="k">for</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">M</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">to</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">to</span><span class="p">)</span><span class="o">&lt;</span><span class="n">epsilon</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">Ut</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">u0</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">to</span><span class="p">);</span>
            <span class="n">Fretard</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">Ut</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
        <span class="k">end</span>
    <span class="k">else</span>
        <span class="n">s</span><span class="o">=</span><span class="nb">floor</span><span class="p">((</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">to</span><span class="p">)/</span><span class="n">dt</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">Ut</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">Uf</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
            <span class="n">Fretard</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">Ut</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">Uold</span><span class="o">=</span><span class="n">U</span><span class="p">;</span>
    <span class="n">Ur</span><span class="o">=</span><span class="n">dt</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="n">Uold</span><span class="o">.*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Uold</span><span class="o">-</span><span class="n">Fretard</span><span class="p">);</span>
    <span class="n">U</span><span class="o">=</span><span class="n">A</span><span class="p">\(</span><span class="n">Uold</span><span class="o">+</span><span class="n">Ur</span><span class="p">);</span>
    <span class="c1">%%</span>
    <span class="c1">%% We plot the evolution of solution $u(x,t)$ at</span>
    <span class="c1">%% $t= \Delta t, \tau, 2 \tau, 3\tau, ...$,</span>
    <span class="c1">%% when $\tau=0$, we plot the solution for $t=5, 10, 15, ...$</span>
    <span class="c1">%%</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">dt</span><span class="p">)</span><span class="o">||</span> <span class="p">(</span><span class="nb">mod</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">to</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">to</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(((</span><span class="nb">mod</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="mi">5</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="n">M</span><span class="p">)))))</span>

        <span class="n">ll</span> <span class="o">=</span><span class="nb">line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">Uold</span><span class="p">,</span><span class="s1">'Color'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">'Parent'</span><span class="p">,</span><span class="n">ax</span><span class="p">);</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">Title</span><span class="o">.</span><span class="n">String</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'t='</span><span class="p">,</span><span class="nb">num2str</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))];</span>
        <span class="nb">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">%%gif;</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">Uf</span><span class="o">=</span><span class="p">[</span><span class="n">Uf</span><span class="p">,</span><span class="n">U</span><span class="p">];</span>
<span class="k">end</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0007/pdedelay4.gif" alt="" /></p>

<p>The solution $u(x,t)$ of PDE with delay</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">[</span><span class="n">X</span> <span class="p">,</span> <span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,[</span><span class="n">t</span><span class="p">]);</span>
<span class="nb">mesh</span> <span class="p">(</span><span class="n">X</span> <span class="p">,</span> <span class="n">Y</span> <span class="p">,</span> <span class="n">Uf</span><span class="o">'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'The evolution of solution u(x,t)'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0007/copiaRM_03.png" alt="" /></p>

<h2 id="references">References</h2>

<p>[1]  G.Bocharov, A. Meyerhans, N. Bessonov, S. Trofimchuk, V. Volpert. Spatiotemporal dynamics of virus infection spreading in tissues. PlosOne, December 20, 2016.</p>

<p>[2]   T. M. Touaoula, M. N. Frioui, N. Bessonov, V. Volpert Dynamics of solutions of a reaction-diffusion equation with delayed inhibition. Manuscript submitted for publication.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3 id="a-multiscale-geometrical-basis-for-variational-problems-in-mechanics"&gt;&lt;em&gt;A Multiscale Geometrical Basis for Variational Problems in Mechanics&lt;/em&gt;&lt;/h3&gt;
</code></pre></div></div>

<p>This tutorial introduces the notion of <em>structured deformation</em> and shows an easy one-dimensional example.</p>

<p>In the continuum theories of bodies deformations, it is necessary to account for mechanisms of different nature that happen at different length scales. These include</p>

<ul>
  <li>elastic deformations during which, once the load on the body is released, the original configuration is restored;</li>
  <li>plastic deformations, which involve a permanent macroscopic deformation after releasing the external load. This permanent macroscopic deformation is explained by means of the reorganisation of atomic bonds;</li>
  <li>fractures, which involve rupture of the material both at the microscopic and at the macroscopic length scales.</li>
</ul>

<p>Structured deformations <a href="#DPO1993">[DPO1993]</a> provide a multiscale geometry that captures the contributions at the macroscopic level of both smooth and non-smooth geometrical changes at sub-macroscopic levels. The latter are called <em>disarrangements</em>. <br />
To encode information of phenomena happening at different length scales in one mathematical object, a (first-order) structured deformation is defined as a pair <script type="math/tex">(g,G)</script>, where <script type="math/tex">g</script> is the macroscopic deformation, the tensor field <script type="math/tex">G</script> is a measure of deformations without disarrangements (the smooth microscopic deformation), and <script type="math/tex">M:=\nabla g-G</script> is a measure of deformations due to disarrangements (the smooth microscopic deformation).
<br />
One can recover the standard notions of plastic deformation from <script type="math/tex">G</script> and <script type="math/tex">M</script>, as well as information on the Burgers vector field associated with closed
curves in the body and the dislocation density field used in describing geometrical changes in bodies with defects from <script type="math/tex">M</script> and <script type="math/tex">\mathrm{curl}M</script> <a href="O2017">[O2017]</a>.</p>

<p>Structured deformations have been set in an energetic formulation framework <a href="#CF1997">[CF1997]</a>, therefore rendering them apt to be studied with variational techniques. In this context, considering suitable function spaces was fundamental to give <script type="math/tex">(g,G)</script> citizenship in the realm of the calculus of variations. The functional-analytic choice of the space <script type="math/tex">SD(\Omega;\mathbb{R}^d)</script>, the set of <script type="math/tex">\mathbb{R}^d</script>-valued structured deformations on <script type="math/tex">\Omega\subset\mathbb{R}^N</script>, was dictated by the necessity of treating the non-smooth behaviours described by the disarrangement tensor <script type="math/tex">M</script>. Being able to describe the discontinuities of the deformation suggested that a good space for <script type="math/tex">g</script> be <script type="math/tex">SBV(\Omega;\mathbb{R}^d)</script>, the space of <script type="math/tex">\mathbb{R}^d</script>-valued <em>special functions of bounded variation</em>. Consequently, the matrix-valued field <script type="math/tex">G</script> is assumed to live in <script type="math/tex">L^1(\Omega;\mathbb{R}^{d\times N})</script>, so that</p>

<script type="math/tex; mode=display">SD(\Omega;\mathbb{R}^d):= SBV(\Omega;\mathbb{R}^d) \times L^1(\Omega;\mathbb{R}^{d\times N}).</script>

<h3 id="aside-on-bv-functions">Aside on <script type="math/tex">BV</script> functions</h3>
<p>Functions of bounded variation are integrable functions whose distributional derivative is a finite Radon measure, in symbols</p>

<script type="math/tex; mode=display">BV(\Omega;\mathbb{R}^d):=\big\{u\in L^1(\Omega;\mathbb{R}^d): Du\in\mathcal{M}(\Omega;\mathbb{R}^{d\times N})\big\}.</script>

<p>It is known that the distributional derivative <script type="math/tex">Du</script> admits a decomposition into three pieces, namely an absolutely continuous part with respect to the Lebesgue measure <script type="math/tex">\mathcal{L}^N</script>, whose density is given by the gradient <script type="math/tex">\nabla u</script>; a jump part, which is concentrated on an <script type="math/tex">(N-1)</script>-dimensional set <script type="math/tex">S_u</script> and whose density with respect to the Hausdorff measure <script type="math/tex">\mathcal{H}^{N-1}</script> is given by <script type="math/tex">[u]\otimes\nu_u</script> (<script type="math/tex">[u]</script> being the jump of <script type="math/tex">u</script> across the <em>singular set</em> <script type="math/tex">S_u</script>, and <script type="math/tex">\nu_u</script> being the normal vector to <script type="math/tex">S_u</script>); and a part <script type="math/tex">D^c u</script> which is singular with respect to both <script type="math/tex">\mathcal{L}^N</script> and <script type="math/tex">\mathcal{H}^{N-1}</script>, called the <em>Cantor part</em>. To summarise,</p>

<script type="math/tex; mode=display">Du=\nabla u\mathcal{L}^N+[u]\otimes\nu_u\mathcal{H}^{N-1}\lfloor S_u+D^c u.</script>

<p>Special functions of bounded variations are those whose distributional derivative has no Cantor part,</p>

<script type="math/tex; mode=display">SBV(\Omega;\mathbb{R}^d):=\big\{u\in BV(\Omega;\mathbb{R}^d): D^c u=0\big\},</script>

<p>so that, for <script type="math/tex">u\in SBV(\Omega;\mathbb{R}^d)</script> we have <script type="math/tex">Du=\nabla u\mathcal{L}^N+[u]\otimes\nu_u\mathcal{H}^{N-1}\lfloor S_u</script>.</p>

<p><br /></p>

<p>One of the fundamental results contained in the seminal paper <a href="#DPO1993">[DPO1993]</a> is the <em>Approximation Theorem</em>, stating that any structured deformation <script type="math/tex">(g,G)</script> can be approximated by a sequence of simple deformations; in the language of <a href="#CF1997">[CF1997]</a>, the approximation theorem reads
<br />
<strong>Approximation Theorem</strong>: <em>Given <script type="math/tex">(g,G)\in SD(\Omega;\mathbb{R}^d)</script>, there exists a sequence <script type="math/tex">u_n\in SBV(\Omega;\mathbb{R}^d)</script> such that</em></p>

<script type="math/tex; mode=display">u_n\to g\quad \text{in $L^1(\Omega;\mathbb{R}^d)$} \qquad \text{and} \qquad \nabla u_n\stackrel{*}{\rightharpoonup}G\quad \text{in $\mathcal{M}(\Omega;\mathbb{R}^{d\times N})$.}</script>

<p>Given the structure of the distributional derivative, it is not difficult to see that the singular part <script type="math/tex">D^s u</script> of <script type="math/tex">Du</script> behaves as below</p>

<script type="math/tex; mode=display">D^s u_n\stackrel{*}{\rightharpoonup} (\nabla g-G)\mathcal{L}^N+ D^s g,</script>

<p>stating that the discontinuities of the approximating sequence <script type="math/tex">u_n</script> converge, in the sense of measures, to a limiting measure which is both diffuse and singular. Therefore, if a structured deformation is such that its disarrangement tensor <script type="math/tex">M=\nabla g-G</script> is non-trivial, it can be approximated by functions with discontinuities which, in the limit, diffuse in the bulk. This has the effect of making the approximating sequence achieve the given structured deformation <script type="math/tex">(g,G)</script> while also achieving <script type="math/tex">M</script>. In a sense, the disarrangement tensor <script type="math/tex">M</script> is a measure of how non-classical a deformation is.</p>

<h2 id="an-example-of-a-1d-structured-deformation">An example of a <script type="math/tex">1D</script> structured deformation</h2>
<p>In this example, we consider a one-dimensional structured deformation and show how it can be approximated. Let <script type="math/tex">\Omega=(0,1)</script>, and let <script type="math/tex">g(x)=2x</script>, <script type="math/tex">G(x)=1</script>. This pair <script type="math/tex">(g,G)</script> describes the deformation of a material which is stretched macroscopically to twice its size by the <script type="math/tex">g</script>, whereas the smooth part of the microscopic deformation has a gradient <script type="math/tex">G</script> equal to the identity.</p>

<p>How is it possible, then, to approximate <script type="math/tex">(g,G)</script> with a sequence of deformations which behave microscopically like the identity, but achieve the overall effect to stretch the material? Such an approximating sequence should have jumps to allow the material to deform macroscopically, while keeping a microscopical deformation gradient of <script type="math/tex">1</script>. The sequence</p>

<script type="math/tex; mode=display">% <![CDATA[
u_n(x):=x+{k\over n},\qquad \text{for ${k\over n}\leq x<{k+1\over n}$},\qquad k\in\{0,1,\ldots, n-1\} %]]></script>

<p>behaves as desired and approximates <script type="math/tex">(g,G)</script> in the sense described in the Approximation Theorem above. As a matter of fact, <script type="math/tex">u_n\to g</script> and <script type="math/tex">u_n'\to G</script> (even) in <script type="math/tex">L^\infty(0,1)</script>. We can get more information on how the jumps of <script type="math/tex">u_n</script> diffuse in the whole interval <script type="math/tex">(0,1)</script> by looking at the distributional gradient</p>

<script type="math/tex; mode=display">Du_n=1\cdot\mathcal{L}^{N}+D^s u_n=1+\sum_{k=1}^{n-1}{1\over n}\delta_{k/n}</script>

<p>Since <script type="math/tex">D^s g=0</script>, the limit of <script type="math/tex">D^s u_n=\sum_{k=1}^{n-1} {1\over n}\delta_{k/n}</script> recovers just the difference <script type="math/tex">u_n'-G=1</script>. A stronger link between these two quantities is evident considering that <script type="math/tex">\sum_{k=1}^{n-1} {1\over n}\delta_{k/n}</script> is the Riemann sum of the function <script type="math/tex">f(x)=1</script> on <script type="math/tex">(0,1)</script>. A depiction of the first elements of the sequence <script type="math/tex">u_n</script> is provided in the picture below.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0007/p0018_50.png" alt="" /></p>

<center>approximation of the broken ramp</center>

<h1 id="references">References</h1>

<p><a name="CF1997">R. Choksi and I. Fonseca: <em>Bulk and Interfacial Energy Densities for Structured Deformations of Continua</em>. Arch. Rational Mech. Anal. <strong>138</strong> (1997), 37-103.</a></p>

<p><br />
<a name="DPO1993">G. Del Piero and D. R. Owen: <em>Structured Deformation of Continua</em>. Arch. Rational Mech. Anal. <strong>124</strong> (1993), 99-155.</a>
<br /></p>

<p><a name="O2017">D. R. Owen: <em>Elasticity with Gradient-Disarrangements: A Multiscale Perspective for Strain-Gradient Theories of Elasticity and of Plasticity</em>. J. Elast. <strong>127</strong> (2017), 115-150.</a></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;The time dependent transmission problem is as follows, where we consider a domain $\Omega \subset \mathbb{R}^2$ which is cut into two subdomains $\Omega_1 \cup \Omega_2 = \Omega$ with transmission conditions at the interface $\Gamma = \Omega_1 \cap \Omega_2$:&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align} \begin{split} & \alpha_m \frac{\partial u_m(\textbf{x},t)}{\partial t} - \nabla \cdot (\lambda_m  \nabla u_m(\textbf{x},t)) = 0,\  \  t \in [t_0, t_f],  \  \  \textbf{x} \in \Omega_m \subset \mathbb{R}^2, \\ & u_m(\textbf{x},t) = 0, \  \  t \in [t_0, t_f], \  \  \textbf{x} \in \partial \Omega_m \backslash \Gamma, \\ & u_1(\textbf{x},t) = u_2(\textbf{x},t), \  \  \textbf{x} \in \Gamma, \\ & \lambda_2 \frac{\partial u_2(\textbf{x},t)}{\partial \textbf{n}_2} = -\lambda_1 \frac{\partial u_1(\textbf{x},t)}{\partial \textbf{n}_1}, \  \  \textbf{x} \in \Gamma, \\ & u_m(\textbf{x},0) = u_m^0(\textbf{x}), \  \  \textbf{x} \in \Omega_m, \end{split} \end{align} %]]></script>

<p>where $\textbf{n}_m$ is the outward normal to $\Omega_m$ for $m=1,2$.</p>

<p>The constants $\lambda_1$ and $\lambda_2$ describe the thermal conductivities of the materials on $\Omega_1$ and $\Omega_2$ respectively. $D_1$ and $D_2$ represent the thermal diffusivities of the materials and they are defined by</p>

<script type="math/tex; mode=display">\begin{align} D_m = \frac{\lambda_m}{\alpha_m}, \  \  \mbox{with} \  \  \alpha_m = \rho_m c_{p_m} \end{align}</script>

<p>where $\rho_m$ represents the density and $c_{p_m}$ the heat capacity of the material placed in $\Omega_m$, $m=1,2$.</p>

<h2 id="discretization">DISCRETIZATION</h2>

<p>Let $u_I^{(1)}$ and $u_I^{(2)}$ correspond to the unknowns on $\Omega_1$ and $\Omega_2$ respectively and $u_{\Gamma}$ correspond to the unknows at the interface $\Gamma$, then the compact 2D finite difference (FD) formulation on equidistant meshes of (1) for the vector of unknowns</p>

<script type="math/tex; mode=display">\textbf{u} = (\textbf{u}_I^{(1)}, \textbf{u}_I^{(2)}, \textbf{u}_{\Gamma})^T</script>

<p>will be</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \tilde{\textbf{M}} \dot{\textbf{u}} - \tilde{\textbf{A}} \textbf{u} = 0 \  \  \mbox{where} \  \  \tilde{\textbf{M}} = \left( \begin{array}{ccc} \textbf{M}_1 & \textbf{0} & \textbf{M}_{I \Gamma}^{(1)} \\ \textbf{0} & \textbf{M}_2 & \textbf{M}_{I \Gamma}^{(2)} \\ \textbf{M}_{\Gamma I}^{(1)} & \textbf{M}_{\Gamma I}^{(2)} & \textbf{M}_{\Gamma \Gamma}^{(1)} + \textbf{M}_{\Gamma \Gamma}^{(2)} \end{array} \right), \  \  \tilde{\textbf{A}} = \left( \begin{array}{ccc} \textbf{A}_1 & \textbf{0} & \textbf{A}_{I \Gamma}^{(1)} \\ \textbf{0} & \textbf{A}_2 & \textbf{A}_{I \Gamma}^{(2)} \\ \textbf{A}_{\Gamma I}^{(1)} & \textbf{A}_{\Gamma I}^{(2)} & -\textbf{A}_{\Gamma \Gamma}^{(1)} - \textbf{A}_{\Gamma \Gamma}^{(2)} \end{array} \right), \end{equation} %]]></script>

<p>for the mass matrices $M_m$, $M_{\Gamma \Gamma}^{(m)}$, $M_{I \Gamma}^{(m)}$, $M_{\Gamma I}^{(m)}$ and the stiffness matrices</p>

<script type="math/tex; mode=display">\textbf{A}_m, \textbf{A}_{\Gamma \Gamma}^{(m)}, \textbf{A}_{I \Gamma}^{(m)}, \textbf{A}_{\Gamma I}^{(m)}</script>

<p>for $m=1,2$.</p>

<p>Applying the implicit Euler method with time step $\Delta t$ to the system (3), we get for the vector of unknowns</p>

<script type="math/tex; mode=display">u^{n+1} = (u_I^{(1),n+1}, u_I^{(2),n+1}, u_{\Gamma}^{n+1})^T</script>

<script type="math/tex; mode=display">\begin{equation} \textbf{A} \textbf{u}^{n+1} = \tilde{\textbf{M}} \textbf{u}^n \  \  \mbox{where} \  \  \textbf{A} = \tilde{\textbf{M}} - \Delta t \tilde{\textbf{A}}. \end{equation}</script>

<h2 id="dirichlet-neumann-iteration">DIRICHLET-NEUMANN ITERATION</h2>

<p>We now employ a standard Dirichlet-Neumann iteration to solve the discrete system (4), getting in the $k$-th iteration the two equation systems</p>

<script type="math/tex; mode=display">\begin{equation} (\textbf{M}_1 - \Delta t \textbf{A}_1) \textbf{u}_I^{(1),n+1,k+1} = -(\textbf{M}_{I \Gamma}^{(1)} - \Delta t \textbf{A}_{I \Gamma}^{(1)}) \textbf{u}_{\Gamma}^{n+1,k} + \textbf{M}_1 \textbf{u}_I^{(1),n} + \textbf{M}_{I \Gamma}^{(1)} \textbf{u}_{\Gamma}^n, \end{equation}</script>

<script type="math/tex; mode=display">\begin{equation} \hat{\textbf{A}} \hat{\textbf{u}}^{k+1} = \hat{\textbf{M}} \textbf{u}^n - \textbf{b}^k, \end{equation}</script>

<p>to be solved in succession. Here,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \begin{split} \hat{\textbf{A}} = \left( \begin{array}{cc} \textbf{M}_2 - \Delta t \textbf{A}_2 & \textbf{M}_{I \Gamma}^{(2)} - \Delta t \textbf{A}_{I \Gamma}^{(2)} \\ \textbf{M}_{\Gamma I}^{(2)} - \Delta t \textbf{A}_{\Gamma I}^{(2)} & \textbf{M}_{\Gamma \Gamma}^{(2)} + \Delta t \textbf{A}_{\Gamma \Gamma}^{(2)} \end{array} \right), \  \  \hat{\textbf{M}} = \left( \begin{array}{ccc} \textbf{0} & \textbf{M}_2 & \textbf{M}_{I \Gamma}^{(2)} \\ \textbf{M}_{\Gamma I}^{(1)} & \textbf{M}_{\Gamma I}^{(2)} & \textbf{M}_{\Gamma \Gamma}^{(1)} + \textbf{M}_{\Gamma \Gamma}^{(2)} \end{array} \right) \  \  \mbox{and} \\ \textbf{b}^k = \left( \begin{array}{c} \textbf{0} \\ (\textbf{M}_{\Gamma I}^{(1)} - \Delta t \textbf{A}_{\Gamma I}^{(1)}) \textbf{u}_I^{(1),n+1,k+1} + (\textbf{M}_{\Gamma \Gamma}^{(1)} + \Delta t \textbf{A}_{\Gamma \Gamma}^{(1)}) \textbf{u}_{\Gamma}^{n+1,k} \end{array} \right),  \  \  \hat{\textbf{u}}^{k+1} = \left( \begin{array}{c} \textbf{u}_I^{(2),n+1,k+1} \\ \textbf{u}_{\Gamma}^{n+1,k+1} \end{array} \right) \nonumber \end{split} \end{equation} %]]></script>

<p>with some initial condition, here $u_{\Gamma}^{n+1,0} = u_{\Gamma}^{n}$. The iteration is terminated according to the standard criterion</p>

<script type="math/tex; mode=display">\vert \textbf{u}_{\Gamma}^{k+1} - \textbf{u}_{\Gamma}^k \vert \leq \tau</script>

<p>where $\tau$ is a user defined tolerance.</p>

<h2 id="implementation">IMPLEMENTATION</h2>

<p>We consider here the thermal interaction between two different materials which physical properties are described by their thermal conductivities and diffusivities $\lambda_1$, $\lambda_2$ and $D_1$, $D_2$ respectively. Furthermore, we consider the non overlapping identical domains $\Omega_1 = [0,1] \times [0,1]$ and $\Omega_2 = [1,2] \times [0,1]$.</p>

<p>The initialization parameters look as follows:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Ns</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>          <span class="c1">%% space discretization points in each dimension</span>
<span class="n">dx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/(</span><span class="n">Ns</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">%% mesh size</span>
<span class="n">tf</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>   <span class="n">t0</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">%% final time - initial time</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>           <span class="c1">%% time discretization points</span>
<span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-</span><span class="n">t0</span><span class="p">)/</span><span class="n">Nt</span><span class="p">;</span>  <span class="c1">%% stepsize</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">D1</span>      <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>    <span class="c1">%% thermal diffusivity of material on domain 1</span>
<span class="n">D2</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">%% thermal diffusivity of material on domain 2</span>
<span class="n">lambda1</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>    <span class="c1">%% thermal conductivity material on domain 1</span>
<span class="n">lambda2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">%% thermal conductivity material on domain 2</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alpha1</span>  <span class="o">=</span> <span class="n">lambda1</span><span class="p">/</span><span class="n">D1</span><span class="p">;</span>
<span class="n">alpha2</span>  <span class="o">=</span> <span class="n">lambda2</span><span class="p">/</span><span class="n">D2</span><span class="p">;</span>
</code></pre></div></div>

<p>In addition to the parameters above, other objects need to be specified before starting the iterative procedure. The space grids both in $x$-direction and $y$-direction are given to later plot the numerical solution, also the initial conditions $u_m^0(x)$, $x \in \Omega_m$ and the mass and stiffness matrices coming from the space discretization:</p>

<p>space grid w.r.t component x</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xplot</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
<span class="c1">%% space grid w.r.t component y</span>
<span class="n">yplot</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">%%</span>
<span class="c1">%% this functions gives the initial conditions w.r.t. domain 1 (U1_0), domain 2 (U2_0) and interface unknowns (UG_0).</span>
<span class="p">[</span><span class="n">U1_0</span><span class="p">,</span> <span class="n">U2_0</span><span class="p">,</span> <span class="n">UG_0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_conditions</span><span class="p">(</span><span class="n">Ns</span><span class="p">);</span>
<span class="c1">%%</span>
<span class="c1">%% this function calculates the discretization matrices using finite differences</span>
<span class="p">[</span><span class="n">A1</span><span class="p">,</span><span class="n">A2</span><span class="p">,</span><span class="n">A1g</span><span class="p">,</span><span class="n">A2g</span><span class="p">,</span><span class="n">Ag1</span><span class="p">,</span><span class="n">Ag2</span><span class="p">,</span><span class="n">Agg1</span><span class="p">,</span><span class="n">Agg2</span><span class="p">,</span><span class="n">M1</span><span class="p">,</span><span class="n">M2</span><span class="p">,</span><span class="n">M1g</span><span class="p">,</span><span class="n">M2g</span><span class="p">,</span><span class="n">Mg1</span><span class="p">,</span><span class="n">Mg2</span><span class="p">,</span><span class="n">Mgg1</span><span class="p">,</span><span class="n">Mgg2</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_matrices</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="n">lambda1</span><span class="p">,</span><span class="n">lambda2</span><span class="p">,</span><span class="n">alpha1</span><span class="p">,</span><span class="n">alpha2</span><span class="p">);</span>
</code></pre></div></div>

<p>Then, the iterative procedure takes place where the equations (4) and (5) are solved alternatively on $\Omega_1$ and $\Omega_2$ respectively until convergence is achieved at each time step. The implementation is specified below:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UG_old</span> <span class="o">=</span> <span class="n">UG_0</span><span class="p">;</span> <span class="c1">%% UG_0 is fixed over the Dirichlet-Neumann iteration while UG_old is being updated</span>
<span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">%% gif('2D_FDM.gif','frame',figure(1))</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">%% time recursion</span>
    <span class="c1">%% initial guess for the stopping criteria of the inner fixed point iteration</span>
    <span class="nb">error</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="c1">%% Dirichlet-Neumann iteration</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">error</span><span class="o">&gt;</span><span class="mf">1e-10</span><span class="p">)</span>
        <span class="c1">%% solve problem on domain 1 using Dirichlet BC at the interface</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">solve_dirichlet</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">U1_0</span><span class="p">,</span><span class="n">UG_0</span><span class="p">,</span><span class="n">A1</span><span class="p">,</span><span class="n">M1</span><span class="p">,</span><span class="n">A1g</span><span class="p">,</span><span class="n">M1g</span><span class="p">,</span><span class="n">UG_old</span><span class="p">);</span>
        <span class="c1">%% solve problem on domain 2 using Neumann BC at the interface</span>
        <span class="p">[</span><span class="n">U2</span><span class="p">,</span> <span class="n">UG_new</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve_neumann</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">U1_0</span><span class="p">,</span><span class="n">U2_0</span><span class="p">,</span><span class="n">UG_0</span><span class="p">,</span><span class="n">A2</span><span class="p">,</span><span class="n">M2</span><span class="p">,</span><span class="n">Ag2</span><span class="p">,</span><span class="n">Mg2</span><span class="p">,</span><span class="n">A2g</span><span class="p">,</span><span class="n">M2g</span><span class="p">,</span><span class="n">Agg1</span><span class="p">,</span><span class="n">Agg2</span><span class="p">,</span><span class="n">Mgg1</span><span class="p">,</span><span class="n">Mgg2</span><span class="p">,</span><span class="n">Ag1</span><span class="p">,</span><span class="n">Mg1</span><span class="p">,</span><span class="n">U1</span><span class="p">,</span><span class="n">UG_old</span><span class="p">);</span>
        <span class="c1">%% calculate value for the stopping criteria (difference between two consecutive iterates at the interface)</span>
        <span class="nb">error</span> <span class="o">=</span> <span class="nb">norm</span><span class="p">(</span><span class="n">UG_old</span> <span class="o">-</span> <span class="n">UG_new</span><span class="p">);</span>
        <span class="c1">%% update UG_old</span>
        <span class="n">UG_old</span> <span class="o">=</span> <span class="n">UG_new</span><span class="p">;</span>

        <span class="c1">%%put together U1,U2 and UG_old for plotting</span>
        <span class="n">Uplot</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Ns</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
        <span class="n">Uplot</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">Ns</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">U1</span><span class="p">;</span>
        <span class="n">Uplot</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">UG_old</span><span class="p">;</span>
        <span class="n">Uplot</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="o">+</span><span class="mi">3</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">U2</span><span class="p">;</span>

<span class="c1">%%         figure(1)</span>
<span class="c1">%%         mesh(xplot,yplot,Uplot);</span>
<span class="c1">%%         zlim([-80 40])</span>
<span class="c1">%%         xlabel('x')</span>
<span class="c1">%%         ylabel('y')</span>
<span class="c1">%%         zlabel('u(x,y)')</span>
<span class="c1">%%         title(['Numerical solution at time: t = ',num2str(k*dt)])</span>
<span class="c1">%%         gif</span>
<span class="c1">%%         pause(0.1)</span>
    <span class="k">end</span>
    <span class="c1">%% update the initial values U1_0, U2_0 and UG_0 to start the next time</span>
    <span class="c1">%% step</span>
    <span class="n">U1_0</span> <span class="o">=</span> <span class="n">U1</span><span class="p">;</span>
    <span class="n">U2_0</span> <span class="o">=</span> <span class="n">U2</span><span class="p">;</span>
    <span class="n">UG_0</span> <span class="o">=</span> <span class="n">UG_old</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0006/2D_FDM.gif" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;The aim of this note is to explain how one can solve an optimal control problem with the moment method. While the theory is collected in [1], we will explain how one is able to use the Globtipoly toolbox, which is a powerful toolbox able to solve many other problems. This toolbox is available in &lt;a href="http://homepages.laas.fr/henrion/software/gloptipoly3/"&gt;http://homepages.laas.fr/henrion/software/gloptipoly3/&lt;/a&gt;. A more detailed documentation is provided in this link, if you are insterested in other applications than the optimal control problem.&lt;/p&gt;
</code></pre></div></div>

<p>The use of this toolbox needs a proper installation either of Sedumi or the Mosek solvers, which are toolboxes instrumental to solve numerically SDP (Semidefinite Program) problems, i.e. optimization problems expressed with LMI (Linear Matrix Inequalities) constraints.</p>

<p>This note does not aim at explaining all the details of the toolbox Globtipoly, since there exists already the paper [2] which introduces really well the problem. It does not aim neither at introducing in details the moment framework developed by Jean Bernard Lasserre and Didier Henrion, which is much more general than the optimal control problem framework. In this note, we just give a simple example to explain how this method can be used in the context of optimal control (especially for ODEs). Thanks to the recent paper [3], we also think that this framework might also work for optimal control of PDEs.</p>

<h2 id="framework">FRAMEWORK</h2>

<p>We focus on the following ordinary differential equations:</p>

<script type="math/tex; mode=display">\begin{cases}    \dot{x} = f(x,u) \\    x(0)=x_0 \end{cases}</script>

<p>where $x$ belongs to a subset $X$ of $\mathbb{R}^n$ and $u$ to a subset $U$ of $\mathbb{R}^m$. We assume that $f$ is a polynomial of $x$ and $u$. Moreover, we assume that $X$ and $U$ can be written with finitely many polynomial inequalities. The Gloptipoly toolbox allows to solve the following kind of optimal control problem:</p>

<script type="math/tex; mode=display">\begin{cases} \rho^\star = \inf_u \int_{t_0}^T l(x(t),u(t))dt + l_T(x(T)) \\ \text{    s.t }  \dot{x} = f(x,u), x(t_0)=x_0 \\                  x(t) \in X,\: t\in  [t_0,T] \\                  u(t) \in U,\: t\in [t_0,T] \\                  x(T) \in X_T, \end{cases}</script>

<p>where $X_T$ is also a subset of $\mathbb{R}^n$ defined with finitely many polynomial inequalities and $l$ is also a polynomial in the variables $x$ and $u$.</p>

<h2 id="a-simpler-example-as-a-motivation">A SIMPLER EXAMPLE AS A MOTIVATION</h2>

<p>We focus on a specific example to make the reading of thenote easier. We have</p>

<script type="math/tex; mode=display">% <![CDATA[
x=\begin{bmatrix} x_1 & x_2\end{bmatrix}\in\mathbb{R}^2 %]]></script>

<p>$u\in\mathbb{R}$ and:</p>

<script type="math/tex; mode=display">f(x,u):=\begin{bmatrix} x_1\\ u \end{bmatrix}</script>

<p>It is a simple chain of integrators, really well-known in automatic control theory. As described in [1], the related system can be equivalently rewritten as follows:</p>

<script type="math/tex; mode=display">\int_{K_2} g(x) d\mu_2(x) -g(x_0) = \int_{K_1} \frac{d}{dx}g(x) f(x,u) d\mu_1(x),</script>

<p>where $g$ is any test function in $C^1(X)$, $\mu_1(x)$ is a measure supported on a compact set $K_1$ representing the constraints on $x$ and $u$, $\mu_2(x)=$ is supported on a given compact set $K_2$ corresponding to performance requirements. For example $K_2 = 0$ indicates that state $x$ must reach the origin.</p>

<p>The approximation provided by Gloptipoly consists in reducing the class of test function $g$ to be polynomials, with maximal degree $d$. This maximal degree $d$ is the parameter of approximation of the program. As proved in [1], the higher the degree $d$ is, the better is the result of the approximation.</p>

<p>Our aim is to find the minimal time so that the trajectories of the system go to $0$. Obviously, this result is already known, but we provide this simple example to make clear the use of the Globtipoly toolbox</p>

<h2 id="implementation">IMPLEMENTATION</h2>

<p>Before going to the optimal control problem, some (easy) technical lines of command are necessary for Gloptipoly to work.</p>

<p>First, you have to add to the path the toolbox Globtipoly</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">untar</span><span class="p">(</span><span class="s1">'http://homepages.laas.fr/henrion/software/gloptipoly3/gloptipoly3.tar.gz'</span><span class="p">)</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="s1">'gloptipoly3'</span><span class="p">))</span>
</code></pre></div></div>

<p>Second, you have also to add to the path the toolbox Sedumi.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">unzip</span><span class="p">(</span><span class="s1">'https://github.com/sqlp/sedumi/archive/master.zip'</span><span class="p">)</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="s1">'sedumi-master'</span><span class="p">))</span>
</code></pre></div></div>

<p>Then, you are ready to define the optimization problem.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span> <span class="n">u0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">%% initial conditions</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">%% maximum degree of test function.</span>
</code></pre></div></div>

<p>We compute the analytic minimum time. We want to know whether we are able to compute the good one with the toolbox Gloptipoly.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="p">(</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">)/</span><span class="mi">2</span>
<span class="n">tmin</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">;</span>
<span class="k">elseif</span> <span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="o">*</span><span class="nb">sign</span><span class="p">(</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">tmin</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nb">sqrt</span><span class="p">(</span><span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="k">else</span>
<span class="n">tmin</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nb">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We define measures for constraints. In other words, we also define the vector field under consideration.</p>

<p>The command mpol in Globtipoly allows to define the variables under consideration. One can then define polynomials with respect to these variables.</p>

<p>The command meas allows to define a measure depending on several variables. Hence, when writing meas([x_1;u_1]), one is defining a measure depending on the variables x_1 and u_1.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mpol</span> <span class="n">x1</span> <span class="mi">2</span>
<span class="n">mpol</span> <span class="n">u1</span>
<span class="n">m1</span> <span class="o">=</span> <span class="n">meas</span><span class="p">([</span><span class="n">x1</span><span class="p">;</span><span class="n">u1</span><span class="p">]);</span>
</code></pre></div></div>

<p>We now define a measure associated to $x_2$, which will be related to some performance requirement. Indeed, we will impose that this variable is dissipative.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mpol</span> <span class="n">x2</span> <span class="mi">2</span>
<span class="n">m2</span> <span class="o">=</span> <span class="n">meas</span><span class="p">(</span><span class="n">x2</span><span class="p">);</span>
</code></pre></div></div>

<p>We then define the vector field.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="n">u1</span><span class="p">];</span>
</code></pre></div></div>

<p>We now define the test functions as polynomials, with maximal degree $d$. The command mmon in Globtipoly allows to define monomials up to an order $d$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g1</span> <span class="o">=</span> <span class="n">mmon</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>
<span class="n">g2</span> <span class="o">=</span> <span class="n">mmon</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>
</code></pre></div></div>

<p>It is also necessary to assign the initial conditions, for the states as well for the control.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assign</span><span class="p">([</span><span class="n">x1</span><span class="p">;</span><span class="n">u1</span><span class="p">],[</span><span class="n">x0</span><span class="p">;</span><span class="n">u0</span><span class="p">]);</span>
<span class="n">g0</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">g1</span><span class="p">);</span>
</code></pre></div></div>

<p>We define $K_1$ and $K_2$. The set $K_1$ is defined as: $K_1= \lbrace x_1,u_1 \in \mathbb{R}^2\mid x_1(2)\geq -1,: u_1^2\leq 1\rbrace$ and $K_2$ is defined as: $K_2 =\lbrace x_2\in\mathbb{R}\mid x_2^2\leq 0\rbrace$.</p>

<p>We have also to define the cost function of the problem under consideration. The one we are considering is quite simple and just reduces to being</p>

<script type="math/tex; mode=display">\int_{K_1} d\mu_1</script>

<p>In terms of functions, this means that you are minizing $x_1(t)$. This implies in particular that you are looking for the minimal time such that the trajectory $(x_1(t),x_2(t))$ will converge to $(0,0)$.</p>

<p>In other words, we are asking that the mass the measure $\mu_1$ is minimal.</p>

<p>Finally, we define also the differential equation with the polynomials truncated up to the order $d$. The command mom corresponds to the integral of polynomials against the suitable measure. For instance, for mom(g_2), one integrates the the polynomial g_2 against the measure $\mu_2$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">P</span> <span class="o">=</span> <span class="n">msdp</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">mass</span><span class="p">(</span><span class="n">m1</span><span class="p">)),</span><span class="k">...</span><span class="c"> %%Definition of the cost function</span>
<span class="n">u1</span><span class="o">^</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span><span class="k">...</span><span class="c"> %% Definition of $K_1$</span>
<span class="n">x1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">...</span><span class="c"> %% Definition of $K_&amp;$</span>
<span class="n">x2</span><span class="o">'*</span><span class="n">x2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span><span class="k">...</span><span class="c"> %% Definition of $K_2</span>
<span class="n">mom</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span> <span class="o">-</span> <span class="n">g0</span> <span class="o">==</span> <span class="n">mom</span><span class="p">(</span><span class="nb">diff</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">));</span> <span class="c1">%% Definition of the dynamics.</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GloptiPoly 3.8 of 15 December 2014
Define moment SDP problem
  Valid objective function
  Number of support constraints = 3
  Number of moment constraints = 28
Measure 1
  Degree = 6
  Variables = 3
  Moments = 84
Measure 2
  Degree = 6
  Variables = 2
  Moments = 28
Relaxation order = 3
Total number of moments = 112
Generate moment and support constraints
Generate moment SDP problem

</code></pre></div></div>

<p>The command msdp allows to define the problem and all the constraints. As written in [1], this means that you are transforming the problem on functions into a SDP (Semi-definite programming) problem.</p>

<p>Once you do that, one has to solve this SDP problem. The command msol allows to do that.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">status</span><span class="p">,</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">msol</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GloptiPoly 3.8 of 15 December 2014
Solve moment SDP problem
*****************************************************
Calling SeDuMi
SeDuMi 1.32 by AdvOL, 2005-2008 and Jos F. Sturm, 1998-2003.
Alg = 2: xz-corrector, Adaptive Step-Differentiation, theta = 0.250, beta = 0.500
Put 28 free variables in a quadratic cone
eqs m = 112, order n = 59, dim = 766, blocks = 7
nnz(A) = 597 + 0, nnz(ADA) = 10192, nnz(L) = 5152
 it :     b*y       gap    delta  rate   t/tP*  t/tD*   feas cg cg  prec
  0 :            6.97E-01 0.000
  1 :  -4.85E+00 2.61E-01 0.000 0.3749 0.9000 0.9000  -0.46  1  1  7.9E+00
  2 :  -1.58E+01 1.08E-01 0.000 0.4124 0.9000 0.9000  -0.63  1  1  5.7E+00
  3 :  -1.60E+01 4.52E-02 0.000 0.4189 0.9000 0.9000   0.74  1  1  2.0E+00
  4 :  -7.27E+00 1.65E-02 0.000 0.3663 0.9000 0.9000   1.88  1  1  4.7E-01
  5 :  -4.16E+00 5.56E-03 0.000 0.3361 0.9000 0.9000   1.60  1  1  1.3E-01
  6 :  -3.52E+00 2.17E-03 0.000 0.3912 0.9000 0.9000   1.07  1  1  5.0E-02
  7 :  -3.37E+00 1.06E-03 0.000 0.4892 0.9000 0.9000   0.88  1  1  2.6E-02
  8 :  -3.24E+00 4.94E-04 0.000 0.4642 0.9000 0.9000   0.70  1  1  1.5E-02
  9 :  -3.17E+00 2.14E-04 0.000 0.4334 0.9000 0.9000   0.58  1  1  7.8E-03
 10 :  -3.12E+00 9.06E-05 0.000 0.4235 0.9000 0.9000   0.46  1  1  4.3E-03
 11 :  -3.08E+00 4.45E-05 0.000 0.4907 0.9000 0.9000   0.48  1  1  2.6E-03
 12 :  -3.05E+00 2.39E-05 0.000 0.5378 0.9000 0.9000   0.34  1  1  1.9E-03
 13 :  -3.02E+00 1.07E-05 0.000 0.4486 0.9000 0.9000   0.46  1  1  1.1E-03
 14 :  -2.98E+00 5.94E-06 0.000 0.5540 0.9000 0.9000   0.23  1  1  8.3E-04
 15 :  -2.95E+00 2.34E-06 0.000 0.3932 0.9000 0.9000   0.35  2  1  4.4E-04
 16 :  -2.91E+00 1.06E-06 0.000 0.4528 0.9000 0.9000   0.22  2  2  3.1E-04
 17 :  -2.88E+00 2.15E-07 0.000 0.2032 0.9000 0.7324   0.34  2  2  1.8E-04
 18 :  -2.84E+00 9.48E-08 0.000 0.4410 0.7706 0.9000   0.22  2  2  1.2E-04
 19 :  -2.82E+00 4.23E-08 0.000 0.4464 0.9000 0.9000   0.34  3  2  7.3E-05
 20 :  -2.78E+00 1.96E-08 0.000 0.4627 0.9000 0.9000   0.20  5  5  5.2E-05
 21 :  -2.76E+00 8.49E-09 0.000 0.4334 0.9000 0.9000   0.34  7  7  3.0E-05
 22 :  -2.73E+00 3.76E-09 0.000 0.4427 0.9000 0.9000   0.19  8  8  2.1E-05
 23 :  -2.70E+00 1.56E-09 0.000 0.4156 0.9000 0.9000   0.33 12 12  1.2E-05
 24 :  -2.67E+00 6.45E-10 0.000 0.4129 0.9000 0.9000   0.20 14 14  7.9E-06
 25 :  -2.66E+00 2.71E-10 0.000 0.4202 0.9000 0.9000   0.35 41 41  4.5E-06
Run into numerical problems.

iter seconds digits       c*x               b*y
 25      0.4   Inf -2.6569125651e+00 -2.6557155494e+00
\vertAx-b\vert =   9.3e-06, [Ay-c]_+ =   1.9E-06, \vertx\vert=  5.2e+03, \verty\vert=  4.9e+04

Detailed timing (sec)
   Pre          IPM          Post
6.598E-03    2.390E-01    7.343E-04    
Max-norms: \vert\vertb\vert\vert=1, \vert\vertc\vert\vert = 1,
Cholesky \vertadd\vert=1, \vertskip\vert = 7, \vert\vertL.L\vert\vert = 3155.
*****************************************************
Check feasibility (eps = 1.0000e-03):
  Marginally feasible SDP: residual = -5.0513e-07
Check Euclidean norm of solution (max = 1.0000e+06):
  Norm = 4.9305e+04
Check ranks of moments matrices (rel gap svd = 1.0000e-03):
  Measure 1
    Rank shift = 1
    Moment matrix of order  1 has size  4 and rank  4
    Moment matrix of order  2 has size 10 and rank 10
    Moment matrix of order  3 has size 20 and rank 20
  Measure 2
    Rank shift = 1
    Moment matrix of order  1 has size  3 and rank  1
  Rank conditions cannot ensure global optimality
Try to extract solutions (rel tol basis detection = 1.0000e-06):
  Measure 1
    Incomplete basis - no solution extracted
    Global optimality cannot be ensured
  Measure 2
    Maximum relative error = 0.0000e+00
    1 solution extracted
Inconsistent number of solutions amongst respective measures
No globally optimal solution could be extracted
Global optimality cannot be ensured

</code></pre></div></div>

<p>You display the minimal time and the lower bound of the cost functional.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">disp</span><span class="p">([</span><span class="s1">'Minimum time = '</span> <span class="nb">num2str</span><span class="p">(</span><span class="n">tmin</span><span class="p">)]);</span>
<span class="nb">disp</span><span class="p">([</span><span class="s1">'LMI '</span> <span class="nb">int2str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="s1">' lower bound = '</span> <span class="nb">num2str</span><span class="p">(</span><span class="n">obj</span><span class="p">)])</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Minimum time = 3.5
LMI 6 lower bound = 2.6557

</code></pre></div></div>

<p>For the initial condition x0 = [1 1] the exact minimum time is equal to 3.5. In table 1 of [2], a table is provided where you can see that when increasing $d$ the minimum time becomes closer and closer to the analytic one. We copy it in the note.</p>

<h2 id="conclusion">Conclusion</h2>

<p>As noticed before, this note aimed at providing a quick course on how using the toolbox Gloptipoly toolbox to solve optimal control problem. The document [2] provides more examples, even for other kinds of optimization problem. Hence, we refer the interested reader to this document if he is interested in using this toolbox for other problems. Let us note moreover that this toolbox has been used to solve nonlinear hyperbolic PDEs, in the paper [3].</p>

<h2 id="references">References</h2>

<p>[1] J. B. Lasserre, D. Henrion, C. Prieur, and E. Trélat, Nonlinear optimal control via occupation measures and LMI-relaxations, SIAM J. Control Opt., vol. 47, 4, pp. 1643-1666, 2008.</p>

<p>[2] D. Henrion, J.B. Lasserre and J. Löfberg. GloptiPoly 3: moments, optimization and semidefinite programming. Optimization Methods &amp; Software, 24(4-5), 761-779, 2009.</p>

<p>[3] S. Marx, T. Weisser, D. Henrion and J.B. Lasserre. A moment approach for entropy solutions to nonlinear hyperbolic PDEs arXiv preprint arXiv:1807.02306</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;This tutorial aims to show how to build equations of motion, control system model and optimally stabilizing controllers for the inverted pendulum. This tutorial is a standard material in control engineering education. We first derive the equations of motion via Lagrange’s method using Symbolic Math Toolbox. Then, a linear control model is derived. The optimal controller is designed using linear quadratic regulator theory. Simulations are carried out for the inverted pendulum nonlinear model. In Appendix, finite horizon linear optimal control is shown by solving a differential Riccati equation.&lt;/p&gt;
</code></pre></div></div>

<p>A schematic of an inverted pendulum is shown below.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0003/Pendulum_pic.png" alt="" /></p>

<p>A pendulum is attached with a cart that moves horizontally due to the force $u$ without friction. The pendulum freely rotates around the pivot on the cart. It is assumed that the cart and pendulum move in the vertical plane. The masses of the pendulum and cart are $m$ and $M$, respectively, and the length of the pendulum is $2l$. The position of the cart is denoted by $x$ and the angle of the pendulum from the vertical axis is $\theta$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">t</span><span class="p">;</span>
<span class="n">syms</span> <span class="n">x</span> <span class="n">dx</span> <span class="n">theta</span> <span class="n">dtheta</span><span class="p">;</span>
<span class="n">syms</span> <span class="n">M</span> <span class="n">m</span> <span class="n">l</span> <span class="n">g</span><span class="p">;</span>
<span class="n">syms</span> <span class="n">Lgr</span> <span class="n">Lgr_x</span> <span class="n">Lgr_dx</span> <span class="n">Lgr_theta</span> <span class="n">Lgr_dtheta</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="derivation-of-equations-of-motion">Derivation of equations of motion</h2>

<p>The Lagrangian $L$ consists of the kinetic energy and potential energy, which is given by</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Lgr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">M</span><span class="o">*</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">/</span><span class="mi">3</span> <span class="o">*</span> <span class="n">m</span><span class="o">*</span><span class="n">l</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">dtheta</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">l</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="n">dtheta</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="k">...</span>
        <span class="o">+</span> <span class="mi">1</span><span class="p">/</span><span class="mi">2</span> <span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">l</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
</code></pre></div></div>

<p>Compute derivatives of Lagrangian</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Lgr_x</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">Lgr</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="n">Lgr_dx</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">Lgr</span><span class="p">,</span><span class="n">dx</span><span class="p">);</span>
<span class="n">Lgr_theta</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">Lgr</span><span class="p">,</span><span class="n">theta</span><span class="p">);</span>
<span class="n">Lgr_dtheta</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">Lgr</span><span class="p">,</span><span class="n">dtheta</span><span class="p">);</span>

<span class="n">syms</span> <span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">dx_f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">dtheta_f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">Lgr_x_f</span> <span class="n">Lgr_dx_f</span> <span class="n">Lgr_theta_f</span> <span class="n">Lgr_dtheta_f</span><span class="p">;</span> <span class="c1">%% _f means functionalized</span>
<span class="n">dx_f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">=</span><span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
<span class="n">dtheta_f</span><span class="o">=</span><span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>

<span class="n">Lgr_dx_f</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Lgr_dx</span><span class="p">,[</span><span class="n">x</span> <span class="n">dx</span> <span class="n">theta</span> <span class="n">dtheta</span><span class="p">],[</span><span class="n">x_f</span> <span class="n">dx_f</span> <span class="n">theta_f</span> <span class="n">dtheta_f</span><span class="p">])</span>
<span class="n">Lgr_theta_f</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Lgr_theta</span><span class="p">,[</span><span class="n">x</span> <span class="n">dx</span> <span class="n">theta</span> <span class="n">dtheta</span><span class="p">],[</span><span class="n">x_f</span> <span class="n">dx_f</span> <span class="n">theta_f</span> <span class="n">dtheta_f</span><span class="p">])</span>
<span class="n">Lgr_dtheta_f</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Lgr_dtheta</span><span class="p">,[</span><span class="n">x</span> <span class="n">dx</span> <span class="n">theta</span> <span class="n">dtheta</span><span class="p">],[</span><span class="n">x_f</span> <span class="n">dx_f</span> <span class="n">theta_f</span> <span class="n">dtheta_f</span><span class="p">])</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Lgr_dx_f =

M*diff(x_f(t), t) + m*diff(x_f(t), t) + l*m*cos(theta_f(t))*diff(theta_f(t), t)


Lgr_theta_f =

g*l*m*sin(theta_f(t)) - l*m*sin(theta_f(t))*diff(theta_f(t), t)*diff(x_f(t), t)


Lgr_dtheta_f =

(4*m*diff(theta_f(t), t)*l^2)/3 + m*cos(theta_f(t))*diff(x_f(t), t)*l


</code></pre></div></div>

<p>Coumpute Lagrange’s equations of motion with external force $u$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Leq</span> <span class="n">Eqn</span><span class="p">;</span>
<span class="n">Leq</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">([</span><span class="n">Lgr_dx_f</span><span class="p">;</span> <span class="n">Lgr_dtheta_f</span><span class="p">],</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="p">[</span><span class="n">Lgr_x</span><span class="p">;</span> <span class="n">Lgr_theta_f</span><span class="p">];</span>
<span class="n">syms</span> <span class="n">Ddx</span> <span class="n">Ddtheta</span> <span class="n">u</span><span class="p">;</span>
<span class="n">Leq</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Leq</span><span class="p">,[</span><span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">],[</span><span class="n">Ddx</span><span class="p">,</span> <span class="n">Ddtheta</span><span class="p">])</span><span class="o">-</span><span class="p">[</span><span class="n">u</span><span class="p">;</span> <span class="mi">0</span><span class="p">];</span>
<span class="n">Eqn</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">Leq</span><span class="o">==</span><span class="mi">0</span><span class="p">,[</span><span class="n">Ddx</span><span class="p">,</span><span class="n">Ddtheta</span><span class="p">]);</span>
</code></pre></div></div>

<p>Construct state space equations of the first order equation</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">x1</span> <span class="n">x2</span> <span class="n">x3</span> <span class="n">x4</span> <span class="n">X</span><span class="p">;</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">;</span><span class="n">x2</span><span class="p">;</span><span class="n">x3</span><span class="p">;</span><span class="n">x4</span><span class="p">];</span>
<span class="n">subs</span><span class="p">(</span><span class="n">Eqn</span><span class="o">.</span><span class="n">Ddx</span><span class="p">,</span> <span class="p">[</span><span class="n">x_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="n">theta_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">]);</span>
<span class="n">subs</span><span class="p">(</span><span class="n">Eqn</span><span class="o">.</span><span class="n">Ddtheta</span><span class="p">,</span> <span class="p">[</span><span class="n">x_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="n">theta_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">]);</span>

<span class="n">syms</span> <span class="n">Nsys</span>
<span class="n">Nsys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x2</span><span class="p">;</span><span class="k">...</span>
        <span class="n">subs</span><span class="p">(</span><span class="n">Eqn</span><span class="o">.</span><span class="n">Ddx</span><span class="p">,</span> <span class="p">[</span><span class="n">x_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="n">theta_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">]);</span><span class="k">...</span>
        <span class="n">x4</span><span class="p">;</span><span class="k">...</span>
        <span class="n">subs</span><span class="p">(</span><span class="n">Eqn</span><span class="o">.</span><span class="n">Ddtheta</span><span class="p">,</span> <span class="p">[</span><span class="n">x_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="n">theta_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">])];</span>

<span class="n">syms</span> <span class="n">F</span><span class="p">;</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Construct linear model $\dot{x} = Ax+Bu$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Amat</span> <span class="n">Bmat</span>
<span class="n">Amat</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">jacobian</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">X</span><span class="p">),[</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x3</span><span class="p">,</span><span class="n">x4</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Bmat</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,[</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x3</span><span class="p">,</span><span class="n">x4</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">u</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Amat =

[ 0, 1,                             0, 0]
[ 0, 0,            -(3*g*m)/(4*M + m), 0]
[ 0, 0,                             0, 1]
[ 0, 0, (3*(M*g + g*m))/(l*(4*M + m)), 0]


Bmat =

                0
      4/(4*M + m)
                0
 -3/(l*(4*M + m))


</code></pre></div></div>

<p>We will use the following physical parameters m = 0.3 [kg]; M = 0.8 [kg]; l = 0.25 [m]; g = 9.8 [m/s^2];</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Amat</span><span class="p">,[</span><span class="n">m</span> <span class="n">M</span> <span class="n">l</span> <span class="n">g</span><span class="p">],[</span><span class="mf">0.3</span> <span class="mf">0.8</span> <span class="mf">0.25</span> <span class="mf">9.8</span><span class="p">]));</span>
<span class="n">B</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Bmat</span><span class="p">,[</span><span class="n">m</span> <span class="n">M</span> <span class="n">l</span> <span class="n">g</span><span class="p">],[</span><span class="mf">0.3</span> <span class="mf">0.8</span> <span class="mf">0.25</span> <span class="mf">9.8</span><span class="p">]));</span>
</code></pre></div></div>

<h2 id="lqr-controller-design">LQR controller design</h2>

<p>We design a linear feedback controller that minimizes the cost function</p>

<script type="math/tex; mode=display">J =\int_0^{\infty} x^TQx + u^2\,dt</script>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">[</span><span class="n">ricsol</span><span class="p">,</span><span class="n">cleig</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">Q</span><span class="p">);</span>

<span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">i_linear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">%% closed loop systems</span>

<span class="n">tspan</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">];</span>
<span class="n">ini</span> <span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.91</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="c1">%%1.1894299</span>
<span class="p">[</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_linear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>
<span class="n">input_linear</span> <span class="o">=</span> <span class="n">f_ctr</span><span class="p">(</span><span class="n">state</span><span class="o">'</span><span class="p">);</span>
</code></pre></div></div>

<p>Simulations with linear and nonlinear models</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Nsys_f</span> <span class="o">=</span> <span class="n">matlabFunction</span><span class="p">(</span><span class="n">Nsys</span><span class="p">);</span> <span class="c1">%% function of M,g,l,m,u,x2,x3,x4</span>
<span class="n">i_nonlinear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">Nsys_f</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">9.8</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>

<span class="p">[</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_nonlinear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>
<span class="n">input_nonlinear</span> <span class="o">=</span> <span class="n">f_ctr</span><span class="p">(</span><span class="n">staten</span><span class="o">'</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Linear model'</span><span class="p">,</span> <span class="s1">'Nonlinear model'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Cart position [m]'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0003/copiaRM_01.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">3</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">3</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Linear model'</span><span class="p">,</span> <span class="s1">'Nonlinear model'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Pendulum angle [rad]'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0003/copiaRM_02.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="nb">time</span><span class="p">,</span> <span class="n">input_linear</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span><span class="nb">grid</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">input_nonlinear</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Linear model'</span><span class="p">,</span><span class="s1">'Nonlinear model'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Input response'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0003/copiaRM_03.png" alt="" /></p>

<h2 id="appendix-finite-interval-optimal-control-with-dre-">Appendix (finite interval optimal control with DRE )</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rho</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="nb">eye</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
</code></pre></div></div>

<h2 id="solve--dxdt--xa--ax---xbr-1bx-q-xt--s-dre">Solve -dX/dt = XA + A’X - X<em>B</em>R^{-1}<em>B’</em>X +Q, X(T) = S (DRE)</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tspan_ric</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="c1">%% change horizon!</span>
<span class="n">iniric</span> <span class="o">=</span> <span class="n">S</span><span class="p">(:);</span>
<span class="n">i_ric</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">f_dric</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">*</span> <span class="n">B</span><span class="o">.'</span><span class="p">,</span> <span class="n">Q</span><span class="p">);</span>
<span class="n">opts</span> <span class="o">=</span> <span class="nb">odeset</span><span class="p">(</span><span class="s1">'RelTol'</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="s1">'AbsTol'</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">);</span>
<span class="p">[</span><span class="n">time_ric</span><span class="p">,</span> <span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_ric</span><span class="p">,</span> <span class="n">tspan_ric</span><span class="p">,</span> <span class="n">iniric</span><span class="p">,</span> <span class="n">opts</span><span class="p">);</span>
<span class="nb">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="k">end</span><span class="p">,:),</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="n">ricsol</span> <span class="c1">%% Convergence check with sol of ARE</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
ans =

   1.0e-04 *

   -0.0103   -0.0124   -0.0358   -0.0065
   -0.0124   -0.0185   -0.0549   -0.0099
   -0.0358   -0.0549   -0.1639   -0.0295
   -0.0065   -0.0099   -0.0295   -0.0053


</code></pre></div></div>

<p>Construct feedback controller using interpolation of DRE sol</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gain</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="nb">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">gain</span><span class="p">(</span><span class="n">i</span><span class="p">,:)</span> <span class="o">=</span> <span class="n">B</span><span class="o">'</span> <span class="o">*</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">i</span><span class="p">,:),</span><span class="nb">size</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>
<span class="k">end</span>
<span class="n">gain_t</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="nb">interp1</span><span class="p">(</span><span class="n">time_ric</span><span class="p">,</span><span class="n">gain</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
<span class="n">u_dr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">gain_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>

<span class="n">tspan</span> <span class="o">=</span> <span class="nb">sort</span><span class="p">(</span><span class="n">tspan_ric</span><span class="p">,</span> <span class="s1">'ascend'</span><span class="p">);</span>
<span class="n">i_nonlinear_dre</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">Nsys_f</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">9.8</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="n">u_dr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="p">[</span><span class="n">timedn</span><span class="p">,</span> <span class="n">statedn</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_nonlinear_dre</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span><span class="c1">%%</span>
<span class="n">input_dric</span><span class="o">=</span><span class="p">[];</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">timedn</span><span class="p">)</span>
    <span class="n">input_dric</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">u_dr</span><span class="p">(</span><span class="n">timedn</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">statedn</span><span class="p">(</span><span class="n">i</span><span class="p">,:)</span><span class="o">'</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timedn</span><span class="p">,</span> <span class="n">statedn</span><span class="p">(:,</span><span class="mi">3</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">3</span><span class="p">),</span><span class="s1">'ro'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'control with DRE [10,0]'</span><span class="p">,</span> <span class="s1">'control with ARE'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Pendulum responses with nonlinear model'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0003/copiaRM_04.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">plot</span><span class="p">(</span><span class="n">timedn</span><span class="p">,</span><span class="n">input_dric</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span><span class="n">input_nonlinear</span><span class="p">,</span><span class="s1">'ro'</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'input with ARE'</span><span class="p">,</span><span class="s1">'input with DRE [10,0]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'input responses with nonlinear model'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0003/copiaRM_05.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;This work is regarding solving 1-d wave equation using RPS semi-discretization method and analysis corresponding dispersion relation&lt;/p&gt;
</code></pre></div></div>

<p>Solving 1-d wave equation with RPS semi-discretization method Considering 1-d wave equation,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} 	\begin{cases} 	&u_{tt}- u_{xx} =0,  0\leq x\leq 1, t\in[0,T] \\ 	& u(x,T)=u_0(x),\, \, 0\leq x\leq 1, \\ 	& u_t(x,T)=u_1(x),\,\,0\leq x\leq 1,  \\ 	& u(0,t)=u(1,t)=0, \,\, t\in[0,T], 	\end{cases} 	\label{wave} 	\end{equation} %]]></script>

<p>When $(u_0,u_1) \in H_0^1(0,1)\times L^2(0,1)$, it admits a unique solution $u(x,t) \in C^0([0,T],H_0^1(0,1)) \cap C^1([0,T],L^2(0,1))$. 	The energy of solution to \eqref{wave} $E(t)$</p>

<script type="math/tex; mode=display">\begin{equation} 	E(t)=\frac{1}{2}\int_{0}^{1} \vert u_x(x,t) \vert^2+ \vert u_t(x,t)\vert^2 dx, 	\end{equation}</script>

<p>is time conserved .</p>

<p>With Hilbert Uniqueness Method, the exact controllability of \eqref{wave} is  equal to the observability of the adjoint \eqref{wave}, Observability of \eqref{wave} reads as: Given $T\geq 2$, there exist a positive constant $C(T)\geq 0$ such that</p>

<script type="math/tex; mode=display">\begin{equation}       E(0)\leq C(T) \int_{0}^{T} \vert u_x(1,t) \vert ^2 dt. \end{equation}</script>

<p>holds for every solution $u(x,t)$ to adjoint system \eqref{wave}</p>

<p>RPS semi-discretization of  weak variation formulation  of \eqref{wave} is written as</p>

<script type="math/tex; mode=display">\begin{equation} 	M \frac{d^2 \boldsymbol{u}}{dt^2}=-R\boldsymbol{u}, 	\label{fem_wave} 	\end{equation}</script>

<p>where $M_{i,j}:=\int_{-\infty}^{+\infty}\phi_i\phi_j dx$ and $R_{i,j}=\int_{-\infty}^{+\infty}\frac{d}{dx}\phi_i\frac{d}{dx}\phi_j dx $ and  the corresponding $\hat{A}(\omega)$ defined as</p>

<script type="math/tex; mode=display">\begin{equation}       \hat{A}(\omega)= \frac{R e^{i\omega x_n}}{M e^{i\omega x_n} }. 	\end{equation}</script>

<p>As for this problem, the rps basis $\phi_i(x)$ corresponding  $x_i$ is defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} 	\phi_i =\left\{ 	\begin{aligned} 	\arg &\min_{v \in H_0^2[-1,1]}  \int_{-1}^{1}(\frac{d^2}{dx^2} v)^2 dx  \\ 	&s.t.\  v(x_j) = \delta_{i,j},\ \ j = \{1,...,N\}, \\ 	\end{aligned} 	\right. 	\label{basis} 	\end{equation} %]]></script>

<p>Set up uniform fine mesh and coarse mesh</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">h</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">);</span> <span class="n">H</span><span class="o">=</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span> <span class="n">Nbasis</span><span class="o">=</span><span class="mi">2</span><span class="p">/</span><span class="n">H</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">/</span><span class="n">h</span><span class="p">;</span> <span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">/</span><span class="n">H</span><span class="p">;</span>
</code></pre></div></div>

<p>Construct the stiffness matrix and massive matrix regarding p1 finite element on fine mesh and coarse mesh respectively</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">L</span> <span class="o">=</span> <span class="nb">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">],[</span><span class="mi">2</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)]);</span>
<span class="n">LL</span><span class="o">=</span> <span class="nb">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">-</span><span class="mi">4</span><span class="p">)]);</span>
<span class="n">M</span> <span class="o">=</span> <span class="nb">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">/</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">/</span><span class="mi">6</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">4</span><span class="p">)]);</span>
<span class="n">MM</span> <span class="o">=</span> <span class="nb">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">/</span><span class="mi">3</span><span class="o">*</span><span class="n">H</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">/</span><span class="mi">6</span><span class="o">*</span><span class="n">H</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">-</span><span class="mi">4</span><span class="p">)]);</span>
<span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">/</span><span class="n">h</span><span class="o">*</span><span class="n">L</span><span class="p">;</span>
<span class="n">LL</span><span class="o">=</span><span class="mi">1</span><span class="p">/</span><span class="n">H</span><span class="o">*</span><span class="n">LL</span><span class="p">;</span>
</code></pre></div></div>

<p>Construct the discrete energy $\vert-div(a\nabla \cdot)\vert$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">temp</span> <span class="o">=</span> <span class="n">L</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">boundary</span> <span class="o">=</span> <span class="n">L</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="k">end</span><span class="p">],</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">temp</span><span class="s1">'*temp+100*(boundary'</span><span class="p">)</span><span class="o">*</span><span class="nb">boundary</span><span class="p">;</span>
</code></pre></div></div>

<p>Matrix corresponding  pointwise constrains</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">H</span><span class="p">/</span><span class="n">h</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nbasis</span><span class="p">],:);</span>
</code></pre></div></div>

<p>Solve the rps basis by solving the optimization problems</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Psi</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nbasis</span><span class="p">);</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ei</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Nbasis</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">ei</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Psi</span><span class="p">(:,</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">\(</span><span class="n">B</span><span class="s1">'*((B*inv(A)*B'</span><span class="p">)\</span><span class="n">ei</span><span class="p">));</span>
<span class="k">end</span>
</code></pre></div></div>

<p>plot the basis and log scale of basis</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">h</span><span class="p">:</span><span class="n">h</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="nb">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Psi</span><span class="p">(:,</span><span class="mi">16</span><span class="p">))));</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">h</span><span class="p">:</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">;</span><span class="n">Psi</span><span class="p">(:,</span><span class="mi">16</span><span class="p">);</span><span class="mi">0</span><span class="p">],</span><span class="s1">'b'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_01.png" alt="" /></p>

<p>Set up the time interval, time step, source term $f=0$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">J</span><span class="o">=</span><span class="mi">10000</span><span class="p">;</span><span class="n">f</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>Set up the concentration parameter of inital data $\gamma$, frequency $\xi$ and generate fine grids $x$ and the initial data defined on them</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">gamma</span><span class="o">=</span><span class="n">H</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mf">1.8</span><span class="p">);</span> <span class="n">xi</span><span class="o">=</span><span class="mi">3</span><span class="p">/</span><span class="mi">4</span><span class="o">*</span><span class="nb">pi</span><span class="p">;</span> <span class="n">x</span><span class="o">=-</span><span class="mi">1</span><span class="o">+</span><span class="n">h</span><span class="p">:</span><span class="n">h</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="n">h</span><span class="p">;</span>
<span class="n">ui</span><span class="o">=</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x</span><span class="p">/</span><span class="n">H</span><span class="p">);</span>
<span class="n">uti</span><span class="o">=-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x</span><span class="p">/</span><span class="n">H</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">/</span><span class="n">H</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">sin</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x</span><span class="p">/</span><span class="n">H</span><span class="p">);</span>
</code></pre></div></div>

<p>Solve the wave equation on fine mesh as a approximation of analytical solution, which will be used then as a reference of rps solution</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">ut</span><span class="p">]</span> <span class="o">=</span>  <span class="n">ODEsolver</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">L</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">ui</span><span class="p">,</span><span class="n">uti</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">M</span><span class="p">);</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span><span class="o">=</span><span class="nb">meshgrid</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">h</span><span class="p">:</span><span class="n">h</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">T</span><span class="p">/</span><span class="n">J</span><span class="p">:</span><span class="n">T</span><span class="p">);</span>
<span class="nb">clf</span><span class="p">,</span> <span class="nb">pcolor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">u</span><span class="o">'</span><span class="p">)</span> <span class="p">;</span><span class="nb">shading</span> <span class="n">interp</span> <span class="p">;</span> <span class="nb">colorbar</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'finemesh solution'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_02.png" alt="" /></p>

<p>Solve the wave equation on coarsemesh using RPS method</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xc</span><span class="o">=</span><span class="n">x</span><span class="p">(</span><span class="n">H</span><span class="p">/</span><span class="n">h</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nbasis</span><span class="p">]);</span>
<span class="n">Mc</span><span class="o">=</span><span class="n">Psi</span><span class="s1">'*M*Psi; Lc=Psi'</span><span class="o">*</span><span class="n">L</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Psi</span><span class="p">;</span>
<span class="n">uci</span><span class="o">=</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">xc</span><span class="p">/</span><span class="n">H</span><span class="p">);</span>
<span class="n">utci</span><span class="o">=-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">xc</span><span class="p">/</span><span class="n">H</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">/</span><span class="n">H</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">sin</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">xc</span><span class="p">/</span><span class="n">H</span><span class="p">);</span>
<span class="n">fc</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">Lc</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
<span class="p">[</span><span class="n">uc</span><span class="p">,</span><span class="n">uct</span><span class="p">]</span><span class="o">=</span><span class="n">ODEsolver</span><span class="p">(</span><span class="n">Mc</span><span class="p">,</span><span class="n">Lc</span><span class="p">,</span><span class="n">uci</span><span class="p">,</span><span class="n">utci</span><span class="p">,</span><span class="n">fc</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">Mc</span><span class="p">);</span>
<span class="nb">clf</span><span class="p">,</span> <span class="nb">pcolor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,(</span><span class="n">Psi</span><span class="o">*</span><span class="n">uc</span><span class="p">)</span><span class="o">'</span><span class="p">);</span><span class="nb">shading</span> <span class="n">interp</span> <span class="p">;</span> <span class="nb">colorbar</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'coarsemesh solution with rps basis'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_03.png" alt="" /></p>

<p>Solve the wave equation on coarsemesh using p1 fem</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">uuc</span><span class="p">,</span><span class="n">uuct</span><span class="p">]</span><span class="o">=</span><span class="n">ODEsolver</span><span class="p">(</span><span class="n">MM</span><span class="p">,</span><span class="n">LL</span><span class="p">,</span><span class="n">uci</span><span class="p">,</span><span class="n">utci</span><span class="p">,</span><span class="n">fc</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">MM</span><span class="p">);</span>
<span class="p">[</span><span class="n">XX</span><span class="p">,</span><span class="n">YY</span><span class="p">]</span><span class="o">=</span><span class="nb">meshgrid</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">H</span><span class="p">:</span><span class="n">H</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="n">H</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">T</span><span class="p">/</span><span class="n">J</span><span class="p">:</span><span class="n">T</span><span class="p">);</span>
<span class="nb">clf</span><span class="p">,</span> <span class="nb">pcolor</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span><span class="n">YY</span><span class="p">,</span><span class="n">uuc</span><span class="o">'</span><span class="p">);</span> <span class="nb">shading</span> <span class="n">interp</span> <span class="p">;</span> <span class="nb">colorbar</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'coarsemesh solution with linear basis'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_04.png" alt="" /></p>

<p><strong>Plot the disperation relation of RPS-semi descretization</strong></p>

<p>RPS semi-discretization of  weak variation formulation  of \eqref{wave} is written as</p>

<script type="math/tex; mode=display">\begin{equation}    M \frac{d^2 \boldsymbol{u}}{dt^2}=-R\boldsymbol{u} \end{equation}</script>

<p>where $M_{i,j}:=\int_{-\infty}^{+\infty}\phi_i\phi_j dx$ and $R_{i,j}=\int_{-\infty}^{+\infty}\frac{d}{dx}\phi_i\frac{d}{dx}\phi_j dx $ and the corresponding $\hat{A}(\omega)$ defined as</p>

<script type="math/tex; mode=display">\begin{equation} \hat{A}(\omega)= \frac{R e^{i\omega x_n}}{M e^{i\omega x_n} }. 	\end{equation}</script>

<p>Since there’s no explicit formulation for matrix $M$ and $R$, We can only calculate the fourier symbol of $M$ and $R$ numerically. Assuming the matrix $M$ is symmetric and toplitze and dimension $N$ of $M$ being a odd number, then fourier symbol of $M$   could be written as</p>

<script type="math/tex; mode=display">\begin{equation} \hat{M}(\omega)= M_{(N+1)/2,(N+1)/2}-2\sum_{i=1}^{(N+1)/2-1}M_{(N+1)/2,i}cos(i\omega h ),\ \omega h = 0,\frac{1}{N+1}\pi,..., 2\pi. \end{equation}</script>

<p>For example, let $M$  be mass matrix corresponding p1 finite element semi-descretization. the fourier symbol of $M$ is</p>

<script type="math/tex; mode=display">\begin{equation} \hat{M}(\omega)=2/3+1/3cos(\omega h)  \end{equation}</script>

<p>Construct the discrete $cos(i\omega h)$ with $\omega h$ sampled at 1000 points at interval $[0,2\pi]$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="nb">cell</span><span class="p">(</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="n">f</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">f</span><span class="p">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="mi">2</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="k">end</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">flip</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

<span class="n">Matrix_cos</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span>
    <span class="n">xx</span><span class="o">=</span><span class="nb">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
    <span class="n">Matrix_cos</span><span class="p">(</span><span class="n">i</span><span class="p">,:)</span><span class="o">=</span><span class="nb">arrayfun</span><span class="p">(</span><span class="n">f</span><span class="p">{</span><span class="n">i</span><span class="p">},</span><span class="n">xx</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Calculate the fourier symbol of $M$ and $R$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M_symbol</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/</span><span class="n">H</span><span class="o">*</span><span class="n">Mc</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">H</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Matrix_cos</span><span class="p">;</span>
<span class="n">R_symbol</span> <span class="o">=</span> <span class="n">H</span><span class="o">*</span><span class="n">Lc</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">H</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Matrix_cos</span><span class="o">.</span><span class="p">/</span><span class="n">xx</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>Plot the numerical phase velocity for sinusoidal solution and compare it with the ones for FDM and FEM</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">hold</span> <span class="n">on</span>
<span class="n">phaseVelocity</span> <span class="o">=</span> <span class="n">R_symbol</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="p">/</span><span class="n">M_symbol</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">clf</span><span class="p">,</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">phaseVelocity</span><span class="p">)</span>
<span class="c1">%% for p1 FEM</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">p1PhaseV</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="n">xx</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="p">/</span><span class="n">xx</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">/</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">/</span><span class="mi">3</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span><span class="o">.^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">p1PhaseV</span><span class="p">)</span>
<span class="c1">%% for FDM</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">fdmPhaseV</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="n">xx</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="p">/</span><span class="n">xx</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">fdmPhaseV</span><span class="p">)</span>
<span class="c1">%%</span>
<span class="n">ax</span><span class="o">=</span><span class="nb">gca</span><span class="p">;</span> <span class="n">ax</span><span class="o">.</span><span class="n">XTick</span> <span class="o">=</span> <span class="p">([</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span> <span class="mi">5</span><span class="p">/</span><span class="mi">6</span><span class="o">*</span><span class="nb">pi</span> <span class="nb">pi</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">]);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XTickLabel</span> <span class="o">=</span><span class="p">({</span><span class="s1">'0'</span><span class="p">,</span><span class="s1">'1/2\pi'</span><span class="p">,</span><span class="s1">'5/6*\pi'</span><span class="p">,</span><span class="s1">'\pi'</span><span class="p">,</span><span class="s1">'2\pi'</span><span class="p">});</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'\omega*H'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'RPS'</span><span class="p">,</span><span class="s1">'P1 FEM'</span><span class="p">,</span><span class="s1">'FDM'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_05.png" alt="" /></p>

<p>Plot the numerical group velocity for sinusoidal solution and compare it with the ones for FDM and FEM</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">groupVelocity</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">phaseVelocity</span><span class="p">)/((</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">-</span><span class="mf">0.1</span><span class="p">)/</span><span class="mi">999</span><span class="p">)</span><span class="o">.*</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">phaseVelocity</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">clf</span><span class="p">,</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">groupVelocity</span><span class="p">)),</span><span class="n">groupVelocity</span><span class="p">)</span>
<span class="c1">%% for p1 FEM</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">p1GroupV</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">p1PhaseV</span><span class="p">)/((</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">-</span><span class="mf">0.1</span><span class="p">)/</span><span class="mi">999</span><span class="p">)</span><span class="o">.*</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">p1PhaseV</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">p1GroupV</span><span class="p">)</span>
<span class="c1">%% for FDM</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">fdmGroupV</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">fdmPhaseV</span><span class="p">)/((</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">-</span><span class="mf">0.1</span><span class="p">)/</span><span class="mi">999</span><span class="p">)</span><span class="o">.*</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">groupVelocity</span><span class="p">))</span><span class="o">+</span><span class="n">fdmPhaseV</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">groupVelocity</span><span class="p">));</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">groupVelocity</span><span class="p">)),</span><span class="n">fdmGroupV</span><span class="p">)</span>
<span class="c1">%% for ecact group velocity</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)),</span><span class="s1">'LineStyle'</span><span class="p">,</span><span class="s1">'--'</span><span class="p">)</span>
<span class="c1">%%</span>
<span class="n">ax</span><span class="o">=</span><span class="nb">gca</span><span class="p">;</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XTick</span><span class="o">=</span><span class="p">([</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span> <span class="mi">5</span><span class="p">/</span><span class="mi">6</span><span class="o">*</span><span class="nb">pi</span> <span class="nb">pi</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">]);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XTickLabel</span> <span class="o">=</span><span class="p">({</span><span class="s1">'0'</span><span class="p">,</span><span class="s1">'1/2\pi'</span><span class="p">,</span><span class="s1">'5/6*\pi'</span><span class="p">,</span><span class="s1">'\pi'</span><span class="p">,</span><span class="s1">'2\pi'</span><span class="p">});</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XLim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="nb">pi</span><span class="p">];</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'\omega*H'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'RPS'</span><span class="p">,</span><span class="s1">'P1 FEM'</span><span class="p">,</span><span class="s1">'FDM'</span><span class="p">,</span><span class="s1">'exact'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_06.png" alt="" /></p>

<p>Plot the numerical disperation relation Disperation relation for RPS semi-discretizaton</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">diperss</span> <span class="o">=</span> <span class="n">phaseVelocity</span><span class="o">.*</span><span class="n">xx</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">diperss</span><span class="p">)</span>
<span class="c1">%% for P1 FEM</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">,</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">xx</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="p">(</span><span class="mi">2</span><span class="p">/</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">/</span><span class="mi">3</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span><span class="o">.^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">));</span>
<span class="c1">%% for FDM</span>
<span class="nb">hold</span> <span class="n">on</span> <span class="p">,</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="p">/</span><span class="mi">2</span><span class="p">))</span>
<span class="c1">%% for exact one</span>
<span class="nb">hold</span> <span class="n">on</span> <span class="p">,</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">xx</span><span class="p">,</span><span class="s1">'LineStyle'</span><span class="p">,</span><span class="s1">'--'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">=</span><span class="nb">gca</span><span class="p">;</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XTick</span><span class="o">=</span><span class="p">([</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span> <span class="mi">5</span><span class="p">/</span><span class="mi">6</span><span class="o">*</span><span class="nb">pi</span> <span class="nb">pi</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">]);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XTickLabel</span> <span class="o">=</span><span class="p">({</span><span class="s1">'0'</span><span class="p">,</span><span class="s1">'1/2\pi'</span><span class="p">,</span><span class="s1">'5/6*\pi'</span><span class="p">,</span><span class="s1">'\pi'</span><span class="p">,</span><span class="s1">'2\pi'</span><span class="p">});</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XLim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="nb">pi</span><span class="p">];</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'\omega*H'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'RPS'</span><span class="p">,</span><span class="s1">'P1 FEM'</span><span class="p">,</span><span class="s1">'FDM'</span><span class="p">,</span><span class="s1">'exact'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_07.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;We analyze the stability of a simplified system modeling two converters in parallel connected to an ideal grid (modelled by a voltage source) via line impedances.&lt;/p&gt;
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0007/converters.png" alt="" /></p>

<p>Each of the converters is fed by a DC source and includes an $LC$ circuit at its output to filter the ripple introduced by the converter switching. Similarly, an $LR$ impedance is included after the $LC$ filter to model the characteristics of the line until the point of common connection (PCC). The grid in this case is modelled with an ideal voltage source $v_g$ with a series $LR$ impedance. In this context, $f$ subscript denotes filter and $o$ subscript denotes output of the inverter. The subscript %%g%% denotes that this variable is from the side of the grid.</p>

<p>The dynamics inside the system (e.g. how does the current in an inductor or the voltage in a capacitor evolve over time) is described by several differential equations describing the evolution of the state input vector. The model is then completed with the introduction of algebraic relations which link the previous equations by applying classical laws such as Kirchoff.</p>

<p>All these equations depend on some parameters characteristic of the physical model:</p>

<ul>
  <li>
    <p>$Rf_{1}$ and $Rf_{2}$: the filter resistors;</p>
  </li>
  <li>
    <p>$Lf_{1}$ and $Lf_{2}$: the inductances of the filter;</p>
  </li>
  <li>
    <p>$Cf_{1}$ and $Cf_{2}$: the capacitances;</p>
  </li>
  <li>
    <p>$Ro_{1}$ and $Ro_{2}$: the output resistors;</p>
  </li>
  <li>
    <p>$Lo_{1}$ and $Lo_{2}$: the output inductances;</p>
  </li>
  <li>
    <p>$Rg$: the grid resistor;</p>
  </li>
  <li>
    <p>$Lg$: the grid inductance.</p>
  </li>
</ul>

<p>The model is then written in the form $\dot{x} = Ax + Bu$, with</p>

<script type="math/tex; mode=display">% <![CDATA[
A = \left(\begin{array}{ccccccc} -\frac{\mathrm{Rf}_{1}}{\mathrm{Lf}_{1}} & -\frac{1}{\mathrm{Lf}_{1}} & 0 & 0 & 0 & 0 & 0\\ \frac{1}{\mathrm{Cf}_{1}} & 0 & -\frac{1}{\mathrm{Cf}_{1}} & 0 & 0 & 0 & 0\\ 0 & -\frac{\frac{1}{L\,\mathrm{Lo}_{1}}-1}{\mathrm{Lo}_{1}} & \frac{\mathrm{Ro}_{1}\,\left(\frac{1}{L\,\mathrm{Lo}_{1}}-1\right)}{\mathrm{Lo}_{1}} & 0 & -\frac{1}{L\,\mathrm{Lo}_{1}\,\mathrm{Lo}_{2}} & \frac{\mathrm{Ro}_{2}}{L\,\mathrm{Lo}_{1}\,\mathrm{Lo}_{2}} & \frac{\mathrm{Ro}_{2}}{L\,\mathrm{Lg}\,\mathrm{Lo}_{1}}\\ 0 & 0 & 0 & -\frac{\mathrm{Rf}_{2}}{\mathrm{Lf}_{2}} & -\frac{1}{\mathrm{Lf}_{2}} & 0 & 0\\ 0 & 0 & 0 & \frac{1}{\mathrm{Cf}_{2}} & 0 & -\frac{1}{\mathrm{Cf}_{2}} & 0\\ 0 & -\frac{1}{L\,\mathrm{Lo}_{1}\,\mathrm{Lo}_{2}} & \frac{\mathrm{Ro}_{1}}{L\,\mathrm{Lo}_{1}\,\mathrm{Lo}_{2}} & 0 & -\frac{\frac{1}{L\,\mathrm{Lo}_{2}}-1}{\mathrm{Lo}_{2}} & \frac{\mathrm{Ro}_{2}\,\left(\frac{1}{L\,\mathrm{Lo}_{2}}-1\right)}{\mathrm{Lo}_{2}} & -\frac{\mathrm{Rg}}{L\,\mathrm{Lg}}\\ 0 & \frac{1}{L\,\mathrm{Lg}\,\mathrm{Lo}_{1}} & -\frac{\mathrm{Ro}_{1}}{L\,\mathrm{Lg}\,\mathrm{Lo}_{1}} & 0 & \frac{\mathrm{Ro}_{1}}{L\,\mathrm{Lg}\,\mathrm{Lo}_{2}} & -\frac{\mathrm{Ro}_{2}}{L\,\mathrm{Lg}\,\mathrm{Lo}_{2}} & \frac{\mathrm{Rg}\,\left(\frac{1}{L\,\mathrm{Lg}}-1\right)}{\mathrm{Lg}} \end{array}\right) %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
B =   \left(\begin{array}{ccc} \frac{m_{1}}{\mathrm{Lf}_{1}} & 0 & 0\\ 0 & 0 & 0\\ 0 & 0 & -\frac{1}{L\,\mathrm{Lg}\,\mathrm{Lo}_{1}}\\ 0 & \frac{m_{2}}{\mathrm{Lf}_{2}} & 0\\ 0 & 0 & 0\\ 0 & 0 & 0\\ 0 & 0 & 0 \end{array}\right) %]]></script>

<p>and $u = [Vdc_{1} Vdc_{2} V_{g}]$. here we defined</p>

<script type="math/tex; mode=display">L=\left(Lo_{1}^{-1}+Lo_{2}^{-1}+Lg^{-1}\right)</script>

<p>The stability of the system is discussed by studying the evolution of the eigenvalues of $A$ in dependence of the aforementioned parameters. Due to the size of the system and to the large number of parameters involved, this stability analysis needs to be addressed by means of fine computational tools.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clear</span>
</code></pre></div></div>

<h2 id="variables-composing-the-state-vector">Variables composing the state vector</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Ii1</span> <span class="n">Vo1</span> <span class="n">Io1</span> <span class="n">Ii2</span> <span class="n">Vo2</span> <span class="n">Io2</span> <span class="n">Ig</span>
</code></pre></div></div>

<h2 id="parameters-entering-in-the-model">Parameters entering in the model</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Ro1</span> <span class="n">Rf1</span> <span class="n">Lf1</span> <span class="n">Cf1</span> <span class="n">Lo1</span>
<span class="n">syms</span> <span class="n">Ro2</span> <span class="n">Rf2</span> <span class="n">Lf2</span> <span class="n">Cf2</span> <span class="n">Lo2</span>
<span class="n">syms</span> <span class="n">Rg</span> <span class="n">Lg</span> <span class="n">L</span>
<span class="c1">%% sustituimos numericamente excepto nRo1 syms m1 m2</span>
</code></pre></div></div>

<p>Out of these parameters, we build the matrices $A$ and $B$ in symbolic form.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="n">Amatrix</span><span class="p">();</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">Bmatrix</span><span class="p">();</span>
</code></pre></div></div>

<p>We now want to study the evolution of the eigenvalues with respect to $\mathrm{Ro}_{1}$. Thus, we assign some fix value to all the others parameters</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nRf1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nLf1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nCf1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nLo1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">nRo2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nRf2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nLf2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nCf2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">nLo2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nRg</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nLg</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/</span><span class="n">nLo1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">/</span><span class="n">nLo2</span> <span class="p">;</span>
</code></pre></div></div>

<p>and we build the corresponding matrix $A$, which will depend only on $Ro_{1}$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">symbolic</span>  <span class="o">=</span> <span class="p">[</span><span class="n">Rf1</span><span class="p">,</span> <span class="n">Lf1</span><span class="p">,</span> <span class="n">Cf1</span><span class="p">,</span> <span class="n">Lo1</span><span class="p">,</span> <span class="k">...</span>
             <span class="n">Ro2</span><span class="p">,</span>  <span class="n">Rf2</span><span class="p">,</span> <span class="n">Lf2</span><span class="p">,</span> <span class="n">Cf2</span><span class="p">,</span> <span class="n">Lo2</span><span class="p">,</span> <span class="k">...</span>
             <span class="n">Rg</span><span class="p">,</span>   <span class="n">Lg</span><span class="p">,</span>  <span class="n">L</span><span class="p">];</span>

<span class="n">numerical</span> <span class="o">=</span> <span class="p">[</span><span class="n">nRf1</span><span class="p">,</span> <span class="n">nLf1</span><span class="p">,</span> <span class="n">nCf1</span><span class="p">,</span> <span class="n">nLo1</span><span class="p">,</span> <span class="k">...</span>
             <span class="n">nRo2</span><span class="p">,</span>  <span class="n">nRf2</span><span class="p">,</span> <span class="n">nLf2</span><span class="p">,</span> <span class="n">nCf2</span><span class="p">,</span> <span class="n">nLo2</span><span class="p">,</span> <span class="k">...</span>
             <span class="n">nRg</span><span class="p">,</span>   <span class="n">nLg</span><span class="p">,</span>  <span class="n">nL</span><span class="p">];</span>
<span class="n">nA</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">symbolic</span><span class="p">,</span><span class="n">numerical</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 
nA =
 
[ -1,   -1,      0,  0,     0,    0,    0]
[  1,    0,     -1,  0,     0,    0,    0]
[  0,  1/2, -Ro1/2,  0,  -1/2,  1/2,  1/2]
[  0,    0,      0, -1,    -1,    0,    0]
[  0,    0,      0,  1,     0,   -1,    0]
[  0, -1/2,  Ro1/2,  0,   1/2, -1/2, -1/2]
[  0,  1/2, -Ro1/2,  0, Ro1/2, -1/2, -1/2]
 

</code></pre></div></div>

<p>Then, we convert it from symbolic to function_handle</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">funRo1</span> <span class="o">=</span> <span class="n">matlabFunction</span><span class="p">(</span><span class="nb">eig</span><span class="p">(</span><span class="n">nA</span><span class="p">));</span>
</code></pre></div></div>

<p>Finally, we compute and plot the eigenvalues of this matrix $A$ and we analyze their evolution while varying $Ro_{1}$ in a given range.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nRo1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="mf">0.05</span><span class="p">:</span><span class="mi">5</span><span class="p">;</span>
<span class="n">eigenvalues</span> <span class="o">=</span> <span class="nb">cell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">length</span><span class="p">(</span><span class="n">nRo1</span><span class="p">));</span>
<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">inRo1</span> <span class="o">=</span> <span class="n">nRo1</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">%% in each iteration we replace in funRo1 a different value of the parameter</span>
    <span class="n">eigenvalues</span><span class="p">{</span><span class="n">index</span><span class="p">}</span> <span class="o">=</span> <span class="n">funRo1</span><span class="p">(</span><span class="n">inRo1</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></div></div>

<p>For each value of $Ro_{1}$, the eigenvalues are stored in a cell. For instance, these are the eigenvalues corresponding to $Ro_{1}=-3$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eigenvalues</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
ans =

  -1.0000 + 0.0000i
   0.0000 + 0.0000i
  -0.5000 - 0.8660i
  -0.5000 + 0.8660i
   0.0000 + 0.0000i
   0.2500 - 0.6614i
   0.2500 + 0.6614i


</code></pre></div></div>

<p>We then use use the Matlab program “EingEvolution” that we specifically degsigned, in order to see the evolution of these eigenvalues. This is done through the command <code class="highlighter-rouge">EingEvolution(autovalues,nRo1,'R_{o1}','Gif_evo_eig.gif')</code>.</p>

<p>Finally, we can plot the evolution of the eigenvalues as a function of $R_{o_1}$.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0007/Gif_evo_eig.gif" alt="" /></p>

<p>This procedure may be repeated for all the others parameters, thus obtaining a complete stability analysis of our model.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;Define vector fields of ODE : Kuramoto control problem whose dynamics is&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">\dot \theta_i = \omega_i + \frac{1}{N}\sum_{j=1}^N K_{ij} \sin(\theta_j-\theta_i),\quad i \neq 1,</script>

<p>where we control the first oscillator,</p>

<script type="math/tex; mode=display">\dot \theta_1 = u + \omega_1 + \frac{1}{N}\sum_{j=1}^N K_{1j} \sin(\theta_j-\theta_1),</script>

<p>in order to <strong>change the limit phase value to be 0</strong>.</p>

<p>We first define the system of ODEs in terms of symbolic variables.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clear</span> <span class="nb">all</span>
<span class="nb">clc</span>

<span class="n">m</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">%% [m]: number of oscillators, which we may change later.</span>

<span class="n">th</span> <span class="o">=</span> <span class="n">sym</span><span class="p">(</span><span class="s1">'th'</span><span class="p">,</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">%% [th_i]: phases of oscillators, $\theta_i$</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">sym</span><span class="p">(</span><span class="s1">'om'</span><span class="p">,</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">%% [om_i]: natural frequencies of osc., $\omega_i$</span>
<span class="n">KK</span> <span class="o">=</span> <span class="n">sym</span><span class="p">(</span><span class="s1">'K'</span><span class="p">,[</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">]);</span> <span class="c1">%% [Ki_j]: the coupling network matrix, $K_{i,j}$</span>

<span class="n">syms</span> <span class="n">Nsys</span><span class="p">;</span>   <span class="c1">%% [Nsys]: the vector fields of ODEs</span>
<span class="n">thth</span> <span class="o">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">th</span><span class="p">,[</span><span class="mi">1</span> <span class="n">m</span><span class="p">]);</span>
<span class="n">Nsys</span> <span class="o">=</span> <span class="n">om</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span><span class="p">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">KK</span><span class="o">.*</span><span class="nb">sin</span><span class="p">(</span><span class="n">thth</span><span class="o">.'</span> <span class="o">-</span> <span class="n">thth</span><span class="p">),</span><span class="mi">2</span><span class="p">);</span>   <span class="c1">%% Kuramoto interaction terms</span>
<span class="n">syms</span> <span class="n">u</span><span class="p">;</span> <span class="c1">%% [u]: One-dimensional control term</span>
<span class="n">Nsys</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Nsys</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>    <span class="c1">%% For the first particle, we put the control term</span>


<span class="c1">%% latex(Nsys)</span>
</code></pre></div></div>

<p>The system is as follows:</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/Nsys.png" alt="Variable 'Nsys' with $m=3$" /></p>

<h2 id="linearized-model-and-numerical-data-setting">Linearized model and numerical data setting</h2>

<p>We now construct the linearized system using Jacobian:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">F</span><span class="p">;</span> <span class="c1">%% [F]: The system without control</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

<span class="n">syms</span> <span class="n">Amat</span> <span class="n">Bmat</span><span class="p">;</span> <span class="c1">%% [Amat, Bmat]: Symbolic versions of the matrix A and B</span>
<span class="n">th_eq</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% Evaluation of Jacobian is at equilibrium, [0;0;0;0].</span>
<span class="n">Amat</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">jacobian</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">th</span><span class="p">),</span><span class="n">th</span><span class="p">,</span><span class="n">th_eq</span><span class="p">);</span>
<span class="n">Bmat</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">th_eq</span><span class="p">),</span><span class="n">u</span><span class="p">);</span>
</code></pre></div></div>

<p>Construction of numerical matrices $A$ and $B$:</p>

<p>We next set the physical parameters. Natural frequencies, however, we put them zero to apply linear-quadratic control model.</p>

<p>The coupling network matrix is set to be random near ones(m,m):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  KK_init = ones(m,m)+0.2*(2*(rand(m,m)-0.5));
</code></pre></div></div>

<p>and save it in the folder ‘functions/coupling.mat’.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">om_init</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">load</span><span class="p">(</span><span class="s1">'functions/coupling.mat'</span><span class="p">,</span><span class="s1">'KK_init'</span><span class="p">);</span>

<span class="n">A</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Amat</span><span class="p">,[</span><span class="n">om</span><span class="p">,</span><span class="n">KK</span><span class="p">],[</span><span class="n">om_init</span><span class="p">,</span><span class="n">KK_init</span><span class="p">]));</span>
<span class="n">B</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Bmat</span><span class="p">,[</span><span class="n">om</span><span class="p">,</span><span class="n">KK</span><span class="p">],[</span><span class="n">om_init</span><span class="p">,</span><span class="n">KK_init</span><span class="p">]));</span>
</code></pre></div></div>

<h2 id="construction-of-the-lqr-controller-and-its-evaluation">Construction of the LQR controller and its evaluation</h2>

<p>We design the LQR controller and solve it with linearized model.</p>

<p>The cost is only for the symmetric quadrature at $[0,0,0]$ <strong>since we want all of them to be 0</strong>.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="p">[</span><span class="n">ricsol</span><span class="p">,</span><span class="n">cleig</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">Q</span><span class="p">);</span>
<span class="n">K</span> <span class="c1">%% Present the feedback matrix</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
K =

  Columns 1 through 7

    0.6358    0.2930    0.2924    0.2829    0.2604    0.3013    0.2775

  Columns 8 through 10

    0.2777    0.2701    0.2713


</code></pre></div></div>

<p>Practically, any $K$ with positive elements can make the limit point to be 0, e.g., K=[1,1,1].</p>

<p>The initial condition is chosen on $[-0.55\pi,0.55\pi]$ by</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ini = 0.55*pi()*(2*(rand(m,1)-0.5));
</code></pre></div></div>

<p>which is stored in the functions folder, ‘functions/ini.mat’.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">load</span><span class="p">(</span><span class="s1">'functions/ini.mat'</span><span class="p">,</span><span class="s1">'ini'</span><span class="p">);</span> <span class="c1">%% Safe data</span>

<span class="n">tspan</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div></div>

<p>1) Simulate the nonlinear dynamics without any control: $u = 0$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Isys_ori</span><span class="p">;</span>
<span class="n">Isys_ori</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">F</span><span class="p">,[</span><span class="n">om</span><span class="p">,</span><span class="n">KK</span><span class="p">],[</span><span class="n">om_init</span><span class="p">,</span><span class="n">KK_init</span><span class="p">]);</span>
<span class="n">Isys_ori_ftn_temp</span> <span class="o">=</span> <span class="n">matlabFunction</span><span class="p">(</span><span class="n">Isys_ori</span><span class="p">,</span><span class="s1">'Vars'</span><span class="p">,{</span><span class="n">th</span><span class="p">});</span>
<span class="n">Isys_ori_ftn</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">Isys_ori_ftn_temp</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="p">[</span><span class="n">timenc</span><span class="p">,</span> <span class="n">statenc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">Isys_ori_ftn</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span> <span class="c1">%% Solve ODE with 'ode45'</span>
</code></pre></div></div>

<p>2) Simulate the linear dynamics with CARE function</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>

<span class="n">i_linear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="p">[</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_linear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>
</code></pre></div></div>

<p>3) Simulate the nonlinear dynamics with the same control</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Isys</span><span class="p">;</span>
<span class="n">Isys</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,[</span><span class="n">om</span><span class="p">,</span><span class="n">KK</span><span class="p">,</span><span class="n">u</span><span class="p">],[</span><span class="n">om_init</span><span class="p">,</span><span class="n">KK_init</span><span class="p">,(</span><span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">th</span><span class="p">)]);</span>
<span class="n">Isys_ftn_temp</span> <span class="o">=</span> <span class="n">matlabFunction</span><span class="p">(</span><span class="n">Isys</span><span class="p">,</span><span class="s1">'Vars'</span><span class="p">,{</span><span class="n">th</span><span class="p">});</span>
<span class="n">Isys_ftn</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">Isys_ftn_temp</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="p">[</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">Isys_ftn</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="visualization">Visualization</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">plot</span><span class="p">(</span><span class="n">timenc</span><span class="p">,</span> <span class="n">statenc</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'-k'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">%% The first oscillator is black-colored.</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timenc</span><span class="p">,</span> <span class="n">statenc</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [\pi]'</span><span class="p">)</span> <span class="c1">%% The unit is $\pi$.</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Figure 1: Phases of the model without control'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/copiaRM_01.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'-k'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [\pi]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Figure 2: Phases of the linearized model'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/copiaRM_02.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'-k'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [\pi]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Figure 3: Phases of the Kuramoto model'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/copiaRM_03.png" alt="" /></p>

<p>In Figure 1, the limit point is not zero since the mean value of initial phases is nonzero.</p>

<p>Figure 2 shows that the first oscillator keeps it phase above zero to make the final phases zero.</p>

<p>The nonlinear model has less decay then the linearized model, but goes to zero in Figure 3.</p>

<h2 id="failure-of-lqr-control-for-large-initial-data">Failure of LQR control for large initial data</h2>

<p>The initial data is from</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ini2</span> <span class="o">=</span> <span class="nb">pi</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="nb">rand</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="p">));</span>
</code></pre></div></div>

<p>which is uniformly distributed on $[-\pi,\pi]$. We expect the limit point to be separated in the real line with differences $2\pi$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">load</span><span class="p">(</span><span class="s1">'functions/ini2.mat'</span><span class="p">,</span><span class="s1">'ini2'</span><span class="p">);</span> <span class="c1">%% Separated data</span>

<span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>

<span class="n">i_linear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">tspan</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">];</span>
<span class="p">[</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_linear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini2</span><span class="p">);</span>

<span class="n">syms</span> <span class="n">Isys</span><span class="p">;</span>
<span class="n">Isys</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,[</span><span class="n">om</span><span class="p">,</span><span class="n">KK</span><span class="p">,</span><span class="n">u</span><span class="p">],[</span><span class="n">om_init</span><span class="p">,</span><span class="n">KK_init</span><span class="p">,(</span><span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">th</span><span class="p">)]);</span>
<span class="n">Isys_ftn_temp</span> <span class="o">=</span> <span class="n">matlabFunction</span><span class="p">(</span><span class="n">Isys</span><span class="p">,</span><span class="s1">'Vars'</span><span class="p">,{</span><span class="n">th</span><span class="p">});</span>
<span class="n">Isys_ftn</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">Isys_ftn_temp</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">[</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">Isys_ftn</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini2</span><span class="p">);</span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'-k'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [\pi]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Figure 4: Phases of the linearized model'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'-k'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [\pi]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Figure 5: Phases of the Kuramoto model'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/copiaRM_04.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/copiaRM_05.png" alt="" /></p>

<p>We can see that $\theta_1$ does not tend to zero in Figure 5 since $K\times\Theta$ is near zero already. Linear feedback control is not enough, or too weak, for this setting.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In this tutorial, we will demonstrate how to design a LQR controller in order to stabilize the linear population dynamics model dependent on age and space&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">\begin{cases} y_t=y_{xx}-y_a+(\lambda-\mu(a))y+ U\chi_{Q_{\omega}} \text{ in } (0,1)\times (0,A)\times (0,T)\\ y(x,a,0)=y_0(x,a) \text { in } (0,1)\times (0,A)\\ y(0,a,t)=y(1,a,t)=0\text{ in } (0,A)\times(0,T)\\ y(x,0,t)=\int_{0}^{A}\beta(a)y(x,a,t)da,\\ \end{cases}</script>

<p>where $\beta$ and $\mu$ are respectively the fertility and mortality rate. The parameter $\lambda&gt;0$ is an immigration term (or unstable term), $Q_{\omega}=(a,b)\times (a_1,a_2)\times (0,T)$ is the control domain with $(a,b)\subset (0,1)$ and $(a_1,a_2)\subset (0,A).$ Here $(a,b)=(0,1)$ and $(a_1,a_2)=(0,A)$ and we take $A=1$.</p>

<p>We need to reduce the PDE to the finite dimensional system of the form <script type="math/tex">\dot{Z}=AZ+BU</script> where $A$ and $B$ are matrices, and</p>

<script type="math/tex; mode=display">\begin{pmatrix} Z(t) \\ U(t) \\ \end{pmatrix}</script>

<p>is the finite dimensional state vector.</p>

<h2 id="implementation">Implementation</h2>

<p>Construction of the matrix A. We suppose that $\lambda=\frac{1}{2}.$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clc</span><span class="p">;</span> <span class="nb">clear</span><span class="p">;</span>
<span class="n">m</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
<span class="n">n</span><span class="o">=</span><span class="mi">9</span><span class="o">*</span><span class="n">m</span><span class="p">;</span>
</code></pre></div></div>

<p>Matrix of birth Here we suppose that fertility rate $\beta$ equal to:</p>

<script type="math/tex; mode=display">% <![CDATA[
\beta(a) = \begin{cases} 0 & \text { if } a<1/9 \\ 25\frac{\alpha(a-1/9)^{\gamma-1}e^{-(a-1/9)/v}}{v^{\gamma}\Gamma(\gamma)} &\text{ if } 2/9<a<7/9\\ 0 &\text{ if } a\geq 7/9. \end{cases} %]]></script>

<p>Here $\alpha=7$, $\gamma=5$, $v=3$, $a_1=\frac{A}{9}$</p>

<p>The density of new born individuals will be approximated by:</p>

<script type="math/tex; mode=display">y(x,0,t)=\int_{0}^{1}\beta(a)y(x,a,t)da=(1/n)\sum_{1}^{n}\beta(a_i)y(x,a_i,t)</script>

<p>where $a_i$ is the age discretization.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A1</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="n">A2</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="k">for</span> <span class="n">j</span><span class="o">=</span><span class="n">m</span><span class="p">:</span><span class="mi">7</span><span class="o">*</span><span class="n">m</span>
    <span class="n">bj</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="p">/</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="mi">9</span><span class="p">)</span><span class="o">^</span><span class="mi">4</span><span class="o">*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">j</span><span class="p">/</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="mi">9</span><span class="p">)/</span><span class="mi">3</span><span class="p">)/(</span><span class="mi">3</span><span class="o">^</span><span class="mi">5</span><span class="o">*</span><span class="nb">gamma</span><span class="p">(</span><span class="mi">5</span><span class="p">)));</span>
    <span class="n">A2</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">=</span><span class="n">bj</span><span class="o">*</span><span class="n">A1</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">P</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">/</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">A2</span><span class="p">;</span>
</code></pre></div></div>

<p>Discrerization of the second derivative in space and the derivative in age.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A3</span><span class="o">=</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="n">n</span><span class="p">);</span>
<span class="n">B1</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">A3</span><span class="p">;</span>
<span class="n">A4</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">/(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="n">A5</span><span class="o">=</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
<span class="n">A6</span><span class="o">=</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">B2</span><span class="o">=</span><span class="n">A4</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">/(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">A5</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">/(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">A6</span><span class="p">;</span>
<span class="n">B3</span><span class="o">=</span><span class="nb">kron</span><span class="p">(</span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">B2</span><span class="p">);</span>
</code></pre></div></div>

<p>Mortality matrix. The mortality rate $\beta(a)=\dfrac{1}{9(A-a)}$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="k">for</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
        <span class="n">S</span><span class="p">((</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">,(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">=-</span><span class="mi">1</span><span class="p">/(</span><span class="mi">16</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">((</span><span class="n">j</span><span class="o">*</span><span class="n">n</span><span class="p">)/(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))));</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="n">A</span><span class="o">=</span><span class="n">P</span><span class="o">+</span><span class="n">B1</span><span class="o">+</span><span class="n">B3</span><span class="o">+</span><span class="n">S</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="initial-condition">Initial condition</h2>

<p>We suppose that $y(x,a,0)=e^{-((a-3/10)^2/\sqrt{2}+100(x-4/10))}$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="n">Z0</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
        <span class="n">Z0</span><span class="p">((</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">i</span><span class="p">/</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">/</span><span class="mi">10</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)/</span><span class="nb">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">j</span><span class="p">/</span><span class="n">n</span><span class="o">-</span><span class="mi">4</span><span class="p">/</span><span class="mi">10</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Numerical solution without control and visualisation</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">Z</span><span class="p">;</span>
<span class="p">[</span><span class="n">t1</span><span class="p">,</span><span class="n">Z</span><span class="p">]</span><span class="o">=</span><span class="nb">ode45</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">],</span><span class="n">Z0</span><span class="p">);</span>
<span class="n">L</span><span class="o">=</span><span class="n">Z</span><span class="p">(</span><span class="mi">256</span><span class="p">,:);</span>
<span class="n">U</span><span class="o">=</span><span class="n">Z</span><span class="p">(</span><span class="mi">512</span><span class="p">,:);</span>
<span class="n">W</span><span class="o">=</span><span class="n">Z</span><span class="p">(</span><span class="mi">1025</span><span class="p">,:);</span>
<span class="n">J</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">X</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">Y</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">F1</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">Z0</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">V1</span><span class="o">=</span><span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">V2</span><span class="o">=</span><span class="n">V1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">[</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">]</span><span class="o">=</span><span class="nb">meshgrid</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span><span class="n">V2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">F1</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'initial condition'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_01.png" alt="" /></p>

<p>Here is the state y of the unstable system at time t=2,5.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">J</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'state y of the unstable system at timte t=2,5'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_02.png" alt="" /></p>

<p>Here is the state y of the unstable system at time t=5.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">X</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'state y of the unstable system at time t=10'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_03.png" alt="" /></p>

<p>Here is the state y of the unstable system at time t=10.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">Y</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'state y of the unstable system at time t=10'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_04.png" alt="" /></p>

<p>The control matrix B is constructed as follows:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<p>We may now proceed with the optimal control strategy. For a continuous time linear system generated by the matrices $(A,B)$ and an infinite time horizon cost functional defined as</p>

<script type="math/tex; mode=display">J = \int_0^\infty \langle Q z(t), z(t) \rangle + \langle R u(t), u(t)   \rangle dt,</script>

<p>the feedback control law that minimizes the value of the cost is $u = -Kz$, where $K = R^{-1}B*P$ and $P$ is found by solving the continuous time algebraic Ricatti equation</p>

<script type="math/tex; mode=display">A*P+PA-(PB)R^1(B*P)+Q=0.</script>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="n">H</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="o">'</span><span class="p">);</span>
</code></pre></div></div>

<p>LQR feedback control-Algebric Ricatti equation</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ricsol</span><span class="p">,</span> <span class="n">cleig</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
<span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">z</span><span class="p">;</span>
</code></pre></div></div>

<p>Numerical solution with LQR feedback control and visualisation</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f_2</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">Z</span><span class="o">+</span><span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">Z</span><span class="p">);</span>
<span class="p">[</span><span class="n">t2</span><span class="p">,</span><span class="n">Z_ctr</span><span class="p">]</span><span class="o">=</span><span class="nb">ode45</span><span class="p">(</span><span class="n">f_2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">],</span><span class="n">Z0</span><span class="p">);</span>
<span class="n">E</span><span class="o">=</span><span class="n">Z_ctr</span><span class="p">(</span><span class="mi">256</span><span class="p">,:);</span>
<span class="n">O</span><span class="o">=</span><span class="n">Z_ctr</span><span class="p">(</span><span class="mi">512</span><span class="p">,:);</span>
<span class="n">G</span><span class="o">=</span><span class="n">Z_ctr</span><span class="p">(</span><span class="mi">1025</span><span class="p">,:);</span>
<span class="n">G1</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">N</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">M</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">O</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<p>Here is the stabilized state y of the system at the time t=2,5.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'stabilized state of the system at time t=2,5'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_05.png" alt="" /></p>

<p>Here is the stabilized state y of the system at time t=5.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">M</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'stabilized state of the system at time t=5'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_06.png" alt="" /></p>

<p>Here is the stabilized state y of the system at time t=10.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">G1</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'stabilized state of the system at time t=10'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_07.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;We consider the semilinear hyperbolic system&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} \partial_t y + \lambda \partial_x y = c_1 v + yv \quad & (x,t)\in (0,L)\times (0,T) \\ \partial_t v + \lambda \partial_x v = c_2 y + yv  & (x,t)\in (0,L)\times (0,T) \\ y(0,t) = v(0,t) & t \in (0,T) \\ v(L,t) = u(t) & t \in (0,T) \\ y(x,0) = y^0(x) & x \in (0,L) \\ v(x,0) = v^0(x) & x \in (0,L), \end{cases} %]]></script>

<p>where $\lambda &gt; 0$ and $u$ is the control. The stability and boundary stabilization of such 1D hyperbolic systems is studied in [1]. The aim of this tutorial is to semi-discretize in space this system of equations and design a stabilizing control by using the LQR method.</p>

<p>The above system linearized around $(y,v) = (0,0)$ has the form</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} \partial_t y + \lambda \partial_x y = c_1 v  \quad & (x,t)\in (0,L)\times (0,T) \\ \partial_t v + \lambda \partial_x v = c_2 y  & (x,t)\in (0,L)\times (0,T) \\ y(0,t) = v(0,t) & t \in (0,T) \\ v(L,t) = u(t) & t \in (0,T) \\ y(x,0) = y^0(x) & x \in (0,L) \\ v(x,0) = v^0(x) & x \in (0,L). \end{cases} %]]></script>

<p>We will first use the LQR method to design a stabilizing control for the semi-discretized linear system, and then this control will be applied to the semi-discretized semilinear system.</p>

<h2 id="space-discretization">Space discretization</h2>

<p>The intervall $(0,L)$ is divided in $n+1$ subintervals, of size $h_x := \frac{L}{n+1}$, by $n+2$ evenly spaced points $x_k = kh_x$. Hence, $x_0 = 0$ and $x_{n+1} = L$. We set $y_k(t) = y(x_k,t), \quad v_k(t) := v(x_k,t)$ and similarly for the inital conditions $y_k^0(t) = y^0(x_k)$ and $v_k^0(t) := v(x_k)$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clear</span><span class="p">;</span> <span class="nb">clc</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">hx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>The points where y and v are unknown are contained in x1 and x2 respectively, where x1 and x2 are defined below.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x1</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>Finite differences for the space derivative give</p>

<script type="math/tex; mode=display">% <![CDATA[
\partial_x y(x_k,t) \approx \begin{cases} \frac{y_1(t)}{h_x} - \frac{v_0(t)}{h_x} \quad & k=1\\ \frac{y_k(t)-y_{k-1}(t)}{h_x} \quad  &\forall k \in \{2, \ldots, n+1 \} \end{cases} %]]></script>

<p>and</p>

<script type="math/tex; mode=display">% <![CDATA[
\partial_x v(x_k,t) \approx \begin{cases} \frac{v_{k+1}(t)-v_{k}(t)}{h_x} &\forall k \in \{0, \ldots, n-1 \} \\ \frac{-v_n(t)}{h_x} + \frac{u(t)}{h_x} \quad &k=n. \end{cases} %]]></script>

<p>The sign of $\lambda$ in each equation must be taken into account to choose the approximation of $\partial_x y$ and $\partial_x v$.</p>

<p>Let $d = 2(n+1)$ represent the dimension of the state space for the semi-discretized systems. Defining the state variable $z \colon (0,T) \mapsto \mathbb{R}^d$ by</p>

<script type="math/tex; mode=display">z = \big(y_1, y_2, \ldots, y_{n+1}, v_0, v_1, \ldots, v_n \big)^\mathrm{T},</script>

<p>the semilinear system writes as</p>

<script type="math/tex; mode=display">\begin{cases} \dot{z} = Az+ Bu + f(z,u) \qquad t \in (0,T)\\ z(0) = z_0, \end{cases}</script>

<p>and the linearized system writes as</p>

<script type="math/tex; mode=display">\begin{cases} \dot{z} = Az+ Bu \qquad t \in (0,T)\\ z(0) = z^0. \end{cases}</script>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">d</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>We pick the initial condition</p>

<script type="math/tex; mode=display">z^0 := \big(y^0_1, y^0_2, \ldots, y^0_{n+1}, v^0_0, v^0_1, \ldots, v^0_n \big)^\mathrm{T}.</script>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y0</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">x1</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
<span class="n">v0</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">x2</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
<span class="n">z0</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="n">z0</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">y0</span><span class="p">;</span> <span class="n">z0</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">v0</span><span class="p">;</span>
</code></pre></div></div>

<p>We set values for $\lambda$, $c_1$ and $c_2$:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lambda</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>We consider the time parameters</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">nT</span> <span class="o">=</span> <span class="mi">70</span><span class="p">;</span>
<span class="nb">time</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">nT</span><span class="p">);</span>
</code></pre></div></div>

<p>The matrix $A$ of size $d \times d$ is given by</p>

<script type="math/tex; mode=display">% <![CDATA[
A = \begin{pmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \end{pmatrix}, %]]></script>

<p>where $A_{11}, A_{12}, A_{21}, A_{22}$, of size $(n+1)\times(n+1)$, are defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
A_{11} = \begin{pmatrix} \frac{-\lambda}{h_x} & & & \\ \frac{\lambda}{h_x} & \ddots & & & \\  & \ddots & \ddots &  \\  & & \frac{\lambda}{h_x} & \frac{-\lambda}{h_x} \end{pmatrix}, \quad A_{12} = \begin{pmatrix} \frac{\lambda}{h_x} & c_1 & & \\  & 0 & \ddots & \\  & & \ddots & c_1 \\  & & & 0 \\ \end{pmatrix} %]]></script>

<p>and</p>

<script type="math/tex; mode=display">% <![CDATA[
A_{21} = \begin{pmatrix} 0 & & & \\ c_2 & \ddots & & \\  & \ddots & \ddots & \\  & & c_2 & 0 \end{pmatrix}, \quad A_{22}= \begin{pmatrix}  \big(\frac{-\lambda}{h_x}+c_2\big) & \frac{\lambda}{h_x} & & \\  & \frac{-\lambda}{h_x} & \ddots & \\  & & \ddots & \frac{\lambda}{h_x} \\  & & & \frac{-\lambda}{h_x} \end{pmatrix}. %]]></script>

<p>They are constructed as follows.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="c1">%% Lower and upper extradiagonals:</span>
<span class="n">ext_down_1</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="n">ext_down_1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">/</span><span class="n">hx</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">ext_down_2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">ext_up_1</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="n">ext_up_1</span><span class="p">(</span><span class="mi">1</span><span class="p">,(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">):(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">/</span><span class="n">hx</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">ext_up_2</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="n">ext_up_2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">/</span><span class="n">hx</span><span class="p">;</span>
<span class="n">ext_up_3</span> <span class="o">=</span> <span class="n">c1</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="c1">%% We assemple:</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">lambda</span><span class="p">/</span><span class="n">hx</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="n">A</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">c2</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="n">ext_up_1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="n">ext_up_2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="n">ext_up_3</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="n">ext_down_1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="n">ext_down_2</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>

<p>The matrix $B$ is of size $d \times 1$ and is given by</p>

<script type="math/tex; mode=display">B = \begin{pmatrix} B_1 \\ B_2 \end{pmatrix},</script>

<p>where $B_1, B_2$, of size $(n+1)\times 1$, are defined by</p>

<script type="math/tex; mode=display">B_1 = \begin{pmatrix} 0 \\ \vdots \\ 0 \\ c_1 \end{pmatrix}, \quad B_2 = \begin{pmatrix} 0 \\ \vdots \\ 0 \\ \frac{\lambda}{h_x} \end{pmatrix}.</script>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span><span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">B</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">c1</span><span class="p">;</span> <span class="n">B</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">/</span><span class="n">hx</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="the-lqr-method">The LQR method</h2>

<p>We check that a LQR control can be computed for the semi-descretize linear system. To begin, we verify that $ (A,BB^\ast) $ is stabilizable (where $B^\ast$ denotes the transpose of $B$), meaning that $\text{rank}((sI-A) BB^\ast) = d$ for any eigenvalue $s$ of $A$ with a nonnegative real part.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">disp</span><span class="p">(</span><span class="s1">'Stabilizability of (A, BB*):'</span><span class="p">);</span>
<span class="n">eA</span><span class="o">=</span><span class="nb">eig</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">not_stabilizable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">cpt</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
    <span class="k">if</span> <span class="nb">real</span><span class="p">(</span><span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">))</span><span class="o">&gt;=</span><span class="mi">0</span>
        <span class="nb">disp</span><span class="p">(</span><span class="n">cpt</span><span class="p">);</span> <span class="nb">disp</span><span class="p">(</span><span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">));</span>

        <span class="n">M</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">);</span>
        <span class="n">M</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="n">A</span><span class="p">;</span>
        <span class="n">M</span><span class="p">(:,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="p">(</span><span class="n">B</span><span class="o">'</span><span class="p">);</span>

        <span class="n">r</span> <span class="o">=</span> <span class="nb">rank</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">~=</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">not_stabilizable</span> <span class="o">=</span> <span class="n">not_stabilizable</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="k">if</span> <span class="n">not_stabilizable</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="nb">disp</span><span class="p">(</span><span class="s1">'stabilizable.'</span><span class="p">);</span>
<span class="k">else</span>
    <span class="nb">disp</span><span class="p">(</span><span class="s1">'not stabilizable.'</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Stabilizability of (A, BB*):
    18

    0.3047

stabilizable.

</code></pre></div></div>

<p>Then, we verify that the eigenvalues of the Hamiltonian matrix</p>

<script type="math/tex; mode=display">% <![CDATA[
H = \begin{pmatrix} A & -BB^* \\ -Q & -A^* \end{pmatrix} %]]></script>

<p>are not purely imzginary. Here, $Q$ is a matrix of size $d \times d$ to be chosen.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="n">H</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="o">'</span><span class="p">);</span>
<span class="n">H</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">Q</span><span class="p">;</span>
<span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">(</span><span class="n">B</span><span class="o">'</span><span class="p">);</span>
<span class="n">eH</span> <span class="o">=</span> <span class="nb">eig</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
<span class="n">nb_imaginary_eig_val_hamiltonian</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">real</span><span class="p">(</span><span class="n">eH</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="nb">disp</span><span class="p">(</span><span class="s1">'Number of eigenvalues of H on the imaginary axis:'</span><span class="p">)</span>
<span class="nb">disp</span><span class="p">(</span><span class="n">nb_imaginary_eig_val_hamiltonian</span><span class="p">);</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Number of eigenvalues of H on the imaginary axis:
     0


</code></pre></div></div>

<p>To finish, we verify that $(Q, A)$ is stabilizable, meaning that the rank of</p>

<script type="math/tex; mode=display">\begin{pmatrix} Q \\ sI-A \end{pmatrix}</script>

<p>is equal to $d$, for any eigenvalue $s$ of $A$ with a nonnegative real part.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">disp</span><span class="p">(</span><span class="s1">'Detectability of (Q, A):'</span><span class="p">);</span>
<span class="n">not_detectable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">cpt</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
    <span class="k">if</span> <span class="nb">real</span><span class="p">(</span><span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">))</span><span class="o">&gt;=</span><span class="mi">0</span>
        <span class="nb">disp</span><span class="p">(</span><span class="n">cpt</span><span class="p">);</span> <span class="nb">disp</span><span class="p">(</span><span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">));</span>

        <span class="n">J</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">J</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="p">,</span> <span class="p">:)</span> <span class="o">=</span> <span class="n">Q</span><span class="p">;</span>
        <span class="n">J</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">:)</span> <span class="o">=</span> <span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="n">A</span><span class="p">;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="nb">rank</span><span class="p">(</span><span class="n">J</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">~=</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">not_detectable</span> <span class="o">=</span> <span class="n">not_detectable</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="k">if</span> <span class="n">not_detectable</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="nb">disp</span><span class="p">(</span><span class="s1">'detectable.'</span><span class="p">);</span>
<span class="k">else</span>
    <span class="nb">disp</span><span class="p">(</span><span class="s1">'not detectable.'</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Detectability of (Q, A):
    18

    0.3047

detectable.

</code></pre></div></div>

<p>The LQR control is given by the matlab routine care(), as the application $t \mapsto -Kz(t)$. The matrix $K$, of size $m \times d$ is an output of care(), where $m$ is the dimention of the input space and is equal to one.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ricsol</span><span class="p">,</span> <span class="n">cleig</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
<span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">z</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="unstable-and-stabilized-systems-solutions">Unstable and stabilized system’s solutions</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>We compute the solution to the linear system with a control equal to zero:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">F1</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">u</span><span class="p">;</span>
<span class="p">[</span><span class="n">t1</span><span class="p">,</span> <span class="n">Z1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="nb">time</span><span class="p">,</span> <span class="n">z0</span><span class="p">);</span>
</code></pre></div></div>

<p>The corresponding solutions $y$ and $v$ are displayed:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z1</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution y for unstable linear system'</span><span class="p">);</span>

<span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z1</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution v for unstable linear system'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_01.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_02.png" alt="" /></p>

<p>We compute the solution to the linear system with the feedback control:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">F2</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="p">[</span><span class="n">t2</span><span class="p">,</span> <span class="n">Z2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">F2</span><span class="p">,</span> <span class="nb">time</span><span class="p">,</span> <span class="n">z0</span><span class="p">);</span>
</code></pre></div></div>

<p>The corresponding solutions $y$ and $v$ are displayed:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z2</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution y for stabilized linear system'</span><span class="p">);</span>

<span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z2</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution v for stabilized linear system'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_03.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_04.png" alt="" /></p>

<p>We compute the solution to the semilinear system with the same feedback control as the one found for the linear system:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">F3</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.*</span><span class="n">z</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span><span class="p">:</span><span class="n">d</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="n">z</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">z</span><span class="p">);</span><span class="n">z</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="p">;</span> <span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.*</span><span class="n">z</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span><span class="p">:</span><span class="n">d</span><span class="p">,</span><span class="mi">1</span><span class="p">)];</span>
<span class="p">[</span><span class="n">t3</span><span class="p">,</span> <span class="n">Z3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="nb">time</span><span class="p">,</span> <span class="n">z0</span><span class="p">);</span>
</code></pre></div></div>

<p>The corresponding solutions $y$ and $v$ are displayed:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z3</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution y for stabilized semilinear system'</span><span class="p">);</span>

<span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z3</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution v for stabilized semilinear system'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_05.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_06.png" alt="" /></p>

<p>We compare the euclidean norm of the preceding solutions:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y1_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z1</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">y2_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z2</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">v1_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z1</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">v2_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z2</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">y3_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z3</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">v3_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z3</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">norm1</span> <span class="o">=</span> <span class="p">(</span><span class="n">y1_norm</span> <span class="o">+</span> <span class="n">v1_norm</span><span class="p">)</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="n">norm2</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2_norm</span> <span class="o">+</span> <span class="n">v2_norm</span><span class="p">)</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="n">norm3</span> <span class="o">=</span> <span class="p">(</span><span class="n">y3_norm</span> <span class="o">+</span> <span class="n">v3_norm</span><span class="p">)</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">norm1</span><span class="p">,</span> <span class="s1">'lineWidth'</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">norm2</span><span class="p">,</span> <span class="s1">'lineWidth'</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="n">norm3</span><span class="p">,</span> <span class="s1">'lineWidth'</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'zero control, linear syst.'</span><span class="p">,</span> <span class="s1">'feedback control, linear syst.'</span><span class="p">,</span> <span class="s1">'feedback control, semilin. syst.'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'euclidean norm of z'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Euclidean norm of solutions across time'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_07.png" alt="" /></p>

<h2 id="references">References</h2>

<p>[1] Bastin G., J.-M. Coron, Stability and boundary stabilization of 1-D Hyperbolic systems. 2016.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;div class="language-matlab highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="nb"&gt;clc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</code></pre></div></div>

<p>Summary of example objective The goal of this tutorial is to use LQR theory applied to a model of collective behavior. The model choosen shares a formal structure with the semidiscretization of the semilinear 1d heat equation.</p>

<p>Consider $N$  agents $y_i$ for $i=1,…,N$, and let $y=(y_1,…,y_N)\in \mathbb{R}^N$.</p>

<p>The model considered is the following:</p>

<p><script type="math/tex">\dot{y}=Ay+\vec{G}(y)=:F(y)</script> where $A$ is a matrix of the form:</p>

<script type="math/tex; mode=display">% <![CDATA[
A:=\begin{pmatrix}  -1 & 1& 0& & &\cdots & & & 0\\  1 & -2& 1& 0& &\cdots & & & 0\\  0 & 1& -2& 1& 0 &\cdots & & & 0\\  \\  \vdots\\  \\  0 & 0& 0& &\cdots & 0& 1& -2& 1\\  0 & 0& 0& &\cdots & & 0& 1& -1 \end{pmatrix}_{N\times N} %]]></script>

<p>and $\vec{G}:\mathbb{R}^N\to\mathbb{R}^N$ is a non linear function of the form</p>

<script type="math/tex; mode=display">\begin{equation} \vec{G}(x)=\begin{pmatrix}  G(x_1)\\  G(x_2)\\  \vdots\\  G(x_N) \end{pmatrix}, \end{equation}</script>

<p>where $G$ is a non-linear function, matrix $A$ models the interaction between agents. Agent $i$ changes its state according to the state of agent $i+1$ and $i-1$ in a linear way plus a non-linear effect that depends only on his state.</p>

<p>Note that the manifold</p>

<script type="math/tex; mode=display">% <![CDATA[
\mathcal{M}_N=\{x\in\mathbb{R}^N\text{ such that }x=\alpha \begin{pmatrix}&1\\&1\\&\vdots\\&1\end{pmatrix}\quad\alpha\in\mathbb{R}\} %]]></script>

<p>is invariant under $F$. Indeed, taking $x\in\mathcal{M}_N$ we have that</p>

<script type="math/tex; mode=display">Ax=0.</script>

<p>Therefore, the mean will follow the following 1-d dynamical system</p>

<script type="math/tex; mode=display">\dot{\alpha}=G(\alpha)</script>

<p>Here we will consider that $G(0)=0$ and that $DG(0)&gt;0$, we have an unstable critical point at 0. Let N=20,</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="n">A</span><span class="o">=</span><span class="nb">full</span><span class="p">(</span><span class="nb">gallery</span><span class="p">(</span><span class="s1">'tridiag'</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">A</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>and that</p>

<script type="math/tex; mode=display">\vec{G}(x)\in \mathcal{M}_N</script>

<p>here $G$ is taken in the following form (and we compute also its derivative).</p>

<p>The non-linearity choosen is:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
<span class="n">c</span><span class="o">=</span><span class="mf">0.20</span><span class="p">;</span>
<span class="n">syms</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">syms</span> <span class="n">DG</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">piecewise</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;=-</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&lt;</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">a</span><span class="p">));</span>
<span class="n">DG</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="n">G</span><span class="o">=@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nb">double</span><span class="p">(</span><span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="n">DG</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nb">double</span><span class="p">(</span><span class="n">DG</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>

<span class="nb">close</span> <span class="nb">all</span>
<span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">fplot</span><span class="p">(</span><span class="n">G</span><span class="p">,[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Plot of the non-linearity'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
<span class="nb">grid</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0003/copiaRM_01.png" alt="" /></p>

<p>The function field assigns an $N$ dimensional vector corresponding to the field for every point in $\mathbb{R}^N$, matrix $A$ and the nonlinear function $G$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">F</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="n">field</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
F =

  function_handle with value:

    @(t,y)field(A,G,y)


</code></pre></div></div>

<p>Now its the turn to define our cost functional. Our goal will be to stabilize the system in a critical point inside the manifold $\mathcal{M}_N$. Notice that, in particular $0$ is a critical point.</p>

<p>We will choose the matrix $Q$ in a way that the vector that defines $\mathcal{M}_N$ is an eigenvector of the matrix $Q$, we have seen that the manifold $\mathcal{M}_N$ is invariant under the flow. Our cost functional will take into account if we are not in this manifold.</p>

<script type="math/tex; mode=display">% <![CDATA[
Q=\begin{pmatrix}1-\frac{1}{N}&-\frac{1}{N}&-\frac{1}{N}&\cdots&-\frac{1}{N}\\-\frac{1}{N}&1-\frac{1}{N}&-\frac{1}{N}&\cdots&-\frac{1}{N}\\ \vdots&\vdots&\vdots& &\vdots\\ -\frac{1}{N}&-\frac{1}{N}&-\frac{1}{N}&\cdots&1-\frac{1}{N}\end{pmatrix} %]]></script>

<p>We check that its eigenvalues are non-negative</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Q</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="nb">ones</span><span class="p">([</span><span class="n">N</span> <span class="n">N</span><span class="p">])/</span><span class="n">N</span><span class="p">;</span>
<span class="n">EigQ</span><span class="o">=</span><span class="nb">eig</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
EigQ =

     0
     1


</code></pre></div></div>

<p>And we define $R$ being just the identity</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</code></pre></div></div>

<p>Linearize arround the unstable equilibrium 0 and obtain the linearized system $\dot{y}=Ly$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">L</span><span class="o">=</span><span class="n">A</span><span class="o">+</span><span class="n">DG</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</code></pre></div></div>

<p>we set our control matrix B</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</code></pre></div></div>

<p>One has to check the rank of the controllability matrix to see if we satisfy the Kalman rank condition</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Co</span><span class="o">=</span><span class="n">ctrb</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
<span class="nb">rank</span><span class="o">=</span><span class="nb">rank</span><span class="p">(</span><span class="n">Co</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
rank =

     2


</code></pre></div></div>

<p>Once it is done, we are in the position of solving the algebraic Riccati equation</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ricsol</span><span class="p">,</span><span class="n">cleig</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">Q</span><span class="p">);</span>
</code></pre></div></div>

<p>Consider a time span and an initial datum</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">radius</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">ini</span>    <span class="o">=</span> <span class="n">radius</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">+</span><span class="nb">rand</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
radius =

     6


ini =

   -1.3855
    1.4941


</code></pre></div></div>

<p>the free dynamics would result</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tspan</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span> <span class="n">F</span><span class="p">,</span> <span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>
    <span class="nb">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">(:,</span><span class="n">i</span><span class="p">));</span>
    <span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="k">end</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">(:,</span><span class="n">N</span><span class="p">))</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Free dynamics'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
<span class="nb">grid</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0003/copiaRM_02.png" alt="" /></p>

<p>Now the LQ controller with the linear and the non-linear dynamics</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">u_lq</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>


<span class="n">i_linear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">L</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">u_lq</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="p">[</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_linear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>

<span class="n">i_nonlinear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)[</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="o">*</span><span class="n">u_lq</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)];</span>
<span class="p">[</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_nonlinear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>
    <span class="nb">plot</span><span class="p">(</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="n">i</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="k">end</span>
<span class="nb">plot</span><span class="p">(</span><span class="nb">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="n">N</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'LQR regulator on the linearized system'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0003/copiaRM_03.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_nonlinear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>
    <span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="n">i</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="k">end</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="n">N</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'LQR regulator on the non-linear dynamics'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0003/copiaRM_04.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In this tutorial, we will demonstrate how to design a LQR controller in order to stabilize the following linear coupled (hybrid) PDE-ODE system:&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}       y_t = \alpha y_{xx} + \beta y & (x, t) \in (0, 1) \times (0, T) \\       \dot{s}(t) = -y_x(0,t) & t \in (0, T) \\       y(0, t) = u(t), y(1, t) = 0 & t \in (0, T) \\       y(x, 0) = y_0(x), s(0) = s_0 & x \in (0, 1).   \end{cases} %]]></script>

<p>Similar systems may appear in the modelling of a variety physical phenomena, such as the melting of ice in a body of water [1] or fluid-structure interaction [2]. This particular system may be seen as a simplification of the well known one-phase Stefan problem. The stabilization and control of the former has been investigated in recent works by Krstic et al. (see [1] for example). The relationship between the considered system and the Stefan problem, as well as the control of the latter will be considered in a future tutorial.</p>

<p>When no forces are applied, a feature of the governing parabolic PDE is its possibility of generating unstable dynamics as $t \rightarrow \infty$. This phenomenon is due to the fact that the sign of the eigenvalues of the governing elliptic differential operator depends on the magnitude of the constant $\beta$. More precisely, as the differential operator has eigenvalues of the form $\mu_k = \beta - \lambda_k$, where $\lambda_k$ are the eigenvalues of the Dirichlet laplacian, taking $\beta &gt; \lambda_1$ (the biggest among the $\lambda_k$) would yield such a result. We will thence implement a LQR optimal control strategy in order to stabilize the system.</p>

<p>We first need to reduce the PDE-ODE system  to a finite dimensional system of the form</p>

<script type="math/tex; mode=display">\dot{z} = Az + Bu,</script>

<p>where $A$ and $B$ are matrices, and</p>

<script type="math/tex; mode=display">z(t) = \begin{pmatrix} y(t) \\ s(t) \end{pmatrix}</script>

<p>is the finite dimensional state vector.</p>

<p>We fix the parameters as follows: $T=1$, $\alpha=1$ and $\beta = 10$:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clc</span><span class="p">;</span> <span class="nb">clear</span><span class="p">;</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">nT</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">nX</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span><span class="p">/</span><span class="n">nT</span><span class="p">;</span> <span class="n">dx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">nX</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Dir0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Dir1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nb">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nb">beta</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<p>We begin the code by discretizing in space the parabolic PDE; this is done by finite differences:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Id</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">nX</span><span class="p">);</span>
<span class="n">Lapl</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">Id</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">nX</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">nX</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
<span class="n">A0</span> <span class="o">=</span> <span class="nb">alpha</span><span class="o">*</span><span class="mi">1</span><span class="p">/</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">Lapl</span> <span class="o">+</span> <span class="nb">beta</span><span class="o">*</span><span class="n">Id</span><span class="p">;</span>
</code></pre></div></div>

<p>In fact, the finite difference discretization of the Dirichlet laplacian may also be done using the MATLAB routine <code class="highlighter-rouge">delsq</code>. We proceed similarly for the term $y_x(1,t)$ in the ODE, and assemble the complete matrix $A$:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">A0</span><span class="p">;</span> <span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">=-</span><span class="mi">1</span><span class="p">/</span><span class="n">dx</span><span class="p">;</span>
</code></pre></div></div>

<p>The control matrix B is constructed as follows:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nX</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">alpha</span><span class="o">*</span><span class="n">Dir0</span><span class="p">/</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span> <span class="n">b</span><span class="p">(</span><span class="n">nX</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">alpha</span><span class="o">*</span><span class="n">Dir1</span><span class="p">/</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>
<span class="n">B</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Dir0</span><span class="p">/</span><span class="n">dx</span><span class="p">;</span>
<span class="n">B</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div></div>

<p>We may now proceed with the optimal control strategy. For a continuous time linear system generated by the matrices $(A,B)$ and an infinite time horizon cost functional defined as</p>

<script type="math/tex; mode=display">J = \int_0^\infty \langle Q z(t), z(t) \rangle + \langle R u(t), u(t)   \rangle dt,</script>

<p>the feedback control law that minimizes the value of the cost is $u = -Kz$, where $K = R^{-1}B*P$ and $P$ is found by solving the continuous time algebraic Ricatti equation</p>

<script type="math/tex; mode=display">A*P+PA-(PB)R^1(B*P)+Q=0.</script>

<p>We check whether the constructed matrices fit in the framework of LQR. Namely, we first verify that the couple $(A, BB*)$ is stabilizable. This is done by checking if $\text{rank}[\lambda I - A, B] = d$ for any $\lambda \in \sigma(A)\cap \mathbb{R}_+$, where $d$ is the dimension of the state space.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eigs</span> <span class="o">=</span> <span class="nb">eig</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="k">for</span> <span class="n">iter</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nb">real</span><span class="p">(</span><span class="nb">eigs</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span><span class="o">&gt;=</span><span class="mi">0</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">M</span><span class="p">(:,</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">eigs</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">A</span><span class="p">;</span> <span class="n">M</span><span class="p">(:,</span><span class="n">nX</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="p">(</span><span class="n">B</span><span class="o">'</span><span class="p">);</span>
        <span class="n">r_</span> <span class="o">=</span> <span class="nb">rank</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="n">stabilizable</span> <span class="o">=</span> <span class="p">(</span><span class="n">r_</span> <span class="o">==</span> <span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Secondly, we check that the eigenvalues of the associated Hamiltonian matrix do not lie on the imaginary axis.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">H</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="o">'</span><span class="p">);</span>
<span class="n">H</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">Q</span><span class="p">;</span> <span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nX</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">(</span><span class="n">B</span><span class="o">'</span><span class="p">);</span>
<span class="n">eigH</span> <span class="o">=</span> <span class="nb">real</span><span class="p">(</span><span class="nb">eig</span><span class="p">(</span><span class="n">H</span><span class="p">));</span>
<span class="n">nb_im_eig</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">eigH</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Finally, we check if the pair $(Q, A)$ is detectable; the variable <code class="highlighter-rouge">not_det</code> should equal $0$ after the loop.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">not_det</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">iter_</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nb">real</span><span class="p">(</span><span class="nb">eigs</span><span class="p">(</span><span class="n">iter_</span><span class="p">))</span><span class="o">&gt;=</span><span class="mi">0</span>
        <span class="n">M_</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">M_</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:)</span> <span class="o">=</span> <span class="n">Q</span><span class="p">;</span> <span class="n">M_</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">2</span><span class="p">:(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">:)</span> <span class="o">=</span> <span class="nb">eigs</span><span class="p">(</span><span class="n">iter_</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">A</span><span class="p">;</span>
        <span class="n">r_</span> <span class="o">=</span> <span class="nb">rank</span><span class="p">(</span><span class="n">M_</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r_</span> <span class="o">~=</span> <span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">not_det</span> <span class="o">=</span> <span class="n">not_det</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We are now in a position to construct the LQR feedback control by solving the algebraic Ricatti equation. This is done by using the MATLAB Control Toolbox routine <code class="highlighter-rouge">care</code>:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ricsol</span><span class="p">,</span> <span class="n">cleig</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
<span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">z</span><span class="p">;</span>
</code></pre></div></div>

<p>We now compare the uncontrolled (thence unstable) dynamics with the dynamics stabilized by the LQR feedback control. As initial datum for both systems, we pick $u_0(x) = \cos(\pi*x)$ and $s_0 = 0.1$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_int</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="p">);</span>
<span class="n">y0</span> <span class="o">=</span> <span class="nb">cos</span><span class="p">(</span><span class="n">x_int</span><span class="o">*</span><span class="nb">pi</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
<span class="n">z0</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">z0</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">z0</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">y0</span><span class="p">;</span>
</code></pre></div></div>

<p>The free system is solved with the Dirichlet boundary condition $u(0,t) = 0.15$:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f1</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="mf">0.15</span><span class="p">;</span>
<span class="p">[</span><span class="n">t1</span><span class="p">,</span> <span class="n">z_free</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">nT</span><span class="p">),</span> <span class="n">z0</span><span class="p">);</span>
<span class="p">[</span><span class="n">X1</span><span class="p">,</span><span class="n">Y1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">x_int</span><span class="p">);</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">Y1</span><span class="p">,</span> <span class="n">z_free</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Unstable state y_{un} = y_{un}(t,x)'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0003/copiaRM_01.png" alt="" /></p>

<p>Now we solve and visualize the controlled problem:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f2</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="p">[</span><span class="n">t2</span><span class="p">,</span> <span class="n">z_ctr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">nT</span><span class="p">),</span> <span class="n">z0</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="p">[</span><span class="n">X2</span><span class="p">,</span><span class="n">Y2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="n">x_int</span><span class="p">);</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">Y2</span><span class="p">,</span> <span class="n">z_ctr</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Stablilized state y_{st} = y_{st}(t,x)'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0003/copiaRM_02.png" alt="" /></p>

<p>We also plot the corresponding solutions to the ODE:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">z_free</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">'Color'</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.8500</span><span class="p">,</span> <span class="mf">0.3250</span><span class="p">,</span> <span class="mf">0.0980</span><span class="p">],</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">z_ctr</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">'Color'</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4470</span><span class="p">,</span> <span class="mf">0.7410</span><span class="p">],</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Unstable'</span><span class="p">,</span> <span class="s1">'Stabilized'</span><span class="p">,</span> <span class="s1">'Location'</span><span class="p">,</span> <span class="s1">'SouthWest'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'The state s'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0003/copiaRM_03.png" alt="" /></p>

<p>As a final test of our results, we compare the $L^2(0,1)$-norms of both the controlled and uncontrolled state with respect to time.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">norm_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/</span><span class="n">nX</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">z_free</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.^</span><span class="mf">0.5</span><span class="p">;</span>
<span class="n">norm_ctr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/</span><span class="n">nX</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">z_ctr</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.^</span><span class="mf">0.5</span><span class="p">;</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">norm_free</span><span class="p">,</span> <span class="s1">'Color'</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.8500</span><span class="p">,</span> <span class="mf">0.3250</span><span class="p">,</span> <span class="mf">0.0980</span><span class="p">],</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">norm_ctr</span><span class="p">,</span> <span class="s1">'Color'</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4470</span><span class="p">,</span> <span class="mf">0.7410</span><span class="p">],</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Unstable state'</span><span class="p">,</span> <span class="s1">'Stabilized state'</span><span class="p">,</span> <span class="s1">'Location'</span><span class="p">,</span> <span class="s1">'NorthWest'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'L^2 Norm'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0003/copiaRM_04.png" alt="" /></p>

<h2 id="references">References:</h2>

<p>[1] Koga, Shumon and Diagne, Mamadou and Krstic, Miroslav. Output feedback control of the one-phase Stefan problem. 2016 IEEE 55th Conference on Decision and Control (CDC) (2016).</p>

<p>[2] Vazquez, Juan Luis and Zuazua, Enrique. Large time behavior for a simplified 1D model of fluid-solid interaction. Comm. Partial Differential Equations 28 (2003), no. 9-10, 1705-1738.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In this tutorial we are going to show how to use MATLAB to control a discrete-time dynamical system that models the interactions between the nodes of a graph. The control policy will minimize a discrete linear quadratic regulator.&lt;/p&gt;
</code></pre></div></div>

<p>Let us consider a graph G that consists on $N$ nodes $x_i\in\mathbb{R}$, $i={1,2,…,N}$ that evolve in discrete time steps according to the following equation:</p>

<script type="math/tex; mode=display">x_i[k+1] = x_i[k] + \gamma\sum_{j\neq i}(x_j[k]-x_i[k]),\ k\in\mathbb{N}\cup \{0\},\ \forall i=1,2,...N \\ x_i[0] = x_{i,0},\ \forall i=1,2,...N</script>

<p>where $\gamma &gt; 0$ is a coupling parameter.</p>

<p>We can simplify this equation by using the Perron matrix $P$ of the graph, this matrix is defined as $P = I - \gamma L$, where $L$ is the Laplacian of the graph and $I$ is the identity matrix. Let $x$ be $[x_1,…,x_N]^T$, the vector of states of the nodes. Moreover, we may add a control</p>

<script type="math/tex; mode=display">\{u[k]\}_{k=0,1,...}, u\in\mathbb{R}^M, 1\leq M \leq N</script>

<p>to drive the states of the nodes to a desired state.</p>

<script type="math/tex; mode=display">x[k+1]=Px[k]+Bu[k] \\    y[k] = Cx[k]        \\    x[0] = x_0 = [x_{1,0},...,x_{N,0}]^T</script>

<p>were $B$ and $C$ are two fixed matrices and $y\in\mathbb{R}^S$ are the observed states of $1\leq S\leq N$ nodes.</p>

<p>We aim to design a control policy ${u[k]}_{k=0,1,…}$ such that minimizes the following functional $J(x,u)$ while stabilizing the system.</p>

<script type="math/tex; mode=display">J(x,u) = \sum_{k=0}^\infty\left(x[k]^TQx[k]+u[k]^TRu[k]\right)</script>

<p>where $Q$ and $R$ are semidefinite positive and definite positive matrices respectively. We can choose these two matrices in order to penalize aggressive or slow controls. To do so, we will use MATLAB’s control system toolbox.</p>

<p>Finally, we will add a reference term in the control so that we can drive the system into a desired state.</p>

<p>For instance, let us consider the coupling parameter</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">gamma</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
</code></pre></div></div>

<p>We define now a connected and bidirected graph G. Let E be the edges of the graph. We will define this set as a 2-column matrix and then we create the graph G.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">E</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">];</span>
<span class="n">E</span> <span class="o">=</span> <span class="nb">table</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="s1">'VariableNames'</span><span class="p">,{</span><span class="s1">'EndNodes'</span><span class="p">});</span>
<span class="n">G</span> <span class="o">=</span> <span class="nb">graph</span><span class="p">(</span><span class="n">E</span><span class="p">);</span>
</code></pre></div></div>

<p>This is our graph</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">plot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'EdgeColor'</span><span class="p">,</span> <span class="s1">'r'</span><span class="p">,</span> <span class="s1">'MarkerSize'</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Graph representation'</span><span class="p">,</span> <span class="s1">'FontSize'</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0002/copiaRM_01.png" alt="" /></p>

<p>N is the size of the graph, that is to say, the number of nodes.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="nb">numnodes</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</code></pre></div></div>

<p>We compute the number of neighbours of each node</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">connectivities</span> <span class="o">=</span> <span class="nb">degree</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</code></pre></div></div>

<p>We check whether the graph is connected or not, if not, we must choose a different graph.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="nb">conncomp</span><span class="p">(</span><span class="n">G</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Generate a new graph'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In this example the considered graph is connected.</p>

<p>We compute the Perron matrix of $G$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">P</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="nb">gamma</span> <span class="o">*</span> <span class="nb">laplacian</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</code></pre></div></div>

<p>We can see that the system tends to reach a consensus, that is to say, if no control is applied to the system, it evolves to a steady state in which all the nodes have the same state.</p>

<p>We define the initial state $x_0$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">'</span><span class="p">;</span>
</code></pre></div></div>

<p>The mean of $x_0$ is 3</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mean</span><span class="p">(</span><span class="n">x_0</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
ans =

     3


</code></pre></div></div>

<p>The states of the nodes will evolve to the mean of the states at the initial time. We let the system evolve for 150 iterations.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">itmax</span> <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">itmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">x</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">x_0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">itmax</span>
    <span class="n">x</span><span class="p">(:,</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="n">x</span><span class="p">(:,</span><span class="n">k</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="nb">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">itmax</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">,:),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Node 1'</span><span class="p">,</span><span class="s1">'Node 2'</span><span class="p">,</span><span class="s1">'Node 3'</span><span class="p">,</span><span class="s1">'Node 4'</span><span class="p">,</span><span class="s1">'Node 5'</span><span class="p">,</span><span class="s1">'Node 6'</span><span class="p">,</span><span class="s1">'Node 7'</span><span class="p">,</span><span class="s1">'Node 8'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Graph evolution without control'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Iterations'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'States of the nodes'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0002/copiaRM_02.png" alt="" /></p>

<p>As stated before, we can see in this figure that the system naturally reaches consensus.</p>

<p>Recall that the system dynamics can be written as</p>

<script type="math/tex; mode=display">x[k+1] = Px[k]+Bu[k] \\    y[k] = Cx[k]</script>

<p>for any $k =0,1,…$.</p>

<p>We want to find a control $u$ such that the system stabilizes to the zero state.</p>

<p>We proceed to define matrices B and C:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="n">C</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="c1">%% We can check whether the system is controllable</span>
<span class="k">if</span> <span class="nb">rank</span><span class="p">(</span><span class="n">ctrb</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">B</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">N</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'it is not controllable!'</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1">%% In this case, it is controllable.</span>
</code></pre></div></div>

<p>We choose the matrices $Q$ and $R$ by using Bryson and Ho’s criterium.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Q_diag</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_0</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
<span class="n">R_diag</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">/</span> <span class="mi">5</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
<span class="n">Q</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="n">Q_diag</span><span class="p">);</span>
<span class="n">R</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="n">R_diag</span><span class="p">);</span>
</code></pre></div></div>

<p>We can use now the function dlqr (discrete linear quadratic regulator) to find the feedback control $u = -K_{f} x[k]$ that minimizes the functional $J(x,u)$.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Kf</span><span class="p">,</span> <span class="o">~</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlqr</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
</code></pre></div></div>

<p>Now we can stabilize the system by using the feedback control that we have just computed</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">itmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">itmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">x</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">x_0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">itmax</span>
    <span class="n">x</span><span class="p">(:,</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kf</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">(:,</span><span class="n">k</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>

<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="nb">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">itmax</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">,:),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Node 1'</span><span class="p">,</span><span class="s1">'Node 2'</span><span class="p">,</span><span class="s1">'Node 3'</span><span class="p">,</span><span class="s1">'Node 4'</span><span class="p">,</span><span class="s1">'Node 5'</span><span class="p">,</span><span class="s1">'Node 6'</span><span class="p">,</span><span class="s1">'Node 7'</span><span class="p">,</span><span class="s1">'Node 8'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Graph stabilization'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Iterations'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'States of the nodes'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0002/copiaRM_03.png" alt="" /></p>

<p>We can see that the system is stabilized fast. One can tune the stabilization speed by choosing matrices $Q$ and $R$ in a smart way.</p>

<p>Now, we are about to add a reference term to the control to drive the system to a desired state. For instance, we can drive the system into the reference state</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
</code></pre></div></div>

<p>We add a reference term to the control that is proportional to the reference r, $u[k] = -K_{f}x[k] + K_{r}r$. We can use linear algebra to compute the matrix $K_{r}$ in terms of the system matrices.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Kr</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kf</span> <span class="o">-</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>We drive the system to the reference state.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">itmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">itmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">x</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">x_0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">itmax</span>
    <span class="n">x</span><span class="p">(:,</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kf</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kr</span> <span class="o">*</span> <span class="n">r</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="nb">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">itmax</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">,:),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Node 1'</span><span class="p">,</span><span class="s1">'Node 2'</span><span class="p">,</span><span class="s1">'Node 3'</span><span class="p">,</span><span class="s1">'Node 4'</span><span class="p">,</span><span class="s1">'Node 5'</span><span class="p">,</span><span class="s1">'Node 6'</span><span class="p">,</span><span class="s1">'Node 7'</span><span class="p">,</span><span class="s1">'Node 8'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Controlled graph'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Iterations'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'States of the nodes'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0002/copiaRM_04.png" alt="" /></p>

<p>Assume now that we can control only the node 1 and we want to drive the node 8 to the reference state r = 1. Can we do it? Let’s see.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">C</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
<span class="n">C</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="nb">rank</span><span class="p">(</span><span class="n">ctrb</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">B</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">N</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'it is not controllable!'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It is controllable.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Q_diag</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_0</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
<span class="n">R_diag</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">/</span> <span class="mi">5</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>
<span class="n">Q</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="n">Q_diag</span><span class="p">);</span>
<span class="n">R</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="n">R_diag</span><span class="p">);</span>
<span class="p">[</span><span class="n">Kf</span><span class="p">,</span> <span class="o">~</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlqr</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
<span class="n">Kr</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kf</span> <span class="o">-</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">itmax</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">itmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">x</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">x_0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">itmax</span>
    <span class="n">x</span><span class="p">(:,</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kf</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kr</span> <span class="o">*</span> <span class="n">r</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="nb">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">itmax</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">,:),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Node 1'</span><span class="p">,</span><span class="s1">'Node 2'</span><span class="p">,</span><span class="s1">'Node 3'</span><span class="p">,</span><span class="s1">'Node 4'</span><span class="p">,</span><span class="s1">'Node 5'</span><span class="p">,</span><span class="s1">'Node 6'</span><span class="p">,</span><span class="s1">'Node 7'</span><span class="p">,</span><span class="s1">'Node 8'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Driving node 8 to the state 1'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Iterations'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'States of the nodes'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0002/copiaRM_05.png" alt="" /></p>

<p>As we can see, the node 8 is driven to the state 1 by achieving consensus in all the states of the graph.</p>

<h2 id="references">References</h2>

<p>[1]: R. Olfati-Saber, J. A. Fax, and R. M. Murray, "Consensus and cooperation in networked multi-agent systems". Proc. IEEE. vol. 95, pp. 215&#150;233, Jan. 2007.</p>
<p>[2]: K. J. &Aring;str&ouml;m, and R. M. Murray, "Feedback Systems: An Introduction for Scientists and Engineers". Princeton University Press, 2008, Princeton, NJ.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;We consider a population of N coupled-phase oscillators, $\theta_i(t)$, $i=1,\ldots,N$ and we want to compute a control such that in time $T$ we reach the state $\theta_i(T)=\ldots =\theta_N(T)=:\bar{\theta}$ in which all the oscillators are sincronized.&lt;/p&gt;
</code></pre></div></div>

<h2 id="the-mathematical-model">The mathematical model</h2>

<p>The dynamics of the oscillators is described by the Kuramoto model</p>

<script type="math/tex; mode=display">\dot{\theta}_i(t) = \frac{1}{N}\sum_{j=1}^N \sin(\theta_j(t)-\theta_i(t)) + b_i(t),\;\;\; i=1,\ldots,N</script>

<script type="math/tex; mode=display">\theta_i(0) = \theta_i^0.</script>

<p>The model is non-linear, then, we apply a standard linearization process around the steady state $\bar{\theta}$ obtaining</p>

<script type="math/tex; mode=display">\dot{\Theta}(t) = A\Theta(t),\;\;\;\Theta(0) = \Theta^0,\;\;\;\Theta =(\theta_1,\ldots,\theta_N)^T.</script>

<p>By classical techniques, the control is obtained by minimizing the following cost functional, subject to the linearized Kuramoto model, for each node</p>

<script type="math/tex; mode=display">J(b_i) = \frac{1}{2N} \sum_{j=1}^N(\theta_j(T)-\theta_i(T))^2+\frac{\beta}{2}\int_0^T b_i(t)^2dt,\;\;\;\beta>0,</script>

<p>in which</p>

<ul>
  <li>
    <p>the first term measures the distance between the rest of nodes and the target.</p>
  </li>
  <li>
    <p>the second term is a penalization one introduced in order to   avoid using control with a too large size.</p>
  </li>
</ul>

<p>In fact, through the above minimization procedure, we find the control $b = (b_1,\ldots,b_N)$ which has minimum norm among all the controls capable to steer the system to the equilibrium dynamics.</p>

<h2 id="how-do-you-usually-solve-this-type-of-problem">How do you usually solve this type of problem?</h2>

<p>The usual technique for solving minimizing problems based on quadratic functionals is the Gradient Descent Method, which is based on the following iterative algorithm</p>

<script type="math/tex; mode=display">b^{k+1}_i = b^k_i - \eta\nabla J(b_i^k).</script>

<p>This technique is tipycally chosen because: - It is (relatively) easy to implement. - It is not very memory demanding.</p>

<h2 id="what-we-propose">What we propose?</h2>

<p>As the functional J(b_i) depend on all nodes $\Theta_j$, the gradient $\nabla J(b_i)$ too. Therefore, in each iteration of the Gradient Descent algorithm we shall consider all nodes in the network. Then, when the number of nodes is large, the complexity if substantial per iteration. To avoid evaluate the full gradient, we propose to approach the problem by means of the Stochastic Descent Gradient method which only uses a small portion of data.</p>

<p>Matrix $A$ of the linearized Kuramoto model</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">A</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
A =

   -1.0000    0.1429    0.1429    0.1429    0.1429    0.1429    0.1429
    0.1429   -1.0000    0.1429    0.1429    0.1429    0.1429    0.1429
    0.1429    0.1429   -1.0000    0.1429    0.1429    0.1429    0.1429
    0.1429    0.1429    0.1429   -1.0000    0.1429    0.1429    0.1429
    0.1429    0.1429    0.1429    0.1429   -1.0000    0.1429    0.1429
    0.1429    0.1429    0.1429    0.1429    0.1429   -1.0000    0.1429
    0.1429    0.1429    0.1429    0.1429    0.1429    0.1429   -1.0000


</code></pre></div></div>

<p>Initial condition: <script type="math/tex">\Theta(0) = \Theta^0.</script></p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mu</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="n">sigma</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">theta0</span> <span class="o">=</span> <span class="n">normrnd</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
theta0 =

   16.2469
    3.5642
    9.8242
   -6.0650
    4.6452
   10.0029
   -9.6151


</code></pre></div></div>

<p>Now, choose initial control,</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">T</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">;</span>
<span class="n">tspan</span> <span class="o">=</span> <span class="n">t0</span><span class="p">:</span><span class="n">dt</span><span class="p">:</span><span class="n">T</span><span class="p">;</span>
<span class="n">u0</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">tspan</span><span class="p">),</span><span class="n">N</span><span class="p">);</span>
</code></pre></div></div>

<p>We can solve with the StochasticGradient function.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Results_Stochastic</span> <span class="o">=</span>  <span class="n">StochasticGradient</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">theta0</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span><span class="n">u0</span><span class="p">);</span>
</code></pre></div></div>

<p>And see the convergence</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig1</span> <span class="o">=</span> <span class="n">JPlotConvergence</span><span class="p">(</span><span class="n">Results_Stochastic</span><span class="p">,</span><span class="s1">'Convergence of Stochastic Method'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0006/copiaRM_01.png" alt="" /></p>

<p>We can see the result obtained</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig2</span> <span class="o">=</span> <span class="n">LastThetaPlot</span><span class="p">(</span><span class="n">Results_Stochastic</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0006/copiaRM_02.png" alt="" /></p>

<h2 id="comparison-clasical-vs-stochastic">Comparison Clasical vs Stochastic</h2>

<p>In this example, we show that stochastic method is faster than the classical descent in a small network.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Results_Classical</span> <span class="o">=</span> <span class="p">{};</span><span class="n">Results_Stochastic</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">%%</span>
<span class="n">maxN</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">%% &lt;=== Maximal number of oscillator allowed in the model</span>
<span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="n">maxN</span>
    <span class="c1">%% We solve the problem for each N</span>
    <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">%% Definition of the linearized Kuramoto problem</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
        <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="c1">%% Initial state</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="n">sigma</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">theta0</span> <span class="o">=</span> <span class="n">normrnd</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">%% Initial control</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">T</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
    <span class="n">tspan</span> <span class="o">=</span> <span class="n">t0</span><span class="p">:</span><span class="n">dt</span><span class="p">:</span><span class="n">T</span><span class="p">;</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">tspan</span><span class="p">),</span><span class="n">N</span><span class="p">);</span>

    <span class="c1">%% Classical Gradient Method</span>
    <span class="n">Results_Classical</span><span class="p">{</span><span class="n">iter</span><span class="p">}</span>  <span class="o">=</span>  <span class="n">ClassicalGradient</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">theta0</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span><span class="n">u0</span><span class="p">);</span>
    <span class="c1">%% Stochastic Gradient Method</span>
    <span class="n">Results_Stochastic</span><span class="p">{</span><span class="n">iter</span><span class="p">}</span> <span class="o">=</span>  <span class="n">StochasticGradient</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">theta0</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span><span class="n">u0</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We can graphically see the following result. If the number of nodes increase we can see better the efectiveness of the stochastic gradient descent method with respect to the classical.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">%% For the next step it is necessary to convert the cells into arrays</span>
<span class="n">Results_Classical</span>  <span class="o">=</span> <span class="p">[</span><span class="n">Results_Classical</span><span class="p">{:}];</span>
<span class="n">Results_Stochastic</span> <span class="o">=</span> <span class="p">[</span><span class="n">Results_Stochastic</span><span class="p">{:}];</span>
<span class="c1">%%</span>
<span class="n">fig2</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span> <span class="n">ax</span>  <span class="o">=</span> <span class="nb">axes</span><span class="p">;</span>
<span class="n">ax</span><span class="o">.</span><span class="n">FontSize</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XLabel</span><span class="o">.</span><span class="n">String</span> <span class="o">=</span> <span class="s1">'Number of Oscillators'</span><span class="p">;</span> <span class="n">ax</span><span class="o">.</span><span class="n">YLabel</span><span class="o">.</span><span class="n">String</span> <span class="o">=</span> <span class="s1">'time(s)'</span><span class="p">;</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XGrid</span> <span class="o">=</span> <span class="s1">'on'</span><span class="p">;</span> <span class="n">ax</span><span class="o">.</span><span class="n">YGrid</span> <span class="o">=</span> <span class="s1">'on'</span><span class="p">;</span>
<span class="c1">%%</span>
<span class="nb">line</span><span class="p">([</span><span class="n">Results_Stochastic</span><span class="o">.</span><span class="n">N</span><span class="p">],[</span><span class="n">Results_Stochastic</span><span class="o">.</span><span class="n">t</span><span class="p">],</span><span class="s1">'Parent'</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="s1">'Color'</span><span class="p">,</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'Marker'</span><span class="p">,</span><span class="s1">'s'</span><span class="p">)</span>
<span class="nb">line</span><span class="p">([</span><span class="n">Results_Classical</span><span class="o">.</span><span class="n">N</span><span class="p">],[</span><span class="n">Results_Classical</span><span class="o">.</span><span class="n">t</span><span class="p">],</span><span class="s1">'Parent'</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="s1">'Color'</span><span class="p">,</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'Marker'</span><span class="p">,</span><span class="s1">'s'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">({</span><span class="s1">'Stochastic Gradient'</span><span class="p">,</span><span class="s1">'Classical Gradient'</span><span class="p">})</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0006/copiaRM_03.png" alt="" /></p>

<p>Altough in this example we are dealing with a small network, we have shown that stochastic method is faster than the classical descent. If the number of nodes increase we can see better the efectiveness of the stochastic gradient descent method with respect to the classical. <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0006/ClassicalVStochastic.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;We study the shape design problem through the minimization of the cost functional&lt;/p&gt;
</code></pre></div></div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%20%5Cleft%28%20%5Ctheta%2C%20y%20%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cint_%7B%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%20%5E2%20%5C%2C%20%5Cmathrm%7Bd%7D%20%5COmega%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?y%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" /> is the state variable, <img src="https://latex.codecogs.com/gif.latex?y_d%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" /> is a target function, and <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29" /> the normal displacement to a reference boundary,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%3D%20%5Cleft%5C%7B%20%5Cmathbf%7Bx%7D%20&plus;%20%5Ctheta%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cmathbf%7Bn%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3A%20%5Cmathbf%7Bx%7D%20%5Cin%20%5CGamma_%7B0%7D%20%5Cright%5C%7D." />
</p>

<p>The problem is subject to the following elliptic PDE in the domain <img src="https://latex.codecogs.com/gif.latex?%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Csubset%20%5Cmathbb%7BR%7D%5Ed" /> with Dirichlet boundary conditions on <img src="https://latex.codecogs.com/gif.latex?%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3D%20%5CGamma_w%20%5Ccup%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29" />,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y%20%3D%20f%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%5C%5C%20y%20%3D%20y_%7Bw%7D%20%26%20%5Ctext%7Bin%20%7D%20%5CGamma_w%2C%5C%5C%20y%20%3D%20y_%7Bs%7D%20%26%20%5Ctext%7Bin%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5Cend%7Bcases%7D" />
</p>

<p>and <img src="https://latex.codecogs.com/gif.latex?f%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" />.</p>

<p>We consider the set of admissible domains whose measure is fixed,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BU%7D_%7Bad%7D%20%3D%20%5Cleft%5C%7B%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3A%20%5Clvert%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Crvert%20%3D%20%5COmega_0%20%5Cright%5C%7D%2C" />
</p>

<p>and aim at finding the optimal shape that minimizes the cost function. In order to do so, we use the steepest descent method with descent direction given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cdelta%20%5Ctheta%20%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%3D%20-%20%5Cleft%5B%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20y%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20y_d%20%5Cright%29%20%5E2%20&plus;%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cfrac%7B%5Cpartial%20y%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20&plus;%20q%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%5D%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?v" /> is solution of the adjoint problem</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%20%5CDelta%20v%20%3D%20y%20-%20y_d%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20v%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3D%20%5CGamma_w%20%5Ccup%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<p>The normal displacement field is updated at every iteration,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B%5Cleft%28%20n%20&plus;%201%20%5Cright%29%7D%20%3D%20%5Ctheta%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20&plus;%20%5Cepsilon%20%5Cdelta%7B%5Ctheta%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%7D%2C" />
</p>

<p>with <img src="https://latex.codecogs.com/gif.latex?\epsilon" /> sufficiently small. The Lagrange multiplier is computed in order to ensure that the volume contraint is fulfilled, thus</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?q%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%3D%20-%20%5Cfrac%7B1%7D%7B%5Cleft%7C%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%5Cright%7C%7D%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20%5Cleft%5B%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20y%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20y_d%20%5Cright%29%20%5E2%20&plus;%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cfrac%7B%5Cpartial%20y%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%5D%20%5Cmathrm%7Bd%7D%20%5CGamma." />
</p>

<h2 id="mesh-motion-solver">Mesh Motion Solver</h2>

<p>The solutions to the primal and adjoint problems are commonly approximated by means of numerical methods, such as the finite element method (FEM) or the finite volume method (FVM). In order to apply these techniques, the domain under study must be tessellated with a mesh. Nevertheless, applying the displacement directly to the controlled boundary will deteriorate the surrounding elements after a few iterations and the computation will crash if the interior nodes of the domain are not reallocated. In order to avoid this, the domain can be re-meshed after a number of iterations. However, this can be very expensive as a completely new mesh must be generated. A commonly used alternative is to move the interior nodes of the mesh according to the displacements prescribed on the boundary.  By doing this the number of elements and the nodes connectivities remain the same, only the mesh nodes positions are updated. The Solid Body Rotation Stress method and the Laplacian smoothing included in the OpenFOAM library have been used.</p>

<h3 id="linear-elasticity">Linear Elasticity</h3>

<p>Mesh motion can be achieved by treating the mesh as an elastic body and solving the equations of Linear Elasticity for solids with prescribed displacements on the domain boundary,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20%5Cpartial_j%20%5Cleft%28%20G%20%5Cpartial_j%20u_i%20%5Cright%29%20&plus;%20%5Cpartial_j%20%5Cleft%28%20G%20%5Cpartial_i%20u_j%20%5Cright%29%20&plus;%20%5Cpartial_i%20%5Cleft%28%20%5Clambda%20%5Cpartial_j%20u_j%20%5Cright%29%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<h3 id="solid-body-rotation-sbr-stress">Solid Body Rotation (SBR) Stress</h3>

<p>The Linear Elasticity model fails when dealing with rotating meshes. This can be mitigated by selecting the material properties in a proper manner,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%202%20%5Cpartial_j%20%5Cleft%28%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cpartial_j%20u_i%20%5Cright%29%20&plus;%20%5Cpartial_j%20%5Cleft%5B%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cleft%28%20%5Cpartial_i%20u_j%20-%20%5Cpartial_j%20u_i%20-%20%5Cdelta_%7Bij%7D%20%5Cpartial_k%20u_k%20%5Cright%29%20%5Cright%5D%20%3D%200%2C%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<h3 id="laplacian-smoothing">Laplacian Smoothing</h3>

<p>A simple and widely used practice is to solve a Laplace equation with the prescribed displacements as boundary conditions,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20%5CDelta%20u_i%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<p>The behavior of the Laplacian smoothing can be improved by adding a non-uniform diffusivity term,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cpartial_k%20%5Cleft%28%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cpartial_k%20u_i%20%5Cright%29%20%3D%200%20%5Cquad%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29." />
</p>

<p>The diffusion field <img src="https://latex.codecogs.com/gif.latex?%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%3A%20%5Cmathbb%7BR%7D%5Ed%20%5Crightarrow%20%5Cmathbb%7BR%7D" /> decreases with the distance to the controlled boundary. A common choice is to make it depend on the inverse of the distance as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7Bd%5Em%7D%2C" />
</p>

<p>so that the nodes next to the deforming boundaries move with similar displacements as those on the boundary.</p>

<h2 id="getting-started">Getting Started</h2>

<p>The solver must be compiled in the terminal. It is advisable to first clean previous compilations with</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wclean
</code></pre></div></div>

<p>and then use</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmake
</code></pre></div></div>

<h3 id="dynamic-mesh">Dynamic Mesh</h3>

<p>The mesh motion solver is specified in the dictionary <em>constant/dynamicMeshDict</em>.</p>

<ul>
  <li>For the Laplacian solver:</li>
</ul>

<pre><code class="language-C++">dynamicFvMesh   dynamicMotionSolverFvMesh;

motionSolverLibs ( "libfvMotionSolvers.so" );

solver          displacementLaplacian;

displacementLaplacianCoeffs
{
    //diffusivity  	uniform;
    //diffusivity     	inversePointDistance (deformedWall);
    diffusivity     	quadratic inversePointDistance (deformedWall);
}
</code></pre>

<ul>
  <li>For SBR Stress method:</li>
</ul>

<pre><code class="language-C++">motionSolver 	displacementSBRStress;

displacementSBRStressCoeffs
{
    // diffusivity  	uniform;
    // diffusivity  	directional (1 200 0);
    // diffusivity  	motionDirectional (1 1000 0);
    // diffusivity  	file motionDiffusivity;
    // diffusivity  	quadratic inverseFaceDistance (deformedWall);
    // diffusivity  	quadratic inverseDistance (deformedWall);
    diffusivity  	quadratic inversePointDistance (deformedWall);
    // diffusivity	inversePointDistance (deformedWall);
}
</code></pre>

<h3 id="prerequisites">Prerequisites</h3>

<p>OpenFOAM C++ library must be installed in order to compile the code.</p>

<p>The OpenFOAM distribution provided by the <a href="https://openfoam.org/">OpenFOAM Foundation</a> was used.</p>

<h2 id="running-a-case">Running a Case</h2>

<p>In order to run the solver move to the case folder <em>poissonOptShapeFoamCase</em> and type in the command line</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./Allprepare

poissonOptShapeFoam
</code></pre></div></div>

<p>The shape optimization method described in the previous section has been tested with a simple example. The Poisson equation is posed in a two-dimensional circular domain with boundary</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma_w%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%3A%20%5Csqrt%7Bx%5E2%20&plus;%20y%5E2%7D%20%3D%20R_w%20%5Cright%5C%7D." />
</p>

<p>The reference geometry to be optimized is an inner hole with boundary given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma_s%20%5Cleft%28%200%5Cright%29%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%20%3A%20%5Csqrt%7B%5Cleft%28%20x%20-%20c_x%20%5Cright%29%5E2%20&plus;%20%5Cleft%28%20y%20-%20c_y%20%5Cright%29%5E2%7D%20%3D%20R_s%20%5Cright%5C%7D." />
</p>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/poissonOptShapeFoam/master/poissonOptShapeFoamCase/figs/fig1.png" style="height: 400px; width: 490px;" />
</p>

<p>The target function <img src="https://latex.codecogs.com/gif.latex?u_d" /> will be the analytical solution of the Poisson equation with the inner hole centered in the origin,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u_%7Banalytic%7D%5Cleft%28%20r%20%5Cright%29%20%3D%20-%5Cfrac%7Bf%7D%7B4%7Dr%5E2%20&plus;%20c_1%20%5Clog%20r%20&plus;%20c_2%2C" />
</p>

<p>where the integration constants are obtained from the boundary conditions,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20c_1%20%3D%20%26%20%5Cfrac%7Bu_w%20-%20u_s%20&plus;%20%5Cdisplaystyle%20%5Cfrac%7Bf%7D%7B4%7D%20%5Cleft%28%20R_w%5E2%20-%20R_s%5E2%20%5Cright%29%7D%7B%5Clog%5Cleft%28%20%5Cdisplaystyle%20%5Cfrac%7BR_w%7D%7BR_s%7D%20%5Cright%29%7D%2C%20%5C%5C%20c_2%20%3D%20%26%20%5Cfrac%7Bu_w%20&plus;%20u_s%7D%7B2%7D%20&plus;%20%5Cfrac%7Bf%7D%7B8%7D%5Cleft%28%20R_w%5E2%20&plus;%20R_s%5E2%20%5Cright%29%20-%20%5Cfrac%7Bc_1%7D%7B2%7D%20%5Clog%5Cleft%28%20R_w%20R_s%20%5Cright%29.%20%5Cend%7Balign*%7D" />
</p>

<p>When the hole center is displaced from the origin, the target state must be extended in the region <img src="https://latex.codecogs.com/gif.latex?r%20%5Cleq%20R_1" />, thus</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u_d%5Cleft%28%20r%20%5Cright%29%3D%20%5Cbegin%7Bcases%7D%20u_s%2C%20%5Cquad%20%26%20r%20%5Cleq%20R_s%2C%20%5C%5C%20u_%7Banalytic%7D%2C%20%5Cquad%20%26%20R_s%20%3C%20r%20%5Cleq%20R_w.%20%5Cend%7Bcases%7D" />
</p>

<p>It is clear that for</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma%5E%7B*%7D_s%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%20%3A%20%5Csqrt%7Bx%5E2%20&plus;%20y%5E2%7D%20%3D%20R_s%20%5Cright%5C%7D" />
</p>

<p>the cost function equals zero, thus it is an optimal solution. The steepest descent algorithm has been coded in the OpenFOAM solver <em>poissonOptShapeFoam</em> with <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon%20%3D%2010%5E%7B-3%7D" />.</p>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/poissonOptShapeFoam/master/poissonOptShapeFoamCase/figs/fig2.png" style="width: 400px; height:300px;" />
</p>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/poissonOptShapeFoam/master/poissonOptShapeFoamCase/figs/fig3.png" style="width: 400px; height:300px;" />
</p>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/poissonOptShapeFoam/master/poissonOptShapeFoamCase/figs/laplace_uniform.gif" style="width: 600px; height:350px;" />
</p>

<h3 id="warning">Warning</h3>

<p>It might be needed to use</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed -i -e 's/\r$//' filename
</code></pre></div></div>

<p>and</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x filename
</code></pre></div></div>

<p>in order to be able to execute</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./filename
</code></pre></div></div>

<h2 id="references">References</h2>

<ul>
  <li>O. Pironneau. <em>Optimal shape design for elliptic systems</em>. Springer Science &amp; Business Media, 2012.</li>
  <li>J Simon. <em>Diferenciación de problemas de contorno respecto del dominio</em>. Technical report, Universidad de Sevilla, Facultad de Matemáticas, Departamento de Análisis Matemático, 1989.</li>
  <li><a href="http://openfoam.org">The OpenFOAM Foundation</a>.</li>
  <li>Moving boundary problem based on calculated data, <a href="http://www.cfd-online.com/Forums/openfoam-programming-development/122557-moving-boundary-problem-based-calculated-data.html">CFDonline</a>, 2013.</li>
</ul>

<p>Linear Elasticity mesh motion method:</p>
<ul>
  <li>Andrew A. Johnson and Tayfun E. Tezduyar. Mesh update strategies in parallel finite element computations of flow problems with moving boundaries and interfaces. <em>Computer methods in applied mechanics and engineering</em>, 119(1-2):73–94, 1994.</li>
  <li>Thomas D. Economon, Francisco Palacios, and Juan J. Alonso. Unsteady continuous adjoint approach for aerodynamic design on dynamic meshes. <em>AIAA Journal</em>, 53(9):2437–2453, 2015.</li>
  <li>George S. Eleftheriou and Guillaume Pierrot. Rigid motion mesh morpher: A novel approach for mesh deformation. In <em>OPT-i, An International Conference on Engineering and Applied Sciences Optimization</em>, Kos, Greece, pages 4–6, 2014.</li>
</ul>

<p>Solid Body Rotation (SBR) Stress method:</p>
<ul>
  <li>Richard P. Dwight. Robust mesh deformation using the linear elasticity equations. In <em>Computational fluid dynamics 2006</em>, pages 401–406. Springer, 2009.</li>
</ul>

<p>Laplacian Smoothing:</p>
<ul>
  <li>Peter Hansbo. Generalized laplacian smoothing of unstructured grids. <em>International Journal for Numerical Methods in Biomedical Engineering</em>, 11(5):455–464, 1995.</li>
  <li>Rainald Löhner and Chi Yang. Improved ale mesh velocities for moving bodies. <em>Communications in numerical methods in engineering</em>, 12(10):599–608, 1996.</li>
  <li>Hrvoje Jasak and Zeljko Tukovic. Automatic mesh motion for the unstructured finite volume method. <em>Transactions of FAMENA</em>, 30(2):1–20, 2006.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;Shows the propagation of the solution of a fractional Schrodinger equation with concentrated and highly oscillatory initial datum. The solution remains concentrated along the rays of geometric optics&lt;/p&gt;
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">hx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)/(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>Definition of the initial datum u0 as a function_handle. u0 is chosen as a Gaussian profile multiplied by a higly oscillatory function</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">%% Center of the Gaussian profile</span>
<span class="nb">gamma</span> <span class="o">=</span> <span class="n">hx</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mf">0.9</span><span class="p">);</span> <span class="c1">%% Amplitude of the Gaussian profile</span>
<span class="n">fr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">hx</span><span class="p">)</span><span class="o">*</span><span class="nb">pi</span><span class="o">^</span><span class="mi">2</span><span class="p">/</span><span class="mi">16</span><span class="p">;</span> <span class="c1">%% Frequency of the oscillations</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">u0</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">i</span><span class="o">*</span><span class="n">fr</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<p>Plot of the initial datum</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span> <span class="o">=</span> <span class="nb">gcf</span><span class="p">;</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gcf</span><span class="p">,</span><span class="s1">'Units'</span><span class="p">,</span><span class="s1">'pixels'</span><span class="p">,</span><span class="s1">'Position'</span><span class="p">,[</span><span class="mi">427</span> <span class="mi">306</span> <span class="mi">712</span> <span class="mi">284</span><span class="p">])</span>

<span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">:</span><span class="n">hx</span><span class="p">:</span><span class="n">L</span><span class="p">;</span>

<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">%% Modulus</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">abs</span><span class="p">(</span><span class="n">u0</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'\vertu_0(x)\vert'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'u(x)'</span><span class="p">);</span>

<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">%% Real part</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">real</span><span class="p">(</span><span class="n">u0</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'real(u_0(x))'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'u(x)'</span><span class="p">);</span>

<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1">%% Imaginary part</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">imag</span><span class="p">(</span><span class="n">u0</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'img(u_0(x))'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'u(x)'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0004/copiaRM_01.png" alt="" /></p>

<h2 id="solution-for-s--12">Solution for s = 1/2</h2>

<p>Define the characteristic parameters of the problem</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1">%% Order of the fractional Laplacian</span>
<span class="n">L</span>        <span class="c1">%% Extrema of the space interval</span>
<span class="n">N</span>        <span class="c1">%% Number of points in the space mesh</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>    <span class="c1">%% Length of the time interval</span>
<span class="n">u0</span>       <span class="c1">%% The function_handle that we have showed before.</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
s =

    0.5000


L =

     1


N =

   250


T =

     5


u0 =

  function_handle with value:

    @(x)exp(-0.5*gamma*(x-x0).^2).*exp(1i*fr*x)


</code></pre></div></div>

<p>To solve the equation, we call the function fractional_schr. The solution of the equation is stored in the u variable.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">fractional_schr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">u0</span><span class="p">);</span>
</code></pre></div></div>

<p>Now we can see a graphical interpretation</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
<span class="c1">%%</span>
<span class="nb">clf</span>
<span class="nb">mesh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">u</span><span class="o">'</span><span class="p">);</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'t'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Ray Evolution'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0004/copiaRM_02.png" alt="" /></p>

<p>By typing “animation(x,t,u)” in the MATLAB console you can see the evolution in time of this wave.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0004/wave.gif" alt="$$u(t)$$ function" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In this work we solve the optimal control problem&lt;/p&gt;
</code></pre></div></div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?%5Cmin%20_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29%7D%20%5Cmathcal%7BJ%7D%5Cleft%28%20u%5Cright%29%20%3D%20%5Cmin%20_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29%7D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cint_%7B%5COmega%7D%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%20%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%20&plus;%20%5Cfrac%7B%5Cbeta%7D%7B2%7D%20%5Cint_%7B%5COmega%7D%20u%20%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?u" /> is the control variable, <img src="https://latex.codecogs.com/gif.latex?y" /> the state variable and <img src="https://latex.codecogs.com/gif.latex?y_d" /> a target function. The minimization problem is subject to the elliptic partial differential equation</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y%20%3D%20f%20&plus;%20u%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20y%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma.%20%5Cend%7Bcases%7D" />
</p>

<p>In order to use the conjugate gradient method, the state variable is separated in two terms as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?y%20%3D%20y_u%20&plus;%20y_%7Bf%7D%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?y_u" /> solves the state equation with zero Dirichlet boundary conditions,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y_u%20%3D%20u%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20y_u%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma%2C%20%5Cend%7Bcases%7D" />
</p>

<p>and <img src="https://latex.codecogs.com/gif.latex?y_f" /> is the control-free solution to the state equation,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y_%7Bf%7D%20%3D%20f%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20y_%7Bf%7D%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma.%20%5Cend%7Bcases%7D" />
</p>

<p>With the above separation of the state variable, the cost functional can be expressed as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%20%5Cleft%28%20u%20%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20y_u%20&plus;%20y_f%20-%20y_d%2C%20y_u%20&plus;%20y_f%20-%20y_d%20%5Cright%29_%7BL%5E2%5Cleft%28%20%5COmega%20%5Cright%29%7D%20&plus;%20%5Cfrac%7B%5Cbeta%7D%7B2%7D%20%5Cleft%28%20u%20%2C%20u%20%5Cright%29%20_%7BL%5E2%5Cleft%28%20%5COmega%20%5Cright%29%7D." />
</p>

<p>We define a linear operator</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20%5CLambda%3A%20L%5E2%5Cleft%28%20%5COmega%20%5Cright%29%20%26%20%5Crightarrow%20L%5E2%5Cleft%28%20%5COmega%20%5Cright%29%20%5C%5C%20u%20%26%20%5Crightarrow%20y_u%20%5Cend%7Balign*%7D2" />
</p>

<p>and its adjoint</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20%5CLambda%3A%20L%5E2%5Cleft%28%20%5COmega%20%5Cright%29%20%26%20%5Crightarrow%20L%5E2%5Cleft%28%20%5COmega%20%5Cright%29%20%5C%5C%20%5Cphi%20%26%20%5Crightarrow%20%5Clambda%20%5Cend%7Balign*%7D" />
</p>

<p>with <img src="https://latex.codecogs.com/gif.latex?\lambda" /> solution to</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%20%5CDelta%20%5Clambda%20%3D%20%5Cphi%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20%5Clambda%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma.%20%5Cend%7Bcases%7D" />
</p>

<p>The directional derivative of the cost function then reads as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BD%7D_%7B%5Cdelta%20u%7D%20%5Cmathcal%7BJ%7D%5Cleft%28%20u%20%5Cright%29%20%3D%20%5Cleft%28%20%5Cunderbrace%7B%20%5Cleft%28%20%5CLambda%5E*%20%5CLambda%20&plus;%20%5Cbeta%20I%20%5Cright%29%7D_%7BA_%7Bcg%7D%7D%20u%20-%20%5Cunderbrace%7B%20%5CLambda%5E*%20%5Cleft%28%20y_d%20-%20y_f%20%5Cright%29%7D_%7Bb_%7Bcg%7D%7D%2C%20%5Cdelta%20u%20%5Cright%29%20_%7BL%5E2%5Cleft%28%20%5COmega%20%5Cright%29%7D." />
</p>

<p>After having identified <img src="https://latex.codecogs.com/gif.latex?A_%7Bcg%7D" /> and <img src="https://latex.codecogs.com/gif.latex?b_%7Bcg%7D" /> we can use the conjugate gradient method to reach the optimal control faster.</p>

<h2 id="getting-started">Getting Started</h2>

<p>The solver must be compiled in the terminal. It is advisable to first clean previous compilations with</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wclean
</code></pre></div></div>

<p>and then use</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmake
</code></pre></div></div>

<h3 id="prerequisites">Prerequisites</h3>

<p>OpenFOAM C++ library must be installed in order to compile the code.</p>

<p>The OpenFOAM distribution provided by the <a href="https://openfoam.org/">OpenFOAM Foundation</a> was used.</p>

<h2 id="running-a-case">Running a Case</h2>

<p>In order to run the solver move to the case folder <em>poissonCGAdjoinFoamCase</em> and type in the command line</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./Allprepare

poissonCGAdjointFoam
</code></pre></div></div>

<p>The <em>poissonCGAdjointFoam</em> solver has been tested in a square domain <img src="https://latex.codecogs.com/gif.latex?%5B0%2C%201%5D%20%5Ctimes%20%5B0%2C%201%5D" /> with zero Dirichlet boundary conditions and <img src="https://latex.codecogs.com/gif.latex?%5Cbeta%20%3D%2010%5E%7B-3%7D%2C10%5E%7B-4%7D%2C10%5E%7B-5%7D%2C10%5E%7B-6%7D" />. The target function is <img src="https://latex.codecogs.com/gif.latex?y_d%20%3D%20xy%20%5Csin%20%5Cleft%28%20%5Cpi%20x%20%5Cright%29%20%5Csin%20%5Cleft%28%20%5Cpi%20y%20%5Cright%29" />.</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/poissonCGAdjointFoam/blob/master/poissonCGAdjointFoamCase/cg_J.png?raw=true" />
</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/poissonCGAdjointFoam/blob/master/poissonCGAdjointFoamCase/cg_Jy.png?raw=true" />
</p>

<h3 id="warning">Warning</h3>

<p>It might be needed to use</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed -i -e 's/\r$//' filename
</code></pre></div></div>

<p>and</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x filename
</code></pre></div></div>

<p>in order to be able to execute</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./filename
</code></pre></div></div>

<h2 id="references">References</h2>

<ul>
  <li>F. Tröltzsch. <em>Optimal control of partial differential equations: theory, methods, and applications</em>. American Mathematical Soc., 2010.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;A natural application in the framework of shape optimization is the aerodynamic design of an airfoil. An object defined by a domain &lt;img src="https://latex.codecogs.com/gif.latex?%5COmega_s%20%5Cin%20%5Cmathbb%7BR%7D%5Ed" /&gt; with boundary &lt;img src="https://latex.codecogs.com/gif.latex?%5CGamma_s" /&gt; immersed in a fluid will experience a net force given by&lt;/p&gt;
</code></pre></div></div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?F_i%20%3D%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20-%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cbm%7Bu%7D%5Cright%29%20%5C%2C%20n_j%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cbm%7Bu%7D%5Cright%29%20%3D%20-p%20%5Cdelta_%7Bij%7D%20&plus;%202%5Cnu%20S_%7Bij%7D%5Cleft%28%5Cbm%7Bu%7D%5Cright%29" /> is the stress tensor, <img src="https://latex.codecogs.com/gif.latex?p" /> is the fluid pressure, <img src="https://latex.codecogs.com/gif.latex?%5Cnu" /> is the kinematic viscosity, <img src="https://latex.codecogs.com/gif.latex?S_%7Bij%7D%5Cleft%28%5Cmathbf%7Bu%7D%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20%5Cpartial_j%20u_i%20&plus;%20%5Cpartial_i%20u_j%20%5Cright%29" /> is the strain rate tensor, and <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bu%7D%20%5Cin%20%5Cmathbb%7BR%7D%5Ed" /> is the fluid velocity vector field.</p>

<p align="center">
  <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/shapeOptimizationFoam/master/figs/fig1.png" width="400" height="320" />
</p>

<p>The force exerted by the fluid on the airfoil parallel to the fluid velocity at infinity is referred to as the drag force, whereas the force in perpendicular direction is often named the lift.</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?D%20%3D%20d%5ED_i%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20-%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cbm%7Bu%7D%5Cright%29%20%5C%2C%20n_j%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma%2C" />
</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?L%20%3D%20d%5EL_i%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20-%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cbm%7Bu%7D%5Cright%29%20%5C%2C%20n_j%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma." />
</p>

<p>We look for the optimal shape in order to minimize the drag, as this force produces energy losses, and at the same time maximize the lift for a fixed airfoil volume. This can be expressed by means of the functional</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%3D%20w%5ED%20D%20-%20w%5EL%20L%20%3D%20d_i%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%29%7D%20-%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cmathbf%7Bu%7D%5Cright%29n_j%20%5Cmathrm%7Bd%7D%20%5CGamma%2C" />
</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?d_i%20%3D%20w%5ED%20d%5ED_i%20-%20w%5EL%20d%5EL_i%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?w%5ED" /> and <img src="https://latex.codecogs.com/gif.latex?w%5EL" /> are weighting factors for drag and lift forces, respectively, and with <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%20%5Cin%20L%5E2%5Cleft%28%20%5CGamma_s%20%5Cright%29" />. The state variables are subject to a set of constraints in the fluid domain <img src="https://latex.codecogs.com/gif.latex?%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29" /> with boundary <img src="https://latex.codecogs.com/gif.latex?%5CGamma_f%20%3D%20%5CGamma_%7Bin%7D%20%5Ccup%20%5CGamma_%7Bout%7D%20%5Ccup%20%5CGamma_s%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Ccup%20%5CGamma_w" />, namely the steady Navier-Stokes equations,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20u_j%20%5Cpartial_j%20u_i%20-%20%5Cpartial_j%20%5Cleft%5B%20%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cmathbf%7Bu%7D%20%5Cright%29%20%5Cright%5D%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20%5Cpartial_j%20u_j%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%20u%5E%5Cinfty_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7Bin%7D%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Ccup%20%5CGamma_w%2C%20%5C%5C%20%5Csigma_%7Bij%7D%20%5Cleft%28p%2C%20%5Cmathbf%7Bu%7D%20%5Cright%29%20n_j%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7Bout%7D%2C%20%5Cend%7Bcases%7D" />
</p>

<p>and to the volume constraint</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cleft%7C%20%5COmega_%7Bs%7D%20%5Cright%7C%20%3D%20%5COmega_0." />
</p>

<p>The adjoint problem reads as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20v_j%20%5Cpartial_i%20u_j%20-%20%5Cpartial_j%20%5Cleft%28%20u_j%20v_i%20%5Cright%29%20-%20%5Cpartial_j%20%5Cleft%5B%20%5Csigma_%7Bij%7D%20%5Cleft%28q%2C%20%5Cmathbf%7Bv%7D%20%5Cright%29%20%5Cright%5D%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20%5Cpartial_j%20v_j%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20v_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7Bin%7D%20%5Ccup%20%5CGamma_w%2C%20%5C%5C%20v_i%20%3D%20-d_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20%5Csigma_%7Bij%7D%20%5Cleft%28q%2C%20%5Cmathbf%7Bv%7D%20%5Cright%29%20n_j%20&plus;%20v_i%20u_j%20n_j%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7Bout%7D.%20%5Cend%7Bcases%7D" />
</p>

<p>The directional derivative of the functional is given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BD%7D_%7B%5Cdelta%20%5Ctheta%7D%20%5Cmathcal%7BJ%7D%20%3D%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20%5Cleft%5B%20r%20-%202%20%5Cnu%20S_%7Bij%7D%20%5Cleft%28%20%5Cmathbf%7Bv%7D%20%5Cright%29%20%5C%2C%20n_j%20%5C%2C%20n_k%20%5C%2C%20%5Cpartial_k%20u_i%20%5Cright%5D%20%5C%2C%20%5Cdelta%20%5Ctheta%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma%2C" />
</p>

<p>and the cost function descreases by choosing the normal displacement to the controlled boundary as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cdelta%20%5Ctheta%20%5E%7B%5Cleft%28n%5Cright%29%7D%20%3D%20-%20%5Cleft%5B%20r%5E%7B%5Cleft%28n%5Cright%29%7D%20-%202%20%5Cnu%20S_%7Bij%7D%20%5Cleft%28%20%5Cmathbf%7Bv%7D%5E%7B%5Cleft%28n%5Cright%29%7D%20%5Cright%29%20%5C%2C%20n_j%5E%7B%5Cleft%28n%5Cright%29%7D%20%5C%20n_k%5E%7B%5Cleft%28n%5Cright%29%7D%20%5C%2C%20%5Cpartial_k%20u_i%5E%7B%5Cleft%28n%5Cright%29%7D%20%5Cright%5D." />
</p>

<p>Hence,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%20%5E%7B%5Cleft%28n&plus;1%5Cright%29%7D%20%3D%20%5Ctheta%20%5E%7B%5Cleft%28n%5Cright%29%7D%20&plus;%20%5Cepsilon%20%5Cdelta%20%5Ctheta%20%5E%7B%5Cleft%28n%5Cright%29%7D%2C" />
</p>

<p>for a sufficiently small value of <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon" />.</p>

<p>The remaining Lagrange multiplier associated to the volume constraint is computed in order to ensure the volume conservation,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?r%5E%7B%5Cleft%28n%5Cright%29%7D%20%3D%20%5Cfrac%7B1%7D%7B%5Cleft%7C%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Cright%7C%7D%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%202%20%5Cnu%20S_%7Bij%7D%20%5Cleft%28%20%5Cmathbf%7Bv%7D%5E%7B%5Cleft%28n%5Cright%29%7D%20%5Cright%29%20n_j%5E%7B%5Cleft%28n%5Cright%29%7D%20n_k%5E%7B%5Cleft%28n%5Cright%29%7D%20%5Cpartial_k%20u_i%5E%7B%5Cleft%28n%5Cright%29%7D%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma." />
</p>

<p>In summary, the shape optimization iteration is as follows:</p>
<ul>
  <li>Solve the primal problem.</li>
  <li>Solve the adjoint problem with the previously computed state variables.</li>
  <li>Compute the Lagrange multiplier for the volume constraint.</li>
  <li>Compute the displacement field.</li>
  <li>Update the displacement field of the previous iteration.</li>
  <li>Perform the mesh motion.</li>
</ul>

<h2 id="getting-started">Getting Started</h2>

<p>The solver must be compiled in the terminal. It is advisable to first clean previous compilations with</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wclean
</code></pre></div></div>

<p>and then use</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmake
</code></pre></div></div>

<h3 id="prerequisites">Prerequisites</h3>

<p>OpenFOAM C++ library must be installed in order to compile the code.</p>

<p>The OpenFOAM distribution provided by the <a href="https://openfoam.org/">OpenFOAM Foundation</a> was used.</p>

<h2 id="running-a-case">Running a Case</h2>

<p>The above shape optimization process has been implemented in the open-source C++ library OpenFOAM. The already existing solver <em>adjointShapeOptimizationFoam</em> is a topological optimization routine that relies on a porosity variable and on the calculation of volume sensitivities to determine which regions of the domain must be blocked to the fluid passage in order to minimize a known functional. We have coded a new solver <em>shapeOptimizationFoam</em> that takes some ideas from the aforementioned one, but which performs a shape optimization iteration instead by computing shape sensitivities.</p>

<p align="center">
    <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/shapeOptimizationFoam/master/shapeOptimizationFoamCase/figs/fig1.png" width="400" height="320" />
</p>

<p>The solver has been tested in the minimization of the the cost function</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%3D%20%5Cleft%28%20w%5ED%20d%5ED_i%20-%20w%5EL%20d%5EL_i%20%5Cright%29%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%29%7D%20-%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cmathbf%7Bu%7D%5Cright%29n_j%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma%2C" />
</p>

<p>subject to</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20u_j%20%5Cpartial_j%20u_i%20-%20%5Cpartial_j%20%5Cleft%5B%20%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cmathbf%7Bu%7D%20%5Cright%29%20%5Cright%5D%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%5Cright%20%29%2C%20%5C%5C%20%5Cpartial_j%20u_j%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%20u%5E%5Cinfty_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7B%5Cinfty%7D%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%5Cright%20%29.%20%5C%5C%20%5Cend%7Bcases%7D" />
</p>

<p>The adjoint problem reads as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20v_j%20%5Cpartial_i%20u_j%20-%20%5Cpartial_j%20%5Cleft%28%20u_j%20v_i%20%5Cright%29%20-%20%5Cpartial_j%20%5Cleft%5B%20%5Csigma_%7Bij%7D%20%5Cleft%28q%2C%20%5Cmathbf%7Bv%7D%20%5Cright%29%20%5Cright%5D%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20%5Cpartial_j%20v_j%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20v_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7B%5Cinfty%7D%2C%20%5C%5C%20v_i%20%3D%20-d_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5C%5C%20%5Cend%7Bcases%7D" />
</p>

<p>In order to run the solver move to the case folder <em>shapeOptimizationFoamCase</em> and type in the command line</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./Allprepare

shapeOptimizationFoam
</code></pre></div></div>

<p>The solver has been run for three different Reynolds numbers and the cost functional value has been normalized with</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B2%7D%20%5Crho%20U_%7B%5Cinfty%7D%5E2%20D%20e" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?D" /> and <img src="https://latex.codecogs.com/gif.latex?e" /> are the cylinder diameter and thickness, respectively.</p>

<p align="center">
    <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/shapeOptimizationFoam/master/shapeOptimizationFoamCase/figs/fig2.png" />
</p>

<h3 id="warning">Warning</h3>

<p>It might be needed to use</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed -i -e 's/\r$//' filename
</code></pre></div></div>

<p>and</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x filename
</code></pre></div></div>

<p>in order to be able to execute</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./filename
</code></pre></div></div>

<h2 id="references">References</h2>

<ul>
  <li>Antony Jameson. Aerodynamic design via control theory. <em>Journal of scientific computing</em>, 3(3):233–260, 1988.</li>
  <li>Antony Jameson and Luigi Martinelli. Aerodynamic shape optimization techniques based on control theory. In <em>Computational Mathematics Driven by Industrial Problems</em>, pages 151–221. Springer, 2000.</li>
  <li>Antony Jameson and James Reuther. Control theory based airfoil design using the euler equations. In <em>5th Symposium on Multidisciplinary Analysis and Optimization</em>, page 4272, 1994.</li>
  <li>Bijan Mohammadi and Olivier Pironneau. Mesh adaption and automatic differentiation in a cad-free framework for optimal shape design. <em>International Journal for Numerical Methods in Fluids</em>, 30(2):127–136, 1999.</li>
  <li>Bijan Mohammadi and Olivier Pironneau. <em>Applied shape optimization for fluids</em>. Oxford University Press, 2010.</li>
  <li>C. Othmer. A continuous adjoint formulation for the computation of topological and surface sensitivities of ducted flows. <em>International Journal for Numerical Methods in Fluids</em>, 58(8):861–877, 2008.</li>
  <li>C. Othmer, E. Papoutsis-Kiachagias, and K. Haliskos. CFD optimization via sensitivity-based shape morphing. In <em>Proceedings of the 4th ANSA &amp; μETA Internat. Conf., Thessaloniki, Greece, BETA CAE Systems SA</em>, 2011.</li>
  <li>Carsten Othmer. Adjoint methods for car aerodynamics. <em>Journal of Mathematics in Industry</em>, 4(1):6, 2014.</li>
  <li>Carsten Othmer, Eugene de Villiers, and Henry Weller. Implementation of a continuous adjoint for topology optimization of ducted flows. In <em>18th AIAA Computational Fluid Dynamics Conference</em>, page 3947, 2007.</li>
  <li>Carsten Othmer and Thorsten Grahs. Approaches to fluid dynamic optimization in the car development process. In <em>International Conference on Evolutionary and Deterministic Methods for Design, Optimization and Control With Applications to Industrial and Societal Problems</em>, 2005.</li>
  <li>Carsten Othmer, Thomas Kaminski, and Ralf Giering. Computation of topological sensitivities in fluid dynamics: cost function versatility. In <em>ECCOMAS CFD 2006: Proceedings of the European Conference on Computational Fluid Dynamics, Egmond aan Zee, The Netherlands, September 5-8, 2006</em>. Citeseer, 2006.</li>
  <li>Olivier Pironneau. <em>Optimal shape design for elliptic systems</em>. Springer Science &amp; Business Media, 2012.</li>
  <li>James Reuther and Antony Jameson. Aerodynamic shape optimization of wing and wing-body configurations using control theory. In <em>33rd Aerospace Sciences Meeting and Exhibit</em>, page 123, 1995.</li>
  <li>James Reuther, Antony Jameson, James Farmer, Luigi Martinelli, and David Saunders. Aerodynamic shape optimization of complex aircraft configurations via an adjoint formulation. In <em>34th Aerospace Sciences Meeting and Exhibit</em>, page 94, 1996.</li>
  <li>James J Reuther, Antony Jameson, Juan J Alonso, Mark J Rimlinger, and David Saunders. Constrained multipoint aerodynamic shape optimization using an adjoint formulation and parallel computers, part 1. <em>Journal of aircraft</em>, 36(1):51–60, 1999.</li>
  <li>J. Simon. Diferenciación de problemas de contorno respecto del dominio. Technical report, Universidad de Sevilla, Facultad de Matemáticas, Departamento de Análisis Matemático, 1989.</li>
  <li>Orlando Soto and Rainald Löhner. On the computation of flow sensitivities from boundary integrals. <em>AIAA paper</em>, 112:2004, 2004.</li>
  <li>Orlando Soto, Rainald Löhner, and Chi Yang. An adjoint-based design methodology for CFD problems. <em>International Journal of Numerical Methods for Heat &amp; Fluid Flow</em>, 14(6):734–759, 2004.</li>
  <li>Schumacher Thomas, Othmer Carsten, et al. Adjoint optimization for vehicle external aerodynamics. <em>International Journal of Automotive Engineering</em>, 7(1):1–7, 2016.</li>
  <li>Henk Kaarle Versteeg and Weeratunge Malalasekera. <em>An introduction to computational fluid dynamics: the finite volume method</em>. Pearson Education, 2007.</li>
  <li>F. Feppon, G. Allaire, F. Bordeu, J. Cortial, and C. Dapogny. Shape optimization of a coupled thermal fluid-structure problem in a level set mesh evolution framework, 2018.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;We study the shape design problem through the minimization of the cost functional&lt;/p&gt;
</code></pre></div></div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%20%5Cleft%28%20%5Ctheta%2C%20y%20%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cint_%7B%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%20%5E2%20%5C%2C%20%5Cmathrm%7Bd%7D%20%5COmega%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?y%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" /> is the state variable, <img src="https://latex.codecogs.com/gif.latex?y_d%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" /> is a target function, and <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29" /> the normal displacement to a reference boundary,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%3D%20%5Cleft%5C%7B%20%5Cmathbf%7Bx%7D%20&plus;%20%5Ctheta%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cmathbf%7Bn%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3A%20%5Cmathbf%7Bx%7D%20%5Cin%20%5CGamma_%7B0%7D%20%5Cright%5C%7D." />
</p>

<p>The problem is subject to the following elliptic PDE in the domain <img src="https://latex.codecogs.com/gif.latex?%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Csubset%20%5Cmathbb%7BR%7D%5Ed" /> with Dirichlet boundary conditions on <img src="https://latex.codecogs.com/gif.latex?%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3D%20%5CGamma_w%20%5Ccup%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29" />,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y%20%3D%20f%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%5C%5C%20y%20%3D%20y_%7Bw%7D%20%26%20%5Ctext%7Bin%20%7D%20%5CGamma_w%2C%5C%5C%20y%20%3D%20y_%7Bs%7D%20%26%20%5Ctext%7Bin%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5Cend%7Bcases%7D" />
</p>

<p>and <img src="https://latex.codecogs.com/gif.latex?f%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" />.</p>

<p>We consider the set of admissible domains whose measure is fixed,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BU%7D_%7Bad%7D%20%3D%20%5Cleft%5C%7B%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3A%20%5Clvert%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Crvert%20%3D%20%5COmega_0%20%5Cright%5C%7D%2C" />
</p>

<p>and aim at finding the optimal shape that minimizes the cost function. In order to do so, we use the steepest descent method with descent direction given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cdelta%20%5Ctheta%20%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%3D%20-%20%5Cleft%5B%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20y%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20y_d%20%5Cright%29%20%5E2%20&plus;%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cfrac%7B%5Cpartial%20y%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20&plus;%20q%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%5D%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?v" /> is solution of the adjoint problem</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%20%5CDelta%20v%20%3D%20y%20-%20y_d%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20v%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3D%20%5CGamma_w%20%5Ccup%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<p>The normal displacement field is updated at every iteration,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B%5Cleft%28%20n%20&plus;%201%20%5Cright%29%7D%20%3D%20%5Ctheta%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20&plus;%20%5Cepsilon%20%5Cdelta%7B%5Ctheta%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%7D%2C" />
</p>

<p>with <img src="https://latex.codecogs.com/gif.latex?\epsilon" /> sufficiently small. The Lagrange multiplier is computed in order to ensure that the volume contraint is fulfilled, thus</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?q%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%3D%20-%20%5Cfrac%7B1%7D%7B%5Cleft%7C%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%5Cright%7C%7D%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20%5Cleft%5B%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20y%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20y_d%20%5Cright%29%20%5E2%20&plus;%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cfrac%7B%5Cpartial%20y%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%5D%20%5Cmathrm%7Bd%7D%20%5CGamma." />
</p>

<h2 id="mesh-motion-solver">Mesh Motion Solver</h2>

<p>The solutions to the primal and adjoint problems are commonly approximated by means of numerical methods, such as the finite element method (FEM) or the finite volume method (FVM). In order to apply these techniques, the domain under study must be tessellated with a mesh. Nevertheless, applying the displacement directly to the controlled boundary will deteriorate the surrounding elements after a few iterations and the computation will crash if the interior nodes of the domain are not reallocated. In order to avoid this, the domain can be re-meshed after a number of iterations. However, this can be very expensive as a completely new mesh must be generated. A commonly used alternative is to move the interior nodes of the mesh according to the displacements prescribed on the boundary.  By doing this the number of elements and the nodes connectivities remain the same, only the mesh nodes positions are updated.</p>

<h3 id="linear-elasticity">Linear Elasticity</h3>

<p>Mesh motion can be achieved by treating the mesh as an elastic body and solving the equations of Linear Elasticity for solids with prescribed displacements on the domain boundary,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20%5Cpartial_j%20%5Cleft%28%20G%20%5Cpartial_j%20u_i%20%5Cright%29%20&plus;%20%5Cpartial_j%20%5Cleft%28%20G%20%5Cpartial_i%20u_j%20%5Cright%29%20&plus;%20%5Cpartial_i%20%5Cleft%28%20%5Clambda%20%5Cpartial_j%20u_j%20%5Cright%29%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<h3 id="solid-body-rotation-sbr-stress">Solid Body Rotation (SBR) Stress</h3>

<p>The Linear Elasticity model fails when dealing with rotating meshes. This can be mitigated by selecting the material properties in a proper manner, which yields</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%202%20%5Cpartial_j%20%5Cleft%28%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cpartial_j%20u_i%20%5Cright%29%20&plus;%20%5Cpartial_j%20%5Cleft%5B%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cleft%28%20%5Cpartial_i%20u_j%20-%20%5Cpartial_j%20u_i%20-%20%5Cdelta_%7Bij%7D%20%5Cpartial_k%20u_k%20%5Cright%29%20%5Cright%5D%20%3D%200%2C%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<h3 id="laplacian-smoothing">Laplacian Smoothing</h3>

<p>A simple and widely used practice is to solve a Laplace equation with the prescribed displacements as boundary conditions,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20%5CDelta%20u_i%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<p>The behavior of the Laplacian smoothing can be improved by adding a non-uniform diffusivity term,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cpartial_k%20%5Cleft%28%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cpartial_k%20u_i%20%5Cright%29%20%3D%200%20%5Cquad%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29." />
</p>

<p>The diffusion field <img src="https://latex.codecogs.com/gif.latex?%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%3A%20%5Cmathbb%7BR%7D%5Ed%20%5Crightarrow%20%5Cmathbb%7BR%7D" /> decreases with the distance to the controlled boundary. A common choice is to make it depend on the inverse of the distance as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7Bd%5Em%7D%2C" />
</p>

<p>so that the nodes next to the deforming boundaries move with similar displacements as those on the boundary.</p>

<h3 id="spring-analogy">Spring Analogy</h3>

<p>A more intuitive approach is reached by thinking of the N mesh nodes as a mechanical system consisting of a finite set of masses that are linked with springs along the mesh edges. We can consider the existence of additional external forces acting on every mesh node, so that for every equilibrium configuration the following must hold,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7BF%7D_i%20-%20%5Csum_%7Bj%3D1%7D%5EN%20k_%7Bij%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D_i%20-%20%5Cmathbf%7Bx%7D_j%20%5Cright%29%20%3D%200%2C%20%5Cquad%201%20%5Cleq%20i%20%5Cleq%20N." />
</p>

<p>The equilibrium equations can be expressed in terms of the nodes displacements,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%5CDelta%20F%7D_i%20-%20%5Csum_%7Bj%3D1%7D%5EN%20k_%7Bij%7D%20%5Cleft%28%20%5Cmathbf%7Bu%7D_i%20-%20%5Cmathbf%7Bu%7D_j%20%5Cright%29%20%3D%200%2C%20%5Cquad%201%20%5Cleq%20i%20%5Cleq%20N." />
</p>

<p>At the M nodes that belong to the domain boundary the displacements are prescribed with unknown forces acting on them. On the other hand, on the interior nodes of the mesh whose displacements are unknown, there are no other forces than the elastic ones. Let us denote with D the indices of the nodes with prescribed displacement, and with S the set of nodes with unknown displacements. The equilibrium can be expressed in matrix form as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20%5Cmathbf%7BK%7D_%7BDD%7D%20%5Cmathbf%7Bu%7D_D%20&plus;%20%5Cmathbf%7BK%7D_%7BDS%7D%20%5Cmathbf%7Bu%7D_%7BS%7D%20%26%20%3D%20%5Cmathbf%7B%5CDelta%20F%7D_%7BD%7D%2C%20%5C%5C%20%5Cmathbf%7BK%7D_%7BSD%7D%20%5Cmathbf%7Bu%7D_D%20&plus;%20%5Cmathbf%7BK%7D_%7BSS%7D%20%5Cmathbf%7Bu%7D_%7BS%7D%20%26%20%3D%20%5Cmathbf%7B%5CDelta%20F%7D_%7BS%7D%20%3D%20%5Cmathbf%7B0%7D.%20%5Cend%7Balign*%7D" />
</p>

<p>One can get the displacements of the interior mesh nodes as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bu%7D_S%20%3D%20-%5Cmathbf%7BK%7D_%7BSS%7D%5E%7B-1%7D%20%5Cmathbf%7BK%7D_%7BSD%7D%20%5Cmathbf%7Bu%7D_D." />
</p>

<h3 id="radial-basis-functions-rbf">Radial Basis Functions (RBF)</h3>

<p>The RBF mesh morphing technique uses the known displacements at the domain boundaries to construct an interpolation expression as a weighted sum of radial functions <img src="https://latex.codecogs.com/gif.latex?%5Cvarphi%3A%20%5Cmathbb%7BR%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D" />,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?s%5E%7B%5Calpha%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3D%20%5Csum_%7Bj%3D1%7D%5EN%20%5Cgamma%5E%7B%5Calpha%7D_j%20%5Cvarphi%20%5Cleft%28%20%5C%7C%20%5Cmathbf%7Bx%7D%20-%20%5Cmathbf%7Bx%7D_%7Bs%2C%20j%7D%20%5C%7C_%7B%5Cmathbb%7BR%7D%5Ed%7D%20%5Cright%29%20&plus;%20p%5E%7B%5Calpha%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%2C%20%5Cquad%201%20%5Cleq%20%5Calpha%20%5Cleq%20d." />
</p>

<p>The weighting coefficients and the polynomials are obtained by imposing the known displacements at the boundaries,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?s%5E%7B%5Calpha%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D_%7Bs%2C%20i%7D%20%5Cright%29%20%3D%20g%5E%7B%5Calpha%7D_%7Bs%2C%20i%7D%20%3D%20%5Cdelta%20%5Ctheta%20n%5E%7B%5Calpha%7D%2C" />
</p>

<p>and the orthogonality conditions for every polynomial with degree less or equal than that of <img src="https://latex.codecogs.com/gif.latex?p%5E%7B%5Calpha%7D" />,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Csum_%7Bj%3D1%7D%5EN%20%5Cgamma%5E%7B%5Calpha%7D_j%20q%20%5Cleft%28%20%5Cmathbf%7Bx%7D_%7Bs%2Cj%7D%20%5Cright%29%20%3D%200%2C%20%5Cquad%201%20%5Cleq%20%5Calpha%20%5Cleq%20d." />
</p>

<p>At the end, a linear system of the form</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7BM%7D_s%20%26%20%5Cmathbf%7BP%7D_s%20%5C%5C%20%5Cmathbf%7BP%7D_s%5ET%20%26%20%5Cmathbf%7B0%7D%20%5Cend%7Bpmatrix%7D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7B%5Cgamma%7D%5E%7B%5Calpha%7D%20%5C%5C%20%5Cmathbf%7B%5Cbeta%7D%5E%7B%5Calpha%7D%20%5Cend%7Bpmatrix%7D%20%3D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7Bg%7D_s%5E%7B%5Calpha%7D%20%5C%5C%20%5Cmathbf%7B0%7D%20%5Cend%7Bpmatrix%7D" />
</p>

<p>must be solved, and the mesh nodes are updated as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?x%5E%7B%5Cmathrm%7Bnew%7D%2C%20%5Calpha%7D%20%3D%20x%5E%7B%5Cmathrm%7Bold%7D%2C%20%5Calpha%7D%20&plus;%20s%5E%7B%5Calpha%7D%5Cleft%28%20%5Cmathbf%7Bx%7D%5E%7B%5Cmathrm%7Bold%7D%7D%20%5Cright%29." />
</p>

<h3 id="free-form-deformation-ffd">Free Form Deformation (FFD)</h3>

<p>An alternative is to use some parametrization technique for the boundary <img src="https://latex.codecogs.com/gif.latex?%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29" /> and extend it to be able to handle the motion of the interior nodes of the mesh as well. This can be done with the Free Form Deformation method, that is based upon the positions of a set of control points inside a parallelepiped.</p>

<p>If we consider the 2-dimensional reference control domain <img src="https://latex.codecogs.com/gif.latex?%5COmega_%7Bst%7D%3D%5Cleft%5B%200%2C%201%20%5Cright%5D%20%5Ctimes%20%5Cleft%5B%200%20%2C%201%20%5Cright%5D" />, we can define a set of <img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%20N%20&plus;%201%20%5Cright%29%20%5Ctimes%20%5Cleft%28%20M%20&plus;%201%20%5Cright%29" /> evenly spaced control points,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7BP%7D_%7Bij%7D%20%3D%20%5Cleft%28%20%5Cfrac%7Bi%7D%7BM%7D%2C%20%5Cfrac%7Bj%7D%7BN%7D%20%5Cright%29%2C%20%5Cquad%200%20%5Cleq%20i%20%5Cleq%20M%2C%20%5Cquad%200%20%5Cleq%20j%20%5Cleq%20N%2C" />
</p>

<p>and introduce the tensorial product of Bernstein polynomials <img src="https://latex.codecogs.com/gif.latex?B_%7Bij%7D%5E%7BMN%7D%5Cleft%5B%5Cmathbf%7BS%7D%20%3D%20%5Cleft%28s%2C%20t%20%5Cright%29%20%5Cright%5D%20%3D%20b_i%20%5EM%20%5Cleft%28%20s%20%5Cright%29%20b_j%20%5EN%20%5Cleft%28%20t%20%5Cright%29" />, with</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20b_i%5EM%20%5Cleft%28%20s%20%5Cright%29%20%26%3D%20%5Cbinom%7BM%7D%7Bi%7D%20s%5Ei%20%5Cleft%281-s%5Cright%29%20%5E%7BM-i%7D%2C%20%5C%5C%20b_j%5EN%20%5Cleft%28%20t%20%5Cright%29%20%26%3D%20%5Cbinom%7BN%7D%7Bj%7D%20t%5Ej%20%5Cleft%281-t%5Cright%29%20%5E%7BN-j%7D.%20%5Cend%7Balign*%7D" />
</p>

<p>The transformation</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%5CPsi%7D%20%5Cleft%28%20%5Cmathbf%7BS%7D%20%5Cright%29%20%3D%20%5Csum_%7Bi%3D0%7D%5EM%20%5Csum_%7Bj%3D0%7D%5EN%20B_%7Bij%7D%5E%7BMN%7D%20%5Cleft%28%20%5Cmathbf%7BS%7D%20%5Cright%29%20%5Cmathbf%7BP%7D_%7Bij%7D" />
</p>

<p>is the identity transformation, i.e., <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%5CPsi%7D%5Cleft%28%20%5Cmathbf%7BS%7D%20%5Cright%29%20%3D%20%5Cmathbf%7BS%7D" />.</p>

<p>We consider a set of control points defined as displacements from the reference positions, <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7BP%7D_%7Bij%7D%20&plus;%20%5Cmathbf%7B%5CDelta%20P%7D_%7Bij%7D" />. In this case it is easy to see that the following holds</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%20%5CDelta%20S%20%7D%20%3D%20%5Cmathbf%7B%20%5CPsi%20%7D%20%5Cleft%28%20%5Cmathbf%7BS%7D%20%5Cright%29%20-%20%5Cmathbf%7BS%7D%20%3D%20%5Csum_%7Bi%3D0%7D%5EM%20%5Csum_%7Bj%3D0%7D%5EN%20B_%7Bij%7D%5E%7BMN%7D%20%5Cleft%28%20%5Cmathbf%7BS%7D%20%5Cright%29%20%5Cmathbf%7B%20%5CDelta%20P%20%7D_%7Bij%7D." />
</p>

<p>We must find the control points displacements <img src="https://latex.codecogs.com/gif.latex?%24%5Cmathbf%7B%5CDelta%20P%7D_%7Bij%7D%20%5Cin%20%5COmega_%7Bst%7D%24" /> that parametrize the controlled boundary and for which, for every boundary node <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7BX%7D_%7Bs%2Ck%7D%20%5Cin%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%201%20%5Cleq%20k%20%5Cleq%20Z" />,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%5CPhi%7D%20%5Cleft%28%20%5Cmathbf%7BX%7D_%7Bs%2Ck%7D%20&plus;%20%5Cvar%7B%5Ctheta%7D%20%5Cmathbf%7Bn%7D%20%5Cright%29%20-%20%5Cmathbf%7B%5CPhi%7D%20%5Cleft%28%20%5Cmathbf%7BX%7D_%7Bs%2Ck%7D%20%5Cright%29%20%3D%20%5Csum_%7Bi%3D0%7D%5EM%20%5Csum_%7Bj%3D0%7D%5EN%20B_%7Bij%7D%5E%7BMN%7D%20%5Cleft%5B%20%5Cmathbf%7B%5CPhi%7D%20%5Cleft%28%20%5Cmathbf%7BX%7D_%7Bs%2Ck%7D%20%5Cright%29%20%5Cright%5D%20%5Cmathbf%7B%20%5CDelta%20P%7D_%7Bij%7D%2C%20%5Cquad%201%20%5Cleq%20k%20%5Cleq%20M." />
</p>

<h2 id="getting-started">Getting Started</h2>

<p>The file <em>main.m</em> needs to be run from the Matlab command line,</p>

<pre><code class="language-Matlab">main.m
</code></pre>

<h3 id="dynamic-mesh">Dynamic Mesh</h3>

<p>The different mesh motion methods can be selected in the heading of <em>main.m</em></p>

<pre><code class="language-Matlab">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARAMETERS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Minimum element size
Hmin = 1e-3;
% Maximum elements size
Hmax = 0.05;
% Step theta^{n+1} = theta^{n} - d * Dtheta^{n}
d = 1e-3;
% Maximum number of iterations
maxIter = 2000000;
% Dirichlet boundary condition on the outer boundary
ue = 1;
% Dirichlet boundary condition on the inner boundary
uc = 0;
% Smoothing of sensitivity field
smoothing = true;
% Reshaping of elements whose edges are lying on the controlled boundary
reshaping = true;
% Mesh motion solver method:
% - Laplace Equation ('laplace')
% - Spring Analogy ('spring')
% - Free Form Deformation ('FFD')
% - Radial Basis Functions ('RBF')
meshMotionSolver = 'laplace';
% Parameters for Laplace method
% Diffusivity (diff)
% - Inverse distance ('invdist')
invdist = true;
m = 6;
% Parameters for FFD method:
% Mi - number of control points along X axis
% Nj - number of control points along Y axis
% Xmin, Xmax - coordinates defining the control rectangle
Mi = 9;
Nj = 9;
Xmin = [-0.7, -0.6];
Xmax = -Xmin;
% Parameters for RBF method
% h - Dimensionless radial distance (r/h)
% RBFtype - Radial Basis Functions
% - Spline type, n odd ('Rn')
% - Thin Plate Spline, n even ('TPSn')
% - Multiquadratic ('MQ')
% - Inverse multiquadratic ('IMQ')
% - Inverse quadratic ('IQ')
% - Gaussian ('GS')
% n - Exponent
h = 2.5*0.3;
RBFtype = 'R';
n = 1;
</code></pre>

<h2 id="running-a-case">Running a Case</h2>

<p>The shape optimization method described in the previous section has been tested with a simple example. The Poisson equation is posed in a two-dimensional circular domain with boundary</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma_w%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%3A%20%5Csqrt%7Bx%5E2%20&plus;%20y%5E2%7D%20%3D%20R_w%20%5Cright%5C%7D." />
</p>

<p>The reference geometry to be optimized is an inner hole with boundary given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma_s%20%5Cleft%28%200%5Cright%29%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%20%3A%20%5Csqrt%7B%5Cleft%28%20x%20-%20c_x%20%5Cright%29%5E2%20&plus;%20%5Cleft%28%20y%20-%20c_y%20%5Cright%29%5E2%7D%20%3D%20R_s%20%5Cright%5C%7D." />
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig1.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig1.png?raw=true" width="400" height="340" /></a>
</p>

<p>The target function <img src="https://latex.codecogs.com/gif.latex?u_d" /> will be the analytical solution of the Poisson equation with the inner hole centered in the origin,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u_%7Banalytic%7D%5Cleft%28%20r%20%5Cright%29%20%3D%20-%5Cfrac%7Bf%7D%7B4%7Dr%5E2%20&plus;%20c_1%20%5Clog%20r%20&plus;%20c_2%2C" />
</p>

<p>where the integration constants are obtained from the boundary conditions,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20c_1%20%3D%20%26%20%5Cfrac%7Bu_w%20-%20u_s%20&plus;%20%5Cdisplaystyle%20%5Cfrac%7Bf%7D%7B4%7D%20%5Cleft%28%20R_w%5E2%20-%20R_s%5E2%20%5Cright%29%7D%7B%5Clog%5Cleft%28%20%5Cdisplaystyle%20%5Cfrac%7BR_w%7D%7BR_s%7D%20%5Cright%29%7D%2C%20%5C%5C%20c_2%20%3D%20%26%20%5Cfrac%7Bu_w%20&plus;%20u_s%7D%7B2%7D%20&plus;%20%5Cfrac%7Bf%7D%7B8%7D%5Cleft%28%20R_w%5E2%20&plus;%20R_s%5E2%20%5Cright%29%20-%20%5Cfrac%7Bc_1%7D%7B2%7D%20%5Clog%5Cleft%28%20R_w%20R_s%20%5Cright%29.%20%5Cend%7Balign*%7D" />
</p>

<p>When the hole center is displaced from the origin, the target state must be extended in the region <img src="https://latex.codecogs.com/gif.latex?r%20%5Cleq%20R_1" />, thus</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u_d%5Cleft%28%20r%20%5Cright%29%3D%20%5Cbegin%7Bcases%7D%20u_s%2C%20%5Cquad%20%26%20r%20%5Cleq%20R_s%2C%20%5C%5C%20u_%7Banalytic%7D%2C%20%5Cquad%20%26%20R_s%20%3C%20r%20%5Cleq%20R_w.%20%5Cend%7Bcases%7D" />
</p>

<p>It is clear that for</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma%5E%7B*%7D_s%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%20%3A%20%5Csqrt%7Bx%5E2%20&plus;%20y%5E2%7D%20%3D%20R_s%20%5Cright%5C%7D" />
</p>

<p>the cost function equals zero, thus it is an optimal solution. The steepest descent algorithm has been coded in Matlab with <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon%20%3D%2010%5E%7B-3%7D" />.</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig2.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig2.png?raw=true" width="400" height="300" /></a>
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig3.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig3.png?raw=true" width="400" height="300" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c1_NS_NR_invdist2.gif" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c1_NS_NR_invdist2.gif?raw=true" width="400" height="300" /></a>
</p>

<p align="center">
  <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c1_NS_NR_invdist2.gif?raw=true" target="_blank"></a>
</p>

<p>Other geometry configurations have been tried. For instance, the inner hole can be initially located farther from its optimal position,</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig4.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig4.png?raw=true" width="400" height="340" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig5.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig5.png?raw=true" width="400" height="300" /></a>
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig6.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig6.png?raw=true" width="400" height="300" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c3_S_R_invdist2.gif" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c1_NS_NR_invdist2.gif?raw=true" width="400" height="300" /></a>
</p>

<p>Different starting shapes can be tested as well,</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig7.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig7.png?raw=true" width="400" height="340" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig8.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig8.png?raw=true" width="400" height="300" /></a>
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig9.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig9.png?raw=true" width="400" height="300" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c3_S_R_invdist2.gif" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/RBF_s2_S_R_R1.gif?raw=true" width="400" height="300" /></a>
</p>

<h2 id="references">References</h2>

<ul>
  <li>O. Pironneau. <em>Optimal shape design for elliptic systems</em>. Springer Science &amp; Business Media, 2012.</li>
  <li>J Simon. <em>Diferenciación de problemas de contorno respecto del dominio</em>. Technical report, Universidad de Sevilla, Facultad de Matemáticas, Departamento de Análisis Matemático, 1989.</li>
</ul>

<p>Linear Elasticity mesh motion method:</p>
<ul>
  <li>Andrew A. Johnson and Tayfun E. Tezduyar. Mesh update strategies in parallel finite element computations of flow problems with moving boundaries and interfaces. <em>Computer methods in applied mechanics and engineering</em>, 119(1-2):73–94, 1994.</li>
  <li>Thomas D. Economon, Francisco Palacios, and Juan J. Alonso. Unsteady continuous adjoint approach for aerodynamic design on dynamic meshes. <em>AIAA Journal</em>, 53(9):2437–2453, 2015.</li>
  <li>George S. Eleftheriou and Guillaume Pierrot. Rigid motion mesh morpher: A novel approach for mesh deformation. In <em>OPT-i, An International Conference on Engineering and Applied Sciences Optimization</em>, Kos, Greece, pages 4–6, 2014.</li>
</ul>

<p>Solid Body Rotation (SBR) Stress method:</p>
<ul>
  <li>Richard P. Dwight. Robust mesh deformation using the linear elasticity equations. In <em>Computational fluid dynamics 2006</em>, pages 401–406. Springer, 2009.</li>
</ul>

<p>Laplacian Smoothing:</p>
<ul>
  <li>Peter Hansbo. Generalized laplacian smoothing of unstructured grids. <em>International Journal for Numerical Methods in Biomedical Engineering</em>, 11(5):455–464, 1995.</li>
  <li>Rainald Löhner and Chi Yang. Improved ale mesh velocities for moving bodies. <em>Communications in numerical methods in engineering</em>, 12(10):599–608, 1996.</li>
  <li>Hrvoje Jasak and Zeljko Tukovic. Automatic mesh motion for the unstructured finite volume method. <em>Transactions of FAMENA</em>, 30(2):1–20, 2006.</li>
</ul>

<p>Spring Analogy:</p>
<ul>
  <li>Ch. Farhat, C. Degand, B. Koobus, and M. Lesoinne. Torsional springs for two-dimensional dynamic unstructured fluid meshes. <em>Computer methods in applied mechanics and engineering</em>, 163(1-4):231–245, 1998.</li>
  <li>Christoph Degand and Charbel Farhat. A three-dimensional torsional spring analogy method for unstructured dynamic meshes. <em>Computers &amp; structures</em>, 80(3-4):305–316, 2002.</li>
  <li>Carlo L Bottasso, Davide Detomi, and Roberto Serra. The ball-vertex method: a new simple spring analogy method for unstructured dynamic meshes. <em>Computer Methods in Applied Mechanics and Engineering</em>, 194(39-41):4244–4264, 2005.</li>
</ul>

<p>Radial Basis Functions mesh morphing:</p>
<ul>
  <li>Stefan Jakobsson and Olivier Amoignon. Mesh deformation using radial basis functions for gradient-based aerodynamic shape optimization. <em>Computers &amp; Fluids</em>, 36(6):1119–1136, 2007.</li>
  <li>AM Morris, CB Allen, and TCS Rendall. Cfd-based optimization of aerofoils using radial basis functions for domain element parameterization and mesh deformation. <em>International Journal for Numerical Methods in Fluids</em>, 58(8):827–860, 2008.</li>
  <li>Daniel Sieger, Stefan Menzel, and Mario Botsch. High quality mesh morphing using triharmonic radial basis functions. In <em>Proceedings of the 21st International Meshing Roundtable</em>, pages 1–15. Springer, 2013.</li>
  <li>Marco Evangelos Biancolini. <em>Fast Radial Basis Functions for Engineering Applications</em>. Springer, 2018.</li>
  <li>Fank Martijn Bos. <em>Numerical simulations of flapping foil and wing aerodynamics: Mesh deformation using radial basis functions</em>. PhD thesis, Technische Universiteit Delf, 2010.</li>
  <li>Armin Beckert and Holger Wendland. Multivariate interpolation for fluid-structure-interaction problems using radial basis functions. <em>Aerospace Science and Technology</em>,
5(2):125–134, 2001.</li>
  <li>A De Boer, MS Van der Schoot, and Hester Bijl. Mesh deformation based on radial basis function interpolation. <em>Computers &amp; structures</em>, 85(11-14):784–795, 2007.</li>
  <li>Holger Wendland. <em>Konstruktion und Untersuchung radialer Basisfunktionen mit kompaktem Träger</em>. PhD thesis, Göttingen, Georg-August-Universität zu Göttingen, Diss, 1996.</li>
</ul>

<p>Free Form Deformation technique:</p>
<ul>
  <li>Matteo Lombardi, Nicola Parolini, Alfio Quarteroni, and Gianluigi Rozza. Numerical
simulation of sailing boats: Dynamics, fsi, and shape optimization. In <em>Variational Analysis and Aerospace Engineering: Mathematical Challenges for Aerospace Design</em>, pages 339–377. Springer, 2012.</li>
  <li>Thomas W Sederberg and Scott R Parry. Free-form deformation of solid geometric models. <em>ACM SIGGRAPH computer graphics</em>, 20(4):151–160, 1986.</li>
  <li>Michele Andreoli, Janka Ales, and Jean-Antoine Désidéri. <em>Free-form-deformation parameterization for multilevel 3D shape optimization in aerodynamics</em>. PhD thesis, INRIA, 2003.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;This is an OpenFOAM solver for the distributed control of the heat equation through the minimization problem&lt;/p&gt;
</code></pre></div></div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20%5Cmin_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Ctimes%20%5Cleft%28%200%20%2C%20T%20%5Cright%29%20%5Cright%29%7D%20%5Cmathcal%7BJ%7D%20%5Cleft%28%20u%20%2C%20y%20%5Cleft%28%20u%20%5Cright%29%20%5Cright%29%20%3D%20%26%20%5Cmin_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Ctimes%20%5Cleft%28%200%20%2C%20T%20%5Cright%29%20%5Cright%29%7D%20%5Cfrac%7B%5Cbeta_1%7D%7B2%7D%20%5Cint_0%5ET%20%5Cint_%7B%5COmega%7D%20u%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%20%5C%2C%20%5Cmathrm%7Bd%7Dt%20&plus;%20%5Cfrac%7B%5Cbeta_2%7D%7B2%7D%5Cint_0%5ET%20%5Cint_%7B%5COmega%7D%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%20%5C%2C%20%5Cmathrm%7Bd%7Dt%20&plus;%20%5Cfrac%7B%5Cbeta_3%7D%7B2%7D%20%5Cint_%7B%5COmega%7D%20%5Cleft%28%20y%5Cleft%28%20%5Ccdot%2C%20T%20%5Cright%29%20-%20Y_d%20%5Cright%29%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%2C%20%5Cquad%20%5Cbeta_1%2C%20%5C%20%5Cbeta_2%2C%20%5C%20%5Cbeta_3%20%5Cin%20%5Cmathbb%7BR%7D%5E&plus;%2C%20%5Cend%7Balign*%7D" />
</p>

<p>subject to the state equation</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20%5Cpartial_t%20y%20-%20%5CDelta%20y%20%3D%20f%20&plus;%20u%20%26%20%5Ctext%7Bin%20%7D%20Q%20%3D%20%5COmega%20%5Ctimes%20%5Cleft%28%200%2C%20T%20%5Cright%29%2C%5C%5C%20y%20%3D%20y_D%20%26%20%5Ctext%7Bon%20%7D%20%5CSigma_D%20%3D%20%5CGamma_D%20%5Ctimes%20%5Cleft%28%200%2C%20T%20%5Cright%29%2C%5C%5C%20%5Cdisplaystyle%20%5Cfrac%7B%5Cpartial%20y%7D%7B%5Cpartial%20n%7D%20%3D%20y_N%20%26%20%5Ctext%7Bon%20%7D%20%5CSigma_N%20%3D%20%5CGamma_N%20%5Ctimes%20%5Cleft%28%200%2C%20T%20%5Cright%29%2C%5C%5C%20y%20%5Cleft%28%20%5Ccdot%2C%200%20%5Cright%29%20%3D%20y_0%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5Cend%7Bcases%7D" />
</p>

<p>with <img src="https://latex.codecogs.com/gif.latex?%5CGamma%20%3D%20%5CGamma_D%20%5Ccup%20%5CGamma_N" /> and <img src="https://latex.codecogs.com/gif.latex?%5CGamma_D%20%5Ccap%20%5CGamma_N%3D%20%5Cemptyset" />.</p>

<p>The cost functional gradient is</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%5E%5Cprime%20%5Cleft%28%20u%20%5Cright%29%20%3D%20%5Cvarphi%20&plus;%20%5Cbeta_1%20u%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?%5Cvarphi" /> solves the adjoint problem</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5Cpartial_t%20%5Cvarphi%20-%20%5CDelta%20%5Cvarphi%20%3D%20%5Cbeta_2%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%2C%20%26%20%5Ctext%7Bin%20%7D%20Q%2C%20%5C%5C%20%5Cvarphi%5Cleft%28%20%5Ccdot%2C%20T%20%5Cright%29%20%3D%20%5Cbeta_3%20%5Cleft%28%20y%20%5Cleft%28%20%5Ccdot%2C%20T%20%5Cright%29%20-%20Y_d%20%5Cright%29%2C%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20%5Cvarphi%20%3D%200%2C%20%26%20%5Ctext%7Bon%20%7D%20%5CSigma_D%2C%20%5C%5C%20%5Cdisplaystyle%20%5Cfrac%7B%5Cpartial%20%5Cvarphi%7D%7B%5Cpartial%20n%7D%20%3D%200%2C%20%26%20%5Ctext%7Bon%20%7D%20%5CSigma_N.%20%5Cend%7Bcases%7D" />
</p>

<p>In the steepest descent method the cost gradient is used to update the control as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u%5E%7B%5Cleft%28%20n%20&plus;%201%20%5Cright%29%7D%20%3D%20u%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20%5Cepsilon%20%5Cmathcal%7BJ%7D%5E%5Cprime%20%5Cleft%28%20u%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%29%2C%20%5Cquad%20%5Cepsilon%20%5Cin%20%5Cmathbb%7BR%7D%5E&plus;%2C" />
</p>

<p>with <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon" /> sufficiently small.</p>

<h2 id="getting-started">Getting Started</h2>

<p>The solver must be compiled in the terminal. It is advisable to first clean previous compilations with</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wclean
</code></pre></div></div>

<p>and then use</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmake
</code></pre></div></div>

<h3 id="prerequisites">Prerequisites</h3>

<p>OpenFOAM C++ library must be installed in order to compile the code.</p>

<p>The OpenFOAM distribution provided by the <a href="https://openfoam.org/">OpenFOAM Foundation</a> was used.</p>

<h2 id="running-a-case">Running a Case</h2>

<p>In order to run the solver move to the case folder <em>heatAdjoinFoamCase</em> and type in the command line</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./Allprepare

heatAdjointFoam
</code></pre></div></div>

<ul>
  <li>The <em>heatAdjointFoam</em> solver has been tested in a square domain <img src="https://latex.codecogs.com/gif.latex?%5B0%2C%201%5D%20%5Ctimes%20%5B0%2C%201%5D" /> with zero Dirichlet boundary conditions, <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon%3D100" />, and <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_1%20%3D%2010%5E%7B-3%7D%2C10%5E%7B-4%7D%2C10%5E%7B-5%7D%2C10%5E%7B-6%7D" />, <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_2%20%3D%201" />, <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_3%20%3D%200" />. The target function is <img src="https://latex.codecogs.com/gif.latex?y_d%20%3D%20xy%20%5Csin%20%5Cleft%28%20%5Cpi%20x%20%5Cright%29%20%5Csin%20%5Cleft%28%20%5Cpi%20y%20%5Cright%29" />.</li>
</ul>

<p align="center">
  <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/J_b2_1_b3_0.png?raw=true" />
</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/Jy_b2_1_b3_0.png?raw=true" />
</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/anim_y_b6.gif?raw=true" width="500" height="300" />
</p>

<ul>
  <li>The <em>heatAdjointFoam</em> solver has been tested in a square domain <img src="https://latex.codecogs.com/gif.latex?%5B0%2C%201%5D%20%5Ctimes%20%5B0%2C%201%5D" /> with zero Dirichlet boundary conditions, <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon%3D10" />, and <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_1%20%3D%2010%5E%7B-3%7D%2C10%5E%7B-4%7D%2C10%5E%7B-5%7D%2C10%5E%7B-6%7D" />, <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_2%20%3D%200" />, <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_3%20%3D%201" />. The target function is <img src="https://latex.codecogs.com/gif.latex?Y_d%20%3D%20xy%20%5Csin%20%5Cleft%28%20%5Cpi%20x%20%5Cright%29%20%5Csin%20%5Cleft%28%20%5Cpi%20y%20%5Cright%29" />.</li>
</ul>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/J_b2_0_b3_1.png?raw=true" />
</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/Jy_b2_0_b3_1.png?raw=true" />
</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/anim_Y_b6.gif?raw=true" width="500" height="300" />
</p>

<h3 id="warning">Warning</h3>

<p>It might be needed to use</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed -i -e 's/\r$//' filename
</code></pre></div></div>

<p>and</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x filename
</code></pre></div></div>

<p>in order to be able to execute</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./filename
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In this work we solve the optimal control problem&lt;/p&gt;
</code></pre></div></div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?%5Cmin%20_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29%7D%20%5Cmathcal%7BJ%7D%5Cleft%28%20u%5Cright%29%20%3D%20%5Cmin%20_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29%7D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cint_%7B%5COmega%7D%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%20%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%20&plus;%20%5Cfrac%7B%5Cbeta%7D%7B2%7D%20%5Cint_%7B%5COmega%7D%20u%20%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?u" /> is the control variable, <img src="https://latex.codecogs.com/gif.latex?y" /> the state variable and <img src="https://latex.codecogs.com/gif.latex?y_d" /> a target function. The minimization problem is subject to the elliptic partial differential equation</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y%20%3D%20f%20&plus;%20u%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20y%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma.%20%5Cend%7Bcases%7D" />
</p>

<p>We use the steepest descent method based on the adjoint methodology. The corresponding adjoint system writes as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%20%5CDelta%20%5Clambda%20%3D%20y%20-%20y_d%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20%5Clambda%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma.%20%5Cend%7Bcases%7D" />
</p>

<p>The directional derivative of the cost function is given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BD%7D_%7B%20%5Cdelta%20u%7D%20%5Cmathcal%7BJ%7D%20%5Cleft%28%20u%20%5Cright%29%20%3D%20%5Cint_%7B%5COmega%7D%20%5Cleft%28%20%5Clambda%20&plus;%20%5Cbeta%20u%20%5Cright%29%20%5Cdelta%20u%20%5C%2C%20%5Cmathrm%7Bd%7D%20%5COmega%2C" />
</p>

<p>and the control variable is updated according to</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u%5E%7B%5Cleft%28%20n%20&plus;%201%20%5Cright%29%7D%20%3D%20u%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20%5Cepsilon%20%5Cleft%28%20%5Clambda%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20&plus;%20%5Cbeta%20u%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%29%2C" />
</p>

<p>for some value of <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon" />.</p>

<h2 id="getting-started">Getting Started</h2>

<p>The solver must be compiled in the terminal. It is advisable to first clean previous compilations with</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wclean
</code></pre></div></div>

<p>and then use</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmake
</code></pre></div></div>

<h3 id="prerequisites">Prerequisites</h3>

<p>OpenFOAM C++ library must be installed in order to compile the code.</p>

<p>The OpenFOAM distribution provided by the <a href="https://openfoam.org/">OpenFOAM Foundation</a> was used.</p>

<h2 id="running-a-case">Running a Case</h2>

<p>In order to run the solver move to the case folder <em>poissonAdjoinFoamCase</em> and type in the command line</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./Allprepare

poissonAdjointFoam
</code></pre></div></div>

<p>The <em>poissonAdjointFoam</em> solver has been tested in a square domain <img src="https://latex.codecogs.com/gif.latex?%5B0%2C%201%5D%20%5Ctimes%20%5B0%2C%201%5D" /> with zero Dirichlet boundary conditions and <img src="https://latex.codecogs.com/gif.latex?%5Cbeta%20%3D%2010%5E%7B-3%7D%2C10%5E%7B-4%7D%2C10%5E%7B-5%7D%2C10%5E%7B-6%7D" />. The target function is <img src="https://latex.codecogs.com/gif.latex?y_d%20%3D%20xy%20%5Csin%20%5Cleft%28%20%5Cpi%20x%20%5Cright%29%20%5Csin%20%5Cleft%28%20%5Cpi%20y%20%5Cright%29" />.</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonAdjointFoam/blob/master/poissonAdjointFoamCase/sd_J.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonAdjointFoam/blob/master/poissonAdjointFoamCase/sd_J.png?raw=true" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonAdjointFoam/blob/master/poissonAdjointFoamCase/sd_Jy.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonAdjointFoam/blob/master/poissonAdjointFoamCase/sd_Jy.png?raw=true" /></a>
</p>

<h3 id="warning">Warning</h3>

<p>It might be needed to use</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed -i -e 's/\r$//' filename
</code></pre></div></div>

<p>and</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x filename
</code></pre></div></div>

<p>in order to be able to execute</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./filename
</code></pre></div></div>

<h2 id="references">References</h2>

<ul>
  <li>F. Tröltzsch. <em>Optimal control of partial differential equations: theory, methods, and applications</em>. American Mathematical Soc., 2010.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this tutorial, we show how to use the C++ library OpenFOAM (Open Field Operation and Manipulation) in order to solve control problems for partial differential equations (PDE).&lt;/p&gt;
</code></pre></div></div>

<p>OpenFOAM is a free open source toolbox that allows the user to code customized solvers for Continuum Mechanics, with special attention to the field of Computational Fluid Dynamics. One can either use one of the multiple solvers already programmed for steady-state, transient or multiphase problems in fluid mechanics, or code his own solver depending on particular needs.</p>

<p>In this work, we will solve the optimal control problem</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:CostFunctional}
\min _{u \in L^2 \left( \Omega \right)} \mathcal{J}\left( u\right) = \min _{u \in L^2 \left( \Omega \right)} \frac{1}{2} \int_{\Omega} \left( y - y_d \right) ^2 \mathrm{d} \Omega + \frac{\beta}{2} \int_{\Omega} u ^2 \mathrm{d} \Omega,
\end{equation}</script>

<p>where $u$ is the control variable, $y$ the state variable and $y_d$ a target function. The minimization problem is subject to the elliptic partial differential equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
-\Delta y &  = f + u && \mathrm{in} \enspace \Omega \label{eq:PoissonEq}, \\
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
y & = 0 && \mathrm{on} \enspace \Gamma \label{eq:PoissonBC}.
\end{align} %]]></script>

<p>We use some classical gradient descent methods based on the adjoint methodology, namely the steepest descent and conjugate gradient methods. The corresponding adjoint system for \ref{eq:PoissonEq} writes as,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
- \Delta \lambda & = y - y_d && \mathrm{in} \enspace \Omega, \label{eq:PoissonAdjointEq} \\
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\lambda & = 0 \ && \mathrm{on} \enspace \Gamma. \label{eq:PoissonAdjointBC}
\end{align} %]]></script>

<p>In the steepest descent gradient method, we compute the directional derivative of the cost function in \ref{eq:CostFunctional},</p>

<script type="math/tex; mode=display">\begin{equation}
J^\prime \left( u \right) \delta u = \int_{\Omega} \left( \lambda + \beta u \right) \delta u \mathrm{d} \Omega,
\end{equation}</script>

<p>where $\lambda$ is solution to the elliptic problem in \ref{eq:PoissonAdjointEq}, and use the gradient to update the control variable as</p>

<script type="math/tex; mode=display">\begin{equation}
u^{\left( n + 1 \right)} = u^{\left( n \right)} - \gamma \left( \lambda^{\left( n \right)} + \beta u^{\left( n \right)} \right),
\end{equation}</script>

<p>for some value of $\gamma$.</p>

<p>One of the main advantages of OpenFOAM is its friendly syntax to describe PDE, as can be seen in the lines 10 and 13 in the code below.</p>

<pre class="cpp" style="font-family:monospace;"><span style="color: #666666;">// Initialize L2 norm of control update</span>
scalar pL2 <span style="color: #000080;">=</span> <span style="color: #0000dd;">10</span><span style="color: #000040;">*</span>tol<span style="color: #008080;">;</span>
&nbsp;
<span style="color: #666666;">// Get the volume of mesh cells</span>
scalarField volField <span style="color: #000080;">=</span> mesh.<span style="color: #007788;">V</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
<span style="color: #0000ff;">while</span> <span style="color: #008000;">&#40;</span>runTime.<span style="color: #007788;">loop</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">&amp;&amp;</span> <span style="color: #008080;">::</span><span style="color: #0000dd;">sqrt</span><span style="color: #008000;">&#40;</span>pL2<span style="color: #008000;">&#41;</span> <span style="color: #000080;">&gt;</span> tol<span style="color: #008000;">&#41;</span>
<span style="color: #008000;">&#123;</span>
    <span style="color: #666666;">// Solve primal equation</span>
    solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, y<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> u<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Solve ajoint equation</span>
    solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, lambda<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> y <span style="color: #000040;">-</span> yd<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Update control</span>
    p <span style="color: #000080;">=</span> lambda <span style="color: #000040;">+</span> beta<span style="color: #000040;">*</span>u<span style="color: #008080;">;</span>
    u <span style="color: #000080;">=</span> u <span style="color: #000040;">-</span> gamma<span style="color: #000040;">*</span>p<span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Control update norm</span>
    pL2 <span style="color: #000080;">=</span> <span style="color: #008080;">::</span><span style="color: #0000dd;">sqrt</span><span style="color: #008000;">&#40;</span>gSum<span style="color: #008000;">&#40;</span>volField<span style="color: #000040;">*</span>p.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #000040;">*</span>p.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Compute cost function</span>
    J <span style="color: #000080;">=</span> <span style="color:#800080;">0.5</span><span style="color: #000040;">*</span>gSum<span style="color: #008000;">&#40;</span>volField<span style="color: #000040;">*</span><span style="color: #008000;">&#40;</span>Foam<span style="color: #008080;">::</span><span style="color: #0000dd;">pow</span><span style="color: #008000;">&#40;</span>y.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #000040;">-</span>yd.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>,<span style="color: #0000dd;">2</span><span style="color: #008000;">&#41;</span> \
	    <span style="color: #000040;">+</span> beta<span style="color: #000040;">*</span>Foam<span style="color: #008080;">::</span><span style="color: #0000dd;">pow</span><span style="color: #008000;">&#40;</span>u.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>,<span style="color: #0000dd;">2</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Display information</span>
    Info <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Iteration &quot;</span> <span style="color: #000080;">&lt;&lt;</span> runTime.<span style="color: #007788;">timeName</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot; - &quot;</span> \
	    <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Cost value &quot;</span> <span style="color: #000080;">&lt;&lt;</span> J <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot; - &quot;</span> \
	    <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Control variation L2 norm &quot;</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #008080;">::</span><span style="color: #0000dd;">sqrt</span><span style="color: #008000;">&#40;</span> pL2 <span style="color: #008000;">&#41;</span> <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Save current iteration results</span>
    runTime.<span style="color: #007788;">write</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
<span style="color: #008000;">&#125;</span></pre>
<!--h4 align="center">steepestdescent.cpp</h4-->

<p>In order to improve the convergence to the optimal control, the conjugate gradient method is applied also to the problem. First, the state variable must be separated in two terms as</p>

<script type="math/tex; mode=display">\begin{equation}
y = y_u + y_{f},
\end{equation}</script>

<p>where $y_u$ solves the state equation with zero Dirichlet boundary conditions,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
-\Delta y_u &  = u && \mathrm{in} \enspace \Omega \label{eq:PoissonEqu}, \\
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
y_u & = 0 && \mathrm{on} \enspace \Gamma \label{eq:PoissonBCu},
\end{align} %]]></script>

<p>and $y_{f}$ is the control-free solution to the state equation,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
-\Delta y_{f} &  = f && \mathrm{in} \enspace \Omega \label{eq:PoissonEq0}, \\
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
y_{f} & = 0 && \mathrm{on} \enspace \Gamma \label{eq:PoissonBC0}.
\end{align} %]]></script>

<p>Now, using the above separation of the state variable, one part depending on the control and the other part on a known source term, the cost functional in \ref{eq:CostFunctional} can be expressed as</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:CostFunctionalcg}
J \left( u \right) = \frac{1}{2} \left( y_u + y_f - y_d, y_u + y_f - y_d \right)_{L^2\left( \Omega \right)} + \frac{\beta}{2} \left( u , u \right) _{L^2\left( \Omega \right)}.
\end{equation}</script>

<p>We define a linear operator $\Lambda: L^2\left( \Omega \right) \rightarrow L^2\left( \Omega \right)$ that takes a control $u$ and returns the solution to problem \ref{eq:PoissonEqu}-\ref{eq:PoissonBCu}, so that $y_u = \Lambda u$. We introduce as well its adjoint operator $\Lambda^<em>: L^2\left( \Omega \right) \rightarrow L^2\left( \Omega \right)$ that takes the source term in \ref{eq:PoissonAdjointEq} and solves the Poisson equation, so that $\lambda = \Lambda^</em> \left( y - y_d \right)$.</p>

<p>The directional derivative of the functional \ref{eq:CostFunctionalcg} then reads as</p>

<script type="math/tex; mode=display">\begin{equation}
J^\prime\left( u \right) \delta u = \left( \underbrace{ \left(  \Lambda^* \Lambda + \beta I  \right)}_{A_{cg}} u - \underbrace{ \Lambda^* \left( y_d - y_f \right)}_{b_{cg}}, \delta u \right) _{L^2\left( \Omega \right)}.
\end{equation}</script>

<p>After having identified $A_{cg}$ and $b_{cg}$ we can use the conjugate gradient method to reach the optimal control faster.</p>

<h6><b>Algorithm 1</b> Optimal control with Conjugate Gradient Method</h6>
<p><b>Require:</b> $y_D$, $u^{\left(0\right)}$, $\beta$, $y_d$, $tol$</p>
<ol>
<li> $n \gets 0 $</li>
<li> compute the control-free solution, $y_f$</li>
<li> $b \gets \Lambda^*\left( y_d - y_f \right)$</li>
<li> $z \gets \Lambda u$</li>
<li> $g \gets \Lambda^*z + \beta u - b$</li>
<li> $h \gets ||g||^2_{L^2\left(\left[0,T\right]\right)}$</li>
<li> $h_a \gets h$</li>
<li> $r \gets -g$</li>
<li><b>While</b> $||r||_{L^2\left(\left[0,T\right]\right)} &gt; tol $ <b>do</b></li>
<li>   &emsp; &emsp;    $z \gets \Lambda r$</li>
<li>   &emsp; &emsp;    $w \gets \Lambda^*z + \beta r$</li>
<li>   &emsp; &emsp;    $\alpha \gets \frac{h}{\left(r,w\right)_{L^2\left(\left[0,T\right]\right)}}$</li>
<li>   &emsp; &emsp;    $u \gets u + \alpha r$</li>
<li>   &emsp; &emsp;    $g \gets g + \alpha w$</li>
<li>   &emsp; &emsp;    $h_a \gets h$</li>
<li>   &emsp; &emsp;    $h \gets ||g||^2_{L^2\left(\left[0,T\right]\right)}$</li>
<li>   &emsp; &emsp;    $\gamma \gets \frac{h}{h_a}$</li>
<li>   &emsp; &emsp;    $r \gets -g + \gamma r$</li>
<li>   &emsp; &emsp;    $n \gets n + 1$</li>
</ol>

<pre class="cpp" style="font-family:monospace;"><span style="color: #666666;">// Compute b: right-hand side of Ax = b</span>
solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, y<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, lambda<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> yd <span style="color: #000040;">-</span> y<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
volScalarField b <span style="color: #000080;">=</span> lambda<span style="color: #008080;">;</span>
&nbsp;
<span style="color: #666666;">// Compute A*f0</span>
<span style="color: #666666;">// Primal equation</span>
solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, y0<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> u<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
<span style="color: #666666;">// Adjoint equation</span>
solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, lambda<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> y0<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
<span style="color: #666666;">// Compute g0: initial gradient</span>
volScalarField g <span style="color: #000080;">=</span> lambda <span style="color: #000040;">+</span> beta<span style="color: #000040;">*</span>u <span style="color: #000040;">-</span> b<span style="color: #008080;">;</span>
scalar gL2 <span style="color: #000080;">=</span> gSum<span style="color: #008000;">&#40;</span> volField <span style="color: #000040;">*</span> g.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">*</span> g.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
scalar gL2a <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span><span style="color: #008080;">;</span>
&nbsp;
<span style="color: #666666;">// Compute initial residual and its norm</span>
volScalarField r <span style="color: #000080;">=</span> <span style="color: #000040;">-</span>g<span style="color: #008080;">;</span>
scalar rL2 <span style="color: #000080;">=</span> gL2<span style="color: #008080;">;</span>
&nbsp;
volScalarField w <span style="color: #000080;">=</span> g<span style="color: #008080;">;</span>
&nbsp;
scalar alpha <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span><span style="color: #008080;">;</span>
scalar gamma <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span><span style="color: #008080;">;</span>
&nbsp;
<span style="color: #0000ff;">while</span> <span style="color: #008000;">&#40;</span>runTime.<span style="color: #007788;">loop</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">&amp;&amp;</span> <span style="color: #008080;">::</span><span style="color: #0000dd;">sqrt</span><span style="color: #008000;">&#40;</span> rL2 <span style="color: #008000;">&#41;</span> <span style="color: #000080;">&gt;</span> tol<span style="color: #008000;">&#41;</span>
<span style="color: #008000;">&#123;</span>
    r.<span style="color: #007788;">dimensions</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>.<span style="color: #007788;">reset</span><span style="color: #008000;">&#40;</span> u.<span style="color: #007788;">dimensions</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Compute w = A*r</span>
    solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, y0<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> r<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, lambda<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> y0<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    w <span style="color: #000080;">=</span> lambda <span style="color: #000040;">+</span> beta<span style="color: #000040;">*</span>r<span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Update alpha</span>
    alpha <span style="color: #000080;">=</span> gL2 <span style="color: #000040;">/</span> gSum<span style="color: #008000;">&#40;</span> volField <span style="color: #000040;">*</span> r.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">*</span> w.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Update control</span>
    u <span style="color: #000080;">=</span> u <span style="color: #000040;">+</span> alpha<span style="color: #000040;">*</span>r<span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Update cost gradient and its norm</span>
    g <span style="color: #000080;">=</span> g <span style="color: #000040;">+</span> alpha<span style="color: #000040;">*</span>w<span style="color: #008080;">;</span>
    gL2a <span style="color: #000080;">=</span> gL2<span style="color: #008080;">;</span>
    gL2 <span style="color: #000080;">=</span> gSum<span style="color: #008000;">&#40;</span> volField <span style="color: #000040;">*</span> g.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">*</span> g.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    gamma <span style="color: #000080;">=</span> gL2<span style="color: #000040;">/</span>gL2a<span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Update residual and its norm</span>
    r.<span style="color: #007788;">dimensions</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>.<span style="color: #007788;">reset</span><span style="color: #008000;">&#40;</span> g.<span style="color: #007788;">dimensions</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    r <span style="color: #000080;">=</span> <span style="color: #000040;">-</span>g <span style="color: #000040;">+</span> gamma<span style="color: #000040;">*</span>r<span style="color: #008080;">;</span>
    rL2 <span style="color: #000080;">=</span> gSum<span style="color: #008000;">&#40;</span> volField <span style="color: #000040;">*</span> r.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">*</span> r.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, y<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> u<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    J <span style="color: #000080;">=</span> <span style="color:#800080;">0.5</span><span style="color: #000040;">*</span>gSum<span style="color: #008000;">&#40;</span>volField<span style="color: #000040;">*</span><span style="color: #008000;">&#40;</span>Foam<span style="color: #008080;">::</span><span style="color: #0000dd;">pow</span><span style="color: #008000;">&#40;</span>y.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #000040;">-</span>yd.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>,<span style="color: #0000dd;">2</span><span style="color: #008000;">&#41;</span> \
     <span style="color: #000040;">+</span> beta<span style="color: #000040;">*</span>Foam<span style="color: #008080;">::</span><span style="color: #0000dd;">pow</span><span style="color: #008000;">&#40;</span>u.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>,<span style="color: #0000dd;">2</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    Info <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Iteration no. &quot;</span> <span style="color: #000080;">&lt;&lt;</span> runTime.<span style="color: #007788;">timeName</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot; - &quot;</span> \
	    <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Cost value &quot;</span> <span style="color: #000080;">&lt;&lt;</span> J <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot; - &quot;</span> \
	    <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Residual &quot;</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #008080;">::</span><span style="color: #0000dd;">sqrt</span><span style="color: #008000;">&#40;</span> rL2 <span style="color: #008000;">&#41;</span> <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span>
&nbsp;
    runTime.<span style="color: #007788;">write</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
<span style="color: #008000;">&#125;</span>
&nbsp;</pre>
<!--h5 align="center">conjugategradient.cpp</h5-->

<p>Both solvers, <i>laplaceAdjointFoam</i> for the steepest descent method with $\gamma = 10$ and <i>laplaceCGAdjointFoam</i> for the conjugate gradient method, have been tested in a square domain $[0, 1] \times [0, 1]$ with zero Dirichlet boundary conditions and $\beta = 10^{-3},10^{-4},10^{-5},10^{-6}$. The target function is $y_d = xy \sin \left( \pi x \right) \sin \left( \pi y \right)$.</p>

<p>The problem setup is called <i>case</i> in OpenFOAM and it is independent from the solver itself. A typical case in OpenFOAM has three folders: <i>0</i>, where the problem fields are stored along with their boundary conditions; <i>constant</i>, that includes the mesh data and the physical properties; and <i>system</i>, with parameters regarding the numerical solution and problem output such as tolerances, linear solvers or write interval. In this example, the case folder is called <i>laplaceAdjointFoamCase</i>.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/sd_J.png" alt="Figure 1.a: Functional value against the number of iterations of the gradient method. Steepest descent method. Steepest descent method" width="560" height="420" class="size-full wp-image-8677" />
Figure 1.a: Functional value against the number of iterations of the gradient method. Steepest descent method. Steepest descent method</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/cg_J.png" alt="Figure 1.b: Functional value against the number of iterations of the gradient method. Steepest descent method. Conjugate gradient method." width="560" height="420" class="size-full wp-image-8675" />
Figure 1.b: Functional value against the number of iterations of the gradient method. Steepest descent method. Conjugate gradient method.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/sd_Jy.png" alt="Figure 2.a" width="560" height="420" class="size-full wp-image-8678" />
Figure 2.a: $|| y - y_d ||_{L^2 \left( \Omega \right)}$ against the number of iterations of the gradient method. Steepest descent method.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/cg_Jy.png" alt="Figure 2.b" width="560" height="420" class="size-full wp-image-8676" />
Figure 2.b: $|| y - y_d ||_{L^2 \left( \Omega \right)}$ against the number of iterations of the gradient method. Conjugate gradient method.</p>

<h6>Bibliography</h6>

<p><strong>[1]</strong> The OpenFOAM Foundation, <a href="http://openfoam.org" target="_blank"><em>http://openfoam.org</em></a>.</p>
<p><strong>[2]</strong> F. Tröltzsch. <a href="https://bookstore.ams.org/gsm-112/" target="_blank"><em>Optimal control of partial differential equations: theory, methods, and applications</em></a>. American Mathematical Soc., 2010.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In &lt;a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref3"&gt;[3]&lt;/a&gt;, we develop a WKB analysis for the propagation of the solutions to the following one-dimensional nonlocal Schrödinger equation&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}\label{main_eq}
	\mathcal{P}_s u:= \left[i\partial_t + \ffl{s}{}\right]u = 0, &\;\;  (x,t)\in\RR\times(0,+\infty),
\end{align} %]]></script>

<p>with highly oscillatory initial datum</p>

<script type="math/tex; mode=display">\begin{align}\label{in_dat}
	u(x,0) = u_{\textrm{\small in}}(x) e^{i\frac{\xi_0}{\varepsilon} x}:=u_0(x),\;\;\; \xi_0\in\RR.
\end{align}</script>

<p>In (\ref{main_eq}), $\ffl{s}{}$ is the fractional Laplacian, defined for all $s\in(0,1)$ and for any function $f$ sufficiently smooth as the following singular integral</p>

<script type="math/tex; mode=display">\begin{align*}
\ffl{s}{f}(x):=\ccs\; P.V. \int_{\RR}\frac{f(x)-f(y)}{\kernel{1+2s}}\,dy,
\end{align*}</script>

<p>with $\ccs$ a normalization constant given by</p>

<script type="math/tex; mode=display">\begin{align*}%\label{ccs}
\ccs:= \left(\int_{\RR} \frac{1-\cos(z)}{|z|^{1+2s}}\,dz\right)^{-1} = \frac{s2^{2s}\Gamma\left(s+\frac 12\right)}{\sqrt{\pi}\Gamma(1-s)},
\end{align*}</script>

<p>where $\Gamma$ is the usual Gamma function. The parameter $\varepsilon$ in (\ref{main_eq}) and in (\ref{in_dat}) represents the fast space and time scale introduced in the equation, as well as the typical wavelength of oscillations of the initial data. Moreover, we will assume the initial phase $u_{\textrm{\small in}}$ to be an $L^2(\RR)$ function, so that we have $u_0\in L^2(\RR)$.</p>

<p>Our study is motivated by control problems. Indeed, the well-known boundary controllability and identifiability properties of solutions of wave-like equations hold because of the fact that the energy of solutions is driven by characteristics that reach the boundary where the controllers or observers are placed. This, in particular, allows the so-called <i>observability</i> of the solutions (namely, the possibility to obtain estimates of the total energy in terms of the energy concentrated on the support of the control along time), which is by now known to be equivalent to control properties. In the framework of wave-like processes, observability is possible if and only if the geometric control condition (GCC), requiring all rays of geometric optics to enter the control region during the control time, holds (<a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref1">[1]</a>).</p>

<p>In the particular case under analysis, the construction that we obtain is then applied to the study of controllability properties for the one dimensional fractional Schrödinger equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}\label{schr_control}
     \begin{cases}
		iu_t+\ffl{s}{u} = g\chi_{\omega\times(0,T)}, & (x,t)\in (-1,1)\times(0,T)
		\\
		u\equiv 0, & (x,t)\in(-1,1)^c\times(0,T)
		\\
		u(x,0)=u_0(x), & x\in(-1,1),
	\end{cases}
\end{align} %]]></script>

<p>where $\omega$ is a neighborhood of the boundary of the space domain $(-1,1)$. In particular, it is possible to find confirmation to the following facts, proved in <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref2">[2]</a>:</p>
<ul>
	<li> For $s&gt; 1/2$, null controllability holds in any finite time $T&gt;0$. In other words, given any $u_0\in L^2(-1,1)$ there exists a control function $g\in L^2(\omega\times(0,T))$ such that the solution to (\ref{schr_control}) satisfies $u(x,T)=0$.</li>
	<li> For $s=1/2$, the same result holds if we assume the controllability time $T$ to be large enough, i.e $T\geq T_0&gt;0$.</li>
	<li> For $ s&lt; 1/2 $, the equation (\ref{schr_control}) is not null controllable.	</li>
</ul>

<p>The above facts are related to the well-known property that the solutions to wave-like equations propagate along the so-called rays of geometric optics. These rays are nothing more than the projection to the physical time-space of the null bicharacteristic, solutions to the Hamiltonian system associated to the equation.</p>

<p>In our case, since $\mathcal{P}_s=i\partial_t+\ffl{s}{}$ is a pseudo-differential operator with symbol
$ p_s(x,t,\xi,\tau) = \tau - |\xi|^{2s} $ , the Hamiltonian system is given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}\label{char_syst}
     \begin{cases}
		\dot{x}(\sigma) = \partial_\xi p_s = \pm 2s|\xi(\sigma)|^{2s-1}, & x(0)=x_0
		\\
		\dot{t}(\sigma) = \partial_\tau p_s = 1, & t(0)=t_0
		\\
		\dot{\xi}(\sigma) = -\partial_x p_s = 0, & \xi(0)=\xi_0
		\\
		\dot{\tau}(\sigma) = -\partial_t p_s =0, & \tau(0)=|\xi_0|^{2s}.
	\end{cases}
\end{align} %]]></script>

<p>Moreover, without losing generality we may assume $t_0=0$. Then, (\ref{char_syst}) can be solved explicitly, and we obtain the following expressions for the bicharacteristics</p>

<script type="math/tex; mode=display">\begin{align*}

\begin{cases}
x(\sigma) = x_0 \pm 2s|\xi_0|^{2s-1}\sigma
\\
t(\sigma) = \sigma
\\
\xi(\sigma) = \xi_0
\\
\tau(\sigma) = |\xi_0|^{2s}.
\end{cases}
\end{align*}</script>

<p>In particular, the rays of $ \mathcal{P}_s $ are given by the curves</p>

<script type="math/tex; mode=display">(t,x_0\pm 2s|\xi_0|^{2s-1}t)\in(0,+\infty)\times\RR</script>

<p>Notice that, as one expects since the operator has constant coefficients, these rays are straight lines.</p>

<p>The approach that we use for building localized solutions is quite standard. In particular, we look for quasi-solutions to (\ref{main_eq}) introducing the ansatz</p>

<script type="math/tex; mode=display">\begin{align}\label{ansatz}
	\ue{u}(x,t) = \varepsilon^s e^{i\left[\xi_0\varepsilon^{-1}x\,+\,|\xi_0|^{2s}\varepsilon^{-2s}t\right]}\sum_{j\geq 0}\varepsilon^{\frac{s}{2}j}a_j\left(x,\varepsilon^{\frac{3}{2}s}t\right),
\end{align}</script>

<p>where the normalization constant $\varepsilon^s$ is chosen asking that the function $\ue{u}$ has $H^s(\RR)$-norm of the order $\mathcal O(1)$. The identification of the $a_j$-s is then carried out imposing</p>

<script type="math/tex; mode=display">\begin{align*}
	\mathcal{P}_s\ue{u} = O(\varepsilon^{\infty}),
\end{align*}</script>

<p>thus obtaining a series of PDEs in which it is possible to clearly separate the leading order terms, with respect to $\varepsilon$, from several remainders which will vanish as $\varepsilon\to 0$. This generates a cascade system for the functions $a_j$, which can then be determined as the solution of certain given Partial Differential Equations. In our case, the cascade system is the following one</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}\label{cascade_system}


     \begin{cases}
		i\partial_\tau a_0 + \mathcal{C}_{\frac s2} \mathcal{D}^{\frac{s}{2}} a_0 = 0  
		\\
		i\partial_\tau a_1 + \mathcal{C}_{\frac s2} \mathcal{D}^{\frac{s}{2}} a_1 + \mathcal{C}_{s} \mathcal{D}^{s} a_0 = 0  
		\\
		i\partial_\tau a_2 + \mathcal{C}_{\frac s2} \mathcal{D}^{\frac{s}{2}} a_2 + \mathcal{C}_{s} \mathcal{D}^{s} a_1 + \mathcal{C}_{\frac{3s}{2}} \mathcal{D}^{\frac{3s}{2}} a_0(\theta,\tau) = 0, & \displaystyle x\leq\theta\leq x+\frac{\varepsilon}{\xi_0}q
		\\
		i\partial_\tau a_j + \mathcal{C}_{\frac s2}\mathcal{D}^{\frac{s}{2}}a_j + \mathcal{C}_{s} \mathcal{D}^{s}a_{j-1} + \mathcal{C}_{\frac{3s}{2}} \mathcal{D}^{\frac{3s}{2}}a_{j-2}(\theta,\tau) + \ffl{s}{a_{j-3}}, & j\geq 3
		\\
		&\displaystyle x\leq\theta\leq x+\frac{\varepsilon}{\xi_0}q.  
	\end{cases}
\end{align} %]]></script>

<p>with $\tau:=\varepsilon^{\frac 32 s}t$ and where $\mathcal{D}^{\,\beta}$ denotes the following fractional derivative of order $\beta$</p>

<script type="math/tex; mode=display">\begin{align*}
	\mathcal{D}^{\beta} f(x):= \frac{1}{\Gamma(1-\beta)}\int_{-\infty}^x \frac{f'(y)}{(x-y)^{\beta}}\,dy.
\end{align*}</script>

<p>Moreover, (\ref{cascade_system}) is uniquely solvable with initial conditions imposed at $\tau = 0$ and this, of course, allows to identify the expressions of the functions $a_j$. See <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref3">[3]</a> for more details.</p>

<p>Now, it is possible to show that the quasi-solutions that can be computed by using the ansatz (\ref{ansatz}) are in fact localized along rays. In more detail, we have the following result</p>

<p><strong>Theorem 1.</strong> Let $u_{\textrm{\small in}}\in L^2(\RR)$ and let $\ue{u}$ be constructed employing the expansion (\ref{ansatz}). Then, for any $\varepsilon&gt;0$ we have:</p>
<ol>
<li> The functions $\ue{u}$ are approximate solutions to (\ref{main_eq}):

$$
\begin{align*}
     \norm{u_0(x)-\ue{u}(x,0)}{L^2(\RR)} = \mathcal{O}(\varepsilon^{\frac{1}{2}}),
\end{align*}
$$


$$
\begin{align*}
     \norm{u(x,t)-\ue{u}(x,t)}{L^2(\RR)} = \mathcal{O}(\varepsilon^{\frac 12}).
\end{align*}
$$
</li>
<li> The initial energy of $\ue{u}$ remains bounded as $\varepsilon\to 0$, i.e.

$$
\begin{align*}
     \norm{\ue{u}(x,0)}{H^s(\RR)}^2 \approx 1.
\end{align*}
$$
</li>
<li> The energy of $\ue{u}$ is exponentially small off the ray $(t,x(t))$:

$$
\begin{align*}
     \int_{|x-x(t)|&gt;\varepsilon^{\frac 14}} \left|\ffl{\frac s2}{\ue{u}}(x,t)\right|^2\,dx = \mathcal O(\varepsilon^{\frac 14}).
\end{align*}
$$
</li>
</ol>
<p>Since the quasi-solution $\ue{u}$ to our original system are concentrated along the rays, they propagate with the group velocity of the plane wave solutions, which can be computed as follows. First of all, rewrite</p>

<script type="math/tex; mode=display">\begin{align*}
	e^{i\left[\xi_0\varepsilon^{-1}x\,+\,|\xi_0|^{2s}\varepsilon^{-2s}t\,\right]} = e^{it\left[\xi_0\varepsilon^{-1}\left(\frac xt\right) + \,|\xi_0|^{2s}\varepsilon^{-2s}\,\right]} = e^{it\phi(x,t,\xi_0,\varepsilon)}.
\end{align*}</script>

<p>Hence, $ v:= \vert x/t \vert $ is obtained solving the equation</p>

<script type="math/tex; mode=display">\begin{align*}
	\frac{\partial\phi}{\partial \xi_0} = \varepsilon^{-1}\frac xt + 2s\varepsilon^{-2s}|\xi_0|^{2s-1}\textrm{sgn}(\xi_0) = 0,
\end{align*}</script>

<p>from which we immediately find that</p>

<script type="math/tex; mode=display">\begin{align*}
	v=\left|\frac xt\right| = 2s\varepsilon^{1-2s}|\xi_0|^{2s-1}.
\end{align*}</script>

<p>Moreover, this group velocity can be analyzed in terms of $s$ and of the frequency $\xi_0$. Firstly, we immediately see that for $s=1/2$ we have</p>

<script type="math/tex; mode=display">\begin{align*}
v=1,
\end{align*}</script>

<p>i.e. the velocity is constant and independent of the frequency $\xi_0$. For $s\in(0,1/2)$, instead, we have that $1-2s&gt;0$. Hence, taking $\varepsilon&lt;1$, we easily get</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
v<|\xi_0|^{2s-1}.
\end{align*} %]]></script>

<p>Finally, for $s\in(1/2,1)$ the situation is the opposite. We have $1-2s&lt;0$ and, for $\varepsilon&lt;1$,</p>

<script type="math/tex; mode=display">\begin{align*}
v>|\xi_0|^{2s-1}.
\end{align*}</script>

<p>In view of these behaviors, we can conclude that:</p>
<ul>
<li> For $s&gt; 1/2$, the group velocity increases with the frequency.	</li>

<li> For $s=1/2$, the group velocity remains constant.	</li>

<li> For $s&lt;1/2$, the group velocity decreases with the frequency.	</li>
</ul>

<p>Therefore, the high-frequency solutions are travelling faster and faster, for $s&gt;1/2$, and slower and slower, for $s&lt;1/2$. This behavior has then consequences from the point of view of observation properties for the solutions. In more detail,</p>
<ul>
	<li> For $s&gt;1/2$, the velocity of propagation of the rays allow them to be observable in any finite time $T&gt;0$.	</li>
	<li> For $s=1/2$, the velocity of propagation being constant, a minimum observation time $T_0$ is needed.	</li>
	<li> for $s&lt;1/2$ the high frequency rays may not reach the control region, thus implying the failing of controllability properties. 	</li>
</ul>
<p>This, in particular, confirms the already known results presented in <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref2">[2]</a>.</p>

<p>In what follows, we present some simulations which show the propagation of solutions to the fractional Schrödinger equation (\ref{main_eq}) corresponding to initial data in the form (\ref{in_dat}).</p>

<p>For the numerical resolution of the equation, we employed a uniform mesh in the space variable and a FE discretization of the fractional Laplacian, obtained following the methodology presented in <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref4">[4]</a>. Moreover, we used a Crank-Nicholson scheme in time, which is known to be stable for the Schrödinger equation. The initial data $u_0$ has been chosen as</p>

<script type="math/tex; mode=display">\begin{align*}
	u_0(x) = e^{-\frac \gamma2 (x-x_0)^2}e^{i\frac {\xi_0}{\varepsilon} x},
\end{align*}</script>

<p>where the profile $u_{\textrm{in}}(x)$ is given by a Gaussian with standard deviation measured in terms of the parameter $\gamma$, which is related to the mesh size $h$. In particular we chose $\gamma = h^{0.9}$. Finally, for the oscillations we considered frequencies $\xi_0=\pi^2/16$ and $\xi_0=2\pi^2$.</p>

<p>In <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#video1">Video 1</a>, we show the plots for $\xi_0=2\pi^2$ and different values of $s\in(0,1)$. The space domain has been chosen to be the interval $(-1,1)$, while we considered a time interval of $5$ seconds.</p>

<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_19.7392_1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_19.7392_1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>

<p>Video 1. Propagation of the solution for $\xi_0 = 2\pi^2$ and different values of $s$.</p>

<!--
[video width="570" height="450" mp4="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_0.61685_1.mp4"][/video]

<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger1_01_1.png" alt="plot_frac_schrodinger1_01_1" width="300" height="235" class="size-medium wp-image-8515" /> Figure 1.a Propagation of the solution for $\xi_0 = 2\pi^2$ and different values of $s$.

<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger1_05_1.png" alt="plot_frac_schrodinger1_05_1" width="300" height="235" class="size-medium wp-image-8516" /> Figure 1.b Propagation of the solution for $\xi_0 = 2\pi^2$ and different values of $s$.

<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger1_09_1.png" alt="plot_frac_schrodinger1_09_1" width="300" height="235" class="size-medium wp-image-8518" /> Figure 1.c Propagation of the solution for $\xi_0 = 2\pi^2$ and different values of $s$.
-->

<p>It is seen there that, for small values of $s$, say $s=0.1$, the solution remains concentrated along rays which propagate only in the vertical direction. In other words, there is no propagation in space and, as we mentioned before, this implies that it will not be possible to control these solutions, no matter how one places the controls. For $s=0.5$, instead, the plots show that the solutions propagate along rays which reach the boundary of the space domain in finite time and are reflected according to the laws of optics. This translate in the fact that, provided that the time is large enough, it will be possible to control these solutions, acting with a control distributed in a neighbourhood $\omega$ of the boundary. The case of high values of the power $s$ of the fractional Laplacian is the most puzzling one. For instance, for $s=0.9$ our plots seem to show a lost of concentration of the solution along the ray, while our theoretical results would suggest that this concentration is preserved. On the other hand, we believe that what the simulations are showing is not in contradiction with the theory. In our opinion, it is only a numerical effect, which has two possible interpretations.</p>

<p>First of all, for $s&gt;1/2$, the velocity of propagation of the solutions is increasing. As a consequence, in the time framework that we are considering the waves reach the boundary and are reflected many more times than in the case $s=1/2$. This large number of reflections is quite hard to clearly distinguish a the discrete level, even when working with very fine meshes (for our simulations, for instance, we are considering a mesh of $500$ points, corresponding to a step $h$ of the order of $10^{-3}$).</p>

<p>A second possible interpretation is that this strange phenomenon appearing in the plot can be explained with the accumulation of higher order terms in the asymptotic expansion of $\ue{z}$ which, combined with the small size of the space interval considered, enhance a chaotic behavior. This interpretation is supported by the fact that, as it is shown in <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#video3">Video 3</a>, enlarging the space domain up to $(-6,6)$ it is possible to appreciate again the localization of the solution along the rays.</p>

<p>In <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#video2">Video 2</a>, the simulations have been run with an initial datum with frequency $\xi_0=\pi^2/16$. The plots obtained show a behavior which is totally analogous with what observed in <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#video1">Video 1</a>:</p>
<ul>
<li> For $s=0.1$, the solutions are once again concentrated along vertical rays, without propagation in time and, therefore, without possibility of being controlled.	</li>

<li> For $s=0.5$, we have propagation with constant velocity, and the ray reaches the boundary in finite time.	</li>

<li> For $s=0.9$ the chaotic comportment is still present.	</li>
</ul>

<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_0.61685_1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_0.61685_1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
<p>Video 2. Propagation of the solution for $\xi_0 = \pi^2/16$ and different values of $s$.</p>

<!--
[video width="560" height="420" mp4="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_19.7392_1.mp4"][/video]

[caption id="attachment_8519" align="aligncenter" width="300"]<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger2_01_1.png" alt="plot_frac_schrodinger2_01_1" width="300" height="235" class="size-full wp-image-8519" /> Figure 2.a Propagation of the solution for $\xi_0 = \pi^2/16$ and different values of $s$.

[caption id="attachment_8520" align="aligncenter" width="300"]<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger2_05_1.png" alt="plot_frac_schrodinger2_05_1" width="300" height="235" class="size-full wp-image-8520" /> Figure 2.b Propagation of the solution for $\xi_0 = \pi^2/16$ and different values of $s$.

[caption id="attachment_8521" align="aligncenter" width="300"]<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger2_09_1.png" alt="plot_frac_schrodinger2_09_1" width="300" height="235" class="size-full wp-image-8521" /> Figure 2.c Propagation of the solution for $\xi_0 = \pi^2/16$ and different values of $s$.
-->

<p>Once again, the most surprising case is the last one, for $s&gt;0.5$, in which the simulations seem to display dispersive features. Nevertheless, as we mentioned before, we retain that this does not contradict the theoretical results, and we think that this chaotic behavior is purely a numerical effect generated by the small size of the space interval $(-1,1)$, by the high velocity of propagation of the solutions, and by the accumulation of high order terms in the asymptotic expansion. In fact, we can observe that the enlargement of the space domain up to $(-6,6)$ seems to fix the problem, and the localization of the solution along the rays appears once again (see Video 3). This, in our opinion, justifies our interpretation of the phenomenon.</p>

<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_6.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_6.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
<p>Video 3. Propagation of the solution for $s=0.9$ on the space interval $(-6,6)$.</p>

<!--
[video width="570" height="450" mp4="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_6.mp4"][/video]

[caption id="attachment_8518" align="aligncenter" width="300"]<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger1_09_6.png" alt="plot_frac_schrodinger1_09_6" width="300" height="235" class="size-full wp-image-8518" /> Figure 3.a Propagation of the solution for $s=0.9$ on the space interval $(-6,6)$.

[caption id="attachment_8522" align="aligncenter" width="300"]<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger2_09_6.png" alt="plot_frac_schrodinger2_09_6" width="300" height="235" class="size-full wp-image-8522" /> Figure 3.b Propagation of the solution for $s=0.9$ on the space interval $(-6,6)$.
-->

<h3>Bibliography</h3>

<p><strong><a name="ref1">[1]</a></strong> Bardos, C., Lebeau, G., and Rauch, J. <a name="cite1" target="_blank"></a>Sharp sufficient conditions for the observation, control, and stabilization of waves from the boundary. <em>SIAM J. Control Optim. 30, 5 (1992), 1024–1065.</em></p>

<p><strong><a name="ref2">[2]</a></strong> Biccari, U. <a href="https://cmc.deusto.eus/internal-control-for-non-local/" target="_blank">Internal control for non-local Schrödinger and wave equations involving the fractional Laplace operator.</a> <em>ESAIM: COCV: to appear. (2018).</em></p>

<p><strong><a name="ref3">[3]</a></strong> Biccari, U., and Aceves, A. B. <a href="https://cmc.deusto.eus/wkb-expansion-for-a-fractional-schr%c2%a8odinger-equation-with-applications-to-controllability/" target="_blank">WKB expansion for a fractional Schröodinger equation with applications to controllability.</a> <em>Submitted. (2018).</em></p>

<p><strong><a name="ref4">[4]</a></strong> Biccari,U., and Hernández-Santamaría, V. <a href="https://cmc.deusto.eus/controllability-of-a-one-dimensional-fractional-heat-equation-theoretical-and-numerical-aspects/" target="_blank">Controllability of a one-dimensional fractional heat equation: theoretical and numerical aspects.</a> <em>HAL Preprint - hal-01562358. (2017).</em></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;In this work, we address the optimal control of parameter-dependent systems. We introduce the notion of averaged control in which the quantity of interest is the average of the states with respect to the parameter family&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">\mathcal{K}= \left\{ \nu_i \in \mathbb{R}, \enspace 1\leq i \leq K \right\}</script>

<p>More precisely, we are interested in solving the next minimization problem:</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:costFunctional}
\min _{u \in L^2(0,T)} \mathcal{J}\left( u\right) = 
\min _{u \in L^2(0,T)} \frac{1}{2} \left[ \frac{1}{K} \sum_{\nu \in \mathcal{K}} x \left( T, \nu \right) - \bar{x} \right]^2  + 
\frac{\beta}{2} \int_0^T u^2 \mathrm{d}t \quad \beta \in \mathbb{R}^+
\end{equation}</script>

<p>Where $\mathcal{U}_{ad}$ is the space of admissible controls and $\bar{x}$ the average state target. The optimization problem (\ref{eq:costFunctional}) is subject to the finite dimensional linear control system</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align} \label{eq:primalODE}
\left\{
\begin{array}{ll}
x^\prime \left( t \right) = A \left( \nu \right) x \left( t \right) + B \left( \nu \right) u \left( t \right), \quad 0 < t <T, \\
x\left( 0 \right) = x^0.
\end{array}
\right.
\end{align} %]]></script>

<p>In (\ref{eq:primalODE}), the vector valued function $ x \left( t, \nu \right) \in \mathbb{R}^N$ is the state of the system, $A \left( \nu \right)$ is a $N \times N$-matrix governing its free dynamics and $u=u\left( t \right) \in \mathbb{R}^M $ is a $M$-component control, with $M \leq N$, entering and acting on the system through the control operator $B\left( \nu \right)$, a $N \times M$ parameter-dependent matrix. Moreover, the initial datum $x^0 \in \mathbb{R}^N$ to be controlled is independent of the parameter $\nu$, but the state of the system itself $x \left( t, \nu \right)$ depends on $\nu$. The effective value of the parameter $\nu$ being unknown, we aim at choosing a control that would perform optimally in an averaged sense, this is, rather than controlling specific realizations of the state, the average with respect to $\nu$ is controlled. This allows building a control independent of the parameter and making a robust compromise of all the possible realizations of the system for the various possible values of the unknown parameter $\nu$</p>

<p>We use the classical gradient descent method based on the adjoint methodology, and obtain the corresponding adjoint system for (\ref{eq:primalODE}),</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\left\{
\begin{array}{ll}
p^\prime \left( t \right) = -A \left( \nu \right) p \left( t \right), \quad 0 < t <T, \\
\displaystyle p\left( T \right) = - \left[ \frac{1}{K} \sum_{\nu \in \mathcal{K}} x \left( T, \nu \right) - \bar{x} \right].
\end{array}
\right.
\end{align} %]]></script>

<p>To minimize the functional in (\ref{eq:costFunctional}), we take the steepest descent direction given by</p>

<script type="math/tex; mode=display">\begin{equation}
J^\prime \left[ u^{\left( k \right)} \right] = \beta u^{\left( k \right)}\left( t \right) - \frac{1}{K} \sum_{\nu \in \mathcal{K}} B^t \left( \nu \right) p^{\left( k \right)} \left( t, \nu \right)
\end{equation}</script>

<p>Hence, the new control reads as</p>

<script type="math/tex; mode=display">\begin{equation}
u^{\left( k+1 \right)} = u^{\left( k \right)} - \gamma J^\prime \left[ u^{\left( k \right)} \right]
\end{equation}</script>

<p>for some $\gamma$ small enough.</p>

<p>We have also used the conjugate gradient method in order to reach faster the optimal control. In order to be able to apply this method the state vector has been split as</p>

<script type="math/tex; mode=display">\begin{equation}
x\left( t \right) = z_u \left( t \right) + y\left( t \right),
\end{equation}</script>

<p>where $z_u$ is the solution to the controlled system with zero initial condition,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\left\{
\begin{array}{ll}
z^\prime_u \left( t \right) = A \left( \nu \right) z_u \left( t \right) + B \left( \nu \right) u \left( t \right), \quad 0 < t <T, \\
z_u{\left( 0 \right)} = 0,
\end{array}
\right.
\end{align} %]]></script>

<p>and $y$ solves the free dynamics problem,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\left\{
\begin{array}{ll}
y^\prime \left( t \right) = A \left( \nu \right) y \left( t \right), \quad 0 < t <T, \\
y{\left( 0 \right)} = x^0.
\end{array}
\right.
\end{align} %]]></script>

<p>The functional in \ref{eq:costFunctional} can be expressed as</p>

<script type="math/tex; mode=display">\begin{equation}
J\left( u \right) = \frac{1}{2}\left( \bar{z}_u\left(T\right) + \bar{y} \left( T \right) - \bar{x}, \bar{z}_u\left(T\right) + \bar{y} \left( T \right) - \bar{x} \right)_{\displaystyle \mathbb{R}^n} + \frac{\beta}{2} \left(u, u\right)_{L^2\left(\left[0,T\right]\right)}
\end{equation}</script>

<p>We introduce the linear operator</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}
\begin{split}
\Lambda: L^2 \left( [0, T] \right) & \rightarrow \mathbb{R}^n \\
u & \rightarrow \bar{z}_u \left( T \right) = \frac{1}{K} \sum_{\nu \in \mathcal{K}} z_u \left( T, \nu \right)
\end{split}
\end{equation} %]]></script>

<p>and its dual counterpart,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}
\begin{split}
\Lambda^*: \mathbb{R}^n & \rightarrow L^2 \left( [0, T] \right) \\
p_T & \rightarrow  - \frac{1}{K} \sum_{\nu \in \mathcal{K}} B^t \left( \nu \right) p \left( t, \nu \right)
\end{split}
\end{equation} %]]></script>

<p>where $p\left(t, \nu\right)$ is solution to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\left\{
\begin{array}{ll}
{p}' \left( t \right) = -A \left( \nu \right) p \left( t \right), \quad 0 < t <T, \\
p{\left( T \right)} = - p_T.
\end{array}
\right.
\end{align} %]]></script>

<p>By doing this we can write the functional gradient as</p>

<script type="math/tex; mode=display">\begin{equation}
J^\prime\left( u \right) \delta u = \left( \underbrace{\left( \Lambda^* \Lambda + \beta I \right)}_{=A_{cg}} u - \underbrace{\Lambda^*\left( \bar{x} - \bar{y} \left( T \right) \right)}_{=b_{cg}}, \delta u \right)_{L^2\left(\left[0,T\right]\right)}.
\end{equation}</script>

<p>After having defined $A_{cg}$ and $b_{cg}$ we can apply the conjugate gradient method to solve the control problem.</p>

<h6><b>Algorithm 1</b> Optimal control with Conjugate Gradient Method</h6>
<p><b>Require:</b> $A\left( \nu \right)$, $B\left( \nu \right)$, $x^0$, $u^{\left(0\right)}$, $\beta$, $T$, $\bar{x}$, $tol$</p>
<ol>
<li>$n \gets 0 $</li>
<li> compute $\bar{y} \left( T \right)$</li>
<li> $b \gets \Lambda^*\left( \bar{x} - \bar{y} \left( T \right) \right)$</li>
<li> $z \gets \Lambda u$</li>
<li> $g \gets \Lambda^*z + \beta u - b$</li>
<li> $h \gets ||g||^2_{L^2\left(\left[0,T\right]\right)}$</li>
<li> $h_a \gets h$</li>
<li> $r \gets -g$</li>
<li><b>While</b> $||r||_{L^2\left(\left[0,T\right]\right)} &gt; tol $ <b>do</b></li>
<li>  &emsp; &emsp;    $z \gets \Lambda r$</li>
<li>  &emsp; &emsp;    $w \gets \Lambda^*z + \beta r$</li>
<li>  &emsp; &emsp;    $\alpha \gets \frac{h}{\left(r,w\right)_{L^2\left(\left[0,T\right]\right)}}$</li>
<li>  &emsp; &emsp;    $u \gets u + \alpha r$</li>
<li>  &emsp; &emsp;    $g \gets g + \alpha w$</li>
<li>  &emsp; &emsp;    $h_a \gets h$</li>
<li>  &emsp; &emsp;    $h \gets ||g||^2_{L^2\left(\left[0,T\right]\right)}$</li>
<li>  &emsp; &emsp;    $\gamma \gets \frac{h}{h_a}$</li>
<li>  &emsp; &emsp;    $r \gets -g + \gamma r$</li>
<li>  &emsp; &emsp;    $n \gets n + 1$</li>
</ol>
<p><img src="http://cmc.deusto.eus/wp-content/uploads/2018/03/xav.png" alt="figure1a" width="560" height="420" class="aligncenter size-full wp-image-8114" /><i align="aligncenter">Figure 1.a: Control system with $N=3$, $M=1$ and target average state $\bar{x}=[0,0,0]^t$. Average state vector components.</i></p>

<p><img src="http://cmc.deusto.eus/wp-content/uploads/2018/03/u.png" alt="figure1b" width="560" height="420" class="aligncenter size-full wp-image-8114" /><i align="aligncenter">Figure 1.b: Control system with $N=3$, $M=1$ and target average state $\bar{x}=[0,0,0]^t$. Control.</i></p>

<p><img src="http://cmc.deusto.eus/wp-content/uploads/2018/03/xi-1024x548.png" alt="figure1b" width="648" height="347" class="aligncenter size-large wp-image-8118" /><i align="aligncenter">Figure 2: State vector components for every parameter $\nu_i$. One can observe that the final state $x\left(T, \nu_i \right)$ is not close to $\bar{x}=[0,0,0]^t$ in general.</i></p>

<h2>Bibliography</h2>

<p><strong>[1]</strong> E. Zuazua (2014) <a href="http://verso.mat.uam.es/web/ezuazua/documentos_public/archivos/publicaciones/averaged-zuazua7.pdf" target="_blank"><em>Averaged Control.</em></a> Automatica, 50 (12), p. 3077-3087.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h4&gt;1 Introduction&lt;/h4&gt;
</code></pre></div></div>

<p>In the post <a href="https://cmc.deusto.eus/how-to-use-ipopt-and-ampl-to-solve-time-optimal-control-problems" target="_blank">IpOpt and AMPL use to solve time optimal control problems</a>, we explain how to use <a href="https://projects.coin-or.org/Ipopt" target="_blank"><i>IpOpt</i></a> and <a href="https://ampl.com/products/ampl/" target="_blank"><i>AMPL</i></a> in order to solve control problems with control constraints and possibly some state constraints.</p>

<p>In the present post, we are going to present a numerical development in order to find the minimal controllability time for the discretized heat equation with unilateral (non-negative) control constraint. More precisely, we consider the controllability of a discretized version of the 1D heat equation under nonnegative Dirichlet control constraint. The infinite dimensional system, we consider is</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}
	\dot{\psi}(t,x) = \partial_x^2 \psi(t,x)              &&              ( t>0,\, x\in(0,1)),\\
	\partial_x\psi(t,0) = 0            &&          (t>0),\\
	\psi(t,1) = u(t)            &&          (t>0),\\
	\psi(0,x) = \psi^0(x)            &&          (x\in(0,1)),\\
	\end{array} %]]></script>

<p>where $\psi$ is the state to control $\psi^0$ the initial state and $u$ the Dirichlet control.
The continuous version of this problem has been analysed in <a href="https://cmc.deusto.eus/control-of-the-semi-discrete-1d-heat-equation-under-nonnegative-control-constraint#ref2">[2]</a> and it has been shown that for every initial state $\psi^0\in L^2(0,1)$ and every positive constant target $\psi^1$, the controllability of this system under the control constraint
\begin{equation}\label{eq:ContConst}
	u(t)\geqslant0 (t\geqslant 0),
\end{equation}
requires a positive waiting time as soon as the target state $\psi^1$ is different from the initial state $\psi^0$.</p>

<p>In this post, we consider a spatially discretized version with has the form</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:SysGen}
	\dot{y}(t)=Ay(t)+B u(t) (t>0),
\end{equation}</script>

<p>where the matrices $A$ and $B$ are</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{eq:ABheat}
	A=(n+1)^2\begin{pmatrix}
		-2		& 2			& 0			& \hdots& \hdots& 0\\
		1			& -2		& 1			& 0			& \hdots& 0\\
		0			& \ddots& \ddots& \ddots&	\ddots& \vdots\\
		\vdots& \ddots& \ddots& \ddots& \ddots& 0\\
		\vdots&				& \ddots& \ddots& \ddots& 1\\
		0			&	\hdots&	\hdots&	0			& 1			& -2
	\end{pmatrix}\in M_{n}(\mathbb{R})\quad\text{and}\quad B=(n+1)^2\begin{pmatrix}
		0\\
		\vdots\\
		\vdots\\
		\vdots\\
		0\\
		1
	\end{pmatrix}\in M_{n,1}(\mathbb{R}).
\end{equation} %]]></script>

<p>where $n+1&gt;2$ is the number of discretization points and $[y]_i(t)$ (the $i^\text{th}$ component of $y(t)\in\mathbb{R}^n$) stands for $\psi(t,(i-1)/n)$.
To obtain the above finite dimensional system, we have used centred finite differences.</p>

<p>The aim is then to minimize the time $T$ such that there exist a control $u:[0,T]\to\mathbb{R}_+$ steering the solution of (\ref{eq:SysGen}) from $y^0\in\mathbb{R}^n$ to $y^1\in\mathbb{R}^n$ in time $T$. For the sake of simplicity, we assume that $y^0$ and $y^1$ are constant vectors of $\mathbb{R}^n$, that is to say that</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:y0y1}
	y^0=u^0\begin{pmatrix}1\\\vdots\\1\end{pmatrix}\in\mathbb{R}^n\quad\text{ and }\quad y^1=u^1\begin{pmatrix}1\\\vdots\\1\end{pmatrix}\in\mathbb{R}^n,
\end{equation}</script>

<p>for some $u^0\in\mathbb{R}$ and $u^1\in\mathbb{R}$ Since the control $u$ shall satisfy the constraint (\ref{eq:ContConst}), it is easy to see, using a discrete version of the comparison principle, that in order to have the existence of a solution, then we need $u^1&gt;0$.
Note that, using again the comparison principle, we can also show that if $u^0\geqslant 0$ then, whatever the control $u\geqslant 0$ is, the solution of (\ref{eq:SysGen}) always satisfies $y(t)\geqslant 0$.</p>

<p>To conclude, the optimization problem we aim to solve is</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{eq:optim0}
	\begin{array}{cl}
		\inf & T\\
		 & \begin{array}{l}
			T\geqslant 0,\\
			y(T;u;y^0)=y^1,\\
			u\in L^\infty(0,T),\quad u(t)\geqslant 0\quad (t\in[0,T]\text{ a.e.}),
		\end{array}
	\end{array}
\end{equation} %]]></script>

<p>where $y^0$ and $y^1$ are given by (\ref{eq:y0y1}) for some $u^0\in\mathbb{R}$ and $u^1\in\mathbb{R}_+^*$, and where $y(t;u;y^0)$ stands for the solution of (\ref{eq:SysGen}) at time $t$, with control $u$ and initial condition $y^0$.</p>

<p>In this post, in order to find numerically the minimal controllability time and a time-optimal control, we are going to use the abstract result presented in the next paragraph. Another way could be to introduce, in addition to the control constraint $u(t)\geqslant 0$, the additional control constraint $u(t)\leqslant M$, and let $M$ increase to $+\infty$. Such an approach has been introduced in the previous post <a href="https://cmc.deusto.eus/how-to-use-ipopt-and-ampl-to-solve-time-optimal-control-problems/" target="_blank">IpOpt and AMPL use to solve time optimal control problems</a>.</p>

<h4>2 Abstract result</h4>

<p>It is shown in <a href="https://cmc.deusto.eus/control-of-the-semi-discrete-1d-heat-equation-under-nonnegative-control-constraint/#ref1">[1]</a> that at the minimal time $\underline{T}(y^0,y^1)$, defined by (\ref{eq:optim0}), there exists a non-negative control $u$ in the class of Radon measure.
Furthermore, it is proved in this article that at the minimal controllability time, there exists one and only one non-negative Radon measure and this time optimal control is a convex sum of at most $\lfloor (n+1)/2 \rfloor$ Dirac masses.
In other words, the non-negative time optimal control takes the form:</p>

<script type="math/tex; mode=display">u=\sum_{k=1}^N\alpha_k\delta_{t_k},</script>

<p>with $N=\lfloor (n+1)/2 \rfloor$, $0\leqslant \alpha_k$ and $0\leqslant t_1\leqslant\dots\leqslant t_N\leqslant T$.
For a control of this form, the solution of (\ref{eq:SysGen}) at time $T$, with initial condition $y^0$, is:</p>

<script type="math/tex; mode=display">y(T)=e^{TA}y^0+\sum_{k=1}^N \alpha_i e^{(T-t_k)A}B.</script>

<p>Consequently, the minimal time $\underline{T}(y^0,y^1)$ given by (\ref{eq:optim0}) is a minimizer of:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{eq:optim1}
	\begin{array}{cl}
		\inf & T \\
		 & \begin{array}{l}
			0\leqslant t_1\leqslant\dots\leqslant t_N\leqslant T, \\
			\alpha_1,\dots,\alpha_N\geqslant 0, \\
			\displaystyle{y^1-e^{TA}y^0=\sum_{k=1}^N \alpha_k e^{(T-t_k)A}B}.
		\end{array}
	\end{array}
\end{equation} %]]></script>

<h4>3 Numerical implementation</h4>

<p>The optimization problem (\ref{eq:optim1}) is not easy to solve directly, mainly because of the presence of a matrix exponential.
Thus, instead we will solve the discretized heat equation on each time interval $(t_k,t_{k+1})$, with $t_0=0$ and $t_{N+1}=T$.
Let us then set $\tau_k=t_{k+1}-t_k$ for every $k\in{0,\dots,N}$.
We have $T=\sum_{k=0}^N\tau_k$ and the optimization problem (\ref{eq:optim1}) also writes</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{cl}
		\inf & \displaystyle{\sum_{k=0}^N\tau_k} \\
		 & \begin{array}{l}
			0\leqslant \tau_k (k\in\{0,\dots,N\}),\\
			0\leqslant \alpha_k (k\in\{1,\dots,N\}),\\
			y_0(0)=y^0,\\
			y_{k+1}(0)=y_k(\tau_k)+\alpha_{k+1}B(k\in\{0,\dots,N-1\}),\\
			y_{N}(\tau_N)=y^1,\\
			\text{~ where $y_k(t)=e^{tA}y_k(0)$, i.e.~$y_k$ is solution of (2) with null control.}
		\end{array}
	\end{array} %]]></script>

<p>In the above constraints, $y_k(\tau)=y(\tau+t_k)$ for every $\tau\in(0,\tau_k)$, where $y$ is the solution of (\ref{eq:SysGen}), with control $u=\sum_{k=1}^N\alpha_k\delta_{t_k}$ and initial condition $y(0)=y^0$. Notice that since $\alpha_k$ is only constrained to be non-negative, and since the vector $B$ (given by (\ref{eq:ABheat})) is of the form $(0,\dots,0,b_n)^\top$, with $b_n\geqslant 0$, the constraint $y_{k+1}(0)=y_k(\tau_k)+\alpha_{k+1}B$ can be expressed as</p>

<script type="math/tex; mode=display">\begin{equation*}
	[y_{k+1}]_n(0)\geqslant [y_k]_n(\tau_k)
	\text{and}
	[y_{k+1}]_i(0)=[y_k]_i(\tau_k) (i\in\{1,\dots,n-1\}).
\end{equation*}</script>

<p>Consequently, the parameters $\alpha_1,\dots,\alpha_N$ can be forgotten.</p>

<p>In order to numerically compute $y_k(t)=e^{tA}y_k(0)$ for $t\in[0,\tau_k]$, we are going to use the Crank-Nicholson method.
More precisely, given $N_t\in\mathbb{N}^*$, we approximate $y_k(j\tau_k/N_t)$ by $y_k^j$, with $y_k^j$ solution of</p>

<script type="math/tex; mode=display">y_k^0=y_k(0), \left( \mathrm{I}_n-\frac{\tau_k}{2N_t}A \right)y_k^{j+1}=\left( \mathrm{I}_n+\frac{\tau_k}{2N_t}A \right)y_k^j (j\in\{0,\dots,N_t-1\})</script>

<p>All in all, the fully discretized optimization problem, is</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:optD1}
		\min\ \sum_{k=0}^N \tau_k,
	\end{equation}</script>

<p>subject to the constraints</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
		\label{eq:optD2}
		& 0\leqslant \tau_k (k\in\{0,\dots,N\}),\\
	\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
		\label{eq:optD3}
		& [y_0^0]_i=u^0 (i\in\{1,\dots,n\}),\\
	\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
		\label{eq:optD4}
		& [y_{k+1}^0]_j=[y_k^{N_t}]_j(k\in\{0,\dots,N-1\},\ j\in\{1,\dots,n\}),\\
	\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
		\label{eq:optD5}
		& [y_{k+1}^0]_n\geqslant [y_k^{N_t}]_n(k\in\{0,\dots,N-1\}),\\
	\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
		\label{eq:optD6}
		& \max_{i\in\{1,\dots,n\}}\left|[y_{N}^{N_t}]_i-u^1\right|\leqslant \varepsilon,\\
	\end{align} %]]></script>

<script type="math/tex; mode=display">\begin{align}
		\label{eq:optD7}
		 \left( \mathrm{I}_n-\frac{\tau_k}{2N_t}A \right)y_k^{j+1}=\left( \mathrm{I}_n+\frac{\tau_k}{2N_t}A \right)y_k^j (k\in\{0,\dots,N\},\ j\in\{0,\dots,N_t-1\}).
	\end{align}</script>

<p>Note that instead of imposing $[y_{N}^{N_t}]_i=u^1$, we chose to relax this condition in the constraint (\ref{eq:optD6}).
This choice has been a maid since we do not expect that the numerical solution exactly reaches the target $y^1$. In practice, we will take, $\varepsilon=1/(n\, N_t)$.</p>

<p>In term of <i>AMPL</i> language, the above constrained optimization problem is</p>

<pre>
<span style="color: green;"># define parameters</span>
<b>param</b> n  = 20;             <span style="color: green;"># number of spatial discretization points</span>
<b>param</b> Nt = 400;            <span style="color: green;"># number of time discretization points</span>
<b>param</b> N  = floor((n+1)/2); <span style="color: green;"># maximal number of control impulses</span>
<b>param</b> eps= 1/(n*Nt);       <span style="color: green;"># relaxation parameter $\varepsilon}$ in (\ref{eq:optD6})</span>
<b>param</b> u0 = 1;              <span style="color: green;"># parameters $u^0\text{ and }u^1}$, see (\ref{eq:y0y1})</span>
<b>param</b> u1 = 5;

<span style="color: green;"># define variables</span>
<b>var</b> y	  {k in 0..N, j in 0..Nt, i in 1..n};	<span style="color: green;"># unknowns $[y_k^j]_i$</span>
<b>var</b> tau {k in 0..N} &gt;=0;   <span style="color: green;"># unknown impulse times $\tau_k}$ subject to (\ref{eq:optD2})</span>

<span style="color: green;"># objective function, see (\ref{eq:optD1})</span>
<b>minimize</b> T:
	sum {k in 0..N} tau[k];

<span style="color: green;"># define the constraints</span>
<span style="color: green;"># constraint (\ref{eq:optD7}) for interior points</span>
<b>subject to</b> y_dyn {k in 0..N, j in 1..Nt, i in 2..n-1}:
	y[k,j,i]-y[k,j-1,i] =
		(n+1)^2*(y[k,j,i-1]-2*y[k,j,i]+y[k,j,i+1]
                +y[k,j-1,i-1]-2*y[k,j-1,i]+y[k,j-1,i+1])/2*tau[k]/Nt;
<span style="color: green;"># constraint (\ref{eq:optD7}) for i=n</span>
<b>subject to</b> y_dyn_Dirichlet {k in 0..N, j in 1..Nt}:
	y[k,j,n]-y[k,j-1,n] =
		(n+1)^2*(y[k,j,n-1]-2*y[k,j,n]+y[k,j-1,n-1]-2*y[k,j-1,n])/2*tau[k]/Nt;
<span style="color: green;"># constraint (\ref{eq:optD7}) for i=1</span>
<b>subject to</b> y_dyn_Neuman {k in 0..N, j in 1..Nt}:
	y[k,j,1]-y[k,j-1,1] =
		(n+1)^2*(y[k,j,2]-y[k,j,1]+y[k,j-1,2]-y[k,j-1,1])/2*tau[k]/Nt;
<span style="color: green;"># initial condition, constraint (\ref{eq:optD3})</span>
<b>subject to</b> y_init {i in 1..n}:
	y[0,0,i] = u0;
<span style="color: green;"># terminal condition, constraint (\ref{eq:optD6})</span>
<b>subject to</b> y_end1 {i in 1..n}:
	y[N,Nt,i] &gt;= u1-eps;
<b>subject to</b> y_end2 {i in 1..n}:
	y[N,Nt,i] &lt;= u1+eps;
<span style="color: green;"># constraint (\ref{eq:optD4})</span>
<b>subject to</b> continuity {k in 0..N-1, i in 1..n-1}:
	y[k+1,0,i]=y[k,Nt,i];
<span style="color: green;"># constraint (\ref{eq:optD5})</span>
<b>subject to</b> jump {k in 0..N-1}:
	y[k+1,0,n]&gt;=y[k,Nt,n];

<span style="color: green;"># solve the problem with IpOpt</span>
<b>option</b> solver ipopt;
<b>option</b> ipopt_options <span style="color: brown;">"max_iter=100000 linear_solver=mumps halt_on_ampl_error yes"</span>;
<b>solve</b>;

<span style="color: green;"># display parameters and solution</span>
<b>printf</b>: <span style="color: brown;">"u0 = %24.16e\n"</span>, u0;
<b>printf</b>: <span style="color: brown;">"u1 = %24.16e\n"</span>, u1;
<b>printf</b>: <span style="color: brown;">"T  = %24.16e\n"</span>, T;
<b>printf</b>: <span style="color: brown;">"n  = %d\n"</span>, n;
<b>printf</b>: <span style="color: brown;">"Nt = %d\n"</span>, Nt;
<b>printf</b>: <span style="color: brown;">"N  = %d\n"</span>, N;
<b>printf</b>: "Data\n";
<b>printf</b>: <span style="color: brown;">"t_k ="</span>;
<b>printf</b> {k in 0..N}:  <span style="color: brown;">" %24.16e\t"</span>, tau[k];
<b>printf</b>: <span style="color: brown;">"\n"</span>;
<b>printf</b>: <span style="color: brown;">"y =\n"</span>;
for {k in 0..N} {
	<b>printf</b> <span style="color: brown;">"k = %d\n"</span>, k;
	<b>printf</b> {j in 0..Nt, i in 1..n}: <span style="color: brown;">" %24.16e\n"</span>, y[k,j,i];
}
<b>end</b>;
<span style="color: green;"># quit AMPL</span>										
</pre>

<p>In the following simulations, we take n=20 and N_t=400. By post-treatment of the results (see the <a href="https://cmc.deusto.eus/how-to-use-ipopt-and-ampl-to-solve-time-optimal-control-problems/#scilab" target="_blank"><i>Scilab</i></a> file in the post <a href="https://cmc.deusto.eus/how-to-use-ipopt-and-ampl-to-solve-time-optimal-control-problems/" target="_blank">IpOpt and AMPL use to solve time optimal control problems</a> for an example), we obtain the following results:</p>
<ul>
<a name="D15"></a>
	<li>for $u^0=1$ and $u^1=5$: The minimal time obtained is $\mathtt{0.1689856}$.
<!--The control and state trajectories are displayed on Figures 1, 2 and 3.
		https://mycore.core-cloud.net/index.php/s/HzcsSlb4BZnZmpX-->
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/03/D15.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/03/D15.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
</li>
<a name="D51"></a>
	<li>for $u^0=5$ and $u^1=1$: The minimal time obtained is $\mathtt{0.7267605}$.
<!--The control and state trajectories are displayed on Figures 4, 5 and 6.
		https://mycore.core-cloud.net/index.php/s/luuWR99kvVIILQZ-->
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/03/D51.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/03/D51.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
</li>
</ul>

<p>In the above videos, red arrows correspond to Dirac masses in the control.</p>

<h4>References</h4>
<p><strong><a name="ref1">[1]</a></strong> J. Lohéac, E. Trélat, and E. Zuazua. <a name="cite1" target="_blank"></a><em>Control of the semi-discrete 1D heat equation under nonnegative control constraint.</em> In preparation.</p>

<p><strong><a name="ref2">[2]</a></strong> J. Lohéac, E. Trélat, and E. Zuazua. <a name="cite2" target="_blank"></a><em>Minimal controllability time for the heat equation under state constraints.</em> Mathematical Models and Methods in Applied Sciences, Volume 27, Issue 09, August 2017</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h5&gt;A Matlab guide for the numerical approximation of the exact control and stabilization of the wave equation&lt;/h5&gt;
</code></pre></div></div>

<p>This webpage contains a free software to compute the control of the wave equation with Matlab.</p>

<h5>Features</h5>

<p>With wave control you can explore the following:</p>

<ul>
<li>Exact control of the 1-d wave equation with finite differences and mixed finite elements when the control acts in one extreme.</li>
<li>Exact control of the 2-d wave equation with finite differences and mixed finite elements when the control acts in the boundary.</li>
<li>The stabilization of the 1-D wave equation in an interval with a damping acting on an internal subset, discretized with finite differences and numerical viscosity.</li>
<li>The stabilization of the 2-D wave equation in a square with a damping acting on an internal set, discretized with finite differences and numerical viscosity.</li>
</ul>

<p>Some views are given below,</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol1.jpg" alt="figure1" class="post-photo-graphic" /><br /><i>Figure 1</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol2.jpg" alt="figure2" class="post-photo-graphic" /><br /><i>Figure 2</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol3.jpg" alt="figure3" class="post-photo-graphic" /><br /><i>Figure 3</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol4.jpg" alt="figure4" class="post-photo-graphic" /><br /><i class="aligncenter">Figure 4</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol5.jpg" alt="figure5" class="post-photo-graphic" /><br /><i>Figure 5</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol6.jpg" alt="figure6" class="post-photo-graphic" /><br /><i>Figure 6</i></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3&gt;The problems considered&lt;/h3&gt;
</code></pre></div></div>

<p>We obtain a finite element (FE) scheme for the numerical approximation of the solution to the following non-local Poisson equation</p>

<script type="math/tex; mode=display">\begin{align}
\begin{cases}
\ffl{s}{u} = f, \quad  x\in(-L,L)
\\
u\equiv 0,  x\in\RR\setminus(-L,L).
\end{cases}
\end{align}</script>

<p>In (1), $f$ is a given function and, for all $s\in(0,1)$, $\ffl{s}{}$ denotes the one-dimensional fractional Laplace operator, which is defined as the following singular integral</p>

<script type="math/tex; mode=display">\begin{align}\label{fl}
\ffl{s}{u}(x) = \ccs\,P.V.\,\int_{\RR}\frac{u(x)-u(y)}{|x-y|^{1+2s} }\,dy.
\end{align}</script>

<p>Here, $\ccs$ is an explicit normalization constant.</p>

<p>The main novelty of this work relies on the fact that, since we are dealing with a one-dimensional problem, each entry of the stiffness matrix can be computed explicitly, without requiring numerical integration, which is instead needed for the multidimensional case (see <a href="#acosta2017short">[1]</a>). This has the great advantage of reducing the computational cost and allows to be used on more general applications.</p>

<p>A natural example is given by the numerical resolution of the following control problem: given any $T&gt;0$, find a control function $g\in L^2((-1,1)\times(0,T))$ such that the corresponding solution to the parabolic problem</p>

<script type="math/tex; mode=display">\begin{align}
\begin{cases}
z_t + \ffl{s}{z} = g\mathbf{1}_{\omega},\quad  (x,t)\in (-1,1)\times(0,T)
\\
z=0,  (x,t)\in[\,\RR\setminus (-1,1)\,]\times(0,T)
\\
z(x,0)=z_0(x),  x\in (-1,1)
\end{cases}
\end{align}</script>

<p>satisfies $z(x,T)=0$.</p>

<p>The approach emploied for solving this control problem is based on the penalized Hilbert Uniqueness Method (<a href="#boyer2013penalised">[2]</a>).</p>
<h3>Preliminary results</h3>
<h4>Variational formulation of the elliptic problem</h4>
<p>Find $u\in H^s_0(-L,L)$ such that</p>

<script type="math/tex; mode=display">\begin{align*}
\frac{\ccs}{2} \int_{\RR}\int_{\RR}\frac{(u(x)-u(y))(v(x)-v(y))}{|x-y|^{1+2s} }\,dxdy = \int_{-L}^L fv\,dx,
\end{align*}</script>

<p>for all $v\in H_0^s(-L,L)$. Here, $H^s_0(-L,L)$ denotes the space</p>

<script type="math/tex; mode=display">\begin{align*}
H^s_0(-L,L) :=\Big\{\, u\in H^s(\RR)\,:\,u=0 \textrm{ in } \RR\setminus(-L,L)\,\Big\},
\end{align*}</script>

<p>while $H^s(\RR)$ is the classical fractional Sobolev space of order <em>s</em>. Since the bilinear form <em>a</em> is continuous and coercive, Lax-Milgram Theorem immediately implies that, if $f\in H^{-s}(-L,L)$, the dual space of $H^s_0(-L,L)$, then (1) admits a unique weak solution $u\in H_0^s(-L,L)$.</p>
<h4>Parabolic problem</h4>
<p><strong>Definition 1.</strong> <em>System (3) is said to be <u>null-controllable</u> at time $T$ if, for any $z_0\in L^2(-1,1)$, there exists $g\in L^2((-1,1)\times(0,T))$ such that the corresponding solution $z$ satisfies</em></p>

<script type="math/tex; mode=display">\begin{align*}
z(x,T)=0.
\end{align*}</script>

<p><strong>Definition 2.</strong> <em>System (3) is said to be <u>approximately controllable</u> at time $T$ if, for any $z_0,z_T\in L^2(-1,1)$ and any $\delta&gt;0$, there exists $g\in L^2((-1,1)\times(0,T))$ such that the corresponding solution $z$ satisfies </em></p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}

\renewcommand{\norm}[2]{ {\left\|#1\right\|}_{#2} }

\norm{z(x,T)-z_T}{L^2(-1,1)}<\delta.
\end{align*} %]]></script>

<p>There are few results in the literature on the null-controllability of the fractional heat equation, and they all deal with the <em>spectral</em> definition of the fractional Laplace operator, which is introduced, e.g., in <a href="#micu2006controllability">[3]</a>,<a href="#miller2006controllability">[4]</a>. In this framework, it is known that the fractional heat equation is null-controllable, provided that $s&gt;1/2$. For $s\leq 1/2$, instead, null controllability does not hold, not even for $T$ large.</p>

<p>However, also for the parabolic equation involving the integral fractional Laplacian (2), at least in the one space dimension, these properties are easily achievable. In more detail, we prove the following.</p>

<p><strong>Proposition 1.</strong> <em>For all $z_0\in L^2(-1,1)$ the parabolic problem (3) is null-controllable with a control function $g\in L^2(\omega\times(0,T))$ if and only if $s&gt;1/2$.
</em></p>

<p>Even if for $s\leq 1/2$ null controllability for (3) fails, we still have the following result of approximate controllability.</p>

<p><strong>Proposition 2.</strong> <em>Let $s\in(0,1)$. For all $z_0\in L^2(-1,1)$, there exists a control function $g\in L^2(\omega\times(0,T))$ such that the unique solution $z$ to the parabolic problem (3) is approximately controllable.
</em></p>
<h3>Development of the numerical scheme</h3>
<h4>Finite element approximation of the elliptic problem</h4>
<p>Let us introduce a partition of the interval $(-L,L)$ as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
-L = x_0<x_1<\ldots <x_i<x_{i+1}<\ldots<x_{N+1}=L\,, 
\end{align*} %]]></script>

<p>with $x_{i+1}=x_i+h$, $i=0,\ldots N$, $h&gt;0$. Having defined $K_i:=[x_i,x_{i+1}]$ we consider the discrete space</p>

<script type="math/tex; mode=display">\begin{align*}
V_h :=\Big\{v\in H_0^s(-L,L)\,\big|\, \left. v\,\right|_{K_i}\in \mathcal{P}^1\Big\},
\end{align*}</script>

<p>where $\mathcal{P}^1$ is the space of the continuous and piece-wise linear functions. If we indicate with</p>

<script type="math/tex; mode=display">\big\{\phi_i\big\}_{i=1}^N</script>

<p>the classical basis of $V_h$ in which each $\phi_i$ is the tent function with $supp(\phi_i)=(x_{i-1},x_{i+1})$ and verifying $\phi_i(x_j)=\delta_{i,j}$, at the end we are reduced to solve the linear system</p>

<script type="math/tex; mode=display">\begin{align*}
\mathcal A_h u=F,
\end{align*}</script>

<p>where the stiffness matrix $\mathcal A_h\in \RR^{N\times N}$ has components</p>

<script type="math/tex; mode=display">\begin{align}\label{stiffness_nc}
a_{i,j}=\frac{\ccs}{2} \int_{\RR}\int_{\RR}\frac{(\phi_i(x)-\phi_i(y))(\phi_j(x)-\phi_j(y))}{|x-y|^{1+2s} }\,dxdy, \;\;\; i,j = 1,\ldots,N,
\end{align}</script>

<p>while the vector $F\in\RR^N$ is given by $F=(F_1,\ldots,F_N)$ with</p>

<script type="math/tex; mode=display">\begin{align*}
F_i = \langle f,\phi_i\rangle = \int_{-L}^L f\phi_i\,dx,\;\;\; i=1,\ldots,N.
\end{align*}</script>

<p>The construction of the stiffness matrix $\mathcal A_h$ is done in three steps, since its elements can be computed differentiating among three well defined regions: the upper triangle, corresponding to indices $j\geq i+2$, the upper diagonal corresponding to $j=i+1$, and the diagonal corresponding to $j=i$. In each of these regions, the intersections among the support of the basis functions are different, thus generating different values of the bilinear form.</p>

<p>After several computations, we obtain the following expressions for the elements of the stiffness matrix $\mathcal{A}_h$: for $s\neq 1/2$</p>

<script type="math/tex; mode=display">\begin{align*}
a_{i,j} = -h^{1-2s} \begin{cases}
\displaystyle \,\frac{4(k+1)^{3-2s} + 4(k-1)^{3-2s}-6k^{3-2s}-(k+2)^{3-2s}-(k-2)^{3-2s} }{2s(1-2s)(1-s)(3-2s)},  \displaystyle k=j-i,\,k\geq 2
\\
\\
\displaystyle\frac{3^{3-2s}-2^{5-2s}+7}{2s(1-2s)(1-s)(3-2s)},  \displaystyle j=i+1
\\
\\
\displaystyle\frac{2^{3-2s}-4}{s(1-2s)(1-s)(3-2s)},  \displaystyle j=i.
\end{cases}
\end{align*}</script>

<p>For $s=1/2$, instead, we have</p>

<script type="math/tex; mode=display">\begin{align*}
a_{i,j} = \begin{cases}
-4(j-i+1)^2\log(j-i+1)-4(j-i-1)^2\log(j-i-1)
\\
\;\;\;+6(j-i)^2\log(j-i)+(j-i+2)^2\log(j-i+2)+(j-i-2)^2\log(j-i-2),  \displaystyle j> i+2
\\
\\
56\ln(2)-36\ln(3),  \displaystyle j= i+2.
\\
\\
\displaystyle 9\ln 3-16\ln 2,  \displaystyle j=i+1
\\
\\
\displaystyle 8\ln 2,  \displaystyle j=i.
\end{cases}
\end{align*}</script>

<h4>Control problem for the fractional heat equation</h4>
<p>We employ the so called penalised Hilbert Uniqueness Method (HUM) that deals with the resolution of the following minimization problem: find</p>

<script type="math/tex; mode=display">\begin{align}\label{min_je}
\varphi^T_\varepsilon=\min_{\varphi\in L^2(-1,1)} J_\varepsilon (\varphi^T)
\end{align}</script>

<p>where</p>

<script type="math/tex; mode=display">\begin{align}\label{penalized_fun}

\renewcommand{\norm}[2]{ {\left\|#1\right\|}_{#2} }

J_\varepsilon(\phi^T):=\frac{1}{2}\int_0^T\int_{\omega}|\varphi|^2\,dxdt + \frac{\varepsilon}{2}\norm{\varphi^T}{L^2(-1,1)}^2 + \int_{\Omega} z_0\varphi(0)\,dx,
\end{align}</script>

<p>where $\varphi$ is the solution to the adjoint problem</p>

<script type="math/tex; mode=display">\begin{align*}
\begin{cases}
-\varphi_t+\ffl{s}{\varphi}=0,  (x,t)\in (-1,1)\times(0,T)
\\
\varphi = 0,  (x,t)\in\big[\RR\setminus(-1,1)\big]\times(0,T)
\\
\varphi(x,T)=\varphi^T(x),  x\in (-1,1).
\end{cases}
\end{align*}</script>

<p>Then, the approximate and null controllability properties of the system, for a given initial datum $z_0$, can be expressed in terms of the behavior of the penalized HUM approach.</p>

<p>In particular, according to <a href="#boyer2013penalised">[2,Theorem 1.7]</a> we have:</p>

<ul>
 	<li style="list-style-type: none;">
<ul>
 	<li>The equation is approximately controllable at time $T$ from the initial datum $z_0$ if and only if</li>
</ul>
</li>
</ul>

<script type="math/tex; mode=display">\begin{align*}
\varphi_\varepsilon^T\rightarrow 0,\;\;\;\textrm{ as }\;\varepsilon\to 0.
\end{align*}</script>

<ul>
 	<li style="list-style-type: none;">
<ul>
 	<li>The equation is null-controllable at time $T$ from the initial datum $z_0$ if and only if</li>
</ul>
</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
M_{z_0}^2:=2\sup_{\varepsilon>0}\left( \inf_{L^2(0,T;L^2(\omega))}J_\varepsilon\right)<+\infty.
\end{align*} %]]></script>

<p>In this case, we have</p>

<script type="math/tex; mode=display">\begin{align*}

\renewcommand{\norm}[2]{ {\left\|#1\right\|}_{#2} }

\norm{g}{L^2(0,T;L^2(\omega))}\leq M_{z_0},\nonumber
\\
\norm{\varphi_\varepsilon^T}{L^2(-L,L)}\leq M_{z_0}\sqrt{\varepsilon}.
\end{align*}</script>

<h3>Numerical results</h3>
<p>Here, we present the numerical simulations corresponding to our algorithms. We provide a complete discussion of the results obtained.</p>

<p>First of all, in order to test numerically the accuracy of our method for the discretization of the elliptic equation (1) we use the following problem</p>

<script type="math/tex; mode=display">\begin{align}\label{PE_real}
\left\{\begin{array}{ll}
\ffl{s}{u} = 1,  x\in(-L,L)
\\
u\equiv 0,  x\in\RR\setminus(-L,L).
\end{array}\right.
\end{align}</script>

<p>In this particular case, the solution can be expressed as follows</p>

<script type="math/tex; mode=display">\begin{align}\label{real_sol}
u(x)=\frac{2^{-2s}\sqrt{\pi} }{\Gamma\left(\frac{1+2s}{2}\right)\Gamma(1+s)}\Big(L^2-x^2\Big)^s.
\end{align}</script>

<p>In figure 1 and figure 2, we show a comparison for different values of $s$ between the exact solution (8) and the computed numerical approximation. Here we consider $L=1$ and $N=50$. One can notice that, when $s=0.1$, the computed solution is to a certain extent different from the exact solution. However, one should be careful with such result and a more precise analysis of the error should be carried.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig1.jpg" alt="Figure 1" width="800" /> Figure 1: Plot for different values of $s&lt;1/2$.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig2.jpg" alt="Figure 2" width="800" /> Figure 2: Plot for different values of $s\geq 1/2$.</p>

<p>In figure 3, we present the computational errors evaluated for different values of $s$ and $h$.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig3.jpg" alt="Figure 3" width="600" /> Figure 3: Convergence of the error.</p>

<p>The rates of convergence shown are of order (in $h$) of $1/2$. This is in accordance with the known theoretical results (see, e.g., <a href="#acosta2017short">[1,Theorem 4.6]</a>). One can see that the convergence rate is maintained also for small values of $s$. Since it is well-known that the notion of trace is not defined for the spaces $H^s(-L,L)$ with $s\leq 1/2$, it is somehow natural that we cannot expect a point-wise convergence in this case.</p>
<h4>Control experiments</h4>
<p>We present some numerical results for the controllability of the fractional heat equation (3). We use the finite-element approximation of $\ffl{s}{}$ for the space discretization and the implicit Euler scheme in the time variable. We choose the penalization term <em>ε</em> as a function of <em>h</em>. A practical rule (<a href="#boyer2013penalised">[2]</a>) is to choose $\phi(h)\sim h^{2p}$ where $p$ is the order of accuracy in space of the numerical method used for the discretization of the spatial operator involved. In this case, we take $p=1/2$.
In figure 4, we observe the time evolution of the uncontrolled solution as well as the controlled solution. Here, we set $s=0.8$, $\omega=(-0.3,0.8)$ and $T=0.3$, and choose $z_0(x) = \sin(\pi x)$. The control domain is the highlighted zone on the plane $(t,x)$. As expected, we observe that the uncontrolled solution decays with time, but does not reach zero at time $T$, while the controlled solution does.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig4.jpg" alt="Figure 4" width="800" /> Figure 4: Time evolution of system (3).</p>

<p>In figure 5, for $s=0.8$ we present the computed values of various quantities of interest when the mesh size goes to zero. More precisely, we observe that the control cost and the optimal energy remain bounded as $h\to 0$. On the other hand, we see that</p>

<script type="math/tex; mode=display">\begin{align}\label{control_norm_behavior}
|y(T)|_{L^2(-1,1)}\,\sim\,C\sqrt{\phi(h)}=Ch^{1/2}.
\end{align}</script>

<p>We know that, for $s=0.8$, system (3) is null controllable. This is now confirmed by (9), according to <a href="#boyer2013penalised">[2,Theorem 1.7]</a>. In fact, the same experiment can be repeated for different values of $s&gt;1/2$, obtaining the same conclusions.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig5.jpg" alt="Figure 5" width="600" /> Figure 5: Convergence properties of the method for controllability of the fractional heat equation.</p>

<p>In figure 6, we illustrate the numerical results for the case $s\leq 1/2$. We observe that the cost of the control and the optimal energy increase in both cases, while the target $y(T)$ tends to zero with a slower rate than $h^{1/2}$. This seems to confirm that a uniform observability estimate for (3) does not hold and that we can only expect to have approximate controllability.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig6.jpg" alt="Figure 6" width="800" /> Figure 6: Convergence properties of the method for $s&lt;1/2$. Same legend as in figure 5.</p>

<p>VIDEOS:</p>
<ol>
 	<li>Uncontrolled dynamics with s = 0.8 and T = 0.2 s - the solution dissipates but the zero state is not reached.
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/10/libre_frac.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/10/libre_frac.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
</li>
 	<li>Controlled dynamics with s = 0.8, T = 0.2 s and \omega = (−0.3, 0.8) - the zero state is reached.
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/10/soly_control_frac.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/10/soly_control_frac.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
</li>
</ol>

<!--h4>Useful links</h5-->
<h3>Bibliography</h3>

<p><strong>[1]</strong> Acosta, G., Bersetche, F. M., and Borthagaray, J. P. <a href="http://www.sciencedirect.com/science/article/pii/S0898122117303310" name="acosta2017short"><em>A short FE implementation for a 2d homogeneous Dirichlet problem of a Fractional Laplacian</em></a> Comput. Math. Appl. (2017).</p>

<p><strong>[2]</strong> Boyer, F <a href="https://www.esaim-proc.org/articles/proc/abs/2013/03/proc134102/proc134102.html" name="boyer2013penalised"><em>On the penalized hum approach and its applications to the numerical approximation of null-controls for parabolic problems</em></a> ESAIM: Proceedings vol. 41 (2013), pp. 15–58.</p>

<p><strong>[3]</strong> Micu, S., and Zuazua, E. <a href="http://epubs.siam.org/doi/abs/10.1137/S036301290444263X" name="micu2006controllability"><em>On the controllability of a fractional order parabolic equation.</em></a> SIAM J. Control Optim., vol. 44, no. 6 (2006), pp. 1950–1972.</p>

<p><strong>[4]</strong> Miller, L. <a href="https://hal.archives-ouvertes.fr/hal-00008809/document" name="miller2006controllability"><em>On the controllability of anomalous diffusions generated by the fractional Laplacian.</em></a> Math. Control Signals Systems, vol. 18, no. 3 (2006), pp. 260–271.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3&gt;Introduction&lt;/h3&gt;
</code></pre></div></div>

<p>We are interested in optimal control problems subject to a class of diffusion-reaction systems that describes the growth and spread of an introduced population of organisms</p>

<script type="math/tex; mode=display">\begin{equation}  \label{pde}
y_t - y_{xx} = f(y), \quad x\in \mathbb{R}, \quad t \in \mathbb{R}^+,  
\end{equation}</script>

<p>where</p>

<script type="math/tex; mode=display">\begin{equation}  \label{fyatet}
f(y)=a y(1-y)(\theta-y),
\end{equation}</script>

<p>is the reaction term that represents local reactions, and $y(t, x) : \mathbb{R}^+ \times \mathbb{R} \rightarrow \mathbb{R}$ is the state of the system. Here $a&lt;0$ and $\theta \in [0,1]$ are two real parameters.</p>

<p>State $y$ represents the local population density. The ``growth’’ of $y$ is subject to an Allee effect (described by the reaction term $f$) in addition to migration (described by the term $y_{xx}$). Allee effect exists for a wide variety of reasons such as less efficient feeding at low densities and reduced effectiveness of vigilance and anti-predator defenses.</p>

<p>The value of $\vert a \vert $ represents the reproductive rate, and the parameter $\theta \in (0,1)$ is the local critical density or Allee threshold $\theta$ that determines the sign (positive or negative) the population growth. Note that, in some literature, the parameter $\theta$ (Allee threshold) has been supposed to be a dynamic parameter that changes with respect to the evolution of the species. Therefore, by means of biological control (e.g. importation of predators), environmental control (e.g. food supply), modern technology (e.g. DNA manipulations), the birth rate and the Allee threshold should be able to be modified. That is to say, we can consider the parameters $a$ and $\theta$ as the control of the system (\ref{pde}).</p>

<p>Note that the reaction term $f$ has three zeros $0$, $\theta$, and $1$, which correspond to three constant solutions of the system (\ref{pde}).
For system (\ref{pde}), there is a propagation phenomenon: one of the state $y=0$, or $y=1$, or $y=\theta$, propagates in the space.
This phenomenon is generally described by <i>traveling wave solution</i> of the form,</p>

<script type="math/tex; mode=display">\begin{equation} \label{tw}
y(t,x) = Y(x - ct), \quad x \in \mathbb{R}
\end{equation}</script>

<p>which connects two of the three constant solutions of the system (\ref{pde}). Here the constant $c \in \mathbb{R}$ is the wave speed, and $Y$ is called the wave profile. Typically, the wave speed and the wave profile depend on the parameters $a$ and $\theta$.</p>

<p>Given a bounded domain $\Omega \subset \mathbb{R}$, our optimal problem is then to choose optimal (control) parameters $a$ and $\theta$ such that the system (\ref{pde}) goes from a given initial state $y(0,x) = y_0(x) \in [0,1]$, $x\in \Omega$ to a final state $y(T,x)$, $x\in \Omega$ which minimizes the distance between this final state and an expected traveling wave solution $y^d$ of the form (\ref{tw}).</p>

<h3>Optimal control problem</h3>

<p>We consider the following optimal control problem $P_{opt}$.</p>

<p>Let $\Omega=[-L,L]\subset\mathbb{ {R} }$ and $T\in\mathbb{ {R}^{+} }$ be the given domain and final time, respectively. Find $u=(a,\theta)$ that minimizes the cost functional</p>

<script type="math/tex; mode=display">\begin{equation}
\label{costfun}
J(u)=\int_{\Omega}|y(T,x)-y^{d}(x)|^{2}dx+K\int_{0}^{T}|\dot{ {a} }(t)|^{2}+|\dot{ {\theta} }(t)|^{2}dt,
\end{equation}</script>

<p>such that the state $y$ satisfies</p>

<script type="math/tex; mode=display">\begin{equation}
\label{eqn_difreac}
y_{t}(t,x)-\triangle y(t,x)=f(x,u(t)),\quad (t,x)\in[0,T]\times\Omega,
\end{equation}</script>

<p>$\partial_{x}y(t,x)=0,\quad t\in[0,T],\quad x\in\partial\Omega$ , where $f(x,u(t))=a(t)y(t,x)(1-y(t,x))(\theta(t)-y(t,x))$, and the control $u=(a,\theta)$ satisfies $a(t)\in[a_{min},a_{max}],\quad,\theta(t)\in[\theta_{min},\theta_{max}]\quad t\in[0,T]$, where $y^{d}$ is a desired traveling wave solution of the form (\ref{tw}),
$a_{min},a_{max}$ are non positive constants, and $\theta_{max},\theta_{min}$ are constants between $0$ and $1$.</p>

<p>To solve this problem numerically with AMPL+(an optimization) solver, we need to discretize the problem and transform it into a nonlinear optimization problem.</p>

<p>Let $N_{t}$ and $N_{x}$ be two positive integers. Define a subdivision of time $0=t_{0}&lt;t_{1}&lt;\cdots&lt;t_{N_{t} }=T$ and a subdivision of space $-L=x_{0}&lt;x^{1}&lt;\cdots&lt;x^{N_{x} }=L$. For any integer $k\in[0,N_{t}-1]$ and $j\in[0,N_{x}-1]$, let $\Delta t_{k}:=t_{k+1}-t_{k}$ and $\Delta x_{j}=x^{j+1}-x^{j}$ be the time and space step size, respectively. Hence, we get a grid of points in the $(t,x)$ plane. Denote then $y_{j}^{k}$ the value of $y$ at the grid point $(t_{k},x^{j})$. Without loss of generality, we assume that the subdivisions are uniform, i.e., all the time (resp. space) intervals are equal, and we denote the time step by $\Delta t$ and the space step by $\Delta x$.</p>

<p>We can now write the discrete version of the cost functional (\ref{costfun}) by</p>

<script type="math/tex; mode=display">\begin{equation}
\label{pb_ocp_dist2}
J^D(u)=\sum_{j=0}^{N_x}|y_{j}^{N_t}-y^d(x^j)|^2 \Delta x^2+\frac{K}{\Delta t^2}\sum_{k=1}^{N_t}\left(|a^{k}-a^{k-1}|^2+|\theta^{k}-\theta^{k-1}|^2 \right)
\end{equation}</script>

<p>Then, we need to discretize the state equation (\ref{eqn_difreac}). For the stability of numerical calculations, we use implicit finite difference schemes. Recall that the basic idea of finite difference schemes is to replace derivatives by finite differences. Here, we use Crank-Nicolson Scheme, which is second-order accurate, and thus we approximate equation (\ref{eqn_difreac}) by</p>

<script type="math/tex; mode=display">\begin{equation}
\label{pb_disc_cn}
\frac{y_j^{k+1} - y_j^k}{\Delta t} = \frac{1}{2} \big( \frac{y_{j+1}^{k+1} - 2 y_{j}^{k+1} + y_{j-1}^{k+1} }{| \Delta x|^2} + \frac{y_{j+1}^{k} - 2 y_{j}^{k+1}+ y_{j-1}^{k+1} }{| \Delta x|^2} \big) + \frac{ f(y_j^{k+1},u^{k+1}) + f(y_j^k,u^k)}{2},
\end{equation}</script>

<p>for $j=1,\cdots,N_{x}-1,\quad k=1,\cdots,N_{t}-1$.</p>

<p>Let us denote the discretized optimal problem by $P_{D}$. Then the problem is to minimize the discretized cost functional (\ref{pb_ocp_dist2}), such that the dynamical constraints (\ref{pb_disc_cn}), initial conditions</p>

<p>$$
y_i^0 = y_0(x^i),\quad i= 1,\cdots, N_x,</p>

<p>$$
boundary conditions</p>

<script type="math/tex; mode=display">y_{0}^k = y_{1}^k, \quad y_{N_x}^k = y_{N_x-1}^k, \quad k=0,\cdots,N_t,</script>

<p>and control constraints</p>

<script type="math/tex; mode=display">a^k \in [a_{min},a_{max}], \quad \theta^k \in [\theta_{min},\theta_{max}],\quad k=0,\cdots,N_t.</script>

<p>are all satisfied.</p>

<p>Now we have transformed the original optimal control problem $ P_{opt} $
into a nonlinear finite-dimensional optimization problem $P_{D}$. Note that in problem $P_{D}$, the unknowns are the state and the control at each discretization point. We solve this problem by programming in AMPL language, combined with IPOPT optimization solver. Before describing the AMPL program in detail, we give a numerical example.</p>

<h3>A numerical example</h3>

<p>Let $K=0.01$, $\delta=0.001$, and the initial data to be a step function,</p>

<script type="math/tex; mode=display">% <![CDATA[
y_{0}(x)=\begin{cases}
\theta_{0}-\delta & x>0\\
0 & x<0
\end{cases} %]]></script>

<p>Let us set, moreover, $a\in[-5,0]$. The optimal solution can then be obtained within $10\,s$, and the final cost $J(u)$ is about $5\times10^{-4}$, with its first term</p>

<script type="math/tex; mode=display">J_{0}(u):=\int_{\Omega}|y(T,x)-y^{d}(x)|^{2}dx=1\times10^{-4}</script>

<p>The obtained optimal solution is illustrated in the Figure 1. In the right subfigure, $u_{1}=a$ and $u_{2}=\theta$.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/ex2_1.png" alt="figure1" width="969" height="325" class="size-full wp-image-01" /><i align="aligncenter">Figure 1: state $y(t,x)$ (left), state $y(\cdot,x)$ (middle), and control $u(t)=(u_1,u_2)$, $u_1=a$, $u_2=\theta$ (right).</i></p>

<h3>AMPL code</h3>

<p>In this section, we introduce how to solve the optimal control problem $P_{D}$ with AMPL. First, we need to define parameters that will be used, for example, the values of $L,T,N_{t},N_{x}$, etc.</p>

<pre>
<span style="color: green;"># Parameters of discretization </span>
<span style="color: green;">param Nt := 250*2; </span>
<span style="color: green;">param Nx := 50; </span>
<span style="color: green;">param L := 30; </span>
<span style="color: green;">param tf := 50; </span>
<span style="color: green;">param dx := 2*L/Nx; </span>
<span style="color: green;">param dt := tf/Nt; </span>
<span style="color: green;">param ymax := 0.6; </span>
<span style="color: green;">set kx ordered := 0..Nx; </span>
<span style="color: green;">set kt ordered := 0..Nt; </span>
<span style="color: green;">param x{j in kx}; </span>
<span style="color: green;">let {j in kx} x[j] := -L+j*dx; </span>
<span style="color: green;">param t{i in kt\}; </span>
<span style="color: green;">let {i in kt} t[i] := i*dt;</span>
<span style="color: green;"></span>
<span style="color: green;"># Parameters of control problem</span>
<span style="color: green;">param u1max := 5; # a_max </span>
<span style="color: green;">param u1min := -5; # a_min </span>
<span style="color: green;">param u2max := 1; # tet_max </span>
<span style="color: green;">param u2min := 0; # tet_min </span>
<span style="color: green;">param tet0 := 0.7;</span>
<span style="color: green;">param tetf := 0.4; </span>
<span style="color: green;">param a0 := -1; </span>
<span style="color: green;">param af := -0.2; </span>
<span style="color: green;">param Ktet := 0.01; </span>
<span style="color: green;">param Ka := 0.01; </span>
<span style="color: green;">param x1 := 0;</span>
<span style="color: green;"></span>
<span style="color: green;"># Parameters of initial data </span>
<span style="color: green;">param A0 := sqrt(-a0); </span>
<span style="color: green;">param c0 := -A0*sqrt(2)*(1/2-tet0); </span>
<span style="color: green;">param y0 {j in kx};</span>
<span style="color: green;">let {j in 0..Nx/2} y0[j] := 0; </span>
<span style="color: green;">let {j in Nx/2+1..Nx} y0[j] := tet0-0.01;</span>
<span style="color: green;"></span>
<span style="color: green;"># Parameters of desired solution</span>
<span style="color: green;">param Af := sqrt(-af); </span>
<span style="color: green;">param cf := -Af*sqrt(2)*(1/2-tetf); </span>
<span style="color: green;">param yobj{i in kx}; </span>
<span style="color: green;">param x2 := x1+cf*Nt*dt;</span>
<span style="color: green;">let {j in kx} yobj[j] := 0.35 ;</span>
<span style="color: green;"></span>
<span style="color: green;"># Parametre for initialisation \par</span>
<span style="color: green;"># (0 =&gt; rien; 1 =&gt; constant; 2 =&gt; init.txt) </span>
<span style="color: green;">param Init_Type = 1;</span>
</pre>

<p>After defining all parameters, we can now define the optimal control problem $P_{D}$., including the cost functional and all constraints on the state and on the control.</p>

<pre>
<span style="color: green;"># Declare the variables and their bounds </span>
<span style="color: green;">var a{i in kt} &gt;= u1min, &lt;= u1max; </span>
<span style="color: green;">var tet{i in kt} &gt;= u2min, &lt;= u2max; </span>
<span style="color: green;">var y{i in kt, j in kx} &gt;= 0, &lt;= 1;</span>
<span style="color: green;"></span>
<span style="color: green;"># Specify the objective function</span>
minimize obj: sum{j in kx} ( ( y[Nt,j] - yobj[j])$\textasciicircum{}2$
+ Ktet*sum{j in kt diff{0} } (tet[j]-tet[j-1])$\textasciicircum{}2$
+ Ka*sum{j in kt diff{0} } (a[j]-a[j-1])$\textasciicircum{}2;$
</pre>

<pre>
<span style="color: green;"># Contraints of the control </span>
subject to c1: tet[0] - tet0 = 0;
subject to c2: a[0] - a0 = 0;
subject to c3: tet[Nt] - tetf = 0;
subject to c4: a[Nt] - af = 0;

<span style="color: green;"># Initial data</span>
subject to i1 {j in kx}: y[0,j] = y0[j] ;

<span style="color: green;"># Dynamical constraints (Backward ) </span>
<b>subject</b> to d1 {i in kt diff{Nt}, j in kx diff {0,Nx} }:
&amp;nbsp <b></b>(y[i+1,j] - y[i,j]) - 1/2*dt*( y[i+1,j+1]-2*y[i+1,j]+
&amp;nbsp <b></b>y[i+1,j-1]+y[i,j+1]-2*y[i,j]+y[i,j-1])/$dx\textasciicircum{}2$-
&amp;nbsp <b></b>1/2*dt*( a[i+1]*y[i+1,j]*(1 - y[i+1,j]) *(tet[i+1]- y[i+1,j])+
&amp;nbsp <b></b>a[i]*y[i,j]*(1 - y[i,j]) *(tet[i]- y[i,j])) = 0;

<span style="color: green;"># Boundary constraints</span>
subject to b1 {i in kt diff{0} }: y[i,1] - y[i,0] = 0;
subject to b2 {i in kt diff{0} }: y[i,Nx] - y[i,Nx-1] = 0;
</pre>

<pre>
<span style="color: green;"># Initialization of state and control variables</span>
<b>if</b> (Init_Type == 1) then {
&amp;nbsp <b>let</b> {j in kt} tet[j] := tetf;
&amp;nbsp <b>let</b> {j in kt} a[j] := 0;
&amp;nbsp <b>for</b> {i in kt diff{0},j in kx}{
&amp;nbsp &amp;nbsp<b>let</b> y[i,j] := ymax*exp(Af*(-L+j*dx-cf*i*dt)/sqrt(2))/
&amp;nbsp &amp;nbsp &amp;nbsp<b></b>(1 + exp(Af*(-L+j*dx-cf*i*dt)/sqrt(2)));
&amp;nbsp <b>}</b>
<b>};</b>
<span style="color: green;"># Initialisation avec $\textquotedbl{}init.txt\textquotedbl{} $(only state and control)</span>
<b>if</b> (Init_Type == 2) then {
&amp;nbsp <b>read</b> {i in kt} (a[i],tet[i]) &lt; init.txt;
 <b>read</b> {i in kt, j in kx} (y[i,j]) &lt; init.txt;
<b>};</b>
</pre>

<p>Now the optimal control problem is defined, we can finally solve it. Here we use IPOPT solver, which implements a primal-dual
interior point method. Recall that an interior point method is a linear or nonlinear programming method. Of course, one can also choose other appropriate optimization solvers.</p>

<pre>
<span style="color: green;"># tell ampl to use the ipopt executable as a solver </span>
<span style="color: green;"># make sure ipopt is in the path! </span>
option solver ipopt;

<span style="color: green;"># solve the problem option </span>
ipopt_options 'max_iter=1000
tol=1e-6';
solve;
</pre>

<p>To see the optimization result, one can print results into txt files, for example:</p>

<pre><span style="color: green;"># print the solution to out.txt</span>
<b>option</b> display_precision 6;
<b>printf</b>: $\textquotedbl{}obj=\textquotedbl{} &gt;&gt;\textcompwordmark{}$ out.txt;
<b>printf</b>: $\textquotedbl{} \%24.16e; \textbackslash{}n\textquotedbl{},
obj &gt;&gt;\textcompwordmark{}$ out.txt;
</pre>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h5&gt;1. Numerical experiments&lt;/h5&gt;
</code></pre></div></div>

<p>Consider the one dimensional linear Vlasov-Fokker-Planck (VPFP) as following.</p>

<script type="math/tex; mode=display">\begin{equation}
\begin{cases}
	\delta_tf + \sigma_1v\delta_x f - \frac{\sigma_2}{\epsilon} \delta_x\phi\delta_v f =\frac{\sigma_3}{\epsilon}\delta_v\ (v f +\delta_vf\ ),  t>0, x\in[0,2\pi], v\in \mathbb{R}, \label{eq: VPFP}\\
	f(0, x,v,z) = f_0(x,v,z),  z\in [a,b].
	\end{cases}
\end{equation}</script>

<p>In the numerical experiments, <strong>we compare the results from the greedy algorithm with the results from the polynomial interpolation of the quadrature points.</strong> we set $\epsilon = 1, T = 0.5$ for all examples. More specifically, we set</p>

<script type="math/tex; mode=display">\text{error} = \sum_{i=1}^{50}\int{ {( \hat{f}(T, x, v, z_i) - f(T, x,v,z_i) )}^2} dxdv \hat{f}(T, x,v,z_i)</script>

<p>is the approximation solution obtained from either method, $f(T, x,v,z_i)$ is the exact solution. $z_i$ is uniformly chosen from $[a,b]$. ${\textbf{Dimension}}$ refers to the number of snap shots.</p>

<p>Observe Figure 1-6, we found that the Greedy algorithm converges to the solution faster than the other method. Especially, when there is discontinuity,  the polynomial interpolation doesn’t converge as dimension increases, however, the Greedy algorithm still converges and almost keeps the same convergent rate.</p>

<p><strong>Algorithm 1.1. The algorithm for the polynomial interpolation:</strong></p>

<p>For <strong>Dimension</strong> $= n$, ${\alpha_i}_{i=1}^n$ is the n roots of $n$-th order Legendre polynomial, and let</p>

<script type="math/tex; mode=display">\begin{equation}
	z_i ^\ast= \frac{b-a}{2}\alpha_i + \frac{a+b}{2},  1\leq i \leq n.\label{}
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
	f_i = f(T, x,v, z_i ^\ast) \text{ be the exact solution at time T}.\label{}
\end{equation}</script>

<p>Then by Lagrange interpolation,</p>

<script type="math/tex; mode=display">\begin{align}
	\hat{f}(T,x,v,z) = \sum_{i=1}^n l_i(z)f_i, l_i = \prod_{j\neq i} \frac{z-z_j ^\ast}{z_i ^\ast - z_j ^\ast}
\end{align}</script>

<h3>1.1 Linear VFP with parametric initial data</h3>
<p>In the first experiment, we consider the case where the parameter $z\in[1,5]$ only involved in the initial data,
<script type="math/tex">\begin{equation}
\sigma_1 = \sigma_2 = \sigma_3 = 1, \delta _x\phi = \cos(x),   
\end{equation}</script></p>

<p>Figure 1:</p>

<script type="math/tex; mode=display">\begin{equation} f_0(x,v,z) = \frac{1}{\sqrt{2\pi}} (2+\frac{\sin(x)}{z}) \text{exp} (-\frac{ |v+\cos(x) + \frac{z}{10} |^2}{2} ).\end{equation}</script>

<p>Figure 2:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} f_0(x,v,z) =\left\{
\begin{array}{rl}
\frac{1}{\sqrt{2\pi}} (2+\frac{\sin(x)}{z}) \text{exp} (-\frac{ |v+\cos(x) + \frac{z}{10} |^2}{2} ), z<3\\
\frac{1}{\sqrt{2\pi}} (2+\frac{\sin(x)}{z}) \text{exp} (-\frac{ |v+\cos(x) + \frac{z+1}{10} |^2}{2} ), z\geq3.
\end{array}
\right.\end{equation} %]]></script>

<p><strong>Algorithm 1.2. The algorithm for PDE with only parameter in initial data:</strong>
<strong>Offline:</strong></p>

<p>Step 1: Set $N = {z_i: z_i = i\delta_z, \delta_z = \frac{b-a}{N_z}, i = 0,1, \dots, N_z}$, we set $N_z = 100$ in this case.</p>

<script type="math/tex; mode=display">\begin{equation}
z_1^\ast = \text{argmax}_{z\in N} || f_0(x,v,z) || ^2,
\end{equation}</script>

<p>where $ \vert f \vert^2 = \int f^2 dxdv$.</p>

<p>Step 2: After obtaining $z_i^\ast, f_i = f_0(x,v,z_i^\ast)$, $i =1, \dots, n-1$,</p>

<script type="math/tex; mode=display">\begin{equation}
z_n^\ast = \text{argmax}_{z\in N\backslash\{z_i^\ast \}_{i=1}^{n-1} } || f_0(x,v,z) - P^{n-1} f_0(x,v,z) ||^2,
\end{equation}</script>

<p>where $P^{n-1} f_0$ is the projection onto the subspace spanned by $f_1, \dots, f_{n-1}$</p>

<p>Step 3: Stops when</p>

<script type="math/tex; mode=display">\begin{equation}
\max_{z\in N\backslash\{z_i^\ast\}_{i=1}^{n-1} } || f_0(x,v,z) - P^{n-1} f_0(x,v,z)||^2 \leq \epsilon
\end{equation}</script>

<p><strong>Online:</strong> After we obtained the snap shots ${z_i^\ast}_{i=1}^n$,</p>

<p>Step 1: Orthogonalize ${f_i}_{i=1}^n$,
         and calculate the corresponding</p>

<script type="math/tex; mode=display">{f^T_i = f(T,x,v,z_i)}_{i=1}^n</script>

<p>Step 2: for any given $z$, one can approximate $f(T, x,v,z)$ by</p>

<script type="math/tex; mode=display">\begin{equation}
a_i = \langle f_0(x,v,z), f_i\rangle,  \hat{f}(x,v, z) = \sum_{i = 1}^na_if^T_i.
\end{equation}</script>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq1_cts.jpg" alt="figure1" class="size-full wp-image-01" /><i align="aligncenter">Figure 1: Continuous initial data</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq1_discts.jpg" alt="figure2" class="size-full wp-image-02" /><i align="aligncenter">Figure 2: Discontinuous initial data</i></p>

<h3>1.2 Linear parametric VFP with deterministic initial data</h3>
<p>In the second experiment, we consider the case where the parameter $z\in[1,5]$ only involved in the PDE,</p>

<script type="math/tex; mode=display">\begin{equation}
 f_0(x,v,z) = \frac{1}{\sqrt{2\pi}} ( 2+\sin(x) ) \text{exp} ( -\frac{|v+\cos(x)|^2}{2} )
\end{equation}</script>

<p>Figure 3:</p>

<script type="math/tex; mode=display">\begin{equation}\sigma_1 = 1+\frac{1.5}{z}, \sigma_2 = \sigma_3 = 1+5e^{\frac{1}{z}}, \delta_x\phi = \cos(x)+\frac{z}{10};\end{equation}</script>

<p>Figure 4:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\sigma_1 = 1+\frac{1.5}{z}, \sigma_2 = \sigma_3 = 1+5e^{\frac{1}{z}}, \delta_x\phi =\left\{
\begin{array}{rl}
& \cos(x)+\frac{z}{10}, z<3\\
&\cos(x)+\frac{z+1}{10}, z\geq3
\end{array}
\right.
\end{equation} %]]></script>

<p><strong>Algorithm 1.3. The algorithm for PDE with only parameters in PDE:</strong>
<strong>Offline:</strong> Set $N = {z_i: z_i = i\delta_z, \delta_z = \frac{b-a}{N_z}, i = 0,1, \dots, N_z}$, we set $N_z = 100$ in this case.</p>

<p>Step 1: choose</p>

<script type="math/tex; mode=display">z_1^\ast = argmax_{z \in N} || ( \sigma_1,\sigma_2,\sigma_3 )||^2</script>

<p>Step 2: After obtaining $z_i^\ast, f_i = f(T,x,v,z_i^\ast)$, $i =1, \dots, n-1$,</p>

<script type="math/tex; mode=display">\begin{equation}
z_n^\ast = argmax_{z\in N\backslash\{z_i^\ast\}_{i=1}^{n-1}} [ \min_{\hat{f} = \sum a_if_i,  \sum a_i = 1}
|| \delta_t\hat{f} + \underbrace{ \sigma_1(z)v\delta_x \hat{f} - \frac{\sigma_2(z)}{\epsilon} \delta_x\phi\delta_v \hat{f} - \frac{\sigma_3(z)}{\epsilon}\delta_v ( v \hat{f} + \delta_v\hat{f} ) }_{A(z)\hat{f} } ||^2 ],
\label{linear z_star}
\end{equation}</script>

<p>Step 3: Stops when the above maximum residual smaller than $\epsilon$.</p>

<p><strong>Online:</strong> After we obtained the snap shots ${z_i}_{i=1}^n$,
and the corresponding $f_i = f(T, x,v,z_i)$,</p>

<script type="math/tex; mode=display">\begin{equation}
\hat{f} = argmin_{\hat{f} = \sum a_if_i,  \sum a_i = 1} || \delta_t\hat{f} + \underbrace{\sigma_1(z)v\delta_x \hat{f} - \frac{\sigma_2(z)}{\epsilon} \delta_x\phi\delta_v \hat{f} - \frac{\sigma_3(z)}{\epsilon}\delta_v (v \hat{f} +\delta_v\hat{f} ) }_{A(z)\hat{f} } ||^2
\end{equation}</script>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq2_cts.jpg" alt="figure3" class="size-full wp-image-03" /><i align="aligncenter">Figure 3: Continuous parameter in PDE</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq2_discts.jpg" alt="figure4" class="size-full wp-image-04" /><i align="aligncenter">Figure 4: Discontinuous parameter in PDE</i></p>

<h3>1.3 Linear parametric VFP with parametric initial data</h3>
<p>In the third experiment, we consider the case where the parameter $z\in[1,5]$ involved in both the initial data and the PDE</p>

<script type="math/tex; mode=display">\begin{equation}\sigma_1 = 1+\frac{1.5}{z}, \sigma_2 = \sigma_3 = 1+5e^{\frac{1}{z}}, f_0(x,v,z) = \frac{1}{\sqrt{2\pi}}(2+\frac{\sin(x)}{z}) \text{exp}(-\frac{|v+\delta_x\phi|^2}{2})
\end{equation}</script>

<p>Figure 5:</p>

<script type="math/tex; mode=display">\begin{equation}\delta_x\phi = \cos(x) + \frac{z}{10}, \text{for }t\geq 0,\end{equation}</script>

<p>Figure 6:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\delta_x\phi =\left\{\begin{array}{rl}& \cos(x)+\frac{z}{10}, z<3\\&\cos(x)+\frac{z+1}{10}, z\geq3\end{array}\right. \text{for }t\geq 0.\end{equation} %]]></script>

<p><strong>Algorithm 1.4. The algorithm for PDE with parameters in PDE and initial data:</strong></p>

<p><strong>Offline:</strong> Set $N = {z_i: z_i = i\delta_z, \delta_z = \frac{b-a}{N_z}, i = 0,1, \dots, N_z}$, we set $N_z = 10000$ in this case.</p>

<p>Step 1: Using Algorithm 1.4 to obtain 50 snap shots out of $N$
        to form a new set $N^\ast$.
Step 2: Using Algorithm 1.3 to get snap shot ${ z_i^\ast }_{i=1}^n$</p>

<p><strong>Online:</strong> Same as Algorithm 1.3.</p>

<p><strong>Remark 1.5.</strong> In the experiments, the exact solution $f(T,x,v,z)$
refers to the numerical solution to VFP, that is, $f(T,x,v,z)$ is a
$N_x\times N_v$ dimensional vector obtained by the following scheme</p>

<script type="math/tex; mode=display">\begin{equation}
\frac{f^{n+1}_{i,j} - f^n_{i,j}}{\delta_t} +\sigma_1 (v\delta_xf)^n_{i,j} = \frac{\sigma_3}{\epsilon}P(f^{n+1}_{i,j})
\end{equation}</script>

<p>where $P(f)$ is the discretization of
$\delta_v (M\delta_v (\frac{f}{M}))$,</p>

<script type="math/tex; mode=display">M = \frac{1}{\sqrt{2\pi}}e^{-\frac{|v+\frac{\sigma_2}{\sigma_3}\delta_x\phi|^2}{2}}</script>

<p><strong>Remark 1.6.</strong> For the matlab coding, the algorithm for the examples is in the “graph.m” file of the folder “eq1”, “eq2”, “eq3” respectively.  You can change the coefficients in “sig_1”, “sig_2”, “sig_3”, and the electric field in “fcn_phi_x”, and initial data in “fcn_phi_x_0”, “fcn_rho_0”.</p>

<p>P.S. Remember to change the path of other functions at the beginning of “graph.m”.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq3_cts.jpg" alt="figure5" class="size-full wp-image-05" /><i align="aligncenter">Figure 5: Continuous parameter in PDE and initial data</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq3_discts.jpg" alt="figure6" class="size-full wp-image-06" /><i align="aligncenter">Figure 6: Discontinuous parameter in PDE and initial data</i></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3&gt;Solving the driving problem with a repulsion force&lt;/h3&gt;
</code></pre></div></div>

<p><img class=" wp-image-1163" src="https://cmc.deusto.eus/wp-content/uploads/2017/03/vector.png" alt="Guidance by repulsion model: driver and evader vectors" width="351" height="190" /> Figure1: The model describes the interaction between two agent: a driver (in red) and an evader (in blue).</p>

<p>The standard approach for solving a driving problem is a leadership strategy, based on the attraction that a driver agent exerts on other agents, [<a href="#borzi2015modeling">1</a>],[<a href="#caponigro2015sparse">2</a>],[<a href="#ginelli2015intermittent">3</a>]. Repulsion forces are mostly used for collision avoidance, defending a target or describing the need for personal space [<a href="#ginelli2015intermittent">3</a>], [<a href="#escobedo2014group">4</a>]. We present a “guidance by repulsion” model [<a href="#escobedo2016optimal">5</a>] describing the behaviour of two agents, a driver and an evader. The driver follows the guided but cannot be arbitrarily close to it, while the evader tries to move away from the driver beyond a short distance. The key ingredient of the model is that the driver can display a circumvention motion around the evader, in such a way that the trajectory of the evader is modified due to the repulsion that the driver exerts on the evader. We propose different open loop strategies for driving the evader from any given point to another assuming that both switching the control and keeping the circumvention mode active have a cost. However, numerical simulations show that the system is highly sensitive to small variations in the activation of the circumvention motion, so a general open-loop control would not be of practical interest. We then propose a feedback control law that avoids an excessive use of the circumvention mode, finding numerically that the feedback law significantly reduces the cost obtained with the open-loop control.</p>
<h3>The "Guidance by Repulsion" model</h3>

<script type="math/tex; mode=display">\begin{equation}
\dot{\vec{u}}_d(t)  = \vec{v}_d(t),
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\dot{\vec{u}}_e(t)  = \vec{v}_e(t),
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\dot{\vec{v}}_d(t)  = {1 \over m_d}
\left[
- C^E_D {\vec{u}(t) \over \|\vec{u}(t)\|^2}
\left( 1 - {\delta_c^2 \over \|\vec{u}(t)\|^2} \right) - \nu_d \vec{v}_d(t)
\right.
\nonumber
\\

\left.
- C_{\rm R} {\delta_1^4 \over \|\vec{u}(t)\|^4}
\left( \vec{u}_d(t) - \vec{u}_e(t) - \kappa(t) \delta_2 \,
{\vec{u}^\bot \over \| \vec{u}(t) \|} \right) \right],
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\dot{\vec{v}}_e(t)  = {1 \over m_e}
\left[ C^D_E { \vec{u}(t) \over \|\vec{u}(t)\|^2}
- \nu_e \vec{v}_e(t) \right],
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\vec{u}_d(t_0)  = \vec{u}_d^0,  \vec{u}_e(t_0) = \vec{u}_e^0,
\vec{v}_d(t_0) = 0  \mbox{and}  \vec{v}_e(t_0) = 0.
\end{equation}</script>

<p>where $\vec{u}_d, \vec{v}_d \in \mathbb{R}^2$ are driver’s position vector and velocity vector respectively. $\vec{u}_e, \vec{v}_e \in \mathbb{R}^2$ are evader’s position vector and velocity vector respectively (Figure 1).</p>

<p><img class="size-full wp-image-1188" src="https://cmc.deusto.eus/wp-content/uploads/2017/03/driverEvader.png" alt="Driver-Evader forces" width="583" height="229" /> Figure 2: When the distance between both agents is larger than the critical distance $\delta_c$, the force acting on the driver attracts it toward the evader. If the driver is closer than $\delta_c$ from the evader, the force acting on the driver becomes a repulsion force. Note that, independently of the distance between agents, the force exerted by the driver on the evader is repulsive.</p>

<p>The control variable is $\kappa(t) \in {-1, 0,1 }$. $\delta_1, \delta_2, \delta_c$ are distances. $C_R, C_D^E, C_E^D$ are coefficients of the atraction-repulsion force and circumvection force. $m_e, m_d$ are the masses of the evader and the driver. $\nu_e, \nu_d$ are the frictions of the evader and the driver (see Figure 2 and Figure 3).</p>

<p><img class="size-full wp-image-1189" src="https://cmc.deusto.eus/wp-content/uploads/2017/03/circunvection.png" alt="Circunvection force." width="346" height="235" /> Figure 3: The circunvection force acting on the driver is effective only when both agents are closes that $\delta_1$, while $\delta_2$ is the distance left by the driver when it makes the circunvection manoeuvre.</p>
<h3>The optimal control problem and the feedback law</h3>
<p>Let denote by $B_\rho(T)$ a ball of radius $\rho$ centered in the target $T$, $N_{\rm ig}(\kappa)$ is the number of times that $\kappa(t)$ changes from 0 to $\pm 1$ and ${\cal C}(\kappa) = \int_{t_0}^{t_f} | \kappa(t) | dt$.
We define the cost functional:</p>

<script type="math/tex; mode=display">\begin{align}
J(\kappa) \stackrel{def}{=} \sigma_1 N_{\rm ig}(\kappa) + \sigma_2 \, {\cal C}(\kappa),
\end{align}</script>

<p>and we formulate the optimal control problem:</p>

<script type="math/tex; mode=display">\begin{align}
(OCP) \; \left\{
\begin{array}{ll}
{\rm Min} \, J(\kappa) = \sigma_1 N_{\rm ig}(\kappa) + \sigma_2 \, {\cal C}(\kappa) \\
\kappa \in U_{\rm ad} =  \big\{ \kappa : [t_0,t_f] \to \{-1,0,1\} \\  \mbox{ such that }
\vec{u}_e(t_f) \in B_\rho(T) \big\}
\end{array}
\right.
\end{align}</script>

<p>For systems that are subject to conditions of high sensitivity, closed-loop or feedback controls offer the possibility of correcting the state of the system for deviations from the desired behaviour instantaneously.
The feedback control law is based on: 1- the alignment of the driver and the evader with the target point $T$ is easier to observe the orientation of the vector $\vec{v}_e(t)$ 2- when the driver is sufficiently far from the evader, $\kappa(t)$ can be set to zero.
We define the alignment of the agents and the characteristic function:</p>

<script type="math/tex; mode=display">\begin{align}
a(t) = (\vec{u}_T - \vec{u}_d) \cdot (\vec{u}_e - \vec{u}_d)^\bot% \\
%= (u_T^x - u_d^x)(u_d^y - u_e^y) + (u_T^y -u_d^y)(u_e^x-u_d^x). %
\end{align}</script>

<script type="math/tex; mode=display">\begin{eqnarray}
{\cal X}(t) = \left\{
\begin{array}{cl}
0  \mbox{ if } r^3(t) \gg \delta_2, \\
1  \mbox{ if not},
\end{array}
\right.
\end{eqnarray}</script>

<p>The feedback control law can then be written as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray}
\kappa_{\rm F}(t) = {\cal X}(t) \times \left\{
\begin{array}{cl}
0  \mbox{ if } |a(t)| \le \bar{a} \\
%\mbox{ and }(\vec{u}_e - \vec{u}_T) \cdot (\vec{u}_e - \vec{u}_d) &lt; 0,% \\ {\rm sign}\{a(t)\}  \mbox{ if } |a(t)| &gt; \bar{a}
%\; \mbox{ or }\; \, (\vec{u}_e - \vec{u}_T) \cdot (\vec{u}_e - \vec{u}_d) \ge 0 .
\end{array}
\right.
\label{fidbaclaw}
\end{eqnarray} %]]></script>

<p><img class="size-full wp-image-1193" src="https://cmc.deusto.eus/wp-content/uploads/2017/03/feed2.png" alt="Agents’ trajectories for the feedback law." width="600" height="280" /> Figure 4: Agents’ trajectories for the feedback law.</p>
<h3>Perspectives</h3>
<ul>
	<li>Formulate the problem for N evader and study the evolution of the cost depending on the number on evaders</li>
	<li>The sheepherding problem is an example of the use of repulsion forces for guiding a flock. One of the close future work is building a sheepherding model, including stochastic terms in it, using experimental data.</li>
	<li>Prove the controllability of the problem.</li>
	<li>Study the sensibility and the efficiency of the model depending on the parameters of the model, in special on the critical distances.</li>
	<li>Mean--field theorem for the guidance by repulsion model passing to the limit in the number of evaders, $N \rightarrow \infty$, as in [<a href="#carrillo2014derivation">6</a>].</li>
	<li>Study of the problem for N evaders and M drivers.</li>
	<li>Formulate the problem in $\mathbb{R}^3$.</li>
</ul>
<h3>References</h3>
<p><strong>[1]</strong> Alfio Borzì and Suttida Wongkaew. <a href="http://www.worldscientific.com/doi/abs/10.1142/S0218202515500098" name="borzi2015modeling"><em>Modeling and control through leadership of a refined flocking system.</em></a> Mathematical Models and Methods in Applied Sciences,25(02):255–282, 2015.</p>
<p><strong>[2]</strong> Marco Caponigro, Massimo Fornasier, Benedetto Piccoli, and Emmanuel Trélat. <a href="https://arxiv.org/abs/1210.5739" name="caponigro2015sparse"><em>Sparse stabilization and control of alignment models.</em></a> Mathematical Models and Methods in Applied Sciences, 25(03):521–564, 2015.</p>
<p><strong>[3]</strong> Francesco Ginelli, Fernando Peruani, Marie-Helène Pillot, Hugues Chaté, Guy Theraulaz, and Richard Bon. <a href="http://www.pnas.org/content/112/41/12729.abstract" name="ginelli2015intermittent"><em>Intermittent collective dynamics emerge from conflicting imperatives in sheep herds.</em></a> Proceedings of the National Academy of Sciences, 112(41):12729–12734, 2015.</p>
<p><strong>[4]</strong> R Escobedo, C Muro, L Spector, and RP Coppinger. <a href="http://rsif.royalsocietypublishing.org/content/11/95/20140204" name="escobedo2014group"><em>Group size, individual role differentiation and effectiveness of cooperation in a homogeneous group of hunters.</em></a> Journal of the Royal Society Interface, 11(95):20140204, 2014.</p>
<p><strong>[5]</strong> Ramón Escobedo, Aitziber Ibañez, and Enrique Zuazua. <a href="http://www.sciencedirect.com/science/article/pii/S1007570416300363" name="escobedo2016optimal"><em>Optimal strategies for driving a mobile agent in a guidance by repulsion model.</em></a> Communications in Nonlinear Science and Numerical Simulation, 39:58–72, 2016.</p>
<p><strong>[6]</strong> José Antonio Carrillo, Young-Pil Choi, and Maxime Hauray. <a href="https://arxiv.org/abs/1304.5776" name="carrillo2014derivation"><em>The derivation of swarming models: mean-field limit and wasserstein distances.</em></a> In Collective dynamics from bacteria to crowds, pages 1–46.Springer, 2014.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3&gt;1 Introduction&lt;/h3&gt;
</code></pre></div></div>

<p>We are interested in the numerical discretization of the  Kolmogorov equation [12]</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{kolmo}
\left\{
\begin{array}{lll}
\partial_t f - \mu \partial_{xx} f - v(x) \partial_y f =0, & (x,y)\in\RR^2, t>0,\\
f(x,y,0) =f_0(x,y),      & (x,y)\in\RR^2
\end{array}
\right.
\end{equation} %]]></script>

<p>where $\mu&gt;0$ is a diffusive  function and  $v$ a potential function.<br />
This is one example of degenerate advection-diffusion equations which have the property of hypo-ellipticity (see for instance, [6, 13, 14]), ensuring the $C^\infty$ regularity of solutions for $t&gt;0$ ([6]).<br />
In the present case, the generator of the semigroup is constituted by the superposition of operators  $\mu \partial_{xx}$ and $ v(x) \partial_y $. Despite the presence of a first order term, that could lead to transport phenomena and, consequently, to the lack of smoothing, the regularizing effect is ensured by the fact that the commutator of these two operators is non-trivial, allowing to gain regularity in the variable $y$. A full characterization of hypo-ellipticity can be found in [6].</p>

<p>Solutions of (1) experience also  decay properties as $t\to  \infty$. This is also a manifestation of hypo-coercivity (in the sense developed by Villani [13], [14]) as a byproduct of the hidden interaction  of the two operators entering in the generator of the semigroup.</p>

<p>In this particular case $\mu=1$ and $v(x)=x$, using the Fourier transform, the fundamental solution of (1) (starting from an initial Dirac mass $\delta_{(x_0, y_0)}$) can be computed explicitly getting the following anisotropic Gaussian kernel</p>

<script type="math/tex; mode=display">\begin{equation*}\label{kernel}
    K_{(x_0, y_0)}(x,y,t)  =
     \frac{1}{3\pi^2 t^2}
          exp \bigg[ -\frac{1}{\pi^2}\left(
                                    \frac{3| y-(y_0+tx_0) |^2}{t^3} +
                                    \frac{3(y-(y_0+tx_0)) (x-x_0)}{t^2}      +
                                    \frac{| x-x_0 |^2}{t}
                                    \right)
                \bigg]
  \end{equation*}</script>

<p>which exhibits different diffusivity and decay scales in the variables $x$ and $y$.
In view of the structure of the fundamental solution, one can deduce the following decay rates:</p>

<script type="math/tex; mode=display">\begin{equation}\label{decay}
\| f(t)\|_{L^2}+ \sqrt t\,  \| \partial_x f(t) \|_{L^2}+ t^{\frac 32} \|\partial_y f(t)\| _{L^2}\leq C ||f_0||_{L^2}
\end{equation}</script>

<p>for solutions with initial data $f_0$ in $L^2$. Similar decay properties can be predicted by scaling arguments, due to the invariance properties of the equation in (\ref{kolmo}).</p>

<p>These decay properties are of anisotropic nature and of a different rate  in the  $x$ and $y$-directions. Indeed, in the $x$-direction, as in the classical heat equation,  we observe a decay rate of the order of $t^{-1/2}$, while, in the $y$-variable, the decay is of order  $t^{-3/2}$.</p>

<p>The obtention of these decay properties by energy methods has been a challenging topic of particular interest when dealing with more general convection-diffusion models that do not allow the explicit computation of the kernel. In this effort, the asymptotic behavior of Kolmogorov equation and several other relevant kinetic models was investigated intensively through the concept and techniques of hypo-coercivity,  which allow to make explicit the hidden diffusivity and dissipativity of the involved operators  (see [13], [14] and the previous references therein).</p>

<p>The literature on the asymptotic behaviour of models related with Kolmogorov equation is huge. We refer for instance to [8], [9], [2] for earlier works, and to [4], [5] for more recent approaches. Roughly speaking, it is by now well known that, constructing well-adapted Lyapunov functionals through  variations of the natural energy of the system,  one can  make the dissipativity properties of the semigroup  emerge and  then obtain the sharp decay rates. These techniques have been developed also in other contexts such as partially dissipative hyperbolic systems (see [1]).</p>

<p>In [10] Porretta and Zuazua introduces a numerical scheme that preserves this hypo-coercivity property at the numerical level, uniformly on the mesh-size parameters. The issue is relevant from a computational point of view since, as it has been observed in a number of contexts (wave propagation, dispersivity of Schrödinger equations, conservation laws, etc. [15], [7]), the convergence property in the classical sense of numerical analysis (a property that concerns finite-time horizons) is not sufficient to ensure the asymptotic behavior of the PDE solutions to be captured correctly. The fact that the numerical approximation schemes preserve the decay properties of continuous solutions can be considered as a manifestation of the property of <i>numerical hypo-coercivity.</i></p>

<p>In [3] Foster <i>et al</i> introduces a numerical scheme which preserves the long time behavior of solutions to the Kolmogorov equation. The method presented is based on a self-similar change of variables technique to transform the Kolmogorov equation into a new form, such that the problem of designing structure preserving schemes, for the original equation, amounts to building a standard scheme for the transformed equation. We also present an analysis for the operator splitting technique for the self-similar method and numerical results for the described scheme.</p>

<p>Here, instead of, we investigate this behavior using the characteristics-Galerkin finite element method (trough Freefem++ [11])  and in particular, we confront the  results to those obtained in [3].</p>

<h4>2 Description of the numerical scheme</h4>
<p>At the numerical level, we employ a finite element method based on characteristics-Galerkin technique, and for the sake of simplicity and ease,  we use the Freefem ++ software ([11]). As described above, solution of Equation (1) does not only diffuses in the direction of x, by the effect of the diffusion operator $\partial_{xx} f$, but it is also diffuses in the direction of $y$, due to the transport equation $\partial_t f   - v(x) \partial_y f$. We will treat both effects, transport and diffusion separately,   using the characteristics method, that we recall hereafter, for the equation $\partial_t f   - v(x) \partial_y f$ and linear or quadratic  finite element to discretise  the diffusion term.</p>
<h3>2.1 Transport</h3>
<!--\label{SectionTransport}-->
<p>Let us consider the following scalar two dimensional transport equation</p>

<script type="math/tex; mode=display">\begin{equation}\label{transport}
\partial_t f +  c \cdot \nabla f = g, \quad  c \in\RR^2 \textrm{ in } \Omega \subset\RR^2 \times (0,T)
\end{equation}</script>

<p>for some function $g$. Let (x,y,t)$\in \mathbb{R}^2 \times \mathbb{R}^+$. This transport equation can be written using the total derivative</p>

<script type="math/tex; mode=display">\begin{equation}\label{td}
\frac{d}{ds} f( X_{x,y,t}(s),s) = g
\end{equation}</script>

<p>if and only if the curve $( X_{x,y,t}(s),s)$ satisfies the system of ordinary differential equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{odec}
\left\{
\begin{array}{ll}
\frac{d}{ds} X_{x,y,t}(s) =  c( X_{x,y,t}(s),s),&  \forall s\in(0,t), \\
 X_{x,y,t}(t) = (x,y) \\
\end{array}\right.
\end{equation} %]]></script>

<p>Under suitable assumptions on $ c$, the problem is well defined and there exists a unique solution to (6) $ X_{x,y,t}$, called the characteristic curve reaching (or passing from)  the point $(x,y)$ at time $t$.
Since we cannot compute explicitly, in general,  the solution of the equation (6), hence (4), we look for an approximate solution. Noting $\delta t&gt;0$ the time step and $t_{n+1} = t_n + \delta t$, an easy manner to approximate the solution of Equation (4) is to perform a backward convection by the method of characteristic</p>

<script type="math/tex; mode=display">\begin{equation}\label{approxMOC}
 \frac{1}{\delta t} \left(f^{n+1}(x,y)-f^{n}( X_{x,y,t_n}(x))\right) = g^n(x,y)
\end{equation}</script>

<p>where $f^n(x,y) = f(x,y,t_n)$ and $ X_{x,y,t_n}(x)$ is an approximation, as shown  below, of the solution at time $t_n=n \delta t$ of the ordinary differential equation (6) for $s\in(t_n,t_{n+1})$ with  the final data $ X_{x,y,t}(t_{n+1}) = (x,y)$.</p>

<p>Assuming $f$ regular enough, by Taylor expansion, one can write</p>

<script type="math/tex; mode=display">f^n( X_{x,y,t}(t_{n}))=f^n( X_{x,y,t}(t_{n+1})) - \delta t \  c( X_{x,y,t_n}(t_n),t_n) \cdot \nabla f^n(x)  + O(\delta t^2)</script>

<p>Applying also a Taylor expansion to the function $t\mapsto f^n((x,y)-t  c( X_{x,y,t_n}(t_n),t_n))$, we get</p>

<script type="math/tex; mode=display">f^n((x,y)-t  c( X_{x,y,t_n}(t_n),t_n)) = f^n( X_{x,y,t}(t_{n+1})) - \delta t \  c( X_{x,y,t_n}(t_n),t_n) \cdot \nabla f^n(x)  + O(\delta t^2)</script>

<p>and therefore one can approximate $f^n( X_{x,y,t}(t_{n}))$   by $f^n((x,y)- \delta t \  c( X_{x,y,t_n}(t_n),t_n))$. For the sake of clarity, in the sequel, we note $X(t)$ the characteristic curve passing through the point $(x,y)$ at time $t$.</p>

<h3>2.2 Numerical algorithm</h3>
<p>For numerical purpose, we consider Equation (1) in $\Omega \subset \mathbb{R}^2$ with homogeneous Neumann boundary conditions. Keeping in mind the characteristic method,  Equation (1) can be written</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{kolmo2}
\left\{
\begin{array}{lll}
\frac{d}{dt} f( X(t)) - \mbox{div}(A \nabla f) =0, & (x,y)\in\Omega, t\in (0,T), T>0\\
A \nabla f \cdot  n =0, & \textrm{ in } \partial\Omega\\
f(x,y,0) =f_0(x,y),      & (x,y)\in\Omega
\end{array}
\right.
\end{equation} %]]></script>

<p>where $ n$ stands for the outward unit normal to $\Omega$, and  for all $s\in(0,t)$,   $ X$ is the solution of</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{odekolmo}
\left\{
\begin{array}{ll}
\frac{d}{ds} X(s) =  v( X_{x,y,t}(s)),&  \forall s\in(0,t), \\
 X(t) = (x,y) \ .\\
\end{array}\right.
\end{equation} %]]></script>

<p>Here, we use the following notations</p>

<script type="math/tex; mode=display">% <![CDATA[
v = \left(\begin{array}{c}            0\\-v           \end{array}\right)$ and $A = \left(\begin{array}{cc}            \mu& 0\\0&0           \end{array}\right) %]]></script>

<p>Formally, thus, one can write, for any $\varphi \in V$ for some functional space, the weak form of Equation (8) as follows</p>

<script type="math/tex; mode=display">\begin{equation}\label{weakform1}
\int_{\Omega}  \frac{d}{dt} f(X(t)) \varphi \ dx dy + \int_{\Omega} A \nabla f \cdot \nabla \varphi \ dx dy  = 0
\end{equation}</script>

<p>Let us denote $t_0&lt;t_1&lt;\ldots &lt; t_M = T$ be the discrete time with $t_n = n \delta t$ where $\delta t$ denotes the time step. We set  $M = T/\delta t$. <br />
Using the method of characteristic for the total derivative (see section 2.1), the weak form (10) can be approximated by</p>

<script type="math/tex; mode=display">\begin{equation*}
\int_{\Omega}  \frac{1}{\delta t}\left(f^{n+1}-f^n \circ  X^n  \right)\varphi  \ dx dy + \int_{\Omega} A \nabla f^{n+1} \cdot \nabla \varphi \ dx dy  = 0
\end{equation*}</script>

<p>or</p>

<script type="math/tex; mode=display">\begin{equation}\label{weakform2}
a(f^{n+1},\varphi) = (f^n,\varphi)
\end{equation}</script>

<p>where
<script type="math/tex">a(f,\varphi) = ((I/ \delta t+A\nabla)f,\varphi) \ .</script>
Here $(\cdot,\cdot)$ is the inner product in $L^2(\Omega)$.</p>

<p>Therefore, denoting $\tau_h$ a partition of $\Omega$ by triangles and $V_h$ the $P_k$-finite element space (of degree $k$),
the weak discrete form of the problem (8) is</p>

<p>Find ${f_h^n}_{n=1}^{M=T/\delta t} \subset V_h$ such that for $n=1,\dots, M$,</p>

<script type="math/tex; mode=display">a(f_h^n,\varphi_h) = (f^n,\varphi_h), \ \forall \varphi_h \in V_h \ .</script>

<p>The Freefem++ script corresponding to the problem may as follows
&lt;/ol&gt;
Freefem++ CODE:</p>
<ol>
 	<li value="1">Freefem++ code for prog_control.m:
<pre>
<span style="color: green;"></span>
<span style="color: green;">/*</span>
<span style="color: green;">C****************************************************************************C</span>
<span style="color: green;">C                                                                            C</span>
<span style="color: green;">C     This program solve the Kolmogorov equation                             C </span>
<span style="color: green;">C     f_t-mu*f_{xx}-v(x) f_y = 0 on Omega x [0,T]                            C  </span>
<span style="color: green;">C     with free boundary conditions                                          C</span>
<span style="color: green;">C     using the Characteristic-Galerkin Finite Element Method                C </span>
<span style="color: green;">C********************************************C*******************************C</span>
<span style="color: green;">C     f(i,j)   ==&gt; unknown scalar function   C</span>
<span style="color: green;">C     phi(i,j) ==&gt; test function             C</span>
<span style="color: green;">C     v(i)     ==&gt; scalar potential function C</span>
<span style="color: green;">C********************************************C</span>
<span style="color: green;">*/      </span>
<span style="color: green;"></span>
<span style="color: green;">//Omega : square mesh [0,20]x[0,20] </span>
<span style="color: green;">real aa = 10;</span>
<span style="color: green;">real x0=-aa,x1=aa;</span>
<span style="color: green;">real y0=-aa,y1=aa;</span>
<span style="color: green;">int m = 100;</span>
<span style="color: green;">mesh Th=square(m,m,[x0+(x1-x0)*x,y0+(y1-y0)*y]);</span>
<span style="color: green;"></span>
<span style="color: green;"></span>
<span style="color: green;">real Tf  = 10,     </span>
<span style="color: green;">     dt  = 0.01,  </span>
<span style="color: green;">     mu  = 1;    // viscosity parameter (see equation above)</span>
<span style="color: green;">     </span>
<span style="color: green;"></span>
<span style="color: green;">fespace Vh(Th,P2);     // P1 linear finite element</span>
<span style="color: green;">Vh f0 = exp(-x^2-y^2), // initial data</span>
<span style="color: green;">   phi,                // test function</span>
<span style="color: green;">   v=-x,</span>
<span style="color: green;">   f;</span>
<span style="color: green;"></span>
<span style="color: green;">   </span>
<span style="color: green;">for(real t=0;t&lt;=Tf;t=t+dt)</span>
<span style="color: green;">{</span>
<span style="color: green;">  Vh c=convect([0,v(x,y)],-dt,f0);</span>
<span style="color: green;">  solve Kolmogorov(f,phi)</span>
<span style="color: green;">            = </span>
<span style="color: green;">              int2d(Th)(f*phi/dt +mu*(dx(f)*dx(phi)))</span>
<span style="color: green;">    	    - int2d(Th)(c/dt*phi)</span>
<span style="color: green;">	    ;</span>
<span style="color: green;">  f0=f;</span>
<span style="color: green;">}</span>
<span style="color: green;"></span>
</pre>
<h4>3 Numerical experiment</h4>
In this section we present a test case, [3], for which we confront to an exact solution of the Kolmogorov Equation (1) with $\mu=1$ and $v(x)=x$. In particular, we compare our results to the one obtained in [3]. For our numerical test case, we have used linear finite element.
The initial value problem (1) with the initial data $f_0(x,y) = \exp(-x^2-y^2)$ admits the following exact solution
$$f_{ex}(x,y,t) = \frac{\exp\left(-\frac{(( 3+3t^2 +4t^3)x^2 +6t(1+2t)xy+3(1+4t)y^2)}{(3+12t+4t^3 +4t^4)}\right)}{\sqrt{1 + 4 t + 4/3 t^2 + 4/3 t^4}} \ . $$
As done in [3], for each numerical tests, we have considered the time interval, and problem domain to be respectively $[0, T=10]$ and $\Omega = [−10, 10] \times [−10,10]$, The time step is kept constant equal to $\delta t = 0.01$ and the number of triangles along each side of the domain is given by $m=50$, $100$ and $150$.
As one can see in the video above, the support for the function grows beyond the problem domain in the given time interval and interact with boundary conditions. This interaction, since we do not use here transparent boundary conditions, increases the error as one can also observe in Figure 1. We also show the time evolution of $\|f(\cdot,t)-f_{ex}(\cdot,t)\|_2$, $\|\partial_xf(\cdot,t)\|_2$, $\|\partial_y f(\cdot,t)\|_2$ and
$$D(t)=\left(\| f(t)\|_{L^2}+ \sqrt t\,  \| \partial_x f(t) \|_{L^2}+ t^{\frac 32} \|\partial_y f(t)\| _{L^2}\right)/||f_0||_{L^2} \ ,$$  in Figure 2. The $L_2$ error at time time $T=10$ is approximately $0.0072$ as one can see in Figure 2(a). Moreover, the error $\int_0^T \| f(\cdot,t)-f_{ex}(\cdot,t)\|_2 dt $ is approximately of order $0.02$. We also observe, due to the interaction with the boundary conditions that the errors increase sensibly for each numerical experiments approximately at time $t\approx 8.5$. Therefore, in order to  compute the numerical order  of convergence, we have computed for each $m$, $m\mapsto \max_t\left( \|f(\cdot,t)-f_{ex}(\cdot,t)\|_2\right)$. We find almost the order $1$ which is satisfactory.  Finally, we have computed the quantity
$$D(t) =\left(\| f(t)\|_{L^2}+ \sqrt t\,  \| \partial_x f(t) \|_{L^2}+ t^{\frac 32} \|\partial_y f(t)\| _{L^2}\right)/||f_0||_{L^2}\ , $$
for which we numerically show that the constant for the decay rates is $C=1$ as shown in Figure 2(d)

<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/11/Kolmogorov1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/11/Kolmogorov1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
<i>Movie 1: Numerical simulation of the test case .</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/freefemsol100.eps_.jpg" alt="Freefem solution with m=100" width="562" height="446" class="size-full wp-image-01" /> <i align="aligncenter">Figure 1.a: Numerical and exact solution at time $T=10$, Freefem solution with $m=100$</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/exactsol100.eps_.jpg" alt="Exact solution" width="562" height="446" class="size-full wp-image-02" /> <i align="aligncenter">Figure 1.b: Numerical and exact solution at time $T=10$, Exact solution</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/L2error.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-1" /> <i align="aligncenter">Figure 2.a: $L_2$ errors, $t\mapsto\|f(\cdot,t)-f_{ex}(\cdot,t)\|_2$</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/L2normdx.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-2" /> <i align="aligncenter">Figure 2.b: $L_2$ errors, $t\mapsto \|\partial_xf(\cdot,t)\|_2$</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/L2normdy.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-3" /> <i align="aligncenter">Figure 2.c: $L_2$ errors, $t\mapsto \|\partial_yf(\cdot,t)\|_2$</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/L2ez.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-4" /> <i align="aligncenter">Figure 2.d: $L_2$ errors,$t\mapsto D(t)$</i>



To end, we present a last numerical simulation of rotating and moving initial data.
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/11/Kolmogorov2.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/11/Kolmogorov2.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
<i>Movie 2: Numerical simulation on $\Omega = [0,10]\times[0,20]$, $[0,T=0.6]$ with $\mu=10^{-3}$, $v(x)=-x$  and $f_0(x,y) = 20 \exp(-(y-15)^2) \exp(-0.1(x-10)^2)$.</i>

<h4>Bibliography</h4>

<p><strong>[1]</strong> K. Beauchard and E. Zuazua, <a href=""><em><i>Sharp large time asymptotics for partially dissipative hyperbolic systems</i></em></a>, Arch. Ration. Mech. Anal. 199 (2011) 177-7227.</p>
<p><strong>[2]</strong> A. Carpio, <a href=""><em><i>Long-time behavior for solutions of the Vlasov-Poisson-Fokker-Planck equation</i></em></a>, Mathematical methods in the applied sciences 21 (1998), 985-1014.</p>
<p><strong>[3]</strong> E. L. Foster, J. Lohéac and  M.-B. Tran, <a href=""><em><i> A Structure Preserving Scheme for the Kolmogorov Equation</i></em></a>, preprint   2014 (arXiv:1411.1019v3).</p>
<p><strong>[4]</strong> F. Hérau, <a href=""><em><i>Short and long time behavior of the Fokker-Planck equation in a confining potential and applications</i></em></a>, J.  Funct.  Anal. 244 (2007), 95-118.</p>
<p><strong>[5]</strong> F. Hérau  and F. Nier, <a href=""><em><i>Isotropic hypoellipticity and trend to equilibrium for the Fokker-Planck equation with a high-degree potential</i></em></a>,  Arch. Ration. Mech. Anal. 171 (2004), 151-218.</p>
<p><strong>[6]</strong> L. Höormander, <a href=""><em><i>Hypoelliptic second order differential equations</i></em></a>,  Acta Math. 119 (1967), 147-171.</p>
<p><strong>[7]</strong> L. Ignat, A. Pozo and E. Zuazua, <a href=""><em><i>Large-time asymptotics, vanishing viscosity and numerics for 1-D scalar conservation laws</i></em></a>, Math of Computation, to appear.</p>
<p><strong>[8]</strong> A. M. Il'in, <a href=""><em><i>On a class of ultraparabolic equations</i></em></a>, Soviet Math. Dokl. 5  (1964), 1673-1676.</p>
<p><strong>[9]</strong> A. M. Il'in and R. Z. Kasminsky, <a href=""><em><i> On the equations of Brownian motion</i></em></a>, Theory Probab. Appl. 9 (1964), 421-444.</p>
<p><strong>[10]</strong> A. Porretta and E. Zuazua, <a href=""><em><i>Numerical hypocoercivity for the Kolmogorov equation</i></em></a>, Mathematics of Computation 86.303 (2017): 97-119.</p>
<p><strong>[11]</strong> Frédéric Hecht, Olivier Pironneau, A~Le~Hyaric and K~Ohtsuka, <a href=""><em><i>Freefem++ manual</i></em></a>, 2005.</p>
<p><strong>[12]</strong> A. Kolmogoroff, <a href=""><em><i>Zufallige bewegungen (zur theorie der brownschen bewegung)</i></em></a><i> Annals of Mathematics</i>, pages 116--117, 1934.</p>
<p><strong>[13]</strong> C. Villani, <a href=""><em><i>Hypocoercivity</i></em></a>, Mem. Amer. Math. Soc. 202  (2009).</p>
<p><strong>[14]</strong> C. Villani, <a href=""><em><i>Hypocoercive diffusion operators</i></em></a>, In International Congress of Mathematicians, Vol. III, 473-498.  Eur. Math. Soc. Zürich, 2006.</p>
<p><strong>[15]</strong> E. Zuazua, <a href=""><em><i>Propagation, observation, and control of waves approximated by finite difference methods</i></em></a>, SIAM Review, 47 (2) (2005), 197-243.</p>
</li></ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;&lt;!--h5&gt;Introduction&lt;/h5--&gt;
</code></pre></div></div>
<h4>1. Adjoint estimation: low or high order?</h4>
<p>Adjoint methods have been systematically associated to the optimal control design [5] and their applications to aerodynamics [1, 4]. During the last decades, several works were oriented to develop a robust control theory based on the concepts of observability, optimality and controllability for linear and non-linear equations and systems of equations [2, 10, 11, 12].</p>
<p>Since the discrete approach forces to use the discrete adjoint problem of the flow solver to numerically solve the adjoint equation, the continuous approach is adopted due to its valuable flexibility of using different solvers for the flow and adjoint equations. It is well known that problems where high frequencies play an important role such as the control of wave equation [11]</p>
<p>The focus is put on the 2D linear scalar transport equation, that can be expressed in a conservative form as follows:<br />
<a name="id2808901204"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (1) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e9a3e84e11b880fa56f25a9a5fca2a9c_l3.png" height="42" width="357" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#116;&#41;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#40;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#32;&#117;&#41;&#32;&#61;&#32;&#48;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;&#61;&#117;&#95;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-50c719d4de6535419310ba5de09c69d7_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#61;&#118;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="88" style="vertical-align: -5px;" /> is a time-independent velocity field of propagation.</p>
<p>Given a target function <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e53901f63bf7a3536ed715227f91b733_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#42;&#61;&#117;&#94;&#42;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="104" style="vertical-align: -5px;" />, the aim in the 2D inverse design problem consists in finding <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-bd421b5f9cc4b54f52392081f3df2e0a_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#95;&#48;" title="Rendered by QuickLaTeX.com" height="12" width="16" style="vertical-align: -3px;" /> such that <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-2c6549776d1bcc59f9dfb850cc125f02_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#84;&#41;&#32;&#92;&#115;&#105;&#109;&#32;&#117;&#94;&#42;" title="Rendered by QuickLaTeX.com" height="20" width="80" style="vertical-align: -5px;" /> via the minimization of a functional <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ddf177ca226c96c8850a9a3f591986ef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#74;" title="Rendered by QuickLaTeX.com" height="14" width="10" style="vertical-align: 0px;" />:</p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (2) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-b1d8ce1bed01da9014c779df45dd842a_l3.png" height="40" width="171" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#74;&#40;&#117;&#41;&#61;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#49;&#125;&#123;&#50;&#125;&#32;&#124;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#124;&#94;&#50; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>This problem can be easily addressed by simply solving the transport equation backwards in time because of the time reversibility of the model. But such a simple approach fails as soon as the model involves nonlinearities (leading to shock discontinuities) or diffusive terms, making the system time-irreversible.</p>
<p>We are thus interested in the development of gradient descent methods with the aid of the adjoint equation (solved backwards in time) that can be easily deduced<br />
<a name="id3132551628"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (3) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-36c03fbd94e90faf1d1ed1488ffdaf49_l3.png" height="42" width="397" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#45;&#32;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#120;&#44;&#121;&#44;&#116;&#41;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#45;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#61;&#32;&#48;&#44;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#84;&#41;&#61;&#32;&#117;&#40;&#84;&#41;&#45;&#32;&#117;&#94;&#42; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-4ef8cf94d8f10416a5234a5f6b3f695e_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#61;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#120;&#44;&#121;&#44;&#116;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="107" style="vertical-align: -5px;" /> is the adjoint variable.</p>
<p>In order to achieve a good match with the continuous solutions, high order numerical schemes need to be used for the forward state equation (<a href="#id2808901204">1</a>). Here we shall use a second order scheme. Our main objective is to test the convenience of using the same order of accuracy when solving the adjoint equation or, by the contrary, to employ a low order one. When implementing the gradient descent iterations, the numerical scheme employed for solving the adjoint equation determines the direction of descent. Hence, different solvers for the adjoint system provide different results that can be compared in terms of accuracy and efficiency.</p>
<p>A gradient-adjoint iterative method is based on iterating a loop where the equation of state (flow equation) is solved in a forward sense while the adjoint equation, which is of hyperbolic nature as well, is solved backwards in time (see Figure 1).<br />
<figure id="attachment_349" style="width: 562px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/loop.eps_.jpg" alt="Iteration of the 2D inverse design." width="562" height="446" class="size-full wp-image-349" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 1. Iteration of the 2D inverse design</i></figcaption></figure></p>
<p>The adequate resolution of this loop is the main question addressed in this work, paying attention not only to accuracy but also to reducing its computational complexity. One could expect that the choice of high order numerical methods to solve both the equation of state and the adjoint one should provide the best results in terms of accuracy, at the prize of a high computational cost. But this is not always true and it is possible to relax the necessity of using the same order of accuracy for the resolution of the adjoint equation, not only reducing considerably the computational time needed by the complete loop but also achieving the same order of accuracy on the approximation of the inverse design, which is our ultimate goal.</p>
<h4>2. 2D linear equation and continuous adjoint derivation</h4>
<p>We focus on the following conservative linear transport scalar equation with an heterogeneous time-independent vector field <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-89ef819400fd901a038118409f8d68d1_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#61;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#40;&#120;&#44;&#121;&#41;&#58;" title="Rendered by QuickLaTeX.com" height="20" width="97" style="vertical-align: -5px;" /><br />
<a name="id3868366351"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 41px;"><span class="ql-right-eqno"> (4) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f7f68ed6539e16a8d751a203049530ab_l3.png" height="41" width="148" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#40;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#32;&#117;&#41;&#32;&#61;&#32;&#48;&#32;&#46; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Obviously, the solution <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-7096bbe46940b5edd35b070bbfad6116_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#61;&#117;&#40;&#120;&#44;&#32;&#121;&#44;&#32;&#116;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="104" style="vertical-align: -5px;" /> exists and it is unique and can be determined by means of the method of characteristics provided <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-970ae81c692225b067b830b9d1218145_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;" title="Rendered by QuickLaTeX.com" height="9" width="9" style="vertical-align: 0px;" /> is smooth enough (say, <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a48f6182579bff650197c4d2372e626d_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#67;&#94;&#49;" title="Rendered by QuickLaTeX.com" height="16" width="19" style="vertical-align: 0px;" />). Thus, for all initial data <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-68beca4bcad52262077bea01e058fe48_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#95;&#48;&#32;&#92;&#105;&#110;&#32;&#76;&#94;&#50;&#40;&#92;&#109;&#97;&#116;&#104;&#98;&#98;&#123;&#82;&#125;&#94;&#50;&#41;" title="Rendered by QuickLaTeX.com" height="21" width="94" style="vertical-align: -5px;" /> there exists an unique solution in the class <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-de30d63fe67346256424d4f29592b08c_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#67;&#40;&#091;&#48;&#44;&#32;&#84;&#093;&#59;&#32;&#76;&#94;&#50;&#40;&#92;&#109;&#97;&#116;&#104;&#98;&#98;&#123;&#82;&#125;&#94;&#50;&#41;&#41;" title="Rendered by QuickLaTeX.com" height="22" width="131" style="vertical-align: -6px;" />.</p>
<p>Let us consider the inverse design problem: Given a target function <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f9563da9419611e9de3c4b493dc857ad_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#42;&#32;&#61;&#32;&#117;&#94;&#42;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="104" style="vertical-align: -5px;" /> at <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f86a2227fd048f89ba8ff7295f735387_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#84;" title="Rendered by QuickLaTeX.com" height="15" width="45" style="vertical-align: -1px;" />, to determine the initial condition <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-bd421b5f9cc4b54f52392081f3df2e0a_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#95;&#48;" title="Rendered by QuickLaTeX.com" height="12" width="16" style="vertical-align: -3px;" /> such that <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-62163ada462a925a2d935909d0289c0b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#32;&#121;&#44;&#32;&#84;&#41;&#32;&#92;&#101;&#113;&#117;&#105;&#118;&#32;&#117;&#94;&#42;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="162" style="vertical-align: -5px;" />.</p>
<p>The problem could be easily addressed solving the equation (<a href="#id3868366351">4</a>) backwards in time from the final datum <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e683cf490d4bbfa843678bd48a89442b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#42;" title="Rendered by QuickLaTeX.com" height="14" width="16" style="vertical-align: 0px;" /> at <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f86a2227fd048f89ba8ff7295f735387_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#84;" title="Rendered by QuickLaTeX.com" height="15" width="45" style="vertical-align: -1px;" />, to determine <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-19483e298575adce51f93a9ea510f4c0_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#95;&#48;&#61;&#117;&#40;&#120;&#44;&#32;&#121;&#44;&#32;&#48;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="112" style="vertical-align: -5px;" /> exactly. But we are interested in addressing it from the point of view of optimal control. Let us therefore define the following functional, as a classical measure of the quadratic error with respect to the target function <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e683cf490d4bbfa843678bd48a89442b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#42;" title="Rendered by QuickLaTeX.com" height="14" width="16" style="vertical-align: 0px;" />:<br />
<a name="id2452523698"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (5) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-140a9df2851e710c02965eb0e3d7045e_l3.png" height="42" width="231" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#74;&#40;&#117;&#41;&#61;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#49;&#125;&#123;&#50;&#125;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#108;&#101;&#102;&#116;&#40;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#32;&#92;&#114;&#105;&#103;&#104;&#116;&#41;&#94;&#50;&#32;&#100;&#83; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>The derivation of the adjoint equation can be achieved by simply multiplying by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-4ef8cf94d8f10416a5234a5f6b3f695e_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#61;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#120;&#44;&#121;&#44;&#116;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="107" style="vertical-align: -5px;" /> and integrating over a control volume <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-2d4c316831b8619f3e16c795ef05083a_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;&#32;&#92;&#116;&#105;&#109;&#101;&#115;&#32;&#091;&#48;&#44;&#84;&#093;" title="Rendered by QuickLaTeX.com" height="20" width="77" style="vertical-align: -6px;" /></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (6) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-dc7867038de1fe60ac54b60e06004ea7_l3.png" height="42" width="288" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#108;&#101;&#102;&#116;&#40;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#40;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#117;&#41;&#32;&#92;&#114;&#105;&#103;&#104;&#116;&#41;&#32;&#100;&#83;&#32;&#100;&#116;&#61;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Integrating by parts</p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (7) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5a75e7a548b300f9146ac534a6b95e64_l3.png" height="42" width="613" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#117;&#32;&#92;&#118;&#101;&#114;&#116;&#95;&#48;&#94;&#84;&#32;&#100;&#83;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#117;&#32;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#100;&#83;&#32;&#100;&#116;&#32;&#43; &#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#111;&#105;&#110;&#116;&#95;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#117;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#110;&#125;&#32;&#100;&#108;&#32;&#100;&#116;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#117;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#100;&#83;&#32;&#100;&#116;&#61;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-2b649edb8c76189fb68ece8b821c6ab8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;" title="Rendered by QuickLaTeX.com" height="14" width="24" style="vertical-align: 0px;" /> is the boundary and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-400cb5ccfdc03d5cef3e429d63ef6583_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#110;&#125;" title="Rendered by QuickLaTeX.com" height="9" width="9" style="vertical-align: 0px;" /> is the outward normal direction to the surface <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-935eef2f3e0a194501d32e2cd067ff88_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;" title="Rendered by QuickLaTeX.com" height="13" width="13" style="vertical-align: 0px;" /> respectively.</p>
<p>It is feasible to take Gateaux derivatives with respect to the variable <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ca96e0dc0bb325e9ad1b1243f2050152_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;" title="Rendered by QuickLaTeX.com" height="9" width="9" style="vertical-align: 0px;" /> in this identity getting:<br />
<a name="id1756110249"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (8) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-6888056be85cb5ec7b6093e138c2755e_l3.png" height="42" width="624" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#118;&#101;&#114;&#116;&#95;&#48;&#94;&#84;&#32;&#100;&#83;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#100;&#83;&#32;&#100;&#116;&#32;&#43; &#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#111;&#105;&#110;&#116;&#95;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#110;&#125;&#32;&#100;&#108;&#32;&#100;&#116;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#100;&#83;&#32;&#100;&#116;&#61;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Gathering appropriately the terms:<br />
<a name="id234599505"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 71px;"><span class="ql-right-eqno"> (9) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-209277fde91a6777ed62d2d0e243b892_l3.png" height="71" width="591" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#111;&#118;&#101;&#114;&#98;&#114;&#97;&#99;&#101;&#123;&#92;&#108;&#101;&#102;&#116;&#40;&#32;&#45;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#45;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#114;&#105;&#103;&#104;&#116;&#41;&#125;&#94;&#123;&#40;&#92;&#115;&#104;&#97;&#114;&#112;&#41;&#125;&#32;&#100;&#83;&#32;&#100;&#116;&#32;&#43;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#118;&#101;&#114;&#116;&#95;&#48;&#94;&#84;&#32;&#100;&#83;&#32;&#43;&#32;&#92;&#111;&#118;&#101;&#114;&#98;&#114;&#97;&#99;&#101;&#123; &#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#111;&#105;&#110;&#116;&#95;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#110;&#125;&#32;&#100;&#108;&#32;&#100;&#116;&#125;&#94;&#123;&#40;&#92;&#115;&#104;&#97;&#114;&#112;&#32;&#92;&#115;&#104;&#97;&#114;&#112;&#41;&#125;&#32;&#61;&#32;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Let us select <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-939150555b7a7fa3091e0b4fde55095d_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#40;&#92;&#115;&#104;&#97;&#114;&#112;&#41;&#32;&#61;&#32;&#48;" title="Rendered by QuickLaTeX.com" height="20" width="55" style="vertical-align: -5px;" /><br />
<a name="id489333017"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 41px;"><span class="ql-right-eqno"> (10) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-2856d200a992b733bb018a0d0f960b6e_l3.png" height="41" width="147" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#45;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#45;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#61;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>and appropriate boundary conditions for <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ec7e7a9db1763eb6501b50e3bce904d8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#40;&#92;&#115;&#104;&#97;&#114;&#112;&#32;&#92;&#115;&#104;&#97;&#114;&#112;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="26" style="vertical-align: -5px;" /> = 0. Hence (9) becomes</p>
<p><a name="id976999153"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (11) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-9057b2491d4be9d4cc99b436123ccb5f_l3.png" height="40" width="284" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#108;&#101;&#102;&#116;&#091;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#40;&#84;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#40;&#84;&#41;&#32;&#45;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#48;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#40;&#48;&#41;&#92;&#114;&#105;&#103;&#104;&#116;&#093;&#32;&#100;&#83;&#32;&#61;&#32;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Assuming <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-85f3220a7fc839ca0b7fda84d63fa617_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#84;&#41;&#32;&#61;&#32;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;" title="Rendered by QuickLaTeX.com" height="20" width="143" style="vertical-align: -5px;" /><br />
<a name="id1644388199"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (12) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-da0e0609e02333827e3754a87ca9e729_l3.png" height="40" width="338" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#40;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#40;&#84;&#41;&#32;&#100;&#83;&#32;&#61;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#48;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#40;&#48;&#41;&#32;&#100;&#83; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>On the other hand, it is also feasible to take the first variation of <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ddf177ca226c96c8850a9a3f591986ef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#74;" title="Rendered by QuickLaTeX.com" height="14" width="10" style="vertical-align: 0px;" /> with respect to <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ca96e0dc0bb325e9ad1b1243f2050152_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;" title="Rendered by QuickLaTeX.com" height="9" width="9" style="vertical-align: 0px;" /> in (<a href="#id2452523698">5</a>)<br />
<a name="id3310359949"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (13) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-87b4e695e63bce19cd51f23b0cc53146_l3.png" height="40" width="265" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#100;&#101;&#108;&#116;&#97;&#32;&#74;&#40;&#117;&#41;&#61;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#40;&#84;&#41;&#32;&#92;&#108;&#101;&#102;&#116;&#40;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#32;&#92;&#114;&#105;&#103;&#104;&#116;&#41;&#32;&#100;&#83; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Finally,<br />
<a name="id3472992234"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (14) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f484e2bfae818579ba2d92c36ef70605_l3.png" height="40" width="408" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#100;&#101;&#108;&#116;&#97;&#32;&#74;&#40;&#117;&#41;&#32;&#61;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#40;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#40;&#84;&#41;&#32;&#100;&#83;&#32;&#61;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#48;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#40;&#48;&#41;&#32;&#100;&#83; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>This derivation led to the adjoint equation <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-c22318e8b063b8569692358f59cf89dd_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#40;&#92;&#115;&#104;&#97;&#114;&#112;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="19" style="vertical-align: -5px;" />:<br />
<a name="id2160690333"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 41px;"><span class="ql-right-eqno"> (15) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-30b668b0f67ea240c8757054ec172940_l3.png" height="41" width="333" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#45;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#45;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#61;&#48;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#84;&#41;&#32;&#61;&#32;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#44; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5d352209bb975d7a80f24c8fb25c2c2b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#61;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#120;&#44;&#121;&#44;&#116;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="107" style="vertical-align: -5px;" /> being the adjoint variable.</p>
<p>This equation measures the sensitivity of the solution to changes in the initial condition. It is worth mentioning that the adjoint equation is solved backwards in time (from <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f86a2227fd048f89ba8ff7295f735387_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#84;" title="Rendered by QuickLaTeX.com" height="15" width="45" style="vertical-align: -1px;" /> to <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-1af17191fcef4df29d5eef02e6c2bf91_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#48;" title="Rendered by QuickLaTeX.com" height="15" width="41" style="vertical-align: -1px;" />). In fact, system (<a href="#id2160690333">15</a>) is well-posed if and only if the original system is well posed in the forward sense.</p>
<h4>3. Numerical schemes</h4>
<p>In order to obtain a numerical solution based on a finite volume approach, (<a href="#id3868366351">4</a>) is integrated in a control volume <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e713a5583244ff2e528fd3d4199b2ae3_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#32;&#92;&#116;&#105;&#109;&#101;&#115;&#32;&#091;&#116;&#94;&#110;&#44;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#093;" title="Rendered by QuickLaTeX.com" height="22" width="112" style="vertical-align: -6px;" /> where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-7d72e89d608d7ba733d1376f4e5e7129_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;" title="Rendered by QuickLaTeX.com" height="16" width="19" style="vertical-align: -3px;" /> represents each computational cell of the domain and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-1ed54c00626c62ad43745a7c5d9a6822_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#61;&#116;&#94;&#110;&#43;&#92;&#68;&#101;&#108;&#116;&#97;&#32;&#116;" title="Rendered by QuickLaTeX.com" height="18" width="123" style="vertical-align: -2px;" /></p>
<p class="ql-center-displayed-equation" style="line-height: 49px;"><span class="ql-right-eqno"> (16) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-6a5e93b5bbf327d2fd09e119ea7b0a0c_l3.png" height="49" width="295" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#116;&#94;&#110;&#125;&#94;&#123;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#125;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#92;&#108;&#101;&#102;&#116;&#40;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#40;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#117;&#41;&#32;&#92;&#114;&#105;&#103;&#104;&#116;&#41;&#32;&#100;&#83;&#32;&#100;&#116;&#61;&#32;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Using the Gauss divergence theorem<br />
<a name="id2364164987"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 48px;"><span class="ql-right-eqno"> (17) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-3e07d2c135741efa1ab7838f5da807fc_l3.png" height="48" width="522" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#41;&#100;&#83;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#116;&#94;&#123;&#110;&#125;&#41;&#100;&#83;&#32;&#43;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#116;&#94;&#110;&#125;&#94;&#123;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#125;&#32;&#92;&#111;&#105;&#110;&#116;&#95;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#102;&#125;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#110;&#125;&#32;&#92;&#59;&#32;&#100;&#109;&#32;&#92;&#59;&#32;&#100;&#116;&#61;&#32;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ce7806862f77c8c8a2b0b8c364077310_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#102;&#125;&#32;&#61;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#117;" title="Rendered by QuickLaTeX.com" height="14" width="51" style="vertical-align: 0px;" /> is the flux, <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-6be11a5a16c770aacf04114b79d80e3b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;" title="Rendered by QuickLaTeX.com" height="17" width="30" style="vertical-align: -3px;" /> denotes the surface surrounding the volume <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-7d72e89d608d7ba733d1376f4e5e7129_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;" title="Rendered by QuickLaTeX.com" height="16" width="19" style="vertical-align: -3px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f717fca1a35be34459a1847549a13dde_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#110;&#125;&#61;&#40;&#110;&#95;&#120;&#44;&#110;&#95;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="21" width="94" style="vertical-align: -6px;" /> its unit normal vector. The last contour integral in (<a href="#id2364164987">17</a>) can be replaced by the sum of the fluxes defined at each edge <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-da785b053ff378eed556e47adadc339c_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#107;" title="Rendered by QuickLaTeX.com" height="14" width="10" style="vertical-align: 0px;" /> of length <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-6f44504a25a3fc1bad03d7f1b659449d_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#108;&#95;&#107;" title="Rendered by QuickLaTeX.com" height="17" width="11" style="vertical-align: -3px;" />:<br />
<a name="id2854128122"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 53px;"><span class="ql-right-eqno"> (18) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-c346383c1a72e1187874488309deeac2_l3.png" height="53" width="510" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#41;&#100;&#83;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#116;&#94;&#123;&#110;&#125;&#41;&#100;&#83;&#32;&#43;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#116;&#94;&#110;&#125;&#94;&#123;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#125;&#32;&#92;&#115;&#117;&#109;&#92;&#108;&#105;&#109;&#105;&#116;&#115;&#95;&#123;&#107;&#61;&#49;&#125;&#94;&#123;&#78;&#95;&#69;&#125;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#102;&#125;&#95;&#107;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#110;&#125;&#95;&#107;&#32;&#108;&#95;&#107;&#32;&#100;&#116;&#61;&#32;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>with <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-103682a409e6b318185c972df4317475_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#78;&#95;&#69;" title="Rendered by QuickLaTeX.com" height="17" width="23" style="vertical-align: -3px;" /> is the number of edges of each cell <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-76f659eac61b53ea391c745b0c71fca3_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#105;" title="Rendered by QuickLaTeX.com" height="14" width="5" style="vertical-align: 0px;" /> (<img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f2e57efadd760689fb27eeb2ec638e37_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#78;&#95;&#69;&#61;&#51;" title="Rendered by QuickLaTeX.com" height="17" width="58" style="vertical-align: -3px;" /> is for triangular grids) with neighbouring cells <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-921604e76e15f16aca895006fdc22edb_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#106;&#95;&#107;" title="Rendered by QuickLaTeX.com" height="18" width="15" style="vertical-align: -4px;" />. Figure 2 clarifies the meaning of each variable.<br />
<figure id="attachment_348" style="width: 562px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/sketch.jpg" alt="Sketch of the 2D finite volume approach." width="562" height="446" class="size-full wp-image-348" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 2. Sketch of the 2D finite volume approach</i></figcaption></figure></p>
<p>In this work two numerical schemes are proposed: a first order upwind (FOU) scheme and a second order upwind (SOU) scheme based on MUSCL-Hancock approach. The details of the implementation can be found in [7] and [6, 9] respectively. The use of a SOU scheme for the flow equation (forward) is mandatory in order to achieve the best accuracy since the FOU scheme is unable to capture the detail for the equation of state when trying to reach the target function. The issue of using one or another approach for solving the adjoint equation and, consequently, the gradient direction approach, is worth analysing.</p>
<h4>4. Test case: Doswell frontogenesis</h4>
<p>This test case was firstly proposed (in a forward sense) in [3]. It symbolizes the presence of horizontal temperature gradients and fronts in the context of meteorological dynamics. The original problem consists of a computational domain <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-46ef7f79829f85449491de1fcd817e4b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;&#61;&#091;&#45;&#53;&#44;&#53;&#093;" title="Rendered by QuickLaTeX.com" height="20" width="89" style="vertical-align: -6px;" /> with open boundary conditions in which a front defined by the following initial condition:<br />
<a name="id1808989430"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (19) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-eb67818383ec5c06a1c0a92d06638a60_l3.png" height="42" width="172" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;&#61;&#92;&#116;&#97;&#110;&#104;&#92;&#108;&#101;&#102;&#116;&#40;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#121;&#125;&#123;&#92;&#100;&#101;&#108;&#116;&#97;&#125;&#92;&#114;&#105;&#103;&#104;&#116;&#41; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>is advected under the velocity field given by</p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (20) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-941bea2d8c5c4a7e149700faf530a629_l3.png" height="40" width="562" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#61;&#40;&#45;&#121;&#32;&#92;&#32;&#103;&#40;&#114;&#41;&#44;&#120;&#32;&#92;&#32;&#103;&#40;&#114;&#41;&#41;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#103;&#40;&#114;&#41;&#61;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#49;&#125;&#123;&#114;&#125;&#32;&#92;&#111;&#118;&#101;&#114;&#108;&#105;&#110;&#101;&#123;&#118;&#125;&#32;&#92;&#32;&#92;&#116;&#101;&#120;&#116;&#123;&#115;&#101;&#99;&#104;&#125;&#94;&#50;&#40;&#114;&#41;&#32;&#92;&#116;&#97;&#110;&#104;&#40;&#114;&#41;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#92;&#111;&#118;&#101;&#114;&#108;&#105;&#110;&#101;&#123;&#118;&#125;&#61;&#50;&#46;&#53;&#57;&#56;&#48;&#55; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-48af324422cc583dd084e15a5f79c588_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#114;&#61;&#92;&#115;&#113;&#114;&#116;&#123;&#120;&#94;&#50;&#43;&#121;&#94;&#50;&#125;" title="Rendered by QuickLaTeX.com" height="21" width="111" style="vertical-align: -4px;" />. The exact solution (the projection or restriction of the analytical solution on the computational mesh) on the whole space <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-87d9474a86518670a57fb9024432e996_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#109;&#97;&#116;&#104;&#98;&#98;&#123;&#82;&#125;&#94;&#50;" title="Rendered by QuickLaTeX.com" height="16" width="21" style="vertical-align: 0px;" /> has the following explicit form:</p>
<p><a name="id4037667042"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 43px;"><span class="ql-right-eqno"> (21) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-c990281a65e430f338a668c0f3cbcc6f_l3.png" height="43" width="331" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#117;&#40;&#120;&#44;&#121;&#44;&#116;&#41;&#61;&#92;&#116;&#97;&#110;&#104;&#92;&#108;&#101;&#102;&#116;&#40;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#121;&#32;&#92;&#99;&#111;&#115;&#40;&#103;&#116;&#41;&#32;&#45;&#32;&#120;&#32;&#92;&#32;&#92;&#115;&#105;&#110;&#40;&#103;&#116;&#41;&#125;&#123;&#92;&#100;&#101;&#108;&#116;&#97;&#125;&#92;&#114;&#105;&#103;&#104;&#116;&#41; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>It is important to mention that the velocity field is divergence-free. The state equation can the be written similarly in divergence or non-divergence form:</p>
<p class="ql-center-displayed-equation" style="line-height: 41px;"><span class="ql-right-eqno"> (22) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-4165c9e553f4e7885a66dc9b8906fb39_l3.png" height="41" width="286" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#100;&#102;&#114;&#97;&amp;##99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#40;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#32;&#117;&#41;&#32;&#61;&#32;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#40;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#41;&#32;&#117;&#61;&#48;&#44; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>because</p>
<p class="ql-center-displayed-equation" style="line-height: 17px;"><span class="ql-right-eqno"> &nbsp; </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-49e362893033310594c5349ebaf6b112_l3.png" height="17" width="77" class="ql-img-displayed-equation quicklatex-auto-format" alt="&#92;&#091;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#101;&#113;&#117;&#105;&#118;&#32;&#48;&#44;&#92;&#093;" title="Rendered by QuickLaTeX.com" /></p>
<p>This allows us to formulate the problem of inverse design. Given the exact value of the solution at time <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f86a2227fd048f89ba8ff7295f735387_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#84;" title="Rendered by QuickLaTeX.com" height="15" width="45" style="vertical-align: -1px;" />, i.e. giving (<a href="#id4037667042">21</a>) as a target function at <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f86a2227fd048f89ba8ff7295f735387_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#84;" title="Rendered by QuickLaTeX.com" height="15" width="45" style="vertical-align: -1px;" />, we aim to recover by a computational version of the gradient-adjoint methodology described above, an accurate and efficient approximation of the initial datum (<a href="#id1808989430">19</a>).</p>
<p>In our numerical experiments we take the values <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-0b67a2dd1c7985c6cc60c86d54f8dee8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#100;&#101;&#108;&#116;&#97;&#61;&#49;" title="Rendered by QuickLaTeX.com" height="14" width="42" style="vertical-align: 0px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-56771b082318c68ab77b07b4f6de69ce_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#84;&#61;&#52;&#115;" title="Rendered by QuickLaTeX.com" height="14" width="55" style="vertical-align: 0px;" />. The exact initial condition and the exact target are shown in Figure 3 (left and right respectively). As can be seen, the target presents a vortex-type profile, due to the heterogeneous geometry of the velocity field.</p>
<p>Our goal is to build a numerical method capable of predicting accurately and efficiently an approximation of (<a href="#id1808989430">19</a>) out of the target (<a href="#id4037667042">21</a>) by means of a numerical version of the optimisation algorithm above.</p>
<p><!--table width="100%">


<tr>


<td>
[caption id="attachment_1" align="aligncenter" width="231"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellLegend_u0.jpg" alt="L_2 errors" width="231" height="446" class="size-full wp-image-1" /> [/caption]
</td>




<td>
[caption id="attachment_2" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellExact_u0.jpg" alt="L_2 errors"  width="562" height="446" class="size-full wp-image-2" /> [/caption]
</td>




<td>
[caption id="attachment_3" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellExact_uT.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-3"  /> [/caption]
</td>




<td>
[caption id="attachment_4" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellLegend_uT.eps_.jpg" alt="L_2 errors" width="562" height="446"  class="size-medium wp-image-4" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_3" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure03.jpg" alt="Figure 3" width="1233" height="535" class="size-full wp-image-3" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 3: Doswell frontogenesis: Exact initial condition (left) and target function (right) for the inverse problem</i></figcaption></figure></p>
<p>The domain is discretized in 39998 unstructured triangles using <i>Triangle</i> [8] in a uniform Delaunay mesh. The initial condition for the first iteration is <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ced16b0bf76e477959072207a391d07b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#48;&#40;&#120;&#44;&#121;&#44;&#48;&#41;&#61;&#48;" title="Rendered by QuickLaTeX.com" height="21" width="113" style="vertical-align: -5px;" />. Both the forward and backward resolution are parallelized with OPENMP in 4 cores. The maximum number of iterations for the gradient method is set to 75, a constant step <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e3d3b3832910e781276f174031db070f_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#118;&#97;&#114;&#101;&#112;&#115;&#105;&#108;&#111;&#110;&#61;&#48;&#46;&#53;" title="Rendered by QuickLaTeX.com" height="14" width="57" style="vertical-align: 0px;" /> is selected and the Courant number is set to <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-921be6463c87a1d3f0f95f3b323c006e_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#67;&#70;&#76;&#61;&#48;&#46;&#53;" title="Rendered by QuickLaTeX.com" height="14" width="84" style="vertical-align: 0px;" />.</p>
<p>Additionally, the step size <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-84590752e1778f03d293c972f9f2b81a_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#118;&#97;&#114;&#101;&#112;&#115;&#105;&#108;&#111;&#110;" title="Rendered by QuickLaTeX.com" height="9" width="8" style="vertical-align: 0px;" /> is set as a constant at the beginning of each iteration. However, if the convergence is not guaranteed, i.e., <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-0a7984d8454e25bcb3b6fe6fa7c099f7_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#74;&#94;&#123;&#107;&#43;&#49;&#125;&#62;&#61;&#74;&#94;&#107;" title="Rendered by QuickLaTeX.com" height="17" width="96" style="vertical-align: -1px;" />, the step size is halved until <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-1bd51b5296f2306b888d2d4f533985c5_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#74;&#94;&#123;&#107;&#43;&#49;&#125;&#60;&#74;&#94;&#107;" title="Rendered by QuickLaTeX.com" height="18" width="82" style="vertical-align: -2px;" />. Therefore, the stopping criteria for the iterative algorithm are:</p>
<ol>
<li> To reach the maximum number of iterations</li>
<li> To achieve the maximum allowable error of the functional, in this case, <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-34db956f2bdeb30eb9d8dbff34707d63_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#49;&#48;&#94;&#123;&#45;&#57;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="35" style="vertical-align: 0px;" /></li>
<li> To descend below <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-30bc3ea2f95c1fbbc940344aefba41a0_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#118;&#97;&#114;&#101;&#112;&#115;&#105;&#108;&#111;&#110;&#95;&#123;&#109;&#105;&#110;&#125;&#32;&#61;&#32;&#49;&#48;&#94;&#123;&#45;&#54;&#125;" title="Rendered by QuickLaTeX.com" height="19" width="95" style="vertical-align: -3px;" /> when halving the step size <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-84590752e1778f03d293c972f9f2b81a_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#118;&#97;&#114;&#101;&#112;&#115;&#105;&#108;&#111;&#110;" title="Rendered by QuickLaTeX.com" height="9" width="8" style="vertical-align: 0px;" /> trying to achieve convergence.</li>
</ol>
<p>The numerical results are shown in Figures 4, 5 and 6 for the target <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-15280474116fc5ccee16cbd3f5502660_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#84;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="74" style="vertical-align: -5px;" />, initial condition <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ccd995a9094d46a3d094500b8ae69bc2_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="70" style="vertical-align: -5px;" /> and adjoint <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-8e1c9c50773cab4bcc7025ecfa04b82c_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#40;&#120;&#44;&#121;&#44;&#48;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="71" style="vertical-align: -5px;" /> respectively at the last iteration of the gradient method. On the left side the <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> approach is displayed while the <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> resolution is illustrated on the right side.</p>
<p><!--table width="100%">


<tr>


<td>
[caption id="attachment_5" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellFOU_uT.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-5" /> [/caption]
</td>




<td>
[caption id="attachment_6" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellSOU_uT.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-6" /> [/caption]
</td>




<td>
[caption id="attachment_7" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellLegend_uT.jpg" alt="L_2 errors" width="562" height="446"  class="size-full wp-image-7" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_4" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure04.jpg" alt="Figure 4" width="1233" height="535" class="size-full wp-image-4" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 4: Doswell frontogenesis: Numerical target <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-15280474116fc5ccee16cbd3f5502660_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#84;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="74" style="vertical-align: -5px;" /> achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> (left) and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> (right)</i></figcaption></figure><br />
<!--table width="100%">


<tr>


<td>
[caption id="attachment_8" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellFOU_u0.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-8" /> [/caption]
</td>




<td>
[caption id="attachment_9" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellSOU_u0.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-9" /> [/caption]
</td>




<td>
[caption id="attachment_10" align="aligncenter" height="562" ]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellLegend_u0.jpg" alt="L_2 errors"  width="562" height="446" class="size-full wp-image-10" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_4" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure05.jpg" alt="Figure 5" width="1233" height="535" class="size-full wp-image-5" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 5: Doswell frontogenesis: Numerical initial condition <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ccd995a9094d46a3d094500b8ae69bc2_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="70" style="vertical-align: -5px;" /> achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> (left) and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> (right)</i></figcaption></figure></p>
<p>In order to complete the qualitative results, the error computed as the difference between the exact and the numerical approximation is displayed in Figures 7 and 8 for the target <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-8ab130fe2665eca0880e1cd9876e9939_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#84;&#41;&#32;&#45;&#32;&#117;&#94;&#42;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="159" style="vertical-align: -5px;" /> and the initial datum <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-d650b3a0651e369d9401d8338a5650f8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;&#32;&#45;&#32;&#117;&#94;&#101;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="156" style="vertical-align: -5px;" />.</p>
<p><!--table width="100%">


<tr>


<td>
[caption id="attachment_11" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellFOU_adj.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-11" /> [/caption]
</td>




<td>
[caption id="attachment_12" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellSOU_adj.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-12" /> [/caption]
</td>




<td>
[caption id="attachment_13" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellLegend_adj.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-13" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_6" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure06.jpg" alt="Figure 6" width="1233" height="535" class="size-full wp-image-6" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 6: Doswell frontogenesis: Numerical adjoint variable <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-d3cff7a72b42d080ab8451c9a36f22cd_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#120;&#44;&#121;&#44;&#48;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="71" style="vertical-align: -5px;" /> achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> (left) and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> (right)</i></figcaption></figure></p>
<p><!--table width="100%">


<tr>


<td>
[caption id="attachment_14" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/diffuT_FOU.png.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-14" /> [/caption]
</td>




<td>
[caption id="attachment_15" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/diffuT_SOU.png.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-15" /> [/caption]
</td>




<td>
[caption id="attachment_16" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/legendDiffuT.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-16" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_7" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure07.jpg" alt="Figure 7" width="1233" height="535" class="size-full wp-image-7" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 7: Doswell frontogenesis: Target error <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-8ab130fe2665eca0880e1cd9876e9939_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#84;&#41;&#32;&#45;&#32;&#117;&#94;&#42;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="159" style="vertical-align: -5px;" /> achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> (left) and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> (right)</i></figcaption></figure></p>
<p><!--table width="100%">


<tr>


<td>
[caption id="attachment_17" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/diffu0_FOU.jpg" alt="L_2 errors"  width="562" height="446"  class="size-full wp-image-17" /> [/caption]
</td>




<td>
[caption id="attachment_18" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/diffu0_SOU.jpg" alt="L_2 errors"  width="562" height="446"  class="size-full wp-image-18" /> [/caption]
</td>




<td>
[caption id="attachment_19" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/legendDiffu0.jpg" alt="L_2 errors"  width="125" height="446"  class="size-full wp-image-19" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_8" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure08.jpg" alt="Figure 7" width="1233" height="535" class="size-full wp-image-8" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 8: Doswell frontogenesis: Initial datum error <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-d650b3a0651e369d9401d8338a5650f8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;&#32;&#45;&#32;&#117;&#94;&#101;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="156" style="vertical-align: -5px;" /> achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> (left) and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> (right)</i></figcaption></figure></p>
<p>Quantitative results can be obtained by means of the computation of <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a85046948103e25fba30bb74a008ae93_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#50;" title="Rendered by QuickLaTeX.com" height="17" width="17" style="vertical-align: -3px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a5978030bdf2e33c5f20248b7890641c_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#123;&#92;&#105;&#110;&#102;&#116;&#121;&#125;" title="Rendered by QuickLaTeX.com" height="18" width="24" style="vertical-align: -4px;" /> norms, not only with respect to the target function but also to the known exact initial condition <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-8d8312fb4575ee14f33a12f12eee253e_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#101;" title="Rendered by QuickLaTeX.com" height="14" width="16" style="vertical-align: 0px;" /> in order to evaluate the results achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" />:<br />
<a name="id3463475655"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 132px;"><span class="ql-right-eqno"> (23) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-2bbbc34f33882a67fb453c742ffc35ff_l3.png" height="132" width="577" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#115;&#112;&#108;&#105;&#116;&#125; &#76;&#95;&#50;&#32;&#40;&#117;&#94;&#84;&#41;&#32;&#61;&#32;&#92;&#115;&#113;&#114;&#116;&#123;&#92;&#115;&#117;&#109;&#95;&#105;&#94;&#78;&#32;&#40;&#117;&#40;&#120;&#95;&#105;&#44;&#84;&#41;&#45;&#117;&#94;&#42;&#40;&#120;&#95;&#105;&#41;&#41;&#94;&#50;&#125;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#76;&#95;&#123;&#92;&#105;&#110;&#102;&#116;&#121;&#125;&#32;&#40;&#117;&#94;&#84;&#41;&#32;&#61;&#32;&#92;&#109;&#97;&#120;&#95;&#105;&#32;&#124;&#117;&#40;&#120;&#95;&#105;&#44;&#84;&#41;&#45;&#117;&#94;&#42;&#40;&#120;&#95;&#105;&#41;&#124;&#32;&#92;&#92; &#76;&#95;&#50;&#32;&#40;&#117;&#94;&#48;&#41;&#32;&#61;&#32;&#92;&#115;&#113;&#114;&#116;&#123;&#92;&#115;&#117;&#109;&#95;&#105;&#94;&#78;&#32;&#40;&#117;&#40;&#120;&#95;&#105;&#44;&#48;&#41;&#45;&#117;&#94;&#101;&#40;&#120;&#95;&#105;&#41;&#41;&#94;&#50;&#125;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#76;&#95;&#123;&#92;&#105;&#110;&#102;&#116;&#121;&#125;&#32;&#40;&#117;&#94;&#48;&#41;&#32;&#61;&#32;&#92;&#109;&#97;&#120;&#95;&#105;&#32;&#124;&#117;&#40;&#120;&#95;&#105;&#44;&#48;&#41;&#45;&#117;&#94;&#101;&#40;&#120;&#95;&#105;&#41;&#124; &#92;&#101;&#110;&#100;&#123;&#115;&#112;&#108;&#105;&#116;&#125; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Table 1 condenses this information as well as the number of iterations and the CPU time for each proposed scheme. For the sake of clarity and for each comparison, the best results are highlighted in bold font.</p>
<table width="100%">
<tr>
<th> Scheme </th>
<th> <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a85046948103e25fba30bb74a008ae93_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#50;" title="Rendered by QuickLaTeX.com" height="17" width="17" style="vertical-align: -3px;" /> (<img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-55b08c6b8db1d876d0e8e76cc21c498b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#84;" title="Rendered by QuickLaTeX.com" height="16" width="19" style="vertical-align: 0px;" />) </th>
<th> <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-01cfd5ffded0366d1126a740fd5b4abe_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#92;&#105;&#110;&#102;&#116;&#121;" title="Rendered by QuickLaTeX.com" height="18" width="24" style="vertical-align: -4px;" /> (<img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-55b08c6b8db1d876d0e8e76cc21c498b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#84;" title="Rendered by QuickLaTeX.com" height="16" width="19" style="vertical-align: 0px;" />) </th>
<th> <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a85046948103e25fba30bb74a008ae93_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#50;" title="Rendered by QuickLaTeX.com" height="17" width="17" style="vertical-align: -3px;" /> (<img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ca25e1ef94b9399e0e1ff81669ad2633_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#48;" title="Rendered by QuickLaTeX.com" height="16" width="16" style="vertical-align: 0px;" />) </th>
<th> <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-01cfd5ffded0366d1126a740fd5b4abe_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#92;&#105;&#110;&#102;&#116;&#121;" title="Rendered by QuickLaTeX.com" height="18" width="24" style="vertical-align: -4px;" /> (<img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ca25e1ef94b9399e0e1ff81669ad2633_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#48;" title="Rendered by QuickLaTeX.com" height="16" width="16" style="vertical-align: 0px;" />) </th>
<th> nIters </th>
<th> CPU Time (s)</th>
</tr>
<tr>
<td>
FOU
</td>
<td> 1.37127e+00 </td>
<td> 1.37078e-01 </td>
<td> <b>1.36043e+00</b> </td>
<td> <b>8.64870e-02</b> </td>
<td> 75 </td>
<td> 366.26 </td>
</tr>
<tr>
<td>
SOU
</td>
<td> <b>1.23889e+00</b> </td>
<td> <b>1.34271e-01</b> </td>
<td> 1.88749e+00 </td>
<td> 1.40718e-01 </td>
<td> 45 </td>
<td> 488.61 </td>
</tr>
<table width="100%">
<i align="aligncenter">Table 1: Doswell Frontogenesis: <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a85046948103e25fba30bb74a008ae93_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#50;" title="Rendered by QuickLaTeX.com" height="17" width="17" style="vertical-align: -3px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a5978030bdf2e33c5f20248b7890641c_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#123;&#92;&#105;&#110;&#102;&#116;&#121;&#125;" title="Rendered by QuickLaTeX.com" height="18" width="24" style="vertical-align: -4px;" /> norms, number of iterations and CPU time for the <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /></i>  &lt;/p&gt;
<p>Note that the number of iterations for the <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> approach does not reach the maximum number of iterations set at the beginning of the inverse design process because at iteration 45, the functional is not able to diminish its value to the next iteration due to the deterioration of the initial condition by the high frequencies.</p>
</table></table>
<p>&lt;/p&gt;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h5&gt;1. Problem formulation&lt;/h5&gt;
</code></pre></div></div>
<p>Let $\Omega\subset \mathbb R^d$ be an open and bounded Lipschitz Domain and consider the parameter dependent parabolic equation with Dirichlet boundary conditions</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{heat_intro}
\begin{cases}
y_{t}-\text{div}(a(x,\nu)\nabla y) +c\, y=\chi_\omega u \quad &\text{in } Q=\Omega\times(0,T), \\
y=0 \quad &\text{on } \Sigma=\partial\Omega\times(0,T), \\
y(x,0)=y^0(x) \quad&\text{in } \Omega,
\end{cases}
\end{equation} %]]></script>

<p>where $y=y(x,t;\nu)$ is the state, $u=u(x,t)$ is a control function and $y_0$ is given initial datum.</p>

<p>In (1), $a(x,\nu)$ is a scalar $L^\infty(\Omega)$ coefficient depending on some parameter $\nu$ and $c=c(x)\in L^\infty(\Omega)$ is given. To abridge the notation, we will denote $a_\nu=a(x,\nu)$.</p>

<p>Now, consider the following associated optimal control problem</p>

<script type="math/tex; mode=display">\begin{equation}\label{min_evo_intro}
\min_{u\in L^2(0,T;L^2(\omega))} \, J^T(u)=\frac{1}{2}\int_{0}^T|u(t)|^2_{L^2(\omega)}+\frac{\beta}{2}\int_{0}^T\|y(t)-y_d\|^2_{L^2(\Omega)},
\end{equation}</script>

<p>where $y$ is the solution to (1), $y_d\in L^2(\Omega)$ is a desired observation and $\beta&gt;0$ is given.</p>

<p>It is classical to prove (see e.g., [3]) that the minimization problem (2) has a unique optimal solution that hereinafter we denote by  $(u^T,y^T)$. Moreover, the optimal control is given by</p>

<script type="math/tex; mode=display">\begin{equation*}\label{opt_evo}
u^T=-\chi_\omega p^T
\end{equation*}</script>

<p>where $q^T$ can be found from the solution $(y^T,p^T)$ of the optimality system</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{opt_sys_evolution}
\begin{cases}
y^T_t-\text{div}(a_\nu \nabla y^T) +c\, y^T =-\chi_\omega p^T, \quad &\text{in } Q, \\
-p_t^T-\text{div}(a_\nu \nabla p^T) +c\, p^T=\beta\,(y^T-y_d), \quad &\text{in } Q, \\
y^T=q^T=0, \quad &\text{on } \Sigma, \\
y^T(x,0)=y^0, \quad q^T(x,T)=0, \quad &\text{in } \Omega.
\end{cases}
\end{equation} %]]></script>

<p>In this work, we use a combination of (weak) greedy methods and the so-called <i>turnpike</i> property to determine the most relevant values of a parameter-space providing the best possible approximation of the set of parameter dependent optimal controls.</p>

<p>Firstly, we will use the <i>turnpike</i> property to reduce the problem of computing the time-dependent optimal controls $u^T$ by computing asymptotic simplifications.</p>

<p>To this end, we begin by considering the stationary version of the state equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{steady_state}
\begin{cases}
-\text{div}(a_\nu \nabla y)+c \, y=\chi_\omega u \quad &\text{in } \Omega, \\
y=0 \quad &\text{on } \partial \Omega. \\
\end{cases}
\end{equation} %]]></script>

<p>Now, consider the corresponding minimization problem</p>

<script type="math/tex; mode=display">\begin{equation}\label{min_steady_intro}
\min_{u\in L^2(\omega)} \, J(u)=\frac{1}{2}|u|^2_{L^2(\omega)}+\frac{\beta}{2}\|y-y_d\|^2_{L^2(\Omega)}.
\end{equation}</script>

<p>As before, one can prove that, since $J$ is strictly convex, continuous and coercive, the minimization problem (5) has a unique optimal solution $(\bar u, \bar y)$, where the optimal control is characterized by</p>

<script type="math/tex; mode=display">\begin{equation*}
\bar u=-\chi_\omega \bar p,
\end{equation*}</script>

<p>and $(\bar y, \bar p)$ solve the optimality system</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{opt_sys_steady}
\begin{cases}
-\text{div}(a_\nu \nabla \bar y) +c\, \bar y=-\chi_\omega \bar p, \quad &\text{in } \Omega, \\
-\text{div}(a_\nu \nabla \bar p) +c\, \bar p=\beta\,(\bar y-y_d), \quad &\text{in } \Omega, \\
\bar y=\bar p=0, \quad &\text{on } \partial \Omega. \\
\end{cases}
\end{equation} %]]></script>

<p>A natural question that arises in this context is to which extent the long horizon optimal controls and states $(u^T(t),y^T(t))$ approach the steady ones $(\bar u,\bar y)$ as $T\to +\infty$. According to [4], we have the following result:
<strong>Theorem 1.1</strong>
Let us consider the control problem (2) and let $(u^T,y^T)$ be the optimal control and state. Then, there exists $\mu&gt;0$ such that</p>

<script type="math/tex; mode=display">\begin{equation}\label{conv_exponential}
\|y^T(t)-\bar y\|_{L^2(\Omega)}+\|u^T(t)-\bar u\|_{L^2(\Omega)} \leq K\left( e^{-\mu t}+e^{-\mu(T-t)}\right), \quad \forall t\in [0,T],
\end{equation}</script>

<p>where $(\bar u,\bar y)$ is the optimal control and state corresponding to (6).
<!--end{theorem}--></p>

<p>This means that we have exponential convergence of the finite horizon control problems to their steady state version as $T$ tends to infinity.</p>

<p>Thanks to Theorem 1.1, we can now focus our attention on the steady system (4). We begin by assuming the following hypotheses:</p>

<ul>
  <li><strong>H1</strong> The parameter $\nu$ ranges within a compact set $\mathcal K \subseteq \mathbb{R}^d$.</li>
  <li><strong>H2</strong> The coefficient functions $a_\nu$ are bounded functions satisfying uniform coercive and boundedness estimates:
<script type="math/tex">% <![CDATA[
\begin{equation*}
\begin{aligned}
  &  0 < a_1\leq  | a_\nu|_{L^\infty(\Omega)} \leq a_2,\quad  &\nu \in K
\label{UEA}
\end{aligned}
\end{equation*} %]]></script></li>
</ul>

<p>In addition, $a_\nu$ depend on $\nu$ in an analytic manner.</p>

<p>Then, the main idea is to propose a methodology to determine an optimal selection of a finite number of realizations of the parameter $\nu$ so that all controls, for all possible values of $\nu$, are optimally approximated. More precisely, the problem can be formulated as follows:
<strong>Problem 1.2</strong>
Let us consider the set of controls verifying (5) for each possible value $\nu \in \mathcal K$. That is,</p>

<script type="math/tex; mode=display">\begin{equation}
\overline{\mathcal U}=\left\{\bar  u_\nu : \nu\in \mathcal K\right\}.
\end{equation}</script>

<p>This control set is compact in $L^2(\omega)$.</p>

<p>Given $\varepsilon&gt;0$, we seek to determine a family of parameters ${\nu_1,\ldots,\nu_n}$ in $\mathcal K$, whose cardinality $n$ depends on $\varepsilon$, so that the corresponding controls, denoted by $u_{\nu_1},\ldots,u_{\nu_n}$ are such that for every $\nu\in \mathcal K$, there exists $u_\nu^\star\in \text{span}{u_{\nu_1},\ldots,u_{\nu_n}}$ such that</p>

<script type="math/tex; mode=display">\begin{equation*}
\|u_\nu^\star-\bar u_\nu\|\leq \varepsilon.
\end{equation*}</script>

<!--end{problem}-->
<!--/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////-->
<h4>2. Greedy optimal control for elliptic problems</h4>
<h5>2.1. Preliminaries on (weak) greedy algorithms</h5>

<p>In this section, we present a short introduction about linear approximation theory of parametric problems based on (weak) greedy algorithms. For a more detailed read, we refer, for instance, to [1, 2]. In general, the goal is to approximate a  compact set $\mathcal K$ in a Banach space $X$ by a sequence of finite dimensional subspaces $V_n$ of dimension $n$.</p>

<p>The algorithm reads as follows.</p>

<p>The algorithm produces a finite dimensional space $V_n$ that approximates the set $\mathcal K$ within precision $\varepsilon$.</p>

<p>The best choice of an approximating space $V_n$ is the one producing the smallest approximation error. This smallest error for a compact set $\mathcal K$ is called the <i>Kolmogorov $n$-width of $\mathcal K$</i>, and is defined as</p>

<script type="math/tex; mode=display">\begin{equation*}
d_n(\mathcal K):=\inf_{\dim Y=n} \sup_{x\in \mathcal K} \, \inf_{y\in Y}  \|{x-y}\|_X\,.
\end{equation*}</script>

<p>It measures how well $\mathcal K$ can be approximated by a subspace in $X$  of a fixed dimension $n$.</p>

<h4>Algorithm 1: Weak greedy algorithm</h4>
<p><strong>initialize:</strong> fix $\gamma\in (0,1]$ and a tolerance parameter $\varepsilon&gt;0$;</p>
<ol>
<li> In the first step, choose $x_1\in\mathcal K$ such that</li>
<li>$\|x_1\|_{ X}\geq \gamma \max_{x\in\mathcal K}\|x\|_X$</li>
<li>At the general step, having found $x_1,\ldots,x_n$ denote </li>
<li>

$$
\begin{equation}
  \label{dist_algo}
$V_n=\text{span}\{x_1,\ldots,x_n\} \quad\text{and}\quad  \sigma_n(\mathcal K):=\max_{x\in \mathcal K}\text{dist}(x,V_n)$;
\end{equation}
$$

</li>
<li><strong>repeat</strong></li>
<li> choose $x_{n+1}$ such that</li>
<li><div align="center">

$$
\text{dist}(x_{n+1},V_n)\geq \gamma\sigma_n(\mathcal K)
$$

</div>
</li>
<li><strong>until</strong>$\sigma_n(\mathcal K)&lt;\varepsilon$</li>
</ol>
<p>&lt;/pre&gt;</p>

<h4>2.2. Definition of the residual</h4>

<p>The main goals of this work is to apply the greedy approach to the family of parameter dependent steady state optimal control problems</p>

<script type="math/tex; mode=display">\begin{equation}\label{min_P}
\left(\mathcal{P}\right) \ \ \ \ \ \ \ \min_{u\in L^2(\omega)} \left\{ J_\nu( u)\right\},
\end{equation}</script>

<p>where $J$ is the cost functional given by</p>

<script type="math/tex; mode=display">\begin{equation*}
\label{J}
J_\nu( u) = \frac{1}{2} |{u}|_{L^2(\omega)}^2 \ + \  \frac{1}{2}   |y_\nu(u)-y^d|^2_{L^2(\Omega)},
\end{equation*}</script>

<p>while $y_\nu(u)$ is the solution to (4).</p>

<p>Essential for an effective application of a greedy algorithm is the construction of a residual by which one can estimate the distance between two (possible unknowns) controls by some easily computable quantity.</p>

<p>In this way, we introduce the residual operator as</p>

<script type="math/tex; mode=display">\begin{equation}
  \label{res}
  \begin{aligned}
    R_\nu(p,y):=\left(
    \begin{matrix}  L_\nu  y+ \chi_\omega p\\
   L_\nu p- \beta\left( y - y^d\right) \\
   \end{matrix}\right).
  \end{aligned}
\end{equation}</script>

<p>The residual $R_\nu(p,y)$ introduced in the previous subsection  enable us to construct a weak greedy algorithm for an effective construction of an approximating linear space of the control manifold. The precise description of the the algorithm is given below
We can summarize the obtained results in the following theorem
<strong>Theorem 2.1</strong>
   The proposed greedy algorithm provides the  following estimates  on the approximate control and approximate optimal state</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
     \begin{aligned}
       & \bullet\quad |u_\nu^\star - \bar u_\nu|_{L^2(\Omega)} \leq \varepsilon, \\
       & \bullet \quad | y_\nu^\star - \bar y_\nu|_{\Omega}
       \leq \left({\varepsilon \over \alpha_1 }\right)
 \end{aligned}
   \end{equation*} %]]></script>

<!--end{theorem}-->
<!--/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////-->
<h4>3. Numerical experiments</h4>
<p>We present here two numerical examples where the greedy approach is applied. To illustrate the procedure, we consider the two dimensional domain $\Omega=(0,1)^2$. We use the elementary finite difference (FD) method. We will approximate the elliptic operator $\mathcal A=-\text{div}(a_\nu\nabla \,\cdot)$ with homogeneous Dirichlet boundary conditions, by using the standard 5-point discretization.</p>

<h4>3.1. Greedy test # 1</h4>
<p>Let us consider a coefficient $a_\nu$ of the form</p>

<script type="math/tex; mode=display">\begin{equation}\label{coef_exp1}
a_\nu(x)=1+\nu(x_1^2+x_2^2)
\end{equation}</script>

<p>where we assume that</p>

<script type="math/tex; mode=display">\begin{equation}\label{range_exp1}
\nu\in [1,10]=\mathcal K.
\end{equation}</script>

<p>In this way, we can readily verify that $a_\nu$ satisfies <b>H1</b> and <b>H2</b>.</p>

<p>On the other hand, we take the coefficient $c$ as</p>

<script type="math/tex; mode=display">\begin{equation*}
c(x)=\sin(\pi x_1)\sin(\pi x_2).
\end{equation*}</script>

<p>which clearly fulfills the condition $c\geq 0$. For the optimal control problem, we set the parameter $\beta=10^4$ while the desired target is the $x_2$-independent function</p>

<script type="math/tex; mode=display">\begin{equation*}
y^d(x)=\sin(2\pi x_1).
\end{equation*}</script>

<p>We take $\omega$ as the region $(0.2,0.5)\times(0,5,0.9)\cup(0.5,0.9)\times(0.1,0.9)$ in the $x_1x_2$-plane (see Figure 2.B).</p>

<h4>Algorithm 2: Greedy control algorithm - offline part</h4>
<p><strong>Initialize:</strong> Fix the approximation error $\varepsilon&gt;0$.</p>
<ol>
<li><strong>STEP 1: (discretisation)</strong></li>
<li>Choose a finite subset $\tilde{\mathcal K}$ such that

$$\forall{\nu} \in \mathcal K \quad  dist(\nu, \tilde{\mathcal K}) &lt;\delta$$

</li>
<li>for  $\delta&gt;0$ a discretization constant.</li>
<li><strong>STEP 2: (Choosing $\nu_1$)</strong></li>
<li>Check the inequality

$$

    \begin{equation}\label{1st_stop}
    	\max_{\tilde{\nu} \in \tilde{\mathcal K}} \|\beta y^{d}_{\nu}\|_{H^{-1}\Omega} &lt;\frac{\varepsilon} 2.\;
    \end{equation}

$$

</li>
<li>If it is satisfied, stop the algorithm. Otherwise, choose the first parameter value as

$$
    \begin{equation}\label{first_sel}
    \nu_1 \in arg\max_{\tilde{\nu} \in \tilde{\mathcal K}} \{ \|y^{d}_{\nu}\|_{H^{-1}(\Omega)}\}.;
    \end{equation}
$$

</li>
<li>and find corresponding optimal primal and dual states $\bar y_1, \bar p_1$;</li>
<li><strong>STEP 3: (Choosing $\nu_{j+1}$)</strong></li>
<li>Having chosen $\nu_1, \ldots, \nu_j$ calculate $R_{\tilde \nu}(\bar p_j, 0)$ and  $R_{\tilde \nu}(0, \bar y_j)$ for each $\tilde \nu \in \tilde{\mathcal K}$.</li>
<li>Check the approximation criteria
<div align="center">

$$

\begin{equation}
\label{stop_crit}
\max_{\tilde\nu \in \tilde{\mathcal K}}   ||\inf_{( p,  y) \in (\overline{\mathcal P}_j, \overline{\mathcal  Y}_j)}
R_{\tilde \nu}(p,  y) ||_{H^{-1}(\Omega)}
&lt; \frac{\varepsilon}2.
\end{equation}

$$

</div>
</li>
<li>If the inequality is satisfied, stop the algorithm. Otherwise, determine the next  parameter value as
<div align="center">

$$

\begin{equation}
\label{step_j}
\nu_{j+1}\in arg\max_{\tilde \nu \in \tilde{\mathcal K}}
|| \inf_{( p,  y) \in (\overline{\mathcal P}_j, \overline{\mathcal  Y}_j)} R_{\tilde \nu}(p,  y) ||_{H^{-1}(\Omega)},
\end{equation}

$$

</div>
</li>
<li>Find the corresponding optimal primal and dual states $\bar y_{j+1}, \bar p_{j+1}$ and repeat Step 3.</li>
</ol>

<p>Since the functional $J_\nu$ is quadratic and coercive, a standard conjugate gradient (CG) algorithm is a simple choice to solve the minimization problem (5). For a given $\nu\in\mathcal K$ one can directly solve the minimization problem (10). The average time for computing the corresponding control up to a given tolerance of $10^{-8}$ using the CG is around six seconds.</p>

<p>Hypotheses <b>H1</b> and <b>H2</b> allow us to implement a <i>naive</i> approach for approximating the parameterized control set $\bar{\mathcal U}(\mathcal K)$. This approach consists in discretizing the parameter set in a very fine mesh, that we denote it by $\tilde{\mathcal K}$, and then computing the corresponding control for each parameter in this finite-dimensional set.</p>

<p>Let us take $\tilde{\mathcal K}$ as the uniform discretization of the interval (13) in $k=100$ values. Then, the <i>naive</i> approach amounts to solve 100 different times the minimization problem (10). The whole process takes around $600$ seconds.</p>

<p>We apply the greedy procedure described in Algorithm 2 over the set $\tilde{\mathcal K}$ and choosing a precision of $\varepsilon=0.005$. The algorithm stops after seven iterations selecting 7 (out of 100) parameter values. The time needed to finish the offline part of the greedy algorithm takes 476 seconds.</p>

<p>[c
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure1a.jpg" alt="Figure 1 a" width="446" height="446" class="size-full wp-image-01" /> <i align="aligncenter">Figure 1.A: Numerical results of the greedy test #1. Distribution of the selected parameters</i>
[c
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure1b.jpg" alt="Figure 1 b" width="446" height="446" class="size-full wp-image-02" /> <i align="aligncenter">Figure 1.B: Numerical results of the greedy test #1. Aproximation error</i>                                          <br />
The way the parameters are chosen for this test is illustrated in Figure 1.A. In Figure 1.B, we plot the approximation rate of the  greedy algorithm  corresponding to</p>

<script type="math/tex; mode=display">\begin{equation*}
\sigma_n(\tilde{\mathcal K})=\max_{\nu\in\tilde{\mathcal K}} \Big((\bar p_\nu,\bar y_\nu),(\bar {\mathcal P}_n,\bar {\mathcal Y}_n)\Big).
\end{equation*}</script>

<p>Such plot suggests an exponential decay of the approximation rate $\sigma_n$, which is in accordance with the greedy theory.</p>

<p>Once the offline part is completed, we can construct (approximate) optimal controls by choosing a suitable combination of the optimal states $\bar p_{\nu_i}$.</p>

<p>In Figure 2, we plot the approximation of the real control with the greedy algorithm for $\nu=\sqrt 2$. The approximated control is nearly identical to the obtained by minimizing directly functional (5) for the associated value $\nu=\sqrt{2}$. In fact, one can obtain for this particular experiment that</p>

<script type="math/tex; mode=display">\begin{equation*}
\|\bar{u}_{\sqrt 2}- u_{\sqrt 2}^\star\|_{L^2(\Omega)}\approx 4.61\times 10^{-5}.
\end{equation*}</script>

<p>In spite of obtaining almost the same solution, the convergence of conjugate gradient method takes 5.4 s compared to 0.488 s in the online greedy part. This fact also shows the computational efficiency of the proposed algorithm.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_control_test1.jpg" alt="greedy_control_test1" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 2.A: Approximated control by greedy methods. The approximated control $x\mapsto \bar u^\star_{\sqrt 2}\,(x)$</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/control_region_test1.jpg" alt="control_region_test1" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 2.B: Approximated control by greedy methods. The control set $\omega$</i></p>

<p>In Figure 3.A, we plot the solution to (4) using the approximated control $u_{\sqrt{2}}^\star$. As for the control, we can compute the difference between the real optimal state against the approximate optimal state $\bar y^\star_{\sqrt 2}$. In this particular test, we obtain the following estimate</p>

<script type="math/tex; mode=display">\begin{equation*}
\|\bar{y}_{\sqrt 2}- y_{\sqrt 2}^\star\|_{L^2(\Omega)}\approx 7.14\times 10^{-7}.
\end{equation*}</script>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_state_top_test1.jpg" alt="greedy_state_top_test1" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 3.A: Controlled solution. The state $x\mapsto \bar y^\star_{\sqrt 2}(x)$</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_state_target_test1.jpg" alt="greedy_state_target_test1" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 3.B: Controlled solution. The state $\bar y^\star_{\sqrt{2}}$ and the target function $y^d$ (dashed)</i></p>

<h4>3.2. Greedy test # 2</h4>
<p>Here, we present a series of experiments for the case when the potential fulfills $c(x)\leq 0$. This will be of particular interest in the discussion of the following section.</p>

<p>We consider again the coefficient (12) and the parameter $\nu$ within the range (13), as in the previous test. For this particular case, we choose a constant function $c$ and the desired target as follows</p>

<script type="math/tex; mode=display">\begin{equation*}
c(x)\equiv-37 \quad{\text{and}}\quad y^d(x)=\sin(\pi x_1)
\end{equation*}</script>

<p>We will use as a control region the shape depicted in figure 4. For this particular test, the average time for computing the optimal control  for different values of $\nu$ is around nine seconds. Implementing the <i>naive</i> approach for the refined mesh $\tilde{\mathcal K}$ implies that at least 900 seconds are needed to finish this process.</p>

<p>Using our computational tool, we choose again the approximation tolerance $\varepsilon=0.005$. The greedy algorithm stops after nine iterations. We present in figure 5a the selected parameters in the order they were chosen by the program. The elapsed time for completing the offline process is 678 seconds.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure4.jpg" alt="Figure 4" width="446" height="446" class="size-full wp-image-04" /><i align="aligncenter">Figure 4: Control region for the second test.</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure5a.jpg" alt="Figure 5 a" width="446" height="446" class="size-full wp-image-05" /><i align="aligncenter">Figure 5.A: Numerical results of the greedy test #2. Distribution of the selected parameters</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure5b.jpg" alt="Figure 5 b" width="446" height="446" class="size-full wp-image-05" /><i align="aligncenter">Figure 5.B: Numerical results of the greedy test #2. Aproximation error</i></p>

<p>In Figure 6 we plot the approximation  of the optimal control obtained  by the greedy method for a chosen value of $\nu=7/5$, while in Figure 7 we show corresponding controlled state and a comparison with the target $y^d$. For this particular test, the elapsed time to compute the online control is 0.406 seconds while the convergence of the CG to compute the optimal control takes 15.9 seconds. The approximation error with respect to the real control is</p>

<script type="math/tex; mode=display">\begin{equation*}
\|\bar u_{7/5}- u^\star_{7/5}\|_{L^2(\Omega)}\approx 1.46\times 10^{-4},
\end{equation*}</script>

<p>while the approximation error for the state using the real and approximated control is</p>

<script type="math/tex; mode=display">\begin{equation*}
\|\bar y_{7/5}- y^\star_{7/5}\|_{L^2(\Omega)}\approx 4.78\times 10^{-5}.
\end{equation*}</script>

<p>In Figure 7, we observe that the approximation to the desired target $y^d$  is (to a certain extent) better than the one we obtain in greedy test #1. This is because  the chosen $y^d$ does not change sign in the domain $\Omega$ (cf. Figure 3.B).</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_control_test2.jpg" alt="greedy_control_test2" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 6: The approximated control $x\mapsto \bar u^\star_{7/5}(x)$.</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_state_top_test1.jpg" alt="greedy_state_top_test1" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 7.A: Controlled solution. The state $x\mapsto \bar y^\star_{\sqrt 2}(x)$</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_state_target_test1.jpg" alt="greedy_state_target_test1" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 7.B: Controlled solution. The state $\bar y^\star_{\sqrt{2}}$ and the target function $y^d$ (dashed)</i></p>

<p>where $y$ is solution to the parabolic problem</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{evo_turn_6}
\begin{cases}
y_t-\div(a_\nu \nabla y)+c\, y=1_\omega u, \quad &\text{in } \Omega\times(0,T), \\
y=0, \quad &\text{on } \partial \Omega\times(0,T), \\
y(x,0)=y^0(x), \quad &\text{in } \Omega.
\end{cases}
\end{equation} %]]></script>

<p>Here, we present a series of experiments related to the (approximated) optimal steady controls in Sections 3.1 and 3.2. We use them to control the corresponding evolution equation and test their efficiency. We will differentiate two main cases to be studied.</p>

<h4>The case $c(x)\geq 0$</h4>
<p>In addition to the parameters already set in the greedy test #1 (see Section 3.1), let us take</p>

<ul>
  <li>$T=3$</li>
  <li>$y^0(x)\equiv 0$</li>
</ul>

<p>In this stage, we are going to use the optimal control $\bar u^\star_{\sqrt 2}$ as a time-independent control for system (18). More precisely, we take</p>

<script type="math/tex; mode=display">\begin{equation}\label{control_exp51}
u(x,t)=\bar u^\star_{\sqrt 2}(x) \quad\text{for }t\in (0,T).
\end{equation}</script>

<p>By plugging such control into equation (18), we obtain the controlled solution displayed in Figure 8. We see that this control steers $y$ away from the initial condition at time $t=0$ and reaches in a short amount of time a region near the optimal steady state $\bar y^\star_{\sqrt{2}}$ (cf. Figure 8.C).</p>

<p>For this experiment, the efficiency of the time-independent control is closely related to the fact that $c(x)\geq 0$. In particular, the conditions on the coefficients $a_\nu$ and $c$ allow to prove that the uncontrolled system (18) is exponentially stable regardless of the initial datum.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/evo_a_test1.jpg" alt="evo_a_test1" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 8.A: Evolution in time for a stable system controlled with the steady control approximated by greedy procedure. $t=0$</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/evo_b_test1.jpg" alt="evo_b_test1" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 8.B: Evolution in time for a stable system controlled with the steady control approximated by greedy procedure. (B) $t=0.025$</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/evo_c_test1.jpg" alt="evo_c_test1" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 8.C: Evolution in time for a stable system controlled with the steady control approximated by greedy procedure. (C) $t\in(0.1,3)$</i></p>

<p>In Figure 9, we illustrate the efficiency of the steady control by plotting different curves representing the time evolution of the $L^2$-norm of $y$ solution to (18) with different initial datums and taking (19) as a control. To compare, we have computed the time-dependent solution $y^T(t)$ associated to the optimal control $u^T(t)$, obtained by minimizing (17), for the given parameter $\nu=\sqrt{2}$ and $y_0(x)=0$.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure9.jpg" alt="Figure 9" width="446" height="446" class="size-full wp-image-09" /><i align="aligncenter">Figure 9: Time evolution comparison for system (18) controlled with turnpike control versus steady control and different initial datum: $y_0(x)=\bar y^\star_{7/5}(x)$, $y_0(x)=0$ and $\tilde y_0(x)=\chi_{(0.4,0.9)^2}(x)$.</i>
.&lt;/i&gt;</p>

<h4>The case $c(x)&lt; 0$</h4>
<p>Let us take the parameters and results in the greedy test #2 shown in Section 3.2 together with $y_0(x)=0$ and $T=3$. As before, we can put the (approximated) steady control $\bar u^\star_{7/5}(x)$ in system (18) and test its performance. Recall that we have chosen $c(x)\equiv -37$. We show in Figure 10 the solution to the evolution problem using the steady control $\bar u^\star_{7/5}$. We see that in this case, the steady control lacks to stabilize the system around the steady state shown in figure 10.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/evo_a_test2.jpg" alt="evo_a_test2" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 10.A: Evolution in time for an unstable system controlled with the steady control approximated by means of the greedy approach. $t=0$</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/evo_b_test2.jpg" alt="evo_b_test2" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 10.B: Evolution in time for an unstable system controlled with the steady control approximated by means of the greedy approach. $t=0.03$</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/evo_c_test2.jpg" alt="evo_c_test2" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 10.C: Evolution in time for an unstable system controlled with the steady control approximated by means of the greedy approach. $t=0.3675$</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/evo_d_test2.jpg" alt="evo_d_test2" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 10.D: Evolution in time for an unstable system controlled with the steady control approximated by means of the greedy approach. $t=1.1175$</i></p>

<p>In Figure 11, we present further experiments where we illustrate that for some initial data, the controlled solution $y$ grows in exponential manner. In fact, only for $y_0(x)=\bar y^\star_{7/5}$ and a sufficiently small neighborhood of this initial datum, the steady control is effective to control the underlying system.</p>

<p>For this particular case, to see the turnpike property it is necessary to compute the solution to the time-dependent minimization problem (18). We show in Figure 12, the time evolution of the optimal  controlled state and control and, as expected, we can see the asymptotic simplification towards the state and control for most of the time horizon. However, we can also see that the control makes a large effort at the beginning of the temporal interval to move the system to this steady state.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure11.jpg" alt="Figure 11" width="446" height="446" class="size-full wp-image-11" /><i align="aligncenter">Figure 11: Time evolution comparison for system for an unstable system controlled with steady control with different initial data: $y_0(x)=\bar y^\star_{7/5}(x)$, $y_0(x)=0$ and $\tilde y_0(x)=\chi_{(0.4,0.9)^2}(x)$.</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/figura12a.jpg" alt="figura12a" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 12.A: Turnpike property for an unstable system. The optimal state&lt;/i
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/figura12b.jpg" alt="figura12b" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 12.B: Turnpike property for an unstable system. The optimal control</i></i></p>

<p>Unlike the case $c(x)\geq 0$, there might be some coefficients $c(x)&lt;0$ such that steady controls, and in particular the approximated controls derived from the greedy approach, are not enough to control the evolution system.</p>

<h3>Bibliography</h3>

<p><strong>[1]</strong> A. Cohen and  R. DeVore <a href="" target="_blank"><em>Approximation of high-dimensional parametric PDEs.</em></a> Acta Numerica, 24, (2015), 1--159.</p>
<p><strong>[2]</strong> R. DeVore, (2005) <a href="" target="_blank"><em>The Theoretical Foundation of Reduced Basis Methods.</em></a> preprint.</p>
<p><strong>[3]</strong> J.-L Lions. <!--a href="" target="_blank"--><em>Optimal control of systems governed by partial differential equations.</em><!--/a--> Springer-Verlag, 1971.</p>
<p><strong>[4]</strong> A. Porretta and E. Zuazua. <a href="http://paginaspersonales.deusto.es/enrique.zuazua/documentos_public/archivos/publicaciones/optimal10.pdf" target="_blank"><em>Long time versus steady state optimal control.</em></a> SIAM Journal on Control and Optimization, 51, 6 (2013), 4242-4273.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3&gt;Introduction&lt;/h3&gt;
</code></pre></div></div>
<p>We introduce the following notation: $L^2=L^2\left(\Omega\right)$, $L^2_T=L^2\left(\Omega\times \left(0,T\right)\right)$,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray*}
	\langle u,v \rangle&=&\int_{\Omega}^{} u(x)v(x) \ dx;\\
	\langle u,v \rangle_T^2&=&\int_{0}^{T} \int_{\Omega}^{} u(x,t)v(x,t) \ dx \ dt
\end{eqnarray*} %]]></script>

<p>and the correspondent norms $\norm{\cdot}=\langle \cdot,\cdot\rangle$ and $\norm{\cdot}_T=\langle \cdot,\cdot\rangle_T$. Moreover, we define the norms</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray*}
	\norm{v}_{1}&=&\int_{\Omega}^{} \abs{v(x)} \ dx;\\
	\norm{v}_{1,T}&=&\int_{0}^{T} \int_{\Omega}^{} \abs{v(x,t)} \ dx \ dt.
\end{eqnarray*} %]]></script>

<p>We want to study the following optimal control problem:</p>

<script type="math/tex; mode=display">\begin{equation*}
\left(\mathcal{P}\right) \ \ \ \ \ \ \ \hat{u}\in argmin_{u\in L^2_T} \left\{J\left(u\right)=\alpha_c \norm{u}_{1,T} + \frac{\beta}{2}\norm{u}^2_{T}+\alpha_s \norm{Lu}_{1,T} + \frac{\gamma}{2}\norm{Lu-z}_{T}^2\right\},
\end{equation*}</script>

<p>where $L: \ L^2_T \to L^2_T$ is defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray*}
Lu&=&y
\end{eqnarray*} %]]></script>

<p>and $y$ is the solution of the PDE given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
y'+Ay=Bu & \left(\Omega \times \left(0,T\right)\right)\\
y=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
y(0)=0 & \left(\Omega\right).
\end{cases}
\end{equation*} %]]></script>

<p>Notice that, by integration by parts, $ L^*\mu=B^\ast p $, where $\varphi$ is solution of the adjoint equation:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
-p'+A^* p =\mu & \left(\Omega \times \left(0,T\right)\right)\\
p=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
p(T)=0 & \left(\Omega\right).
\end{cases}
\end{equation*} %]]></script>

<h3>Sparse control: $\alpha_c&gt;0$ ($\alpha_s=0$)</h3>
<h3>The stationary problem</h3>

<script type="math/tex; mode=display">\begin{equation*}
\left(\mathcal{S}\mathcal{P}_c\right) \ \ \ \ \ \ \ \bar{u}\in argmin_{u\in L^2} \left\{J_s\left(u\right)=\alpha_c \norm{u}_{1} + \frac{\beta}{2}\norm{u}^2+ \frac{\gamma}{2}\norm{y-z}^2: \ \ \ Ay=Bu \right\}.
\end{equation*}</script>

<h4>Optimality conditions</h4>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
A\bar{y}=B \ shrink(-B^*\bar{p},\frac{\alpha_c}{\beta}) & \left(\Omega\right)\\
A^*\bar{p}=\gamma\left(\bar{y}-z\right) & \left(\Omega\right)\\
\bar{y}=0, \ \bar{p}=0 & \left(\partial\Omega\right).
\end{cases}
\end{equation*} %]]></script>

<h4>Numerical algorithm</h4>
<p>In order to compute a numerical solution of problem</p>

<script type="math/tex; mode=display">\left(\mathcal{S}\mathcal{P}_c\right)</script>

<p>after a discretization by finite differences, we use a prox-prox splitting: first write the state as $y=A^{-1}Bu$, then</p>
<ul>
	<li> Proximal-point step:</li>

$$
\begin{equation*}
\begin{split}
\tilde{u}_{k} &amp; =argmin_{u\in L^2} \left\{\frac{\beta}{2}\norm{u}^2 + \frac{\gamma}{2}\norm{A^{-1}Bu-z}^2+ \frac{1}{2\lambda_k}\norm{u-u_k}^2\right\}\\
&amp; = \left[\left(\beta+\frac{1}{\lambda_k}\right)I+\gamma B^*A^{-*}A^{-1}B\right]^{-1}\left(\frac{1}{\lambda_k}u_k+\gamma B^*A^{-*}z\right).
\end{split}
\end{equation*}
$$

<li> Proximal-point step:</li>

$$
\begin{equation*}
	\begin{split}
	u_{k+1}&amp; =argmin_{u\in L^2} \left\{\alpha_c \norm{u}_{1,T} + \frac{1}{2\lambda_k}\norm{u-\tilde{u}_k}_{T}^2\right\}\\
	&amp; = shrink(\tilde{u}_k,\alpha_c \lambda_k).
	\end{split}
	\end{equation*}
$$

</ul>
<p><strong>Remark:</strong> Notice that, when $\alpha_s=0$, the solution of $\left(\mathcal{P}^c_s\right)$ is simply given by</p>

<script type="math/tex; mode=display">\bar{u}=\gamma \left[\beta I+\gamma B^*A^{-*}A^{-1}B\right]^{-1}B^*A^{-*}z.</script>

<h3>Evolutionary problem</h3>

<script type="math/tex; mode=display">\begin{equation*}
\left(\mathcal{P}_c\right) \ \ \ \ \ \ \ \hat{u}\in argmin_{u\in L^2_T} \left\{J\left(u\right)=\alpha_c \norm{u}_{1,T} + \frac{\beta}{2}\norm{u}^2_{T} + \frac{\gamma}{2}\norm{Lu-z}_{T}^2\right\}.
\end{equation*}</script>

<h4>Optimality conditions</h4>
<p>Define the classical Lagrangian</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\mathcal{L}\left(u,y,p\right)&=J\left(u\right)+\langle p, Bu-y'-Ay\rangle_T.
\end{split}
\end{equation*} %]]></script>

<p>By integration by parts, we have</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\mathcal{L}\left(u,y,p\right)&=\alpha_c \norm{u}_{1,T} + \frac{\beta}{2}\norm{u}^2_{T}+ \frac{\gamma}{2}\norm{y-z}_{T}^2 + \langle B^*p, u\rangle_T \\
& \quad + \langle p'-A^*p,y\rangle_T + \langle p(0),y(0)\rangle - \langle p(T),y(T)\rangle.
\end{split}
\end{equation*} %]]></script>

<p>Deriving with respect to the three variables $\left(u,y,p\right)$, we obtain the optimality system:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
\hat{y}'+A\hat{y}=B\hat{u} & \left(\Omega \times \left(0,T\right)\right)\\
-\hat{p}'+A^*\hat{p}=\gamma\left(y-z\right) & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=0, \ \hat{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
\hat{y}(0)=0, \ \hat{p}(T)=0 & \left(\Omega\right),
\end{cases}
\end{equation*} %]]></script>

<p>where the relation between the optimal control and the dual state is given by</p>

<script type="math/tex; mode=display">\begin{equation*}
0\in \alpha_c \ \partial \norm{\cdot}_{1,T} \left(\hat{u}\right) + \beta \hat{u} + B^*\hat{p}.
\end{equation*}</script>

<p>The latter is equivalent to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\hat{u}&=\left(\beta I+\alpha_c \ \partial \norm{\cdot}_{1,T} \right)^{-1}\left(-B^*\hat{p}\right)\\
&=argmin_{v\in L^2_T} \left\{ \alpha_c \norm{v}_{1,T}+\frac{1}{2\beta}\norm{v+B^*\hat{p}}_T^2 \right\}\\
&=shrink(-B^*\hat{p},\frac{\alpha_c}{\beta}),
\end{split}
\end{equation*} %]]></script>

<p>where the operator of $soft-shrinkage$ is defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
shrink(t,\alpha)=
\begin{cases}
t+\alpha & (t<-\alpha)\\
0 & (-\alpha\leq t \leq \alpha)\\
t-\alpha & (t>\alpha).
\end{cases}
\end{equation*} %]]></script>

<p>Finally,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
\hat{y}'+A\hat{y}=B \ shrink(-B^*\hat{p},\frac{\alpha_c}{\beta})& \left(\Omega \times \left(0,T\right)\right)\\
-\hat{p}'+A^*\hat{p}=\gamma\left(y-z\right) & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=0, \ \hat{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
\hat{y}(0)=0, \ \hat{p}(T)=0 & \left(\Omega\right).
\end{cases}
\end{equation*} %]]></script>

<h4>Numerical algorithm</h4>
<p>In order to compute a numerical solution of problem $\left(\mathcal{P}_c\right)$, after a discretization by finite differences, we use a grad-prox splitting:</p>
<ul>
	<li> Gradient step:</li>
$$
	\begin{equation*}
	\begin{split}
	\tilde{u}_{k} &amp; = u_k-\lambda_k \nabla_u \left[\frac{\beta}{2}\norm{u}^2_{T} + \frac{\gamma}{2}\norm{Lu-z}_{T}^2 \right]\left(u_k\right) \\
	&amp; = u_k-\lambda_k \left[\beta u_k+\gamma L^*\left(Lu_k-z\right)\right]\\
	&amp; = u_k - \lambda_k\left[\beta u_k+\gamma B^*p_k\right],
	\end{split}
	\end{equation*}
$$

where

$$
	\begin{equation*}
	\begin{cases}
	y_k'+Ay_k=Bu_k &amp; \left(\Omega \times \left(0,T\right)\right)\\
	y_k=0 &amp; \left(\partial\Omega\times \left(0,T\right)\right)\\
	y_k(0)=0 &amp; \left(\Omega\right)
	\end{cases}
	\end{equation*}
$$

and

$$
	\begin{equation*}
	\begin{cases}
	-p_k'+A^* p_k =y_k-z &amp; \left(\Omega \times \left(0,T\right)\right)\\
	p_k=0 &amp; \left(\partial\Omega\times \left(0,T\right)\right)\\
	p_k(T)=0 &amp; \left(\Omega\right).
	\end{cases}
	\end{equation*}
$$

<li> Proximal-point step:</li>

$$
\begin{equation*}
\begin{split}
u_{k+1}&amp; =argmin_{u\in L^2_T} \left\{\alpha_c \norm{u}_{1,T} + \frac{1}{2\lambda_k}\norm{u-\tilde{u}_k}_{T}^2\right\}\\
	&amp; = shrink(\tilde{u}_k,\alpha_c \lambda_k).
\end{split}
\end{equation*}
$$

</ul>
<p><strong>Remarks:</strong> Another possibility is to include the term $\frac{\beta}{2}\norm{u}^2_{T}$ in the proximal step.
Notice that, for</p>

<script type="math/tex; mode=display">f(u)=\frac{\beta}{2}\norm{u}^2_{T} + \frac{\gamma}{2}\norm{Lu-z}_{T}^2,</script>

<p>then $\nabla f$ is Lipschitz continuous. Indeed, for $u_i\in L^2_T$ ($i=1,2$), then</p>

<script type="math/tex; mode=display">\nabla f (u_i)=\beta u_i+\gamma B^{*}p_i,</script>

<p>where</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
y_i'+Ay_i=Bu_i & \left(\Omega \times \left(0,T\right)\right)\\
y_i=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
y_i(0)=0 & \left(\Omega\right)
\end{cases}
\end{equation*} %]]></script>

<p>and</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
-p_i'+A^* p_i=y_i-z & \left(\Omega \times \left(0,T\right)\right)\\
p_i=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
p_i(T)=0 & \left(\Omega\right).
\end{cases}
\end{equation*} %]]></script>

<p>By linearity $\delta y=y_2-y_1$ and $\delta p=p_2-p_1$ solve the same equations with right-hand-sides $B(u_2-u_1)$ and $\delta y$, respectively. Then</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\norm{\nabla f(u_2)-\nabla f(u_1)}&\leq \beta\norm{u_2-u_1}_T + \gamma \norm{B^*}\norm{\delta p}_T\\
&\leq \beta\norm{u_2-u_1}_T + \gamma \ C_{adj} \norm{B} \norm{\delta y}_T\\
& \leq \beta\norm{u_2-u_1}_T + \gamma \ C_{adj} C \ \norm{B} \norm{B(u_2-u_1)}_T\\
& \leq L \norm{u_2-u_1}_T,
\end{split}
\end{equation*} %]]></script>

<p>where we defined</p>

<script type="math/tex; mode=display">L=\beta+\gamma \ C_{adj} C \ \norm{B}^2.</script>

<p>In order the prox-grad method to converge, the restriction on the step size is given by</p>

<script type="math/tex; mode=display">% <![CDATA[
0<\lambda \leq \lambda_k \leq \Lambda <\frac{2}{L}. %]]></script>

<h3>Sparse state: $\alpha_s&gt;0$ ($\alpha_c=0$)</h3>

<script type="math/tex; mode=display">\begin{equation*}
\left(\mathcal{P}_s\right) \ \ \ \ \ \ \ \hat{u}\in argmin_{u\in L^2_T} \left\{J\left(u\right)=\frac{\beta}{2}\norm{u}^2_{T}+\alpha_s \norm{Lu}_{1,T} + \frac{\gamma}{2}\norm{Lu-z}_{T}^2\right\}.
\end{equation*}</script>

<h3>The stationary problem</h3>

<script type="math/tex; mode=display">\begin{equation*}
\left(\mathcal{S}\mathcal{P}_s\right) \ \ \ \ \ \ \ \bar{u}\in argmin_{u\in L^2} \left\{J_s\left(u\right)=\alpha_c \norm{u}_{1} + \frac{\beta}{2}\norm{u}^2+ \frac{\gamma}{2}\norm{y-z}^2: \ \ \ Ay=Bu \right\}.
\end{equation*}</script>

<h4>Optimality conditions</h4>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
A\bar{y}=-\frac{1}{\beta}BB^*\hat{p} & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=shrink(A^*\hat{p}+\gamma z,\frac{\alpha_s}{\gamma}) & \left(\Omega \times \left(0,T\right)\right)\\
\bar{y}=0, \ \bar{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right).
\end{cases}
\end{equation*} %]]></script>

<p>Finally, we obtain a single equation in the dual variable $p$:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
A \ shrink(A^*\bar{p}+\gamma z,\frac{\alpha_s}{\gamma})=-\frac{1}{\beta}BB^*\bar{p} & \left(\Omega \times \left(0,T\right)\right)\\
\bar{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right).
\end{cases}
\end{equation*} %]]></script>

<h4>Numerical algorithm</h4>
<p>In order to compute a numerical solution of problem $\left(\mathcal{P}_s\right)$, after a discretization by finite differences, we use a prox-prox splitting on the Augmented Energy: first write the state as $y=A^{-1}Bu$, then</p>
<ul>
	<li> Proximal-point step:</li>
$$
	\begin{equation*}
	\begin{split}
	u_{k+1} &amp; =argmin_{u\in L^2} \left\{\frac{\beta}{2}\norm{u}^2 + \frac{\gamma}{2}\norm{A^{-1}Bu-z}^2+\frac{\delta}{2\lambda_k}\norm{A^{-1}Bu-y_k}^2 +\frac{1}{2\lambda_k}\norm{u-u_k}^2\right\}\\
	&amp; = \left[\left(\beta+\frac{1}{\lambda_k}\right)I+\left(\gamma+\frac{\delta}{\lambda_k}\right) B^*A^{-*}A^{-1}B\right]^{-1}\left[\frac{1}{\lambda_k}u_k+ B^*A^{-*}\left(\gamma z+\frac{\delta}{\lambda_k}y_k\right)\right].
	\end{split}
	\end{equation*}
$$

	<li> Proximal-point step:</li>
$$
	\begin{equation*}
	\begin{split}
	y_{k+1}&amp; =argmin_{y\in L^2} \left\{
	\alpha_s \norm{y}_{1} + \frac{\delta}{2\lambda_k}\norm{y-A^{-1}Bu_{k+1}}^2+\frac{1}{2\lambda_k}\norm{y-y_k}_{T}^2\right\}\\
	&amp; = shrink(\tilde{y}_k,\tilde{\lambda}_k),
	\end{split}
	\end{equation*}
$$

	where we defined

$$
	\begin{eqnarray*}
		\tilde{y}_k &amp; = &amp; \frac{y_k+\delta A^{-1}B u_{k+1}}{1+\delta};\\
		\tilde{\lambda}_k &amp; = &amp; \frac{\alpha_s \lambda_k}{1+\delta}.
	\end{eqnarray*}
$$

</ul>
<p><strong>Remark:</strong> Notice that again, when $\alpha_s=0$, the solution of $\left(\mathcal{P}_s\right)$ is simply given by</p>

<script type="math/tex; mode=display">\bar{u}=\gamma \left[\beta I+\gamma B^*A^{-*}A^{-1}B\right]^{-1}B^*A^{-*}z.</script>

<h3>Evolutionary problem</h3>
<h4>Optimality conditions</h4>
<p>Define the classical Lagrangian</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\mathcal{L}\left(u,y,p\right)&=J\left(u\right)+\langle p, Bu-y'-Ay\rangle_T.
\end{split}
\end{equation*} %]]></script>

<p>By integration by parts, we have</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\mathcal{L}\left(u,y,p\right)&=\frac{\beta}{2}\norm{u}^2_{T}+\alpha_s \norm{y}_{1,T} +  \frac{\gamma}{2}\norm{y-z}_{T}^2 + \langle B^*p, u\rangle_T \\
& \quad + \langle p'-A^*p,y\rangle_T + \langle p(0),y(0)\rangle - \langle p(T),y(T)\rangle.
\end{split}
\end{equation*} %]]></script>

<p>Deriving with respect to the three variables $\left(u,y,p\right)$, we obtain the optimality system:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
\hat{y}'+A\hat{y}=B\hat{u} & \left(\Omega \times \left(0,T\right)\right)\\
-\hat{p}'+A^*\hat{p}\in\gamma\left(\hat{y}-z\right)+\alpha_s \ \partial \norm{\cdot}_{1,T} \left(\hat{y}\right) & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=0, \ \hat{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
\hat{y}(0)=0, \ \hat{p}(T)=0 & \left(\Omega\right),
\end{cases}
\end{equation*} %]]></script>

<p>where the relation between the optimal control and the dual state is given by</p>

<script type="math/tex; mode=display">\begin{equation*}
\hat{u} = -\frac{1}{\beta}B^*\hat{p}.
\end{equation*}</script>

<p>The adjoint equation is equivalent to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\hat{y}&=\left(\gamma I+\alpha_s \ \partial \norm{\cdot}_{1,T} \right)^{-1}\left(-\hat{p}'+A^*\hat{p}+\gamma z\right)\\
&=shrink(-\hat{p}'+A^*\hat{p}+\gamma z,\frac{\alpha_s}{\gamma}).
\end{split}
\end{equation*} %]]></script>

<p>Finally,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
\hat{y}'+A\hat{y}=-\frac{1}{\beta}B B^*\hat{p} & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=shrink(-\hat{p}'+A^*\hat{p}+\gamma z,\frac{\alpha_s}{\gamma}) & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=0, \ \hat{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
\hat{y}(0)=0, \ \hat{p}(T)=0 & \left(\Omega\right),
\end{cases}
\end{equation*} %]]></script>

<h4>Numerical algorithm</h4>
<p>In order to compute a numerical solution of problem $\left(\mathcal{P}_s\right)$, after a discretization by finite differences, we use a grad-prox splitting on the following Augmented Energy:</p>

<script type="math/tex; mode=display">\begin{equation*}
\mathcal{L}_{\lambda}\left(u,y\right)=\frac{\beta}{2}\norm{u}^2_{T}+\alpha_s \norm{y}_{1,T}+ \frac{\gamma}{2}\norm{Lu-z}_{T}^2+\frac{\delta}{2\lambda}\norm{Lu-y}_{T}^2.
\end{equation*}</script>

<p>Then,</p>
<ul>
	<li> Gradient step:</li>
$$
	\begin{equation*}
	\begin{split}
	u_{k+1} &amp; = u_k-\lambda_k \nabla_u \left[\frac{\beta}{2}\norm{u}^2_{T}+ \frac{\gamma}{2}\norm{Lu-z}_{T}^2+\frac{\delta}{2\lambda}\norm{Lu-y}_{T}^2 \right]\left(u_k\right) \\
	&amp; = u_k-\lambda_k \left[\beta u_k+\gamma L^*\left(Lu_k-z\right)+\frac{\delta}{\lambda_k}L^*\left(Lu_k-y_k\right)\right]\\
	&amp; = \left(1-\beta\lambda_k\right)u_k - B^*p_k,
	\end{split}
	\end{equation*}
$$

where

$$
	\begin{equation*}
	\begin{cases}
	y_{u_k}'+Ay_{u_k}=Bu_k &amp; \left(\Omega \times \left(0,T\right)\right)\\
	y_{u_k}=0 &amp; \left(\partial\Omega\times \left(0,T\right)\right)\\
	y_{u_k}(0)=0 &amp; \left(\Omega\right)
	\end{cases}
	\end{equation*}
$$

and

$$
	\begin{equation*}
	\begin{cases}
	-p_k'+A^* p_k =\left(\gamma \lambda_k + \delta\right)y_{u_k}-\gamma \lambda_k z - \delta y_k &amp; \left(\Omega \times \left(0,T\right)\right)\\
	p_k=0 &amp; \left(\partial\Omega\times \left(0,T\right)\right)\\
	p_k(T)=0 &amp; \left(\Omega\right).
	\end{cases}
	\end{equation*}
$$

<li> Proximal-point step:</li>

$$
	\begin{equation*}
	\begin{split}
	y_{k+1}&amp; =argmin_{y\in L^2_T} \left\{\alpha_s \norm{y}_{1,T} + \frac{\delta}{2\lambda_k}\norm{y-Lu_{k+1}}_T^2+\frac{1}{2\lambda_k}\norm{y-y_k}_{T}^2\right\}\\
	&amp; = shrink(\tilde{y}_k,\tilde{\lambda}_k),
	\end{split}
	\end{equation*}
$$

where we defined
$$
	\begin{eqnarray*}
	\tilde{y}_k &amp; = &amp; \frac{y_k+\delta L u_{k+1}}{1+\delta};\\
	\tilde{\lambda}_k &amp; = &amp; \frac{\alpha_s \lambda_k}{1+\delta}.
	\end{eqnarray*}
$$
<ul>
<strong>Remark: </strong>Another possibility is to consider
$$
	\begin{equation*}
	\mathcal{L}_{\lambda}\left(u,y\right)=\frac{\beta}{2}\norm{u}^2_{T}+\alpha_s \norm{y}_{1,T}+ \frac{\gamma}{2}\norm{y-z}_{T}^2+\frac{\delta}{2\lambda}\norm{Lu-y}_{T}^2.
	\end{equation*}
$$

<h3>Computational experiments</h3>
In the following, we present the setting for the numerical experiments.
<ul>
	<li> Spacial domain: $\Omega=\left(0,1\right)$;</li>
	<li> Time interval: $\left[0,T\right]$, with $T=1$;</li>
	<li> Weight-parameters: $\alpha_c=[0, 0.01]$, $\alpha_s=[0, 0.65]$, $\beta=0.0001$ and $\gamma=1$;</li>
	<li> Trajectory target: $$z(x)=\mathcal{I}_{\left[x_a,x_b\right]},$$ where $x_a=1.7/3$, $x_b=3.5/4$;</li>
	<li> Control operator: for $x_1=1/7$ and $x_2=4/5$,
$$B=\mathcal{I}_{\left[x_1,x_2\right]};$$
    </li>

	<li> $A$ is the finite difference discretization of $-\Delta$;</li>
	<li> Numerical grid: $N_x=300$ in space, $N_t=100$ in time.</li>
</ul>
<h3>Stationary solutions</h3>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/uy_alphazero_staz.jpg" alt="Figure 1" width="600" /> Figure 1: $\alpha_c=\alpha_s=0$.  

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/uy_alpha_staz.jpg" alt="Figure 2" width="600" /> Figure 2: $\alpha_c=0.01$, $\alpha_s=0$.  

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/uy_alpha_staz-1.jpg" alt="Figure 3" width="600" /> Figure 3: $\alpha_c=0$, $\alpha_s=0.65$.

<h3>Evolutionary problem</h3>  
<h4>Optimal control</h4>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/u_alphazero_ev.jpg" alt="Figure 4 TOP" width="600" />Figure 4a: Optimal control for $\alpha_c=\alpha_s=0$. In red, the controllable subdomain; in blue, the stationary optimal controls.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/u_alpha_tot.jpg" alt="Figure 4 MIDDLE" width="600" />Figure 4b: Optimal control for $\alpha_c=0.01$, $\alpha_s=0$. In red, the controllable subdomain; in blue, the stationary optimal controls.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/u_alpha_tot-1.jpg" alt="Figure 4 BOTTOM" width="600" /> Figure 4c: Optimal control for $\alpha_c=0$, $\alpha_s=0.65$. In red, the controllable subdomain; in blue, the stationary optimal controls.
<h4>Optimal state</h4>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/y_alphazero_ev.jpg" alt="Figure 5 TOP" width="600" />Figure 5a: Optimal state for $\alpha_c=\alpha_s=0$ . In red, the target $z$; in blue, the stationary optimal states.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/y_alpha_tot.jpg" alt="Figure 5 MIDDLE" width="600" />Figure 5b: Optimal state for $\alpha_c=0.01$, $\alpha_s=0$. In red, the target $z$; in blue, the stationary optimal states.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/y_alpha_tot-1.jpg" alt="Figure 5 BOTTOM" width="600" /> Figure 5c: Optimal state for $\alpha_c=0$, $\alpha_s=0.65$. In red, the target $z$; in blue, the stationary optimal states.
<h4>Optimal adjoint</h4>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/p_alphazero_ev.jpg" alt="Figure 6 TOP" width="600" />Figure 6a: Optimal adjoint for $\alpha_c=\alpha_s=0$.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/p_alpha_tot.jpg" alt="Figure 6 MIDDLE" width="600" />Figure 6b: Optimal adjoint for $\alpha_c=0.01$, $\alpha_s=0$.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/p_alpha_tot-1.jpg" alt="Figure 6 BOTTOM" width="600" /> Figure 6c: Optimal adjoint for $\alpha_c=0$, $\alpha_s=0.65$.

<h4>Bibliography</h4>
<strong>[1]</strong> Peypouquet, J. <a href="http://jpeypou.mat.utfsm.cl/wp-content/uploads/2014/05/Convex-Optimization.pdf"><em>Convex optimization in normed spaces: theory, methods and examples. With a foreword by Hedy Attouch.</em></a> Springer Briefs in Optimization. Springer, Cham, 2015. xiv+124 pp.
</ul></ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;This is a set of Matlab functions to interpolate scattered data with Radial Basis Functions (RBF).&lt;/p&gt;
</code></pre></div></div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?F%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3D%20%5Csum_%7Bj%3D1%7D%5EN%20%5Cgamma_j%20%5Cvarphi%20%5Cleft%28%20%5C%7C%20%5Cmathbf%7Bx%7D%20-%20%5Cmathbf%7Bx%7D_%7Bs%2C%20j%7D%20%5C%7C_%7B%5Cmathbb%7BR%7D%5Ed%7D%20%5Cright%29%20&plus;%20p%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29" />
</p>

<h2 id="getting-started">Getting Started</h2>

<pre><code class="language-Matlab">y = RBFinterp(xs, ys, x, RBFtype, R)
</code></pre>
<p>interpolates to find y, the values of the function y=f(x) at the points x.</p>

<p>Xs must be a matrix of size [N,Dx], with N the number of data points and Dx the dimension of the points in xs and x.</p>

<p>Ys must be a matrix of size [N,Dy], with N the number of known values at points in Xs, and Dy the dimension of the y values.</p>

<p>X must be a matrix of size [M,Dx], with M the number of query points.</p>

<p>RBFtype specifies the radial basis functions (RBF) to be used.</p>

<ul>
  <li>The available global support RBFs are:
    <ul>
      <li>‘R1’    - linear spline</li>
      <li>‘R3’    - cubic spline</li>
      <li>‘TPS2’  - thin plate spline</li>
      <li>‘Q’     - quadric</li>
      <li>‘MQ’    - multiquadric</li>
      <li>‘IMQ’   - inverse multiquadric</li>
      <li>‘IQ’    - inverse quadric</li>
      <li>‘GS’    - Gauss</li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">RBF name</th>
      <th style="text-align: center">Abbreviation</th>
      <th style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cvarphi%20%5Cleft%28%20r%20%5Cright%29" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Linear spline</td>
      <td style="text-align: center">R1</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cepsilon%20r" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Cubic splie</td>
      <td style="text-align: center">R3</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%5E3" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Thin plate spline</td>
      <td style="text-align: center">TPS2</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%5E2%20%5Clog%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%24" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Quadric</td>
      <td style="text-align: center">Q</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?1%20&plus;%20%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%5E2" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Multiquadric</td>
      <td style="text-align: center">MQ</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Csqrt%7B1%20&plus;%20%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%20%5E2%7D" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Inverse multiquadric</td>
      <td style="text-align: center">IMQ</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B%5Csqrt%7B1%20&plus;%20%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%20%5E2%7D%7D" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Inverse quadric</td>
      <td style="text-align: center">IQ</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B%201%20&plus;%20%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%20%5E2%20%7D" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Gauss</td>
      <td style="text-align: center">GS</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?e%5E%7B-%5Cleft%28%5Cepsilon%20r%20%5Cright%29%5E2%7D" /></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>The available compact support RBFs are (see Wendland H., Konstruktion und Untersuchung radialer Basisfunktionen mit kompaktem Träger. PhD  thesis, Göttingen, Georg-August-Universität zu Göttingen, Diss, 1996):
    <ul>
      <li>‘CP_C0’</li>
      <li>‘CP_C2’</li>
      <li>‘CP_C4’</li>
      <li>‘CP_C6’</li>
      <li>‘CTPS_C0’</li>
      <li>‘CTPS_C1’</li>
      <li>‘CTPS_C2a’</li>
      <li>‘CTPS_C2b’</li>
    </ul>
  </li>
</ul>

<p>Compact support functions have the form</p>

<p align="center">
	<img src="https://latex.codecogs.com/gif.latex?%5Cvarphi%20%5Cleft%28%20%5Cxi%20%3D%20%5Cfrac%7Br%7D%7BR%7D%20%5Cright%29%20%3D%20%5Cbegin%7Bcases%7D%20f%20%5Cleft%28%20%5Cxi%20%5Cright%29%2C%20%26%200%20%5Cleq%20%5Cxi%20%5Cleq%201%20%5C%5C%200%2C%20%26%20%5Cxi%20%3E%201%20%5Cend%7Bcases%7D" />
</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">RBF name</th>
      <th style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cvarphi%20%5Cleft%28%20%5Cxi%20%5Cright%29" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCP%20%7D%20%5Cmathcal%7BC%7D%5E0" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%201%20-%20%5Cxi%20%5Cright%29%5E2" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCP%20%7D%20%5Cmathcal%7BC%7D%5E2" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%201%20-%20%5Cxi%20%5Cright%29%5E4%20%5Cleft%28%204%20%5Cxi%20&plus;%201%20%5Cright%29" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCP%20%7D%20%5Cmathcal%7BC%7D%5E4" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%201%20-%20%5Cxi%20%5Cright%29%5E6%20%5Cleft%28%20%5Cfrac%7B35%7D%7B3%7D%20%5Cxi%5E2%20&plus;%206%20%5Cxi%20&plus;%201%20%5Cright%29" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCP%20%7D%20%5Cmathcal%7BC%7D%5E6" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%201%20-%20%5Cxi%20%5Cright%29%5E8%20%5Cleft%28%2032%20%5Cxi%5E3%20&plus;%2025%20%5Cxi%5E2%20&plus;%208%20%5Cxi%20&plus;%201%20%5Cright%29" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCTPS%20%7D%20%5Cmathcal%7BC%7D%5E0" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%201%20-%20%5Cxi%20%5Cright%29%5E5" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCTPS%20%7D%20%5Cmathcal%7BC%7D%5E1" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?1%20&plus;%20%5Cfrac%7B80%7D%7B3%7D%20%5Cxi%5E2%20-%2040%20%5Cxi%5E3%20&plus;%2015%20%5Cxi%5E4%20-%20%5Cfrac%7B8%7D%7B3%7D%20%5Cxi%5E5%20&plus;%2020%20%5Cxi%5E2%20%5Clog%20%5Cxi" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCTPS%20%7D%20%5Cmathcal%7BC%7D%5E2_a" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?1%20-%2030%20%5Cxi%5E2%20-%2010%20%5Cxi%5E3%20&plus;%2045%20%5Cxi%5E4%20-%206%20%5Cxi%5E5%20-%2060%20%5Cxi%5E3%20%5Clog%20%5Cxi" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCTPS%20%7D%20%5Cmathcal%7BC%7D%5E2_b" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?1%20-%2020%20%5Cxi%5E2%20&plus;%2080%20%5Cxi%5E3%20-%2045%20%5Cxi%5E4%20-%2016%20%5Cxi%5E5%20&plus;%2060%20%5Cxi%5E4%20%5Clog%20%5Cxi" /></td>
    </tr>
  </tbody>
</table>

<p>R is either the support radius for the compact support RBFs or a parameter to make the distance values dimensionless for the global support RBFs.</p>

<pre><code class="language-Matlab">[fPar, M] = RBFparam(xs, ys, RBFtype, R)
</code></pre>

<p>returns the weights in the RBF summation and the polynomial coefficients in a column vector fPar by solving a linear system</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7BM%7D%20%26%20%5Cmathbf%7BP%7D_s%20%5C%5C%20%5Cmathbf%7BP%7D_s%5ET%20%26%20%5Cmathbf%7B0%7D%20%5Cend%7Bpmatrix%7D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7B%5Cgamma%7D%20%5C%5C%20%5Cmathbf%7B%5Cbeta%7D%20%5Cend%7Bpmatrix%7D%20%3D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7Bf%7D_s%20%5C%5C%20%5Cmathbf%7B0%7D%20%5Cend%7Bpmatrix%7D" />
</p>

<pre><code class="language-Matlab">[y] = RBFeval(xs, x, fPar, RBFtype, R)
</code></pre>

<p>returns the values of the interpolation weighted function at points x by performing the matrix-vector product</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bf%7D%20%3D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7B%5Chat%7BM%7D%7D%20%26%20%5Cmathbf%7B%5Chat%7BP%7D%7D%20%5Cend%7Bpmatrix%7D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7B%5Cgamma%7D%20%5C%5C%20%5Cmathbf%7B%5Cbeta%7D%20%5Cend%7Bpmatrix%7D" />
</p>

<h2 id="running-the-example">Running the example</h2>

<p>An example case can be run just by typing in the Matlab command line</p>

<pre><code class="language-Matlab">test
</code></pre>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/RBF-interp/master/test.png" />
</p>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/RBF-interp/master/test2.png" />
</p>

<h2 id="references">References</h2>

<ul>
  <li>Beckert, Armin and Wendland, Holger. Multivariate interpolation for fluid-structure-interaction problems using radial basis functions. <em>Aerospace Science and Technology</em>, 5 (2), p. 125-134, 2001.</li>
  <li>Wendland, Holger. <em>Konstruktion und Untersuchung radialer Basisfunktionen mit kompaktem Träger}</em>. PhD thesis, Göttingen, Georg-August-Universität zu Göttingen, Diss, 1996.</li>
  <li>De Boer, A and Van der Schoot, MS and Bijl, Hester. Mesh deformation based on radial basis function interpolation. <em>Computers &amp; structures</em>, 85 (11-14), p. 784-795, 2007.</li>
  <li>Biancolini, Marco Evangelos. <em>Fast Radial Basis Functions for Engineering Applications</em>. Springer, 2018.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;We design a LQR controller for stabilyzing the fractional reaction diffusion equation&lt;/p&gt;
</code></pre></div></div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} y_t + (-d_x^2)^s y-\delta y = u\chi_\omega, & (x,t) \in(-L,L)\times(0,T) \\ y = 0, & (x,t)\in [\mathbb{R}\setminus(-L,L)]\times(0,T) \\ y(x,0) = y_0(x), & x\in(-L,L), \end{cases} %]]></script>

<p>where $\delta&gt;0$ is a given constant, $\omega = (a,b)\subset(-L,L)$ and $(-d_x^2)^s$, $s\in(0,1)$ denotes the one-dimensional fractional Laplacian defined as</p>

<script type="math/tex; mode=display">(-d_x^2)^s y(x) = c(s) P.V. \int_{\mathbb{R}} \frac{y(x)-y(z)}{\vert x-z\vert^{1+2s}}dz,</script>

<p>with $c(s)$ an explicit normalization constant.</p>

<p>When considering this equation without the action of the the control $u$, we know that, depending on the value of $\delta$, the corresponding dynamics may become unstable. This is due to the fact that the eignenvalues of the associated elliptic problem are given by $\mu_k=c-\lambda_k$ ($\lambda_k$ being the eigenvalues of the fractional Laplacian on $(-L,L)$ with zero Dirichlet boundary conditions), and they are positive if $c&gt;\lambda_1$ (since, in addition, we know that $\lambda_1&lt;\lambda_k$ for all $K$). We are then intersted in designing a LQR control which is able to stabilyze this solution and prevent its blow-up.</p>

<p>The computation of the LQR control is carried out by means of the following procedure:</p>

<h2 id="step-1-discretization-of-the-equation">STEP 1. Discretization of the equation</h2>

<p>We start by discretizing our original system on a uniform mesh $x_i$, $i=1,\ldots,N$, thus obtaining a N-dimensional system of the type</p>

<script type="math/tex; mode=display">\begin{cases} \dot{y} = Ay+Bu \\ y(0) = y_0 \end{cases}</script>

<p>where:</p>

<ul>
  <li>
    <p>with some abuse of notation, we denoted $y\in\mathbb{R}^N$ as the   $N$-dimensional vector whose entries $y_i=y(x_i)$, $i=1,\ldots,N$ are   the evaluation of the function $y$ on the points of the mesh;</p>
  </li>
  <li>
    <p>the matrix $A$ is a discretization of the operator $-(-d_x^2)^s + I$,   $I$ denoting the identity;</p>
  </li>
  <li>
    <p>the matrix $B$ defines the action of the control.</p>
  </li>
</ul>

<p>The computation of the matrix requires the discretization of the fractional Laplacian $(-d_x^2)^s$. This is done by employing the function “fl_rigidity”, which implements a finite elements method on a uniform mesh discretizing the space interval $(-L,L)$ (complete details on this method may be found in [1]).</p>

<p>The function “fl_rigidity” works by requiring 3 input parameters:</p>

<ul>
  <li>
    <p>s: the order of the fractional Laplacian, which can be any real value      in the interval $(0,1)$;</p>
  </li>
  <li>
    <p>L: any real value, defining the extrema of the space interval $(-L,L)$;</p>
  </li>
  <li>
    <p>N: the number of discretization points in the mesh employed.</p>
  </li>
</ul>

<p>The outputs are:</p>

<ul>
  <li>
    <p>x: the vector containing the mesh;</p>
  </li>
  <li>
    <p>A: the matrix discretizing the fractional Laplacian.</p>
  </li>
</ul>

<p>The matrix B, instead, is constructed by employing the function “construction_matrix_B”, which takes in input</p>

<ul>
  <li>
    <p>the vector $x$ containing the mesh;</p>
  </li>
  <li>
    <p>the number of discretization points $N$;</p>
  </li>
  <li>
    <p>the characteristic function of the sub-interval $\omega$.</p>
  </li>
</ul>

<h2 id="step-2-definition-of-the-cost-functional-and-computation-of-the-control">STEP 2. Definition of the cost functional and computation of the control</h2>

<p>Once we have the semi-discretization of our original problem, the control we are looking for is computed by minimizing the following cost functional</p>

<script type="math/tex; mode=display">J_{\infty} = \int_{0}^{+\infty} \Big(y^TQy + u^TRu\Big)dt,</script>

<p>where $Q\geq 0$ and $R&gt;0$ are given matrices. Moreover, we know that this control is given in a feedback form by $u^*=-R^{-1}B^TPy$, where $P$ is the solution of the algebraic Riccati equation</p>

<script type="math/tex; mode=display">PA + A^TP-PBB^TP+Q = 0.</script>

<h2 id="implementation">Implementation</h2>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clear</span> <span class="nb">all</span>
<span class="nb">clc</span>
</code></pre></div></div>

<p>We start by defining the parameter $s\in(0,1)$ (order of the fractional Laplacian), the size of the interval $(-L,L)$, the constant $\delta&gt; \lambda_1$ and the number $N$ of discretization points in our mesh.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="nb">pi</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mf">0.1</span><span class="p">;</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div></div>

<p>and we compute the corresponding approximation of the fractional Laplacian</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">FL</span><span class="p">]</span> <span class="o">=</span> <span class="n">fl_rigidity</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
</code></pre></div></div>

<p>We then use it for building the matrix $A$ describing the dynamics</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">D</span> <span class="o">=</span> <span class="n">d</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">FL</span><span class="o">+</span><span class="n">D</span><span class="p">;</span>
</code></pre></div></div>

<p>Secondly, we use the function “construction_matrix_B” for computing the control operator $B$ on the interval $\omega=(-0.3,0.5)$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matrix_B</span> <span class="o">=</span>  <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">interval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.5</span><span class="p">);</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">construction_matrix_B</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">matrix_B</span><span class="p">);</span>
</code></pre></div></div>

<p>Out of the matrices $A$ and $B$, we solve the algebraic Riccati equation by employing the specific function from the control systems toolbox of Matlab. For simplicity, we choose both $R$ and $Q$ as the identity, but other choices are possible in order to improve the efficiency of the method.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="n">Q</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="p">[</span><span class="n">P</span><span class="p">,</span><span class="n">cleig</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">));</span>
</code></pre></div></div>

<p>The output matrix $K=-R^{-1}B^TP$ is used for defining the action of the control and include it in our system</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">eq_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<p>Finally, we choose an initial datum</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y0</span> <span class="o">=</span> <span class="nb">cos</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
</code></pre></div></div>

<p>and we solve our equation with and without control employing the “ode45” function of Matlab. For the equation without control we choose a relatively short time horizon, since we know that the unstable dynamics will rapidly diverge. For the equation with control, instead, we choose a longer time horizon in order to have enough time for stabilyzing the system.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T1</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">T2</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
<span class="n">tspan1</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="n">tspan2</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="n">eq_free</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">[</span><span class="n">time1</span><span class="p">,</span> <span class="n">sol_free</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">eq_free</span><span class="p">,</span><span class="n">tspan1</span><span class="p">,</span><span class="n">y0</span><span class="p">);</span>
<span class="p">[</span><span class="n">time2</span><span class="p">,</span> <span class="n">sol_ctr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">eq_ctr</span><span class="p">,</span><span class="n">tspan2</span><span class="p">,</span><span class="n">y0</span><span class="p">);</span>
</code></pre></div></div>

<p>We then plot our results and compare them. Firstly, the free dynamics.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">surf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">time1</span><span class="p">,</span><span class="n">sol_free</span><span class="p">)</span>
<span class="nb">colormap</span> <span class="nb">jet</span>
<span class="n">msol_free</span> <span class="o">=</span> <span class="nb">floor</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">sol_free</span><span class="p">)));</span>
<span class="n">Msol_free</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">sol_free</span><span class="p">)));</span>
<span class="nb">xticks</span><span class="p">([</span><span class="o">-</span><span class="n">L</span> <span class="n">L</span><span class="p">])</span>
<span class="nb">yticks</span><span class="p">([</span><span class="mi">0</span> <span class="n">T1</span><span class="p">])</span>
<span class="nb">zticks</span><span class="p">([</span><span class="n">msol_free</span> <span class="n">Msol_free</span><span class="p">])</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">135</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Free unstable dynamics'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0001/copiaRM_01.png" alt="" /></p>

<p>We clearly see the growth of the solution, already in the short time horizon [0,4]. When introducing the LQR control, instead, the problem is corrected and the equation is stabilyzed in time $T_2$</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">surf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">time2</span><span class="p">,</span><span class="n">sol_ctr</span><span class="p">)</span>
<span class="nb">colormap</span> <span class="nb">jet</span>
<span class="n">msol_ctr</span> <span class="o">=</span> <span class="nb">floor</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">sol_ctr</span><span class="p">)));</span>
<span class="n">Msol_ctr</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">sol_ctr</span><span class="p">)));</span>
<span class="nb">xticks</span><span class="p">([</span><span class="o">-</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">])</span>
<span class="nb">yticks</span><span class="p">([</span><span class="mi">0</span> <span class="n">T2</span><span class="p">])</span>
<span class="nb">zticks</span><span class="p">([</span><span class="n">msol_ctr</span> <span class="n">Msol_ctr</span><span class="p">])</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">135</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Controlled dynamics'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/OT02/P0001/copiaRM_02.png" alt="" /></p>

<h2 id="references">References</h2>

<p>[1] U. Biccari and V. Hernandez-Santamaria, “Controllability of a one-dimensional fractional heat equation: theoretical and nuerical aspects”, IMA J. Math. Control I. (2018).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3&gt;Featured Video&lt;/h3&gt;
</code></pre></div></div>

<p><i>Evolution of the controls and of the state for $y^0=1$, $y^1=5$, $M=20$ and the discretization parameters $N_x=30$, $N_t=450$ in the minimal computed time $T\simeq\mathtt{0.2093}$.</i></p>
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>

<h3>Introduction</h3>

<p>In this short tutorial we explain how to use IpOpt in order to solve time optimal control problems. We refer to [<a href="#cite1">1</a>,<a href="#cite4">4</a>,<a href="#cite5">5</a>] for a survey on numerical methods in optimal control and how to implement them efficiently according to the context.</p>
<h4>The tools</h4>
<ul>
 	<li><a href="https://projects.coin-or.org/Ipopt" target="_blank" rel="noopener noreferrer">IpOpt</a> is an interior-point optimization routine (see <a href="#IPOPT">[6]</a>).
Basically, it numerically solves optimisation problems of the form:                                   

$$
\begin{equation}\label{eq:P0}\tag{P0}
			\begin{array}{cl}
				\min &amp; f(x)\\
				 &amp; \begin{array}{l}
					x\in\mathbb{R}^n\, ,\\
					g(x)\leqslant 0\, ,\\
					h(x)=0\, .
				\end{array}
			\end{array}
		\end{equation}

$$

IpOpt can be used together with <a href="https://www.mathworks.com/products/matlab.html" target="_blank" rel="noopener noreferrer">Matlab</a>, <a href="http://www.freefem.org" target="_blank" rel="noopener noreferrer">FreeFem++</a>...and can be used directly in <strong>.cpp</strong> codes.</li>
 	<li><a href="http://ampl.com/" target="_blank" rel="noopener noreferrer">AMPL</a> is an automatic differentiation and the modelling language (see <a href="#AMPL">[2]</a>). The interest of using AMPL together with IpOpt is that, the gradient of the cost function and the constraints is automatically generated. Solving problems with IpOpt and AMPL can be made online through the <a href="https://neos-server.org/neos/solvers/nco:Ipopt/AMPL.html" target="_blank" rel="noopener noreferrer">NEOS</a> solvers.</li>
</ul>
<h4>Solving problem (P0)</h4>
<p>Let us write in AMPL language the problem (P0).</p>
<pre><span style="color: green;"># The variable of the problem</span>
<b>var</b> x {i in 1..n}
<span style="color: green;"># The cost function to be minimized</span>
<b>minimize</b> cost : f(x); 						 
<span style="color: green;"># The inequality constraints</span>
<b>subject to</b> inequality_constraints : g(x)&lt;=0;
<span style="color: green;"> # The equality constraints</span>
<b>subject to</b> equality_constraints: h(x)=0; 	
<span style="color: green;"> # Set IpOpt as solver</span>
<b>option solver</b> ipopt;						 
<span style="color: green;"># Set options for IpOpt, such as the maximal number of iterations</span>
<b>option</b> ipopt_options <span style="color: brown;">"max_iter=20000 linear_solver=mumps halt_on_ampl_error yes"</span>;
<span style="color: green;"># Solve the problem</span>
<b>solve</b>;
<span style="color: green;"># Display the cost value</span>
<b>printf</b> : <span style="color: brown;">"# cost = %24.16e\n"</span>, cost;		
<b>printf</b> : <span style="color: brown;">"# Data\n"</span>;
<span style="color: green;"># Display the optimal values of x</span>
<b>printf</b> {i in 0..n} : <span style="color: brown;">"%24.16e\n"</span>, x[i];		
<span style="color: green;"># Quit AMPL</span>
<b>end</b>;										
</pre>
<h4>Solving a time optimal control problem with constraints</h4>
<p>Let us now turn to a time optimal control problem.
Given a dynamical system,</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:1a}
\dot{y}=f(y,u)\, ,
\end{equation}</script>

<p>some initial condition $\mathrm{y}^0\in \mathbb{R}^n$ and some terminal condition $\mathrm{y}^1\in\mathbb{R}^n$ and some bound $M&gt;0$, the aim is to find the minimal time $T\geqslant 0$ such that there exist a control $u\in L^\infty(0,T)^m$ such that,</p>

<script type="math/tex; mode=display">\begin{equation}
|u_i(t)|\leqslant M  (t\in(0,T)\ \text{a.e.}\, ,\ i\in\{1,\dots,m\}),
\end{equation}</script>

<p>and the solution $y$ of (1) satisfies the constraint,</p>

<script type="math/tex; mode=display">\begin{equation}
g(y(t))\leqslant 0 (t\in(0,T)),
\end{equation}</script>

<p>and the terminal condition,</p>

<script type="math/tex; mode=display">\begin{equation}
y(T)=\mathrm{y}^1\, ,
\end{equation}</script>

<p>where $g$ is given and define constraints of the state variable $y$. Of course to be able to solve this system, one needs to have $g(\mathrm{y}^0)\leqslant0$ and $g(\mathrm{y}^1)\leqslant0$.
The above optimal control problem, can be recast as an optimisation problem under constraints similar to (P0). More precisely, it is</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{cl}
	\min & T\\
	 & \begin{array}{l}
		u\in L^\infty(0,T)^M\, ,\\
		\dot{y}=f(y,u)\, , y(0)=\mathrm{y}^0\, ,\\
		y(T)=\mathrm{y}^1\, ,\\
		g(y(t))\leqslant 0 (t\in(0,T)).
	\end{array}
\end{array} %]]></script>

<p>In order to handle numerically, this problem, we will use a time discretization. Let us explain it with the explicit Euler method. But any other time discretization can be used.
Fix some parameter $N_t\in\mathbb{N}^*$ (the number of time steps) and for $T&gt;0$ given, define $y_i$ the estimation of $y(iT/N_t)$ for $i\in{0,\dots,N_t}$. The explicit Euler scheme, gives the relation,</p>

<script type="math/tex; mode=display">y_{i+1}=y_i+\frac{T}{N_t}f(y_i,u_i)\, ,</script>

<p>with $u_i\simeq u(iT/N_t)$. Then the state and control constraints are replaced by:</p>

<script type="math/tex; mode=display">g(y_i)\leqslant 0 \text{and} |u_i|\leqslant M\, .</script>

<p>Consequently, in discretized version, we end up with a finite dimensional control problem under constraints, whose AMPL version is:</p>
<pre><span style="color: green;"># Define the parameters of the problem</span>
<span style="color: green;"># number of time step discretization points</span>
<b>param</b> Nt=100;
<span style="color: green;"># bound on the control</span>
<b>param</b> M =1;   
<span style="color: green;"># initial condition</span>
<b>param</b> y0=1;
<span style="color: green;"># final condition</span>
<b>param</b> y1=0;

<span style="color: green;"># Define variables of the problem</span>
<b>var</b> y {i in 0..Nt};
<span style="color: green;"># The control shall be in [-M,M]</span>
<b>var</b> u {i in 0..Nt} &gt;=M, &lt;=M;  
<span style="color: green;"># The time T shall be nonnegative</span>
<b>var</b> T &gt;=0;                    

<span style="color: green;"># The cost function is the time T</span>
<b>minimize</b> cost: T;
<span style="color: green;"># Set the constraints</span>
<span style="color: green;"># y is solution of (1)</span>
<b>subject to</b> y_dyn {i in 0..Nt-1} :                        
		y[i+1]=y[i]+T/Nt*f(y[i],u[i]);
<span style="color: green;"># y(0)=y0</span>
<b>subject to</b> y_init : y[0] =y0;                            
<span style="color: green;"># y(T)=y1</span>
<b>subject to</b> y_end  : y[Nt]=y1;                            
<span style="color: green;"># g(y(t))&lt;=0</span>
<b>subject to</b> state_constraint {i in 1..Nt-1} : g(y[i])&lt;=0;

<span style="color: green;"># Solve with IpOpt</span>
<b>option solver</b> ipopt;
<b>option</b> ipopt_options <span style="color: brown;">"max_iter=20000 linear_solver=mumps halt_on_ampl_error yes"</span>;
<b>solve</b>;
<span style="color: green;"># Display solution</span>
<b>printf</b> : <span style="color: brown;">"# T = %24.16e\n"</span>, T;
<b>printf</b> : <span style="color: brown;">"# Nt = %d\n"</span>, Nt;
<b>printf</b> : <span style="color: brown;">"# Data\n"</span>;
<b>printf</b> {i in 0..Nt} : <span style="color: brown;">" %24.16e\n"</span>, u[i];
<b>printf</b> {i in 0..Nt} : <span style="color: brown;">" %24.16e\n"</span>, y[i];
<b>end</b>;
</pre>
<h4>Application to the constrained heat equation</h4>
<p>Now we can turn to the control of the heat equation with nonnegative state constraint.
To this end, we consider the controlled 1D heat equation with Neumann boundary control.</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc2}
\left\{
\begin{array}{r@{\>}l@{}l}
\dot{y}(t,x)  =\partial_x^2y(t,x)  (t>0\, ,\ x\in(0,1)),\\[2mm]
\partial_xy(t,0)  =v_0(t)  (t>0),\\[2mm]
\partial_xy(t,1)  =v_1(t)  (t>0),
\end{array}
\right.
\end{equation}</script>

<p>To this problem, we add the control constraints,</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc2CC}
|v_0(t)|\leqslant M \text{and} |v_1(t)|\leqslant M (t>0\ \text{a.e.}),
\end{equation}</script>

<p>with some $M&gt;0$ given and we add the state constraint,</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc2SC}
y(t,x)\geqslant 0 ( (t,x)\in \mathbb{R}_+^*\times(0,1)\ \text{a.e.}).
\end{equation}</script>

<p>To the system (5) we add the initial condition</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc2IC}
y(0,x)=y^0(x) (x\in(0,1)),
\end{equation}</script>

<p>and the terminal condition</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc2TC}
y(T,x)=y^1(x) (x\in(0,1)).
\end{equation}</script>

<p>In <a href="#LTZheat">[3]</a>, it has been proved that every positive constant state $\mathrm{y}^0$ can be steered to some over positive constant state $\mathrm{y}^1$ in a large enough time $T$. Our goal here is to find numerically the minimal time $T$ such there exist controls satisfying (6) such that the corresponding solution $y$ of (5) and (8) satisfies the constraint (6) and the terminal condition (9), i.e.~ we aim to minimize</p>

<script type="math/tex; mode=display">\begin{array}{cl}
\min  T\\
  \begin{array}{l}
T>0\, ,\\
v_0,\, v_1\in L^\infty(0,T)\, ,
y \text{ solution of (5) and (8) satisfies}\\
 y(T,\cdot)=y^1 \text{and} y(t,x)\geqslant 0 (t>0,\ x\in(0,1)\ $\text{a.e.}$).
\end{array}
\end{array}</script>

<p>Firstly, we will use a space discretization to reduce the system (5). To this end, we define $N\in\mathbb{N}^*$ and for every $n\in{0,\dots,N}$, $x_n=\frac{n}{N}$. Based on this discretization of $[0,1]$, we will discretized (5) using centered finite differences. That is to say, given $V(t)=(v_0(t)\, ,\ v_1(t))^\top$ and $Y(t)\in \mathbb{R}^{N+1}$, a vector approaching $\bigl( y(t,x_0),\ \dots,\ y(t,x_N)\bigr)^\top$, $Y$ is solution of</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc3a}
	\dot{Y}=AY+BV (t>0)\, ,
\end{equation}</script>

<p>with the initial condition</p>

<script type="math/tex; mode=display">\begin{equation}
	Y(0)=\mathrm{y}^0e_{N+1}
\end{equation}</script>

<p>the target state,</p>

<script type="math/tex; mode=display">\begin{equation}
	Y(T)=\mathrm{y}^1e_{N+1}
\end{equation}</script>

<p>the state constraint,</p>

<script type="math/tex; mode=display">\begin{equation}
	Y(t)\geqslant 0  (t>0\ \text{a.e.})
\end{equation}</script>

<p>and the control constraint,</p>

<script type="math/tex; mode=display">\begin{equation}
	|V_0(t)|\leqslant M\text{and} |V_1(t)|\leqslant M (t>0\ \text{a.e.})\, ,
\end{equation}</script>

<p>where we have set $e_{N+1}=(1,\dots,1)^\top\in\mathbb{R}^{N+1}$,</p>

<script type="math/tex; mode=display">% <![CDATA[
A=N^2\begin{pmatrix}
2 & -2  & 0 & \hdots &\hdots & \hdots & 0\\
1 & -2  & 1 & 0  & \hdots &  \hdots & 0\\
0 & \ddots & \ddots &  \ddots &  \ddots  & \vdots\\
\vdots & \ddots & \ddots  & \ddots & \ddots & \ddots & \vdots\\
\vdots & \ddots & \ddots & \ddots  & \ddots & 0\\
0  & \hdots & \hdots & 0 & 1 & -2 & 1\\
0  & \hdots & \hdots & \hdots & 0  &2 & -2\\
\end{pmatrix}\in M_{N+1}(R)\text{and} B=2N\begin{pmatrix}
1 & 0\\
0 & \vdots\\
\vdots & \vdots\\
\vdots & \vdots\\
\vdots & \vdots\\
\vdots& 0\\
0  &  1
\end{pmatrix}\in M_{N+1,2}(\mathbb{R})\, . %]]></script>

<p>Now we can discretize (10) using explicit Euler scheme and similarly to the previous example, we obtain an optimisation problem of finite dimension with constraints whose AMPL formulation is</p>
<pre><span style="color: green;"># Parameters of the problem</span>
<b>param</b> Nx=30;   <span style="color: green;"># Number of space discretisation points</span>
<b>param</b> Nt=300;  <span style="color: green;"># Number of time discretisation points</span>
<span style="color: green;"># One have to check a posteriori that the number of time steps is large enough so that the</span>
<span style="color: green;"># CFL condition, T*Nx^2/Nt &lt;=1/2, is satisfied</span>
<b>param</b> dx=1/Nx; <span style="color: green;"># Space step</span>
<b>param</b> M =20;   <span style="color: green;"># Bound on the controls</span>

<span style="color: green;"># Variables of the system</span>
<span style="color: green;"># i stands for the time index and j for the space index</span>
<b>var</b> y {i in 0..Nt, j in 0..Nx} &gt;=0; <span style="color: green;"># State of the control problem</span>
<span style="color: green;"># Neuman controls in 0 and 1. The controls are in [-M,M].</span>
<b>var</b> v0 {i in 0..Nt} &gt;=-M, &lt;=M;
<b>var</b> v1 {i in 0..Nt} &gt;=-M, &lt;=M;
<b>var</b> T &gt;=0;      <span style="color: green;"># Control time</span>
<b>var</b> dt=T/Nt;    <span style="color: green;"># Time step</span>

<span style="color: green;"># Define the cost function</span>
<b>minimize</b> cost: T;

<span style="color: green;"># Define the constraints</span>
<span style="color: green;"># y is solution of the discretize system</span>
<b>subject to</b> y_dyn {i in 0..Nt-1, j in 1..Nx-1}:
	(y[i+1,j]-y[i,j])*(dx)^2=(y[i,j-1]-2*y[i,j]+y[i,j+1])*dt;
<span style="color: green;"># Neuman boundary conditions in 0 and 1</span>
<b>subject to</b> left_boundary  {i in 1..Nt-1}: y[i,1]-y[i,0]    =v0[i]*dx;
<b>subject to</b> right_boundary {i in 1..Nt-1}: y[i,Nx]-y[i,Nx-1]=v1[i]*dx;
<span style="color: green;"># y(0)=y0 and y(T)=y1</span>
<b>subject to</b> y_init {j in 0..Nx}: y[0,j] =5;
<b>subject to</b> y_end  {j in 0..Nx}: y[Nt,j]=1;

<span style="color: green;"># Solve with IpOpt</span>
<b>option solver</b> ipopt;
<b>option</b> ipopt_options <span style="color: brown;">"max_iter=2000 linear_solver=mumps halt_on_ampl_error yes"</span>;
<b>solve</b>;

<span style="color: green;"># Write the solution in the file out.txt</span>
<b>printf</b>: <span style="color: brown;">" # T = %24.16e\n"</span>, T &gt;  out.txt;
<b>printf</b>: <span style="color: brown;">" # Nx = %d\n"</span>, Nx    &gt;&gt; out.txt;
<b>printf</b>: <span style="color: brown;">" # Nt = %d\n"</span>, Nt    &gt;&gt; out.txt;
<b>printf</b>: <span style="color: brown;">" # Data\n"</span>           &gt;&gt; out.txt;
<b>printf</b> {i in 0..Nt}: <span style="color: brown;">" %24.16e\n"</span>, v0[i] &gt;&gt; out.txt;
<b>printf</b> {i in 0..Nt}: <span style="color: brown;">" %24.16e\n"</span>, v1[i] &gt;&gt; out.txt;
<b>printf</b> {i in 0..Nt, j in 0..Nx}: <span style="color: brown;">" %24.16e\n"</span>, y[i,j] &gt;&gt; out.txt;

<b>end</b>;
</pre>
<p>Once the file out.txt is written, it can be for instance read by <a name="scilab">Scilab</a> with the following code</p>
<pre>fid= <b>mopen</b>(<span style="color: brown;">'out.txt'</span>,<span style="color: brown;">'r'</span>);            <span style="color: green;">// Open out.txt</span>
T  = <b>mfscanf</b>(fid,<span style="color: brown;">'%s %s %s'</span>);         <span style="color: green;">// Read ``# T =''</span>
T  = <b>mfscanf</b>(fid,<span style="color: brown;">'%f'</span>);               <span style="color: green;">// Read value of T</span>
Nx = <b>mfscanf</b>(fid,<span style="color: brown;">'%s %s %s'</span>);         <span style="color: green;">// Read ``# Nx =''</span>
Nx = <b>mfscanf</b>(fid,<span style="color: brown;">'%d'</span>);               <span style="color: green;">// Read value of Nx</span>
Nt = <b>mfscanf</b>(fid,<span style="color: brown;">'%s %s %s'</span>);         <span style="color: green;">// Read ``# Nt =''</span>
Nt = <b>mfscanf</b>(fid,<span style="color: brown;">'%d'</span>);               <span style="color: green;">// Read value of Nt</span>
s  = <b>mfscanf</b>(fid,<span style="color: brown;">'%s %s'</span>); s=[];      <span style="color: green;">// Read ``# Data''</span>
v0 = <b>mfscanf</b>(Nt+1,fid,<span style="color: brown;">'%f'</span>); v0=v0';  <span style="color: green;">// Read the Nt+1 values of v0</span>
v1 = <b>mfscanf</b>(Nt+1,fid,<span style="color: brown;">'%f'</span>); v1=v1';  <span style="color: green;">// Read the Nt+1 values of v1</span>
y  = <b>mfscanf</b>((Nt+1)*(Nx+1),fid,<span style="color: brown;">'%f'</span>); <span style="color: green;">// Read the (Nt+1)*(Nx+1) values of y</span>
<b>mclose</b>(fid);                          <span style="color: green;">// Close out.txt</span>

y = <b>matrix</b>(y,Nx+1,Nt+1); y=y'; <span style="color: green;">// Reshape y as a matrix, line i is the solution at time i/Nt</span>
x = 0:1/Nx:1; t = 0:T/Nt:T;    <span style="color: green;">// Define the space and time discretisations</span>
<b>printf</b>(<span style="color: brown;">'time:\t%f\n'</span>,T);       <span style="color: green;">// Display the control time</span>
<b>plot</b>(t,[v0;v1]); <b>sleep</b>(2000); <b>clf</b>();               <span style="color: green;">// plot controls and wait 2s</span>
<b>plot2d</b>(x,y(1,:),rect=[0 0 1 10]); <b>sleep</b>(100);      <span style="color: green;">// plot the initial state and wait 0.1s</span>
<b>for</b> i=2:1:Nt,
	<b>plot</b>(x,y(i,:),rect=[0 0 1 10]); <b>sleep</b>(10); <span style="color: green;">// plot the state at each time instants</span>
<b>end</b>
<b>plot</b>(x,y(\$,:),rect=[0 0 1 10]);
<span style="color: green;">// plot the final state</span>
</pre>
<p>Based on these two codes, we obtain</p>
<ul>
 	<li>for $y^0=1$, $y^1=5$, $M=20$ and the discretization parameters $N_x=30$, $N_t=450$ the results displayed on the video:
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
(the minimal time obtained is $T\simeq\mathtt{0.2093}$);</li>
 	<li>for $y^0=5$, $y^1=1$, $M=800$ and the discretization parameters $N_x=30$, $N_t=450$ the results displayed on the video:
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N2.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N2.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
(the minimal time obtained is $T\simeq\mathtt{0.1938}$).</li>
</ul>
<p>Similarly, we can consider the time optimal control problem,</p>

<script type="math/tex; mode=display">\begin{array}{cl}
\min  T\\
  \begin{array}{l}
T>0\, ,\\
u_0,\, u_1\in L^\infty(0,T)\\
u_0(t)\geqslant0\text{and} u_1(t)\geqslant 0  (t\in(0,T)\ \text{a.e.}),\\
y \text{ solution of (11) satisfies } y(T,\cdot)=y^1\, ,
\end{array}
\end{array}</script>

<p>with (11) given by,</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc4}
\left\{\begin{array}{r@{\>}l@{}l}
\dot{y}(t,x)  =\partial_x^2y(t,x)  (t>0\, ,\ x\in(0,1)),\\[2mm]
y(t,0)  =u_0(t)  (t>0),\\[2mm]
y(t,1)  =u_1(t)  (t>0),\\[2mm]
y(0,x)  =y^0(x)  (x\in(0,1).
\end{array}\right.
\end{equation}</script>

<p>Numerically, we obtain</p>
<ul>
 	<li>for $y^0=5$, $y^1=1$, $M=50$ and the discretization parameters $N_x=30$, $N_t=450$ the results displayed on the video:
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
(the minimal time obtained is $T\simeq\mathtt{0.1931}$);</li>
 	<li>for $y^0=1$, $y^1=5$, $M=50$ and the discretization parameters $N_x=20$, $N_t=200$ the results displayed on the video:
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D2.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D2.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
(the minimal time obtained is $T\simeq\mathtt{0.0498}$);</li>
 	<li>for $y^0=1$, $y^1=5$, $M=3000$ and the discretization parameters $N_x=20$, $N_t=200$ the results displayed on the video:
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D3.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D3.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
(the minimal time obtained is $T\simeq\mathtt{0.0438}$).</li>
</ul>
<h3>Useful links</h3>
<ul>
 	<li>IpOpt project: <a href="https://projects.coin-or.org/Ipopt" target="_blank">https://projects.coin-or.org/Ipopt</a></li>
 	<li>AMPL project: <a href="http://ampl.com/products/ampl/" target="_blank">http://ampl.com/products/ampl/</a></li>
 	<li>NEOS solvers: <a href="https://neos-server.org/neos/solvers/" target="_blank">https://neos-server.org/neos/solvers/</a></li>
</ul>

<h6>References</h6>

<p><strong>[1]</strong> J. T. Betts. <a href="http://epubs.siam.org/doi/book/10.1137/1.9780898718577" name="cite1" target="_blank"><em>Practical methods for optimal control and estimation using nonlinear programming.</em></a> 2nd ed. Philadelphia, PA: Society for Industrial and Applied Mathematics (SIAM),2nd ed. edition, 2010.</p>

<p><strong>[2]</strong> R. Fourer, D. M. Gay, and B. W. Kernighan. <a href="http://ampl.com/resources/the-ampl-book/" name="cite2" target="_blank"><em>A modeling language for mathematical programming.</em></a> Manage. Sci., 36(5):519–554, 1990.</p>

<p><strong>[3]</strong> J. Lohéac, E. Trélat, and E. Zuazua. <a name="cite3" target="_blank"></a><em>Minimal controllability time for the heat equation under state constraints.</em> In preparation.</p>

<p><strong>[4]</strong> E. Trélat. <a href="https://www.ljll.math.upmc.fr/trelat/fichiers/livreopt.pdf" name="cite4" target="_blank"><em>Contrôle optimal. Théorie et applications.</em></a> Paris: Vuibert, 2005.</p>

<p><strong>[5]</strong> E. Trélat. <a href="https://www.ljll.math.upmc.fr/trelat/fichiers/contaero.pdf" name="cite5" target="_blank"><em>Optimal control and applications to aerospace: some results and challenges.</em></a> J.Optim. Theory Appl., 154(3):713–758, 2012.</p>

<p><strong>[6]</strong> A. Wächter and L. T. Biegler. <a href="http://link.springer.com/article/10.1007/s10107-004-0559-y" name="cite6" target="_blank"><em>On the implementation of an interior-point filter line-search algorithm for large-scale nonlinear programming.</em></a> Math. Program., 106(1 (A)):25–57, 2006.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3&gt;The problem&lt;/h3&gt;
</code></pre></div></div>
<p>We analyze a model tracking problem for a 1D scalar conservation law. It consists in optimizing the initial datum so to minimize a weighted distance to a given target during a given finite time horizon. To be more precise, given a finite time $T &gt; 0$,  a target function $u^d\in L^2(\mathbb R\times(0,T))$, and a positive weight  function $\rho\in L^\infty(\mathbb R\times(0,T))$ with compact support in $\mathbb R\times(0,T)$, we consider the functional cost  to be minimized $J$, over a suitable class of initial data $\mathcal{U}_{ad}$, defined by</p>

<script type="math/tex; mode=display">\begin{equation}\label{FunctionalJ}
J(u^0)=\frac 1 2\int_0^T\int_{\mathbb{R}}\rho(x,t)|u(x,t)-u^d(x,t)|^2dxdt,
\end{equation}</script>

<p>where  $u:\mathbb R_x\times\mathbb R_t\to \mathbb R$ is the unique entropy solution of the scalar conservation law</p>

<script type="math/tex; mode=display">\begin{equation}\label{conservativeEquation}
\partial_t u+\partial_x(f(u))=0,\; \textrm{in }\mathbb R \times(0,T); \;\;\; u(x,0)=u^0(x),\; x\in\mathbb R.
\end{equation}</script>

<p>Thus, the problem under consideration reads: To find $u^{0,min}\in\mathcal{U}_{ad}$ such that</p>

<script type="math/tex; mode=display">\begin{equation}\label{optimalProblem}
J(u^{0,min})=\min_{u^0\in\mathcal{U}_{ab}}J(u^0).
\end{equation}</script>

<p>Here the flux $f:\mathbb R\to\mathbb R$ is assumed to be  smooth:  $f\in C^1(\mathbb R,\mathbb R)$. The initial datum $u^0$ will be assumed to belong to a suitable admissible class $\mathcal{U}_{ad}$ to ensure the existence of a minimizer.</p>
<h5>Sensitivity of the state in the presence of shocks</h5>
<p>Inspired in several results on the sensitivity of  solutions of conservation laws in the presence of shocks in one-dimension  (see [<a href="#BressanMarson1995">7</a>, <a href="#BardosPironneau2002">4</a>, <a href="#BouchutJames1998">5</a>, <a href="#BouchutJames1999">6</a>, <a href="#Ulbrich2003">17</a>, <a href="#GodlewskiRaviart1999">13</a>]), we focus on the particular case of solutions having a single shock. But the analysis can be extended to consider more general one-dimensional systems of conservation laws with a finite number of noninteracting shocks. We introduce the following hypothesis:</p>

<p><strong>Hypothesis 1.1:</strong>
<i>Assume that $u(x,t)$ is a weak entropy solution of (\ref{conservativeEquation}) with a discontinuity along a regular curve $\Sigma={(\varphi(t),t),\;t\in(0,T)}$, which is Lipschitz continuous outside $\Sigma$. In particular, it satisfies the Rankine-Hugoniot condition on $\Sigma$</i></p>

<script type="math/tex; mode=display">\varphi'(t)[u]_{\Sigma^t}=[f(u)]_{\Sigma^t}.</script>

<p><i>Here we have used the notation: </i></p>

<script type="math/tex; mode=display">[v]_{\Sigma^t}=\lim\limits_{\varepsilon\searrow 0}v(\varphi(t)+\varepsilon,t) -v(\varphi(t)-\varepsilon,t)</script>

<p><i>for the jump at $\Sigma^t=(\varphi(t),t)$ of any piecewise continuous function $v$ with a discontinuity at $\Sigma^t$.
</i></p>

<p>Note that $\Sigma$ divides $\mathbb R \times (0, T )$ into two parts: $Q_-$ and $Q_+$ , the sub-domains of $\mathbb R \times (0, T)$ to the left and to the right of $\Sigma$ respectively.
As we will see, in the presence of shocks, to deal correctly with optimal control and design problems, the state of the system needs to be viewed as constituted by the pair $(u,\varphi)$ combining the solution of (\ref{conservativeEquation}) and the shock location $\varphi$. This is relevant in the analysis of sensitivity of functions below and when applying descent algorithms.
We adopt the functional framework based on the generalized tangent vectors (see [<a href="#BressanMarson1995">7</a>] and Definition 4.1 in [<a href="#castro2008alternating">8</a>]).
Let $u^0$ be the initial datum,  that we assume to be Lipschitz continuous to both sides of a single discontinuity located at $x = \varphi^0$, and consider a generalized tangent vector $(\delta u^0,\delta \varphi^0) \in L^1(\mathbb R) \times \mathbb R$ for all $0 \leq T$. Let $u^{0,\varepsilon}$ be a path which generates $(\delta u^0,\delta \varphi^0)$. For $\varepsilon$ sufficiently small, the solution $u^\varepsilon(\cdot,t)$ of (\ref{conservativeEquation}) is Lipschitz continuous with a single discontinuity at $x = \varphi^{\varepsilon}(t)$, for all $t \in [0,T]$. Therefore, $u^{\varepsilon}(\cdot, t)$ generates a generalized tangent vector $(\delta u(, t), \delta\varphi(t)) \in L^1(\mathbb R) \times \mathbb R$. Moreover, in [<a href="#castro2008alternating">8</a>] it is proved that it satisfies the following linearized system:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray}
\label{1DlinearizedSystem01}
\partial_t \delta u+\partial_x(f'(u)\delta u)&=&0,\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{in } Q_-\cup Q_+\\
\label{1DlinearizedSystem03}
\frac{d}{dt}\left([u]_{\Sigma^t}\delta\varphi\right)&=&[f'(u)\delta u]_{\Sigma^t}-[\delta u]_{\Sigma^t}\frac{d}{dt}\varphi,\;\; t\in(0,T)\\
\label{1DlinearizedSystem02}
\delta u(x,0)&=&\delta u^0(x),\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\{x<\varphi^0\}\cup\{x>\varphi^0\}\\
\label{1DlinearizedSystem04}
\delta\varphi(0)&=&\delta\varphi^0.
\end{eqnarray} %]]></script>

<h5>Sensitivity of the cost in the presence of shocks</h5>
<p>In this section we study  the sensitivity of the functional $J$ with respect to variations associated with the generalized tangent vectors defined in the previous section. We first define an appropriate generalization of the Gateaux derivative of $J$.</p>

<p><strong>Definition 1.2:</strong> <i>Let $J : L^1(\mathbb R) \to \mathbb R$ be a functional and $u^0 \in L^1(\mathbb R)$ be Lipschitz continuous with a discontinuity in  $\Sigma^0$, an initial datum for which the solution of (\ref{conservativeEquation}) satisfies hypothesis (1.1). $J$ is Gateaux differentiable at $u^0$ in a generalized sense if for any generalized tangent vector $(\delta u^0,\delta \varphi^0)$ and any family $u^{0,\varepsilon}$	associated to $(\delta u^0, \delta \varphi^0)$ the following limit exists,</i></p>

<script type="math/tex; mode=display">\delta J=\lim_{\varepsilon\to 0}\frac{J(u^{0,\varepsilon})-J(u^0)}{\varepsilon},</script>

<p>and it depends only on $(u^0,\varphi^0)$ and $(\delta u^0,\delta\varphi^0)$, i.e. it does not depend on the particular family $u^{0,\varepsilon}$ which generates $(\delta u^0,\delta\varphi^0)$. The limit is the generalized Gateux derivative of $J$ in the direction $(\delta u^0,\delta\varphi^0)$.
&lt;/i&gt;</p>

<p>The following result easily provides a characterization of the generalized Gateaux derivative of $J$ in terms of the solution of the associated adjoint system (\ref{1DSystemAdj}).</p>

<p><strong>Proposition 1.3:</strong> <em>The Gateaux derivative of $J$ can be written as follows</em></p>

<script type="math/tex; mode=display">\begin{equation}
\label{GateauxDerivativeJ02}
\delta J(u^0)[\delta u^0,\delta\varphi^0]=\int_{\RR}p(x,0)\delta u^0(x) dx-q(0)[u]_{\Sigma^0}\delta\varphi^0,
\end{equation}</script>

<p>where the adjoint state pair $(p,q)$ satisfies the system</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray}
\label{1DSystemAdj}
-\partial_t p-f'(u)\partial_x p&=&\rho\,(u-u^d),\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; \text{in } Q_-\cup Q_+\\  
\,[p]_{\Sigma^t}&=&0,\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; t\in(0,T) \label{1Dadjoint0202}\\
q(t)&=&p(\varphi(t),t),\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; t\in (0,T)\label{1Dadjoint0203}\\
-\frac{d}{dt}q&=&\frac{(1+(\dot{\varphi})^2)^{1/2}[\rho\,(u-u^d)^2]_{\Sigma^t}}{2[u]_{\Sigma^t}},\;\;\;\;\;\;\;\;\; t\in (0,T) \label{1Dadjoint03} \\
p(x,T)&=&0,\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\{x<\varphi(T)\}\cup\{x>\varphi(T)\} \label{1Dadjoint02}\\
q(T)&=&0. \label{1Dadjoint04}
\end{eqnarray} %]]></script>

<p>Let us briefly comment the result of Proposition 1.3 before giving its proof.
System (\ref{1DSystemAdj}) has a unique solution. In fact, to solve the backward system (\ref{1DSystemAdj}) we first define the solution $q$ on the shock $\Sigma$ from the conditions for $q$. This determines the value of $p$ along the shock. We then propagate this information to both sides of $\Sigma$, by characteristics (see Figure 1 where we illustrate this construction).</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/05/ConservationLawsShocksFig1.jpg" alt="Characteristic lines entering on a shock" width="600" /> Figure 1: Characteristic lines entering on a shock and how they may be used to build the solution of the adjoint system both away from the shock and on its region of influence.</p>

<p>Formula (\ref{GateauxDerivativeJ02}) provides an obvious way to compute a first descent direction of $J$ at $u^0$. We just take</p>

<script type="math/tex; mode=display">\begin{equation}\label{descentDirection01}
(\delta u^0,\delta \varphi^0)=(-p(\cdot,0),q(0)[u]_{\Sigma^0}).
\end{equation}</script>

<p>Here, the value of $\delta \varphi^0$ must be interpreted as the optimal infinitesimal displacement of the discontinuity of $u^0$.</p>

<p>In [<a href="#castro2008alternating">8</a>], when considering the inverse design problem, it was observed that the solution $p$ of the corresponding adjoint system at $t=0$ was discontinuous, with two discontinuities, one in each side of the original location of the discontinuity at $\Sigma^0$. This was a reason not to use this descent direction and  for introducing the alternating descent method. In the present setting, however, the adjoint state $p$ obtained is typically continuous. This is due to the fact that $p$ at both side of the discontinuity is defined by the method of characteristics and that, on the region of influence of the characteristics emanating from the shock, the continuity is preserved by the fact that, on one hand, $q=q(t)$ itself is continuous as the primitive of an integrable function and that the data for $p$ and $q$ at $t=T$ are continuous too. Despite of this, as we shall see, the implementation of the alternating descent direction method is worth since it significantly improves the results obtained by the purely discrete approach.</p>

<h3>Numerical Experiments</h3>
<p>In this section we present some numerical experiments which illustrate the results obtained in an optimization model problem with each one of the numerical methods described in the previous section.
We have chosen as computational domain the interval $(-4, 4)$ and we have taken as boundary conditions in the numerical scheme, at each time step $t = t^n$, the value of the initial data at the boundary. This can be justified if we assume that the initial datum $u^0$ is constant in a sufficiently large inner neighborhood of the boundary $x = \pm 4$ (which depends on the size of the $L^\infty$-norm of the data under consideration and the time horizon $T$), due to the finite speed of propagation. A similar procedure is employed for the adjoint equation.
We underline once more that the solutions obtained with each method may correspond to global minima or local ones since the gradient algorithm does not distinguish them.
In the experiments we consider the Burgers’ equation, i.e. $f(z)=z^2/2$,</p>

<script type="math/tex; mode=display">\begin{equation}\label{BurgerNumerica}
\partial_tu+\partial_x\left(\frac{u^2}{2}\right)=0,\;\;\; u(x,0)=u^0(x).
\end{equation}</script>

<p>The weight function $\rho$, under consideration in the experiments is given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\rho(x,t)=\left\{
\begin{array}{cl}
1 & t\in ( T/2,T)\\
0 & \text{otherwise.}
\end{array}
\right. %]]></script>

<p>And the  time horizon $T=1$.
To compare the efficiency of the different methods we consider a fixed $\Delta x = 1/20, \lambda = \Delta t /\Delta x = 2/3$ (which satisfies the CFL condition). We then analyze the number of  iterations that each method needs  to attain a prescribed value of the functional.</p>

<h5>Experiment 1</h5>
<p>We first consider a piecewise constant target profile $u^d$ given by the solution of \ref{BurgerNumerica} with the initial condition $(u^d)^0$ given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{E1u0minimoa}
(u^d)^0(x)=\left\{
\begin{array}{cl}
0.7 & x\in[-2,1]\\
0 & \text{otherwise.}
\end{array}
\right.
\end{equation} %]]></script>

<p>Note that, in this case,  \ref{E1u0minimoa} yields a particular solution of the optimization problem and the minimum value of $J$ vanishes.
We solve the optimization problem \ref{optimalProblem} with the above described different methods starting from the following initialization for $u^0$:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{Ep1u^0}
u^0(x)=\left\{
\begin{array}{cl}
0.5 & x\leq 0\\
-0.1 & x>0,
\end{array}
\right.
\end{equation} %]]></script>

<p>which also has a discontinuity but located on a different point.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/06/ConservationLawsShocksFig2.jpg" alt="Characteristic lines entering on a shock" width="600" /> Figure 2: Experiment 1. $\log (J)$ versus the number of iterations in the descent algorithm for the discrete  and the alternating descent methods.</p>

<p>In Figures 3 and 4, we present the minimizers  obtained by the methods above, and the associated solutions, Figures 5 and 6.
The initial datum $u^0$ obtained by the alternating descent method (Figures 4) is a good  approximation of \ref{E1u0minimoa}. The solution given by  the discrete approach (Figure 3) presents added spurious oscillations. Furthermore, the discrete method is much slower and does not achieve the same level of accuracy since the functional $J_\Delta$ does not decrease so much.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/06/ConservationLawsShocksFig3-6.jpg" alt="Experiment1 iterations and solutions" width="600" /> </p>

<h5>Experiment 2</h5>
<p>The previous experiment indicates that the alternating descent method performs significantly better. In order to show that this is a systematic fact, which arises independently of the initialization of the method, we consider the target $u^d$ given by the solution of \ref{BurgerNumerica} with the initial condition $(u^d)^0$ given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{E2u0minimo}
(u^d)^0(x)=\left\{
\begin{array}{cl}
0.5 & x\leq 0.5\\
0 & \text{otherwise,}
\end{array}
\right.
\end{equation} %]]></script>

<p>but this time we compare the performance of both methods starting from different initializations.
The obtained numerical results are presented in Figure 7.
We see that, regardless the initialization considered, the alternating descent method performs significantly better.
We observe that in the five experiments the alternating descent method perfumes better ensuring the descent of the functional in much fewer iterations and yielding smoother, less oscillatory approximation of the minimizer.
Note also  that the discrete method, rather than yielding discontinuous approximations of the minimizer as the alternating descent method does, it produces an initial datum with a Lipschitz front. Observe that these are  two different configurations that can lead to the same evolution for the Burgers equation after some time, once the front develops the discontinuity. This is in agreement with the fact that the functional to be minimized is only active in the time-interval $T/2 \le t \le T$.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/06/ConservationLawsShocksFig7.jpg" alt="Experiment2 comparision results" width="800" /> </p>

<h3>Bibliography</h3>

<p><strong>[1]</strong> A. Adimurthi, S.S. Ghoshal and V. Gowda <a name="adimurthi:hal-00805317"><em>Optimal controllability for scalar conservation laws with convex flux.</em></a> 12, Jan. 2012.</p>

<p><strong>[2]</strong> D. Auroux and J. Blum <a name="AB" href="http://www.sciencedirect.com/science/article/pii/S1631073X05002074"><em>Back and forth nudging algorithm for data assimilation problems.</em></a> Comptes Rendus Mathematique, 340(12):873 – 878, 2005.</p>

<p><strong>[3]</strong> D. Auroux and M. Nodet <a name="AN" href="https://arxiv.org/abs/0809.4838"><em>The back and forth nudging algorithm for data assimilation problems: theoretical results on transport equations.</em></a> ESAIM: Control, Optimisation and Calculus of Variations, 18(2):318–342, 7 2012.</p>

<p><strong>[4]</strong> C. Bardos and O. Pironneau <a name="BardosPironneau2002" href="http://www.sciencedirect.com/science/article/pii/S1631073X02025748"><em>A formalism for the differentiation of conservation laws.</em></a> C. R. Math. Acad. Sci. Paris, 335(10):839–845, 2002.</p>

<p><strong>[5]</strong> F. Bouchut and F. James <a name="BouchutJames1998" href="http://www.sciencedirect.com/science/article/pii/S1631073X02025748"><em>One-dimensional transport equations with discontinuous coefficients.</em></a> Nonlinear Anal., 32(7):891–933, 1998.</p>

<p><strong>[6]</strong> F. Bouchut and F. James <a name="BouchutJames1999" href="https://link.springer.com/chapter/10.1007/978-3-0348-8720-5_13"><em>Differentiability with respect to initial data for a scalar conservation law.</em></a> In Hyperbolic problems: theory, numerics, applications, Vol. I (Zürich, 1998), volume 129 of Internat. Ser. Numer.Math., pages 113–118. Birkhäuser, Basel, 1999.</p>

<p><strong>[7]</strong> A. Bressan and A. Marson <a name="BressanMarson1995" href="https://www.math.psu.edu/bressan/PSPDF/hyp-varcalculus.pdf"><em>A variational calculus for discontinuous solutions of systems of conservation laws.</em></a> Comm. Partial Differential Equations, 20(9-10):1491–1552, 1995.</p>

<p><strong>[8]</strong> C. Castro, F. Palacios and E. Zuazua <a name="castro2008alternating" href="https://www.newton.ac.uk/files/preprints/ni07040_0.pdf"><em> An alternating descent method for the optimal control of the inviscid burgers equation in the presence of shocks.</em></a> Mathematical Models and Methods in Applied Sciences, 18(03):369–416, 2008</p>

<p><strong>[9]</strong> C. Castro, F. Palacios and E. Zuazua <a name="Castro2010" href="http://adl.stanford.edu/papers/Integral_Methods_2010.pdf"><em> Optimal control and vanishing viscosity for the burgers equation.</em></a> Integral Methods in Science and Engineering, Volume 2, pages 65–90.Birkhäuser Boston, 2010.</p>

<p><strong>[10]</strong> C. Castro and E. Zuazua <a name="MR2813348" href="http://paginaspersonales.deusto.es/enrique.zuazua/documentos_public/archivos/publicaciones/fluxidrev.pdf"><em> Flux identification for 1-d scalar conservation laws in the presence of shocks.</em></a> Math. Comp., 80(276):2025–2070, 2011</p>

<p><strong>[11]</strong> S. Garreau, P. Guillaume and M. Masmoudi. <a name="Garreau:2000:TAP:587448.587670" href="http://epubs.siam.org/doi/abs/10.1137/S0363012900369538"><em>The topological asymptotic for pde systems: The elasticity case.</em></a> SIAM J. Control Optim., 39(6):1756–1778, Dec. 2000.</p>

<p><strong>[12]</strong> E. Godlewski and P. Raviart <a name="BookE.GodlewskiRaviart" href="https://books.google.es/books/about/Hyperbolic_systems_of_conservation_laws.html?id=hzvvAAAAMAAJ&amp;redir_esc=y"><em>Hyperbolic systems of conservation laws, Mathématiques and Applications</em></a> Ellipses, Paris, 1991.</p>

<p><strong>[13]</strong> E. Godlewski and P. Raviart <a name="GodlewskiRaviart1999"><em>The linearized stability of solutions of nonlinear hyperbolic systems of conservation laws. A general numerical approach.</em></a> Math. Comput. Simulation, 50(1-4):77–95, 1999. Modelling ’98 (Prague)</p>

<p><strong>[14]</strong> L. Gosse and F. James <a name="2000GosseJames" href="http://www.ams.org/journals/mcom/2000-69-231/S0025-5718-00-01185-6/"><em>Numerical approximations of one-dimensional linear conservation equations with discontinuous coefficients.</em></a> Mathematics of Computation, 69(231):pp. 987–1015, 2000.</p>

<p><strong>[15]</strong> S. N. Kružkov <a name="kruzkov" href="http://iopscience.iop.org/article/10.1070/SM1970v010n02ABEH002156/meta"><em>First order quasilinear equations with several independent variables.</em></a> Mat. Sb. (N.S.), 81 (123):228–255, 1970.</p>

<p><strong>[16]</strong> R. Lecaros and E. Zuazua <a name="RLEZ2014" href="http://www.ams.org/journals/mcom/2016-85-299/S0025-5718-2015-03015-4/"><em>Control of 2D scalar conservation laws in the presence of shocks.</em></a> Math. Comp. 85 (2016), 1183-1224</p>

<p><strong>[17]</strong> S. Ulbrich <a name="Ulbrich2003" href="http://www.sciencedirect.com/science/article/pii/S016769110200275X"><em>Adjoint-based derivative computations for the optimal control of discontinuous solutions of hyperbolic conservation laws.</em></a> Systems Control Lett., 48(3-4):313–328, 2003. Optimization and control of distributed systems.</p>

<p><strong>[18]</strong> X. Wen and S. Jin <a name="MR2378582" href="http://www.global-sci.org/jcm/freedownload/v26_1.pdf"><em>Convergence of an immersed interface upwind scheme for linear advection equations with piecewise constant coefficients I: $L^1$-error estimates.</em></a> J. Comput. Math., 26(1):1–22, 2008.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3&gt;Introduction&lt;/h3&gt;
</code></pre></div></div>
<p>In this work, we analyze the numerical approximation of the inverse design problem for the Burgers equation, both in the viscous and in the inviscid case:</p>

<script type="math/tex; mode=display">\begin{equation}
\min_{u_0} \mathcal{J}_\nu(u_0) =\min_{u_0} \frac12\int_\mathbb{R} \left(u^\nu(x,T)-u^\ast(x)\right)^2 dx,
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\mbox{subject to} \begin{cases}
\partial_t u^\nu+\partial_x \left(\frac{(u^\nu)^2}{2}\right)=\nu \partial_{xx} u^\nu, x\in\mathbb{R},\,t>0,\\[15pt]
u^\nu(x,0)=u_0(x), x\in\mathbb{R},
\end{cases}
\end{equation}</script>

<p>distinguishing the viscous, $\nu &gt;0$, and the inviscid case, $\nu=0$. Given a time $T&gt;0$ and a target function $u^\ast$ the aim is to identify the initial datum $u_0$ so that the solution, at time $t=T$, reaches the target $u^\ast$ or gets as close as possible to it. In particular, we focus on problems with large values of $T$, for which convergence of the numerical schemes in the classical sense of numerical analysis might not suffice to obtain accurate results.</p>

<p>This issue is motivated by the challenging problem of sonic-boom minimization for supersonic aircrafts, which is governed by a Burgers-like equation. The travel time of the signal to the ground is larger than the time scale of the initial disturbance by orders of magnitude and this motivates our study of large time control of the sonic-boom propagation.</p>

<h3>Description of the numerical algorithms</h3>
<p>To implement the problem numerically, we opt for a discretization of (2) using classical conservative schemes. Let us denote spatial nodes $x_{j+1/2}={\Delta x}(j+1/2)$, $j\in\mathbb{Z}$, and time instants $t_n=n{\Delta t}$, $n\in n \cup{0}$, where ${\Delta x},{\Delta t}&gt;0$ are the mesh size and time-step respectively. We approximate the solution $u$ of (2) by a piecewise constant function $u_\Delta$ such that</p>

<script type="math/tex; mode=display">u_\Delta(x,t)=u^n_j, x\in[x_{j-1/2},x_{j+1/2}),\,t\in[t_n,t_{n+1}),</script>

<p>where</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:scheme}
\begin{cases}
\displaystyle u^{n+1}_j=u^n_j-\frac{ {\Delta t} }{ {\Delta x} }(g^n_{j+1/2}-g^n_{j-1/2}) \\[15pt]
\displaystyle +\frac{\nu{\Delta t} }{ {\Delta x}^2}(u^n_{j-1}-2u^n_j+u^n_{j+1}),\ j\in\mathbb{Z},n=0,\dots,N, \\[20pt]
\displaystyle u^0_j=\frac{1}{ {\Delta x} }\int_{x_{j-1/2} }^{x_{j+1/2} } u_0(x)dx,\ j\in\mathbb{Z}.
\end{cases}
\end{equation}</script>

<p>Here, $N=\lceil T/{ {\Delta t} }\rceil$ is the number of time-steps needed to reach $T$. We denote $g^n_{j+1/2}=g(u^n_j,u^n_{j+1})$, where the function $g$ is the numerical flux. In this paper we compare two fluxes:</p>

<script type="math/tex; mode=display">\mbox{Engquist-Osher (EO): } g^{EO}(v,w)=\dfrac{v(v+|v|)}{4}+\dfrac{w(w-|w|)}{4}, \\[10pt]
\mbox{Modified Lax-Friedrichs (MLF): } g^{MLF}(v,w)=\dfrac{v^2+w^2}{4}-\dfrac{ {\Delta x} }{ {\Delta t} }\left(\dfrac{w-v}{4}\right)</script>

<p>In the simulations we follow the discrete approach to optimization. For the discretization of (1), we consider a simple quadrature rule:</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:funcdiscr}
\mathcal{J}_{\Delta}(u_\Delta^0)=\frac{ {\Delta x} }{2} \sum_\mathbb{Z} (u_j^N-u^\ast_j)^2,
\end{equation}</script>

<p>where the target function $u^\ast$ has been discretized in the same manner as the initial data $u_0$ in (3).</p>

<p>Regarding the optimization technique, we use the classical gradient descent method based on the adjoint methodology. Following the discrete approach, it is easy to obtain the corresponding discrete adjoint system for (3):</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:adjscheme}
\begin{cases}
\rho^{n}_j=\rho^{n+1}_j+\frac{ {\Delta t} }{ {\Delta x} }\Big(\partial_v g(u^n_j,u^n_{j+1}) \left(\rho^{n+1}_{j+1}-\rho^{n+1}_j\right) \\[15pt]
 +\partial_w g(u^n_{j-1},u^n_{j})\left(\rho^{n+1}_j-\rho^{n+1}_{j-1}\right)\Big) \\[15pt]
 +\frac{\nu{\Delta t} }{ {\Delta x}^2}(\rho^{n+1}_{j-1}-2\rho^{n+1}_j+\rho^{n+1}_{j+1}),  j\in\mathbb{Z},n=N-1\dots,0, \\[15pt]
\rho^N_j=u^N_j-u^\ast_j,  j\in\mathbb{Z},
\end{cases}
\end{equation}</script>

<p>To minimize (4), we will take the descent direction given by:</p>

<script type="math/tex; mode=display">\begin{equation*}
\delta u_j^0=-\rho^0_j,  j\in\mathbb{Z}.
\end{equation*}</script>

<p>This direction is straightforwardly obtained following the same arguments as for the continuous level. Thus, the new initial data $u_\Delta^{0,\varepsilon}$ will be given by</p>

<script type="math/tex; mode=display">\begin{equation*}
u^{0,\varepsilon}_j = u^0_j-\varepsilon \rho^0_j,  j\in\mathbb{Z}
\end{equation*}</script>

<p>for some $\varepsilon&gt;0$ small enough.</p>

<p>The pseudocode for the complete algorithm can be found in Algorithm 1. Note that it is valid both for the viscous and the inviscid case of the Burgers equation.</p>

<h3>Algorithm 1: Solve discrete optimization problem</h3>
<p><strong>Input:</strong></p>

<script type="math/tex; mode=display">\Delta x,\Delta t,N,\{u^0_j\}_{j=0,...,M},\{u^\ast_j\}_{j=0,...,M}</script>

<p><br /></p>
<ol>
<li><strong>for</strong> $j=0$ <strong>to</strong> $M$ <strong>do</strong></li>
<li>	<strong>set</strong> $u^{0,new}_j = u^0_j$</li>
<li><strong>end for</strong></li>
<li><strong>compute</strong> $\{u^n_j\}^{n=1,...,N}_{j=0,...,M}$ from $\{u^{new,0}_j\}_{j=0,...,M}$ using (3)</li>
<li><strong>compute</strong> functional $\mathcal{J}(u_\Delta^{0,new})$ using (4)</li>
<li><strong>while</strong> stopping criteria are not met <strong>do</strong></li>
<li>	<b>for</b> $j=0$ <strong>to</strong> $M$ <strong>do</strong></li>
<li>		<b>set</b> $u^{0,old}_j = u^{0,new}_j$</li>
<li>		<b>set</b> $\rho^N_j = u^N_j-u^\ast_j$</li>
<li>	<b>end for</b></li>
<li>	<strong>compute</strong> $\{\rho^0_j\}_{j=0,...,M}$ from $\{\rho^N_j\}_{j=0,...,M}$ and $\{u^n_j\}^{n=1,...,N}_{j=0,...,M}$ using (5)</li>
<li>	<strong>compute</strong> descending step-size $\varepsilon$</li>
<li>	<b>for</b> $j=0$ <strong>to</strong> $M$ <strong>do</strong></li>
<li>		<b>set</b> $u^{0,new}_j = u^{0,old}_j-\varepsilon \rho^0_j$</li>
<li>	<b>end for</b></li>
<li>	<strong>compute</strong> $\{u^n_j\}^{n=1,...,N}_{j=0,...,M}$ from $\{u^{new,0}_j\}_{j=0,...,M}$ using (3)</li>
<li>	<strong>compute</strong> functional $\mathcal{J}(u_\Delta^{0,new})$ using (4)</li>
<li><b>end while</b></li>
<li><b>for</b> $j=0$ <strong>to</strong> $M$ <strong>do</strong></li>
<li>	<b>set</b> $u^{*,0}_j = u^{0,new}_j$</li>
<li><b>end for</b></li>
</ol>
<p><strong>Output:</strong> Optimal solution</p>

<script type="math/tex; mode=display">\{u^{*,0}_j\}_{j=0,...,M}</script>

<h3>Numerical viscosity</h3>
<p>It is well known that (3) can be rewritten in its viscous form in the following manner:</p>

<script type="math/tex; mode=display">\begin{equation*}
\frac{u_{j}^{n+1}-u_j^n}{\Delta t}+\frac{(u_{j+1}^n)^2-(u_{j-1}^n)^2}{4\Delta x}=R(u_j^n,u_{j+1}^n)-R(u_{j-1}^n,u_{j}^n)+\frac{\nu}{ {\Delta x}^2}(u^n_{j-1}-2u^n_j+u^n_{j+1}),
\end{equation*}</script>

<p>where $R$ is uniquely defined by</p>

<script type="math/tex; mode=display">\begin{equation*}
R(u,v)=\frac{1}{2{\Delta x} } \Big(\frac{u^2}{2}+\frac{v^2}{2}-2g(u,v)\Big).
\end{equation*}</script>

<p>In the case of the numerical fluxes that we consider in this paper, we have:</p>

<script type="math/tex; mode=display">R^{MLF}(u,v)=\frac{v-u}{4{\Delta t} }, \\
 R^{EO}(u,v)=\frac{1}{4{\Delta x} }(v|v|-u|u|).</script>

<p>Both schemes are convergent in the classical sense of the numerical analysis. However, the large-time behavior of $u_\Delta$ depends on the degree of homogeneity of the term $R$. In other words, let us assume that there exists $\alpha\in R$ such that</p>

<script type="math/tex; mode=display">\begin{equation*}
R(\mu u, \mu v)=\mu^\alpha R(u,v), \forall u,v\in\mathbb{R} \mbox{ and } \forall \mu>0.
\end{equation*}</script>

<p>It is clear that $\alpha=2$ for Engquist-Osher and $\alpha=1$ for modified Lax-Friedrichs. Thus, the numerical viscosity inherent in MLF drives the system into a diffusive wave too early and, consequently, continuous metastable states are not reproduced numerically.</p>

<p><img class="size-full wp-image-1616" src="https://cmc.deusto.eus/wp-content/uploads/2017/05/scheme_compare.jpg" width="800" /> Figure 1: Solutions of (2) with $\nu=10^{-6}$ at $t=1$, $t=100$ and $t=5000$, using (3) with ${\Delta x}=0.2$, ${\Delta t}=0.5$ and numerical fluxes EO (blue) and MLF (red).</p>

<p>The main aim of our work is to emphasize that ignoring the dynamics of the continuous model at the numerical level can produce undesired results in optimal control problems in large time horizons. On one hand, we show that the gradient descent method performs successfully whenever the numerical flux and the mesh sizes are chosen appropriately. On the other hand, we present examples where excessive numerical viscosity dominates the physical one.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;The turnpike property establishes that, when a general optimal control problem is settled in large time, for most of the time the optimal control and trajectories remain exponentially close to the optimal control and state of the corresponding steady-state or static optimal control problem.&lt;/p&gt;
</code></pre></div></div>

<h4>The turnpike property</h4>
<p><img class=" wp-image-1524" src="https://cmc.deusto.eus/wp-content/uploads/2017/03/dibujo4.png" alt="The turnpike property illustrated" width="500" /> Figure 1: When an optimal control problem satisfies the turnpike property, the solution remains close to certain path for most of the time, except maybe for an initial time interval $T_1$ and a final time interval $T_2$. In this Figure, $x(t,x_0,u(t))$ is solution of the optimal control problem (3) with the cost function (2), while $\bar{x}$ is the optimal solution of the stationary problem (5).</p>

<p>The origin of the term Turnpike is in the interpretation that Samuelson did of this phenomenon in [<a href="#dorfman1958linear">1</a>] : suppose we want to travel from city A to city B by car, the best way to do it, the optimal way, is to take the highway (namely, the turnpike) as near as we can from city A, and leave it when we are close to B. So, except nearby A and B, we are expected to be on the highway: in other words, the turnpike of the problem.
The turnpike property is very useful, since it gives us an idea of the nature of the optimal solution of a problem, without having to solve it analytically. In practice, the turnpike property allows performing a significant improvement of the numerical methods used to solve optimal control problems.</p>

<h4>The Turnpike property in the Linear Case</h4>
<p>Consider the finite-dimensional dynamical system</p>

<script type="math/tex; mode=display">\begin{equation}
\begin{cases}
\label{linearproblem}
 x_t + Ax = Bu\\
 x(0)=x_0 \in \mathbb{R}^{N}
\end{cases}
\end{equation}</script>

<p>where $A \in M(N,N)$, $B\in M(N,M)$, with control $u \in L^2 (0,T;\mathbb{R}^{N})$. Given a matrix $C \in M(N,N)$, and some $x^\ast  \in \mathbb{R}^{N}$, consider the optimal control problem</p>

<script type="math/tex; mode=display">\begin{equation}
\min_{u} J^T (u) = \frac{1}{2} \int_0^T \left( |u(t)|^2 + |C(x(t)-x^\ast )|^2 \right)dt.
\end{equation}</script>

<p>There exists a unique optimal control $u(t)$ in $ L^2 (0,T;\mathbb{R}^{M})$, characterized by the optimality condition</p>

<script type="math/tex; mode=display">u = - B^\ast p =
    \begin{cases}
    -p_t + A^\ast  p = C^\ast C( x-x^\ast ) \\
    p(T)=0 \in \mathbb{R}^N
    \end{cases}</script>

<p>Let formulate the same problem for the steady-state model</p>

<script type="math/tex; mode=display">\begin{equation}
Ax=Bu
\end{equation}</script>

<p>Then, there exists a unique minimum $\bar{u}$, and a unique optimal state $\bar{x}$, of the stationary optimal control problem</p>

<script type="math/tex; mode=display">\begin{equation}
%\nonumber
\left\lbrace
\begin{array}{clc}
 \min_{u} J_s (u) = \frac{1}{2} \left( |u|^2 + |C(x -x^\ast )|^2 \right). \
\\  subject \,\,\, to\,\,\, Ax=Bu
\end{array}
\right.
\end{equation}</script>

<p>Let assume that:</p>
<ol>
	<li>The pair $(A,B)$ is controllable.</li>
	<li>The pair $(A,C)$ is observable.</li>
</ol>
<p>Then, we have the following result (proved in [<a href="porretta2013long">2</a>])
<strong>Theorem:</strong> <em>there exist positive constants $\lambda$ and $K$, independent on $T$, such that $ \forall t \in [0,T]$</em></p>

<script type="math/tex; mode=display">|u(t) -\bar{u}| + |x(t) - \bar{x}| \leq K \left( e^{-\lambda t} + e{-\lambda (T-t)} \right) .</script>

<h4>Some results and extensions on the turnpike property</h4>
<ul>
	<li>Turnpike theorems were derived in the 60's for discrete-time optimal control problems arising in econometry [<a href="#mckenzie1976turnpike">3</a>] and references therein).</li>
	<li>See [<a href="#carlson2012infinite">4</a>], [<a href="#zaslavski2006turnpike">5</a>] and the references therein for an extensive overview of turnpike results</li>
	<li>In [<a href="#trelat2015turnpike">6</a>] they proved a turnpike theorem for nonlinear finite--dimensional systems, involving the state, the control and also the adjoint. Besides that, they explain how the turnpike can be used to improve certain numerical methods.</li>
	<li>A turnpike theorem for the 1-D wave equation with a homogeneous Dirichlet boundary condition at one side, and a Neumann boundary control action at the other can be found in [<a href="#gugat2016optimal">7</a>].</li>
	<li>A turnpike theorem for the two--dimensional Navier-Stokes Equation is proved in [<a href="#zamorano2016turnpike">8</a>], for both time depending and non-depending control.</li>
	<li>An application of the turnpike property to the Lotka-Volterra model can be found in [<a href="#ibanez2017optimal">9</a>]. The property is used to improve the single shooting method to solve the problem.</li>
</ul>
<p><img class=" wp-image-1536" src="https://cmc.deusto.eus/wp-content/uploads/2017/05/fig2-e1494492767300.jpg" alt="turnpike phenomenon in two species" width="482" height="361" /> Figure 2: The Lotka-Volterra equations model a biological ecosystem where two species interact: a prey and a predator. In [<a href="#ibanez2017optimal">9</a>] the control is introduced by hunting both species. In this figure we can see the turnpike phenomenon in both species ($x_1$ is the prey and $x_2$ is the predator species) and the control $u(t)$, which represents the hunting. In dashed blue, we have the evolution of each variable, and in black, the turnpike.</p>

<h4>Perspectives</h4>
<ul>
<li> The study of the periodic turnpike property for optimal control problems in Hilbert spaces (in progress, E.Tr&eacute;lat, C. Zhang and E. Zuazua)</li>
<li> Clarify the turnpike property for nonlinear PDE without smallness conditions on the target.</li>
<li> The turnpike property on multi-D wave equations.</li>
<li> Prove a turnpike theorem for a constrained control for linear and nonlinear finite--dimensional optimal control problems.</li>
<li> Develope the turnpike computational code to solve a wide range of problems as it has been done in [<a href="#ibanez2017optimal">9</a>] for the Lotka-Volterra model.</li>
</ul>

<h4>References</h4>

<p><strong>[1]</strong> Robert Dorfman, Paul Anthony Samuelson, and Robert M Solow <a name="dorfman1958linear"><em>Linear programming and economic analysis.</em></a> Courier Corporation, 1958.</p>

<p><strong>[2]</strong> Alessio Porretta and Enrique Zuazua. <a name="porretta2013long" href="http://epubs.siam.org/doi/abs/10.1137/130907239"><em>Long time versus steady state optimal control.</em></a> SIAM Journal on Control and Optimization, 51(6):4242–4273, 2013.</p>

<p><strong>[3]</strong> Lionel W McKenzie. <a name="mckenzie1976turnpike" href="http://www.dictionaryofeconomics.com/article?id=pde2012_T000259"><em>Turnpike theory.</em></a> Econometrica: Journal of the Econometric Society, pages 841–865, 1976.</p>

<p><strong>[4]</strong> Dean Carlson, Alain B Haurie, and Arie Leizarowitz. <a name="carlson2012infinite" href="http://www.springer.com/la/book/9783642767579"><em>Infinite horizon optimal control: deterministic and stochastic systems.</em></a> Springer Science &amp; Business Media, 2012.</p>

<p><strong>[5]</strong> Alexander Zaslavski. <a name="zaslavski2006turnpike" href="http://www.springer.com/us/book/9780387281551"><em>Turnpike properties in the calculus of variations and optimal control, volume 80.</em></a> Springer Science &amp; Business Media, 2006.</p>

<p><strong>[6]</strong> Emmanuel Trélat and Enrique Zuazua. <a name="trelat2015turnpike" href="http://www.sciencedirect.com/science/article/pii/S0022039614003568"><em>The turnpike property in finite-dimensional nonlinear optimal control</em></a> Journal of Differential Equations, 258(1):81–114, 2015.</p>

<p><strong>[7]</strong> Martin Gugat, Emmanuel Trélat, and Enrique Zuazua. <a name="gugat2016optimal" href="https://arxiv.org/abs/1505.05017"><em>Optimal Neumann control for the 1D wave equation: finite horizon, infinite horizon, boundary tracking terms and the turnpike property</em></a> Systems &amp; Control Letters, 90:61–70, 2016.</p>

<p><strong>[8]</strong> S Zamorano. <a name="zamorano2016turnpike" href="https://arxiv.org/abs/1601.04984"><em>The turnpike property for two-dimensional navier-stokes equations.</em></a> arXiv preprint arXiv:1601.04984, 2016.</p>

<p><strong>[9]</strong> Aitziber Ibañez. <a name="ibanez2017optimal" href="https://www.ncbi.nlm.nih.gov/pubmed/27642712"><em>Optimal control of the Lotka–Volterra system: turnpike property and numerical simulations.</em></a> Journal of Biological Dynamics, 11(1):25–41, 2017.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h3&gt;The problem&lt;/h3&gt;
</code></pre></div></div>
<p><img class="size-full" style="float: right;" src="https://cmc.deusto.eus/wp-content/uploads/2017/02/surrogate.png" alt="Surrogate" width="400" /><strong>Control of a parameter dependent system in a robust manner.</strong>
Fix a control time $T &gt; 0$, an arbitrary initial data $x^0$, and a final target $x^1 \in R^N$
Given $\varepsilon &gt; 0$ we aim at determining a family of parameters $\nu_1,…, , \nu_n$ in $\mathcal{N}$ so that the corresponding controls $u_1, …, u_n$ are such that for every $\nu \in \mathcal{N}$ there exists $u^\star_\nu \in {\rm span}{u_1,…, u_n}$ steering the system to the state $x_\nu^\star(T)$ within the $\varepsilon$ distance from the target $x^1$.</p>

<h3>The system</h3>
<p>A finite dimensional linear control system:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}
\begin{cases}
x'(t)=A( \nu)x(t)+Bu(t),\,0 < t < T,\\
x(0)=x^0
\end{cases}
\end{equation} %]]></script>

<ul>
	<li>$ A( \nu)$ is a $N \times N$−matrix,</li>
	<li>$B$ is a $N\times M$ control operator, $\,M \leq N$,</li>
	<li>$\nu$ is a parameter living in a compact set, $\,\mathcal{N}$ of $\mathbb{R}^d$</li>
</ul>
<p>Assumptions:</p>
<ul>
	<li>the system is (uniform) controllable for all $\nu \in N$,</li>
	<li>system dimension $\mathcal{N}$ is large</li>
</ul>
<h3>The greedy approach</h3>
<p>$X$ – a Banach space
$K\subset X$ – a compact subset.
The method approximates $K$ by a a series of finite dimensional linear spaces $V_n$ (a <strong>linear method</strong>).</p>
<h5 style="color:green">A general greedy algorithm</h5>
<ul><li><strong>The first step</strong>
Choose $x_1 \in K$ such that $$ { {\| x_1 \|}_{X}} = \max_{x \in K} { {\| x \|}_{X}} $$</li>
<li><strong>The general step</strong>
Having found $x_1 .. x_n$, denote

$$
V_n={\rm span} \{x_1, \ldots,x_n\}
$$

Choose the next element

$$
x_{n+1}:= \arg\!\max_{x \in K} {\rm dist}(x, V_n)
$$
</li>
<li><strong>The algorithm stops</strong> when $\sigma_n(K):= \max_{x \in K} {\rm dist}(x, V_n) $ becomes less than the given tolerance $\varepsilon$.</li>


<strong>The Kolmogorov $n$ width</strong>, $d_n(K) $ measures optimal approximation of $K$ by a $n$-dimensional subspace.
$$
d_n(K):=\inf_{\dim Y=n} \sup_{x\in K} \, \inf_{y\in Y} { {\| x-y \|}_{X}}\,.
$$
<strong>The greedy approximation rates have same decay as the Kolmogorov widths.</strong>

<img src="http://cmc.deusto.es/wp-content/uploads/2017/02/greedyControlFig1.jpg" alt="Evolution of last 5 system components and the approximate control" width="562" height="446" class="size-full wp-image-349" srcset="https://cmc.deusto.eus/wp-content/uploads/2017/02/greedyControlFig1.jpg 562w, https://cmc.deusto.eus/wp-content/uploads/2017/02/greedyControlFig1-300x238.jpg 300w, https://cmc.deusto.eus/wp-content/uploads/2017/02/greedyControlFig1-242x192.jpg 242w" sizes="(max-width: 562px) 100vw, 562px" />

Figure1: Evolution of a) last 5 system components and  b) the approximate control for $\nu=\pi$.

<h3>Greedy control</h3>
Each control can be uniquely determined by the relation
$$
u_{\bf \nu} = {\bf B}^\ast e^{(T-t){\bf A}_{\bf \nu}^\ast}  \varphi^0_{\bf \nu},
$$
where $\varphi^0_{\bf \nu}\in { {\bf R}}^N$ is the unique  minimiser of a  quadratic functional associated to the adjoint problem.
This minimiser can  be expressed as the solution of the linear system 
\begin{equation*}
\label{phi^0}
\Lambda_{\bf \nu}   \varphi^0_{\bf \nu} = {\sf x}^1 -  e^{T{\bf A}_{\bf \nu}} {\sf x}^0,
\end{equation*}
where $\Lambda_{\bf \nu} $  is the controllability Gramian 
\begin{equation*}
\Lambda_{\bf \nu}=\int_0^T e^{(T-t){\bf A}_{\bf \nu}}{\bf B}_{\bf \nu} {\bf B}_{\bf \nu}^\ast e^{(T-t){\bf A}_{\bf \nu}^\ast} dt\,.
\end{equation*}

Perform a greedy algorithm to the manifold $\varphi^0({\cal N})$:
$$
\nu \in {\cal N} \to \varphi^0_\nu \in  \bf{R}^N\,.
$$

The (unknown) quantity ${\rm dist} (\varphi^0_{\bf \nu}, \varphi_i^0)$ to be maximised by the greedy algorithm is replaced by a  <strong>surrogate</strong>:

$$
\begin{aligned}
{\rm dist} (\varphi^0_{\bf \nu}, \varphi_i^0)
&amp;\sim {\rm dist} (\Lambda_{\bf \nu}  \varphi^0_{\bf \nu}, \Lambda_{\bf \nu}  \varphi^0_i) \cr
&amp;= {\rm dist} ({\sf x}^1 -  e^{T{\bf A}_{\bf \nu}} {\bf x}^0, \Lambda_{\bf \nu}  \varphi^0_i) \,.\cr
\end{aligned}
$$

<img src="http://cmc.deusto.es/wp-content/uploads/2017/02/surrogate.png" alt="Surrogate" />
<strong>The greedy control algorithm  results in an optimal decay of the  approximation rates.</strong>
<h3>Numerical examples</h3>
<h5>Wave equation</h5>
We consider the system (1) with:

$$
  {\bf A}=\left(\begin{matrix}
  {\bf 0} &amp; -I\cr
  { \nu} ( N/2+1)^2 \tilde {\bf A} &amp; {\bf 0}\cr
  \end{matrix}\right),
$$
$$
    \tilde {\bf A}=\left(\begin{matrix}
    2 &amp; -1&amp; 0 &amp; \cdots &amp; 0\cr
    -1&amp;  2 &amp; -1&amp;  \cdots &amp; 0\cr
    0 &amp; -1&amp;  2 &amp;  \cdots &amp; 0\cr
    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\cr
        0 &amp;0&amp;  0 &amp; \cdots  &amp;2\cr
    \end{matrix}\right),
    \ \
     {\bf B}=\left(\begin{matrix}
       0\cr
       0\cr
       \vdots\cr
       0\cr
       1\cr
     \end{matrix}\right).
$$
The system corresponds to the discretisation of the wave equation problem with the control on the right boundary:

$$
\begin{equation}
		\begin{cases}
     	\partial_{tt} v -  \nu \partial_{xx} v=0 \ \ (t, x) \in \langle 0, T \rangle  \times \langle 0,1 \rangle \\
     	v(t, 0)=0 \ \ v(t, 1)=u(t) \\
     	v(0, x)=v_0 \ \ \partial_t v(x, 0)=v_1 
     	\end{cases}
\end{equation}
$$
We take the following values:
  $$T=3,\;  N=50,\;
  v_0=\sin(\pi x), \; v_1=0,\;
  x^1=0
  $$

  $$
  \nu \in [1,10]  = \mathcal{N}
  $$

The greedy control has been applied with $\varepsilon=0.5$ and the uniform discretisation of ${\cal N}$ in $k=100$ values.
The offline algorithm stopped after 24 iterations.
<strong>The 20-D controls manifold is  well approximated by a 10-D subspace:</strong>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/04/wave-online-3D-nu.jpg" alt="Evolution of the solution to the semi-discretised problem" width="562" height="446" class="size-full wp-image-350" /> 
Figure2: Evolution of the solution to the semi-discretised problem (2) governed by the approximate control $u_\nu^\star$ for $\nu=\pi$.

<h5>Heat equation</h5>
For  $   {\bf A}=( N+1)^2\tilde{\bf A}    $, with $\tilde{\bf A}$ given by:

$$
    \tilde {\bf A}=\left(\begin{matrix}
    2 &amp; -1&amp; 0 &amp; \cdots &amp; 0\cr
    -1&amp;  2 &amp; -1&amp;  \cdots &amp; 0\cr
    0 &amp; -1&amp;  2 &amp;  \cdots &amp; 0\cr
    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\cr
        0 &amp;0&amp;  0 &amp; \cdots  &amp;2\cr
    \end{matrix}\right)
$$

and the control operator $ {\bf B}= (0, \ldots,0, ( N+1)^2 )^\top,$ the system (1) corresponds to the space-discretisation of the heat equation problem with $N$ internal grid points and  the control on the right boundary:

$$
\begin{equation}
  \begin{cases}
     \partial_{t} v -  \nu \partial_{xx} v=0 \ \ (t, x) \in \langle 0, T \rangle  \times \langle 0, 1\rangle\\
     v(t, 0)=0 \ \ v(t, 1)=u_\nu(t),\\
      v(0, x)=v_0 \\
    \end{cases}
\end{equation}
$$

The parameter $\nu$ represents the diffusion coefficient and is supposed to range within the set $\mathcal{N}=[1,2]$.  
The system satisfies the Kalman's rank condition for any $\nu\in {\cal N}$ and any target time $T$.     
We aim to control the system  from the initial state $v_0(x)=\sin(\pi x)$ to zero in time $T=0.1$. 
The greedy control algorithm has been  applied for the system of dimension $N=50$ with  $\varepsilon=0.0001$, and the uniform discretisation of ${\cal N}$ in $k=100$ values. 
The algorithm stops after only three iterations.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/03/heat-online-3D.jpg" alt="Evolution of the solution to the semi-discretised problem for heat equation" width="562" class="size-full wp-image-350" /> Figure3: Evolution of the solution to the semi-discretised problem (3) governed by the approximate control $u_\nu^\star$ for $\nu=\sqrt 2$.


</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;&lt;a href="https://cmc.deusto.eus/Carlos-Esteve-Yague/"&gt;&lt;strong&gt;Carlos Esteve Yagüe&lt;/strong&gt;&lt;/a&gt; holds a Postdoctoral position at the ERC Advanced Grant project DyCon under the supervision of Prof. Enrique Zuazua (UAM and DeustoTech). He earned his PhD in analysis of nonlinear parabolic partial differential equations under the supervision of Prof. Philippe Souplet (Université Paris 13). His main research interests are singularity formation for parabolic PDE, Hamilton-Jacobi equations, optimal control theory and differential games.&lt;/p&gt;

&lt;a name="NoburuSakamoto"&gt;&lt;/a&gt;Noboru Sakamoto&lt;/strong&gt; received the B.Sc. degree in mathematics from Hokkaido University and M.Sc. and Ph.D. degrees in aerospace engineering from Nagoya University, in 1991, 1993, and 1996, respectively. From 1996 until 2015, he held positions in the Graduate School of Engineering in Nagoya University. Currently, he is a Professor with the Science and Engineering of &lt;a href="http;//www.nanzan-u.ac.jp/English/index.html" target="_blank"&gt;Nanzan University&lt;/a&gt; in Nagoya, Japan. He has held a visiting research position at University of Groningen, The Netherlands, in 2005 and 2006. He received the SICE Best Paper Prizes in 1997, 2006, 2008 and 2011 and SICE Kimura Prize in 2016. His research interests include nonlinear control theory, control of chaotic systems, dynamical system theory and control applications for aerospace engineering.

&lt;strong&gt;Jérôme Lohéac&lt;/strong&gt; is a Senior Scientific Researcher at the &lt;a href="http://www.irccyn.ec-nantes.fr/en/"&gt;Institut de Recherche en Communications et Cybernétique de Nantes&lt;/a&gt;, a scientific institution linked to the &lt;a href='http://www.cnrs.fr/'&gt;CNRS&lt;/a&gt; in France. His fields of research are Swimming of microorganisms(1); Time optimal control for PDEs(2); Optimal control of finite dimensional systems with state constraints(3) and Controllability of parameter-dependent systems(4).

&lt;strong&gt;Martin Lazar&lt;/strong&gt; is a Research professor at &lt;a href='http://www.unidu.hr/' target='_blank'&gt;University of Dubrovnik&lt;/a&gt;, Croatia. His fields of research are Control of parameter dependent systems (greedy control, averaged control), optimal control of parabolic problems. Microlocal analysis; PDEs and homogenisation, velocity averaging, microlocal defect functionals (1-scale H-measures, semiclassical measures, H-distributions), and Geophysical fluid dynamics; analytical modelling in oceanography.

&lt;strong&gt;Césare Molinari&lt;/strong&gt; was PhD student in Applied Mathematics at &lt;a href='http://www.usm.cl/' target='_blank'&gt;Universidad Técnica Federico Santa María&lt;/a&gt; (Valparaíso, Chile). His scientific interests were related to numerical algorithms for maximal monotone variational inequalities and convex non-differentiable optimization. In this context, his research was focused on the design of the algorithms, on the analysis of the asymptotic properties and of the rate of convergence. This theory finds natural applications in sparse optimal control of PDEs and reconstruction of images. He was doing an internship in Control Theory under the joint supervision of professor Enrique Zuazua.

Navid Allahverdi's work focuses on simulation based engineering and application of scientific computing in engineering design and optimization.

Alejandro Pozo is a Post Doctoral researcher in Mathematics. He has a markedly applied profile, which is why he has oriented his career towards the field of technological innovation. In this sense, he understands that mathematics can add value and contribute significantly to the solution of the most diverse R &amp; D &amp; i problems.

&lt;a href='https://cmc.deusto.eus/umberto-biccari/'&gt;Umberto Biccari&lt;/a&gt;&lt;/strong&gt; is a PhD. Currently he holds a Postdoctoral position at the ERC Advanced Grant project &lt;a href='cmc.deusto.eus/dycon'&gt;DyCon&lt;/a&gt; under the supervision of &lt;a href='http://paginaspersonales.deusto.es/enrique.zuazua/'&gt;Prof. Enrique Zuazua&lt;/a&gt; (&lt;a href='https://www.uam.es/ss/Satellite/es/home.htm' target='_blank'&gt;UAM&lt;/a&gt; and &lt;a href='http://deustotech.deusto.es/cs/Satellite/ingenieria/es/deustotech' target='_blank'&gt;DeustoTech&lt;/a&gt;). In the past, he collaborated within the ERC research project &lt;a href='http://www.bcamath.org/projects/NUMERIWAVES/' target='_blank'&gt;NUMERIWAVES&lt;/a&gt;. His current research interests are related to the analysis of Partial Differential Equations, in particular from the point of view of control theory. During the years of his PhD he has been concerned with the study of controllability properties of hyperbolic (waves), parabolic (heat) and dispersive (Schrödinger) PDEs, involving non-local terms, singular inverse-square potentials, variable degenerate coefficients or dynamical boundary conditions. At the moment, he is getting interested in non-local transport problems, derived from models of collection behaviour.

&lt;strong&gt;Jesus Oroya&lt;/strong&gt; is the Software Expert in &lt;b&gt;&lt;a href='cmc.deusto.eus/dycon/'&gt;DyCon&amp;#58; Dynamic Control&lt;/a&gt;&lt;/b&gt;, the Advanced Research Project funded by the &lt;a href='https://erc.europa.eu/'&gt;European Research Council(ERC)&lt;/a&gt;. He got a BSc in Physics from the &lt;a href='https://www.ehu.eus/en/web/guest/en-home'&gt;University of the Basque Country&lt;/a&gt;, specializing in physical simulation. He has worked at CIC Nanogune for the company SIMUNE, looking for a method of optimization of atomic bases for calculations of electronic structure in the SIESTA code. In 2017, he worked at Accenture, managing and analyzing databases. He has also developed business applications for Liberty Seguros. Currently he is studying a MSc in Computational Engineering and Intelligent Systems in the &lt;a href='https://www.ehu.eus/en/web/guest/en-home'&gt;University of the Basque Country&lt;/a&gt;.

&lt;a href='http://deus.to/zuazua'&gt;&lt;strong&gt;Enrique Zuazua&lt;/strong&gt;&lt;/a&gt; is the Director of the Chair of Computational Mathematics at &lt;a class='rsst' href='http://deustotech.deusto.es/' target='_blank'&gt;DeustoTech&lt;/a&gt; Laboratory in the University of Deusto, Bilbao (Basque Country-Spain) where he leads the research team funded by the European Research Council Advanced Grant “&lt;a class='rsst' href='http://enzuazua.net/dycon/' target='_blank'&gt;DYCON; Dynamic Control&lt;/a&gt;”. He is also a Professor of the &lt;a class='rsst' href='http://verso.mat.uam.es/web/index.php/es/' target='_blank'&gt;Department of Mathematics&lt;/a&gt; Universidad Autónoma de Madrid where he holds a Chair in Applied Mathematics since 2001.

&lt;strong&gt;Alejandro B. Aceves&lt;/strong&gt; is a Professor of Applied Mathematics and Department Chair at the &lt;a href='http://www.smu.edu/dedman' target='_blank'&gt;Southern Methodist University&lt;/a&gt; (Dallas, United States). His research interests are related to Nonlinear Optics and Nonlinear Wave Propagation. Namely, he is now working on modeling of nonlinear optical pulse propagation in waveguide gratings, code development to solve Maxwell's equations in nonlinear dielectrics, noise effect due to manufacturing imperfections in the problem of light localization in nonlinear fiber arrays, modeling of intense laser light propagation in air, studying the spread of diseases, and the effect of thermal baths in dimers and oscillator chains.

&lt;strong&gt;&lt;a href='https://cmc.deusto.eus/victor-hernandez-santamaria'&gt;Víctor Hernández-Santamaría&lt;/a&gt;&lt;/strong&gt; earned his Ph.D. degree in the department of automatic control in &lt;a href='http://www.cinvestav.mx/' target='_blank'&gt;CINVESTAV&lt;/a&gt; (Mexico), under the supervision of Luz de Teresa (Instituto de Matemáticas, UNAM, México) and Alexander Poznyak (CINVESTAV). His research interests are related to control problems for coupled parabolic equations, especially, those arising in the insensitizing control and hierarchic control problems, both from a theoretical and numerical point of view. He holded a Postdoctoral position at the &lt;a href='http://cmc.deusto.eus/dycon'&gt;ERC DyCon Advanced Grant project&lt;/a&gt; under the supervision of &lt;a href='http://paginaspersonales.deusto.es/enrique.zuazua/'&gt;Prof. Enrique Zuazua&lt;/a&gt;.

&lt;strong&gt;&lt;a href='https://cmc.deusto.eus/jose-vicente-lorenzo/'&gt;José Vicente Lorenzo&lt;/a&gt;&lt;/strong&gt; was a PhD student at &lt;a href='http://www.uam.es' target='_blank'&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. He finished his MSc Industrial Engineering at the &lt;a href='http://en.us.es/eng' target='_blank'&gt;University of Seville&lt;/a&gt; in 2014. He has worked at &lt;a href='https://home.cern/' target='_blank'&gt;CERN&lt;/a&gt; in Superconducting Magnets group (Geneva, Switzerland) and Spanish organism for Research in Energy and Environment &lt;a href='http://www.ciemat.es/' target='_blank'&gt;CIEMAT&lt;/a&gt;.

&lt;strong&gt;&lt;a href='https://ananavarroquiles.wordpress.com'&gt;Ana Navarro&lt;/a&gt;&lt;/strong&gt; is a PhD. She held a Postdoctoral position at the ERC Advanced Grant project &lt;a href='cmc.deusto.eus/dycon'&gt;DyCon&lt;/a&gt; under the supervision of &lt;a href='http://paginaspersonales.deusto.es/enrique.zuazua/'&gt;Prof. Enrique Zuazua&lt;/a&gt; (&lt;a href='https://www.uam.es/ss/Satellite/es/home.htm' target='_blank'&gt;UAM&lt;/a&gt; and &lt;a href='http://deustotech.deusto.es/cs/Satellite/ingenieria/es/deustotech' target='_blank'&gt;DeustoTech&lt;/a&gt;). Before that, she had a Predoctoral position at the &lt;a href='https://www.upv.es/index-en.html' target='_blank'&gt;Instituto Universitario de Matemática Multidisciplinar&lt;/a&gt;, financed by the &lt;a href='http://www.imm.upv.es' target='_blank'&gt;Universitat Politècnica de València&lt;/a&gt;. Her main research interest is the study from a probabilistic point of view of different problems based on differential equations (ordinary or partial) with uncertainty in its formulation. Now, she is concerned to connect her recent research with Control Theory.

&lt;strong&gt;&lt;a href='https://cmc.deusto.eus/dario-pighin/'&gt;Dario Pighin&lt;/a&gt;&lt;/strong&gt; is a PhD Student at &lt;a href='http://www.uam.es' target='_blank'&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. He earned both the Bachelor's Degree and the Master's Degree in Mathematics at the &lt;a href='https://web.uniroma2.it/home/newlang/english' target='_blank'&gt;University of Rome Tor Vergata (Rome 2)&lt;/a&gt;. His &lt;a href='https://drive.google.com/file/d/0B1dHVFQGZucNajBwM2JqYkk5SkE/view?usp=sharing' target='_blank'&gt;Master's thesis&lt;/a&gt; is about the Turnpike Property in Optimal Control Theory. Currently, he is studying for his PhD in Control Theory, under the joint supervision of professor Enrique Zuazua.

&lt;strong&gt;Alejandro Cunillera&lt;/strong&gt; was a PhD Student at &lt;a href='http://www.uam.es' target='_blank'&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. He earned a Bachelor's Degree in Mathematics and Physics at the &lt;a href='https://www.ucm.es/english' target='_blank'&gt;Universidad Complutense de Madrid&lt;/a&gt; and a Master's Degree in Physics of Complex Systems at &lt;a href='https://ifisc.uib-csic.es/en/'&gt;IFISC, Instituto de Física Interdisciplinar y Sistemas Complejos (CSIC-UIB)&lt;/a&gt;.

&lt;strong&gt;Borjan Geshkovski&lt;/strong&gt;&lt;/a&gt; is a PhD student at &lt;a href='http://www.uam.es' target='_blank'&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. He earned a Master's degree in Mathematics at the &lt;a href='https://www.u-bordeaux.com/' target='_blank'&gt;University of Bordeaux&lt;/a&gt;. He first did an internship on parabolic variational inequalities, optimal control of obstacles and free boundary problems under the supervision of Professor Enrique Zuazua, before joining the team as a PhD student later.

&lt;strong&gt;Domènec Ruiz&lt;/strong&gt; is a PhD Student at &lt;a href='http://www.uam.es' target='_blank'&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. He earned a BSc in Mathematics and a BSc in Physics at the &lt;a href='https://www.ucm.es/english' target='_blank'&gt;Universitat Autònoma de Barcelona&lt;/a&gt;. Later he earned and a MSc in Applied Mathematics in an Erasmus Mundus program between the &lt;a href='http://www.univaq.it/en/index.php?&amp;lang_s=en'&gt;Università degli Studi dell'Aquila (UAQ)&lt;/a&gt; and &lt;a href='https://www.uni-hamburg.de/en.html'&gt;Universität Hamburg (UH)&lt;/a&gt;. His master thesis was about asymptotic analysis and control of kinetic Cucker-Smale models. Currently, he is studying for a PhD in Control Theory under the supervision of Professor Enrique Zuazua.

&lt;strong&gt;Charlotte Rodriguez&lt;/strong&gt; is a PhD Student at &lt;a href='https://www.fau.eu/' target='_blank'&gt;Friedrich-Alexander-University&lt;/a&gt;, Erlangen-Nurnberg, Germany. She finished her Master studies in Mathematics (Analysis, Partial Differential Equations, Probability) at the &lt;a href='https://www.u-bordeaux.com/'&gt;University of Bordeaux&lt;/a&gt; in 2018. Since then she has been working in Mathematical network modelling of nonlinear fluid structure interaction, model reduction and uncertainty quantification (Part of Marie Sklodowska-Curie ITN ConFlex) under the supervision of Prof Gunter Leugering. She was in Bilbao for a 2 month internship under the supervision of Professor Enrique Zuazua, working in Control theory.

&lt;strong&gt;Dongnam Ko&lt;/strong&gt; is a Postdoctoral researcher at the ERC Advanced Grant project &lt;a href='cmc.deusto.eus/dycon'&gt;DyCon&lt;/a&gt; under the supervision of &lt;a href='http://paginaspersonales.deusto.es/enrique.zuazua/'&gt;Prof. Enrique Zuazua&lt;/a&gt; (&lt;a href='https://www.uam.es/ss/Satellite/es/home.htm' target='_blank'&gt;Universidad Autónoma de Madrid&lt;/a&gt; and &lt;a href='http://deustotech.deusto.es/cs/Satellite/ingenieria/es/deustotech' target='_blank'&gt;DeustoTech&lt;/a&gt;). Before that, he was a Post-Doctoral researcher at the &lt;a href='http://hyke.snu.ac.kr/'&gt;Research Institute of Mathematics&lt;/a&gt;, &lt;a href='http://www.useoul.edu/'&gt;Seoul National University&lt;/a&gt;, Korea. His main research interests are the emergent dynamics of coupled particle networks, the Stochastic particle-path analysis on mean-field models and the numerical methods on kinetic dynamics.

&lt;strong&gt;Yacouba SIMPORE&lt;/strong&gt; is an Associate Professor at the &lt;a href='http://www.univ-ouaga.bf/spip.php?rubrique39' target='_blank'&gt;Université Ouaga 1 Professeur Joseph Ki Zerbo&lt;/a&gt;, Ouagadougou, Burkina Faso, where he obtained his PhD in Optimal Control in 2016. He visited the Chair of Computational Mathematics of DeustoTech during 3 months within the Senior Visitor Program of the &lt;strong&gt;&lt;a href='devcmc.deusto.es/dycon/'&gt; ERC Advanced Grant DyCon&amp;#58; Dynamic Control&lt;/a&gt;&lt;/strong&gt;.

&lt;strong&gt;Xinliang Liu&lt;/strong&gt; is a PhD Student at &lt;a href='https://www.fau.eu/' target='_blank'&gt;Shanghai Jiao Tong University&lt;/a&gt;, China. In the same university, he finished his Master studies in Applied Mathematics in 2017, with the thesis 'A variational framework to identify optimal approximation basis and its application to integral equation'. He was in Bilbao for a 2 month internship under the supervision of Professor Enrique Zuazua, working in Control theory.

Mehmet is currently an associate professor at the Université de Toulon (La Garde, France) and does his research at the Institut Mathématiques de Toulon (IMATH) -Équipe de Modélisation Numérique (MN). His fields of specialization and research interests include Non linear analysis of PDEs and Numerical analysis in fluid mechanics. Before joining the MN team, he was a postdoctoral researcher at the Basque Center for Applied Mathematics, Derio, Spain, directed by/in collaboration with Enrique Zuazua. He obtained his PhD in Applied Mathematics at the Laboratoire de Mathématiques-LAMA under the supervision of Christian Bourdarias &amp; Stéphane Gerbi, Université de Savoie (Chambéry, France) in 2010. He delivers Scientific Computing and Numerical Analysis courses at the Ecole d'Ingénieurs de l'Université de Toulon which offers the possibility to get high level skills.

Yuhua is a fourth-year Ph.D student in Department of Mathematics at University of Wisconsin-Madison. Her interests lie in uncertainty quantification in kinetic theory and Machine learning.

Swann MARX got his PhD in GIPSA-lab (Grenoble, France) under the supervision of Christophe Prieur and Vincent Andrieu. During the PhD he focused on the stabilization of PDEs whose control is subject to some amplitude constraints. Currently he is a post-doctoral researcher at LAAS-CNRS (Toulouse, France), working on polynomial optimization applied to nonlinear hyperbolic PDEs and he did an internship in the DyCon project, under the supervision of Prof. Enrique Zuazua.

Carlos Castro is a professor in the Mathematics and Informatics Department of &lt;a href="http://www.caminos.upm.es/default.asp" target="_blank"&gt;ETSI Caminos, Canales y Puertos, Universidad Politécnica de Madrid&lt;/a&gt; (Spain).

Miguel Cea is a Product Director in INCLAM. Msc. and Postgraduate in Mathematics from the Universidad Autónoma de Madrid, and PhD Candidate in Mathematics on Optimal Design Problems. Extensive experience in mathematical models and numerical methods. Currently, he is the Product Director of SUAT (Unified Early Warning Service), which is defined as a SaaS service that consists of a Web platform that generates alerts and management recommendations in real time based on hydro-meteorological variables.

Sorin is a professor at the Department of Mathematics in the Faculty of Sciences at the University of Craiova, Romania. His main research directions are Control and stabilization(1), Partial derivative equations(2) and Numerical analysis(3). The main purpose of his research activity is to show that innovative mathematical reasoning can lead to new perspectives on the studied phenomena and a deeper understanding of more and more complex physical models. His most important scientific contributions include the study of complex systems that couples vibrations of different natures (the so-called hybrid systems) in terms of their spectral properties, controllability, stabilization and existence of periodic solutions.

&lt;a href="http://math.univ-bpclermont.fr/~munch/" target="_blank"&gt;Arnaud&lt;/a&gt; is a professor at &lt;a href="https://en.uca.fr/english-version/" target="_blank"&gt;Clermont Auvergne University&lt;/a&gt;, Laboratoire de mathématiques Blaise Pascal, Clermont-Ferrand, France.

&lt;a href="https://scholar.google.com/citations?user=5EexYDAAAAAJ&amp;hl=es"&gt;Mihaela&lt;/a&gt; is a professor in Universidad Complutense de Madrid, Spain.

Aitziber Ibáñez was a PhD student at &lt;a href="http://www.uam.es/UAM/Home.htm?language=en" target="_blank"&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. She finished her Bachelor’s degree in Mathematics at the &lt;a href="https://www.ehu.eus/en/web/guest/en-home" target="_blank"&gt;University of the Basque Country (UPV/EHU)&lt;/a&gt; in June 2009. She studied Master’s degree in Computational Engineering and Intelligent Systems, also in (UPV/EHU).

Emmanuel Trélat matriculated at École normale supérieure de Cachan (mathematics) in 1995 and obtained the agrégation in 1998. In 2000, he obtained a doctorate under the direction of Bernard Bonnard at the University of Burgundy at Dijon with thesis entitled Étude asymptotique et transcendance de la fonction valeur en contrôle optimal; catégorie log-exp en géométrie sous-Riemannienne dans le cas Martinet (Asymptotic study and transcendence of the value function in optimal control; category log-exp in sub-Riemannian geometry in the Martinet case).[1] In 2001 he was appointed a lecturer at the University of Paris-Sud, where he obtained in 2005 his habilitation Contrôle en dimension finie et infinie (Control in finite and infinite dimension). In 2006 he was appointed a professor at the University of Orleans. Since 2011 he has been a professor at Pierre and Marie Curie University at the Laboratoire Jacques-Louis Lions. Since 2015 he has been director of the Fondation sciences mathématiques de Paris

Computational Science and Engineering Division, Oak Ridge National Laboratory (Tennessee, United states).

University of Chile, Centro de Modelamiento Matemático (CMM).

Jiamin is currently a Post Doctoral researcher in Paris and Madrid, under the direction of Enrique Zuazua and Emmanuel Trélat, under the ANR-ICON Project (Control Interactions, Partial Differential Equations, and Numerical Analysis).

Former Marie S. Curie fellow, Research Center on Animal Cognition, Université Paul Sabatier, Toulouse (France).

&lt;strong&gt;Azahar Monge&lt;/strong&gt;&lt;/a&gt; holds a Postdoctoral position at the ERC Advanced Grant project DyCon under the supervision of &lt;a href="http://paginaspersonales.deusto.es/enrique.zuazua/" target="_blank"&gt;Prof. Enrique Zuazua&lt;/a&gt; (UAM and DeustoTech). Before that, she earned her PhD in Numerical Analysis at the Centre for Mathematical Sciences, &lt;a href="http://www.maths.lu.se/english/" target="_blank"&gt;Lund University&lt;/a&gt; (Sweden) under the supervision of Prof. Philipp Birken. Her thesis was focused on the numerical aspects around the partitioned approach for the simulation of time-dependent thermal fluid-structure interaction. Earlier, she was awarded an Erasmus Mundus scholarship to participate in the &lt;a href="http://www.mathmods.eu/" target="_blank"&gt;MSc programme MATHMODS&lt;/a&gt; (Mathematical Modelling in Engineering - Theory, Numerics, Applications). Her main research interests are domain decomposition methods, coupled problems, PDEs and time adaptive multirate time integration methods.&lt;/p&gt;&lt;ul class="list-nomarker"&gt;&lt;li&gt;&lt;i class="fa fa-envelope fa-blue"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href="mailto:azahar.monge@deusto.es"&gt;azahar.monge@deusto.es&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;i class="fa fa-phone fa-blue"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href="tel:34944139003,3282"&gt;(+34) 944 139 003 Ext. 3282&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;strong&gt;Jose Matias&lt;/strong&gt; – &lt;a href="https://www.ulisboa.pt/" target="_blank"&gt;Universidade de Lisboa&lt;/a&gt;, Lisboa, Portugal.

&lt;strong&gt;Marco Morandotti&lt;/strong&gt; &amp;#8211; &lt;a href="http://www.disma.polito.it/" target="_blank"&gt;Dipartimento di Scienze Matematiche&lt;/a&gt;, Politecnico di Torino, Italy.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Email &lt;a href="mailto:marco.morandotti@polito.it" target="_blank"&gt;marco.morandotti@polito.it&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Web page &lt;a href="http://marcomorandotti.weebly.com/" target="_blank"&gt;http://marcomorandotti.weebly.com&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

Mohammed Nor FRIOUI is a Phd student at Abou Bekr Belkaid University of Tlemcen, Algeria. He obtained a scholarship at the Autonomous university of Madrid in the framework of Erasmus program for a research and training intensification with professor Enrique Zuazua from march to july 2019.

&lt;p&gt;&lt;strong&gt;Debayan Maity&lt;/strong&gt; holds a Postdoctoral position at the ERC Advanced Grant project DyCon under the supervision of &lt;a href="http://paginaspersonales.deusto.es/enrique.zuazua/" target="_blank"&gt;Prof. Enrique Zuazua&lt;/a&gt; (UAM and DeustoTech). Before that, he was a Post-Doctoral researcher at the Institut de Mathématiques de BordeauxI under the supervision of Prof. Marius Tucsnak. His main research interests are the fluid-solid interaction problems and the control of partial differential equations, namely fluid motions, population dynamics models, etc.&lt;/p&gt;

&lt;strong&gt;Thibault Liard&lt;/strong&gt; holds a Postdoctoral position at the ERC Advanced Grant project DyCon under the supervision of &lt;a href="http://paginaspersonales.deusto.es/enrique.zuazua/" target="_blank"&gt;Prof. Enrique Zuazua&lt;/a&gt; (UAM and DeustoTech). He earned his PhD in observation and control for some conservative systems under the supervision of Alain Haraux and Yannick Privat. His previous Postdoctoral positions were focused on the study of strongly coupled PDE/ODE systems where the PDE consists of a system of conservation laws and the ODE represents the trajectory of particles. Therefore, his main research interests are control theory, calculus of variations, hybrid PDE/ODE, scalar conservation laws with constraints and Wave-front tracking methods.&lt;/p&gt;
</code></pre></div></div>


    <!-- Footer -->
<footer>
  <hr>
  <div class="container">
    <div class="row">
      <ul class="list-inline text-center">
        <li style="margin-right: 50px;">
          <img style="width: 250px;" src="/DyCon-Blog/img/logos/logo_DyCon.png " alt="">
        </li>
        <li style="padding-bottom: 5px;">
          <img style="width: 230px;" src="/DyCon-Blog/img/logos/logo_CCM_subDerecha_v002.png " alt="">
        </li>
      </ul>
    </div>
  </div>
</footer>

</body>
</html>
