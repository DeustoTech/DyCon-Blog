<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Welcome to the web interface of DyCon Toolbox, the computational platform developed within the <a href='https://cmc.deusto.eus/dycon/' target='_blank'>ERC DyCon - Dynamic Control</a> project.">
	<link rel='shortcut icon' type='image/png' href='/DyCon-Blog/favicon.png' />

  <title>
    typo - DyCon Blog
    
  </title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="canonical" href="https://deustotech.github.io/DyCon-Blog/typo">

  <!-- Bootstrap Core CSS -->
  <link rel="stylesheet" href="https://deustotech.github.io/DyCon-Blog/css/bootstrap.min.css">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="https://deustotech.github.io/DyCon-Blog/css/clean-blog.css">

   <!-- Adjust Colors -->
  <link rel="stylesheet" href="https://deustotech.github.io/DyCon-Blog/colorscheme.css">

  <!-- Pygments Github CSS -->
  <link rel="stylesheet" href="https://deustotech.github.io/DyCon-Blog/css/syntax.css">

  <link rel="stylesheet" href="https://deustotech.github.io/DyCon-Blog/css/google-search.css">


  
  <script src="https://deustotech.github.io/DyCon-Blog/lib/js/libgif.js "></script>
  <script src="https://deustotech.github.io/DyCon-Blog/lib/js/rubbable.js "></script>


  <!-- Google Fonts Raleway -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,700" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
	<!-- MathJax -->
  <script type="text/x-mathjax-config">
	MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    },
		TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      },
      extensions: ["AMSmath.js", "AMSsymbols.js"],
      Macros:{
        norm: ["|| #1 ||",1],
        abs: ["| #1 |",1],
        hdots: "...",
        RR: "\\mathbb{R}",
        ffl: ["(d_x^2)^{#1}",1],
        ccs: "c_{1,s}",
        kernel: ["|x-y|^{#1}",1],
        ue: ["#1^{\\epsilon}",1]
      }
    },
    CommonHTML: {
      styles: {
        "@font-face /* vec */ ": {
          "font-family": "MJX-VEC",
          src: [
            "url(data:application/x-font-woff;charset=utf-8;base64,",
            "d09GRgABAAAAAARMAA0AAAAABiQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEMAAAABwA",
            "AAAccRGLqUdERUYAAAQMAAAAJAAAACgANAAmT1MvMgAAAaAAAABJAAAAYFc5gfFjbWFwAAACAAAA",
            "AEYAAAFKQxjlbWdhc3AAAAQEAAAACAAAAAj//wADZ2x5ZgAAAlQAAACUAAAAlIQU9HBoZWFkAAAB",
            "MAAAADAAAAA2C748e2hoZWEAAAFgAAAAHgAAACQFXQDqaG10eAAAAewAAAAUAAAAFAYvAE9sb2Nh",
            "AAACSAAAAAwAAAAMACgAcm1heHAAAAGAAAAAHQAAACAASQAmbmFtZQAAAugAAADxAAAB5uwlD0hw",
            "b3N0AAAD3AAAACgAAAA34M9aEXjaY2BkYGAA4uOfgq7G89t8ZeBmfgEUYbga+icNTssClVxnOgXk",
            "cjAwgUQBdqEMW3jaY2BkYGBu+feBgYHxCwMQMF5nYGRABawAcaQESgAAeNpjYGRgYGBlUGZgYgAB",
            "EMnIABJzAPMZAAZZAHAAAAB42mNgYSxn/MLAysDA1MW0h4GBoQdCMz5gMGRkAooysDEzwAAjECvA",
            "OAFprikMBxgUFCcxt/z7wMDA3MIoAFUDAwoMjACD8Qv5AAAAAfQAMgAAAAABTQAAAPoAAAH0AB14",
            "2mNgYGBmgGAZBkYGEHAB8hjBfBYGDSDNBqQZGZgYFBQn/f8P5IPp/4/vFUHVAwEjGwOcw8gEJJgY",
            "UAEjxIrhDACLGwmnAAAAAAAUABQAFAAUAEoAAgAyAAABwgIVAAMABwAAMxEhESUhESEyAZD+ogEs",
            "/tQCFf3rMgGxAAEAHQIEAdcCygAiAAABNDYzMhcWFxYXFhUUBgcGBw4DIyImNTQ3IycmNTQ3ISYB",
            "eQsJBwUFBQofCwYLKyACBwMGBAcNL6urDQ0BZxgCtggMBQQPJRQHCwkGBhYpAgkCAgsJEygBCQoH",
            "DSYAeNqVjrGKwkAURe/EGBBUrG12CishMrFQcDuLsAi26YMOmsIMxAh+hN8i+CF+gd+y4B3zttjC",
            "woHhncu7774HoI8rFP5eIKzQw5dwgAjfwi2McBEO6bkLtzHAr3CEnhrTqcKOpDasMCQ1HKCLWLiF",
            "HyyFQ3puwm1oPIQjDFXfR62Ro8YeK9YzMlhsqB0qtvJ6v8rPmd3Uzkv2tihwwoHCbosTa0pryYH0",
            "NbKjRWPB/z626Se8dsY/hSHPGeTKOnXVzuqF/reYOoln8dQk80+u9b0KR97rD9Rc4xdNXtVQI7PV",
            "sXClNiaZGGP0B+FPMN1KMAAAAHjaY2BiAIP/zQxGDNgAKxAzMjAxMDMycSUWFeWXF2WmZ5QAAGh5",
            "BhgAAAAB//8AAnjaY2BkYGDgA2IJBgUgycTAyMDMwAIkWcA8BgZGCAYACgIAWwAAAAEAAAAAxmW3",
            "ygAAAADVVeemAAAAANVV7Dg=) format('woff')"
          ].join('')
        },
        ".MJX-VEC": {
          "font-family": "MJX-VEC"
        }
      }
    }
  });
  MathJax.Hub.Register.StartupHook("CommonHTML Jax Ready", function () {
    var MML = MathJax.ElementJax.mml;
    var fixCombiningChar = MML.mo.prototype.CHTMLfixCombiningChar;
    MML.mo.Augment({
      CHTMLfixCombiningChar: function (node) {
        if (node.textContent === '\u20D7') {
          //
          //  Safari makes combining characters into non-combining ones when
          //  they don't have anything to combine with; replace \vec arrow
          //  with a non-combining one so all browsers get the same thing
          //
          node = node.firstChild;
          node.firstChild.nodeValue = "\u2192";
          node.className = "mjx-char MJX-VEC";
          node.style.marginLeft = "-.5em";
          node.style.paddingTop = ".45em";
        } else {
          fixCombiningChar.call(this,node);
        }
      }
    });
  });
	</script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.4.13/d3.min.js" type="text/javascript"></script>-->

    <!-- jQuery -->
	<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

	<!-- Bootstrap Core JavaScript -->
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>

	<!-- Custom Theme JavaScript -->
  <script src="https://deustotech.github.io/DyCon-Blog/js/clean-blog.min.js "></script>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-128123935-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-128123935-3');
  </script>
  <!-- End Google Analytics -->



  <!-- marKdown editor -->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.css">
  <script src="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.js"></script>
</head>

<body>
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <!-- <a class="navbar-brand" href="/DyCon-Blog/">
                 <img src="https://deustotech.github.io//DyCon-Blog//assets/logo_DyCon.png">
            </a> -->
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/DyCon-Blog/">Home</a>
                </li>
                
                
                    
                        
                    
                                   
                <li>
                    <a href="/DyCon-Blog/projects/posts">Documentation</a>
                </li>
                
                    
                
                    
                <li>
                        <a href="https://deustotech.github.io/DyCon-Blog/projects/search.byWP">Sitemap</a>
                </li>
                <li>
                        <a href="http://cmc.deusto.eus/">Chair of Computational Mathematics</a>
                </li>
                
            </ul>

        
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3 id="background-and-motivation"&gt;Background and motivation&lt;/h3&gt;
</code></pre>
</div>

<p>Let us consider the random heat equation described 
by the following system:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}\tag{1}
y_t-\alpha \Delta y =f1_{G_0}, &\text{ in } (0,T)\times G,\\
y=0, & \text{ on } (0,T)\times \partial G,\\
y(0,\cdot)=y^0,  & \text{ on } G,
\end{cases} %]]></script>

<p>for $G$  a domain, $G_0\subset G$ a subdomain, 
$f$ a control,  $y^0$  the initial configuration 
and $\alpha$ the diffusivity coefficient, which is a positive 
random variable with density function $\rho$.
We have that the averaged solution of (1)
is given by:</p>

<script type="math/tex; mode=display">\tilde y(t,x;y^0,f):=\int_0^{+\infty} y(t,x;\alpha,y^0,f)\rho(\alpha)d\alpha.</script>

<p>We want to determine if, given a positive random variable 
$\alpha$ and an initial configuration $y^0\in L^2(G)$, there 
is some $f\in L^2((0,T)\times G_0)$ such that $\tilde y(T,\cdot)=0$.</p>

<p>In order to illustrate the effect of averaging in
 the dynamics, let us study the dynamics of
(1) when $G=\mathbb R^d$ and $f=0$.
As averaging and the Fourier transform commute, we work on the
Fourier transform of the fundamental solution of the
heat equation, which is given by:</p>

<script type="math/tex; mode=display">\exp(-\alpha |\xi|^2t).</script>

<p>Consequently, the Fourier transform of the average
of the fundamental solutions is given by:</p>

<script type="math/tex; mode=display">\int_0^{+\infty} \exp (-\alpha |\xi|^2t)\rho(\alpha)d\alpha;</script>

<p>i.e. the Laplace transform of $\rho$ evaluated in $|\xi|^2t$. 
In particular, for $r\in(0,1)$ if $\rho(\alpha)\sim_{0^+} e^{-C\alpha^{-\frac{r}{1-r}}}$
we have that:</p>

<script type="math/tex; mode=display">\tag{2}
\int \exp (-\alpha |\xi|^2t)\rho(\alpha)d\alpha\sim \exp(-C|\xi|^{2r}t^r)</script>

<p>when $|\xi|^2t\to+\infty$, which can be proved by the Laplace method.
Thus, for those density functions 
the averaged dynamics in $\mathbb R^d$ has a fractional nature. As it is proved in [1],
for $G$ bounded this is also true and we have the usual controllability 
and observability results of fractional dynamics;
that is, (2) implies that
the averaged unique continuation is preserved,
but (2) preserves the null averaged observability
if and only if $r&gt;1/2$, being the threshold density functions  those
which satisfy:</p>

<script type="math/tex; mode=display">\rho(\alpha)\sim_{0^+} e^{-C\alpha^{-1}}.</script>

<h3 id="some-numerical-simulations">Some numerical simulations</h3>

<p>Let us now illustrate the difference between several probability distributions for the diffusion through numerical simulations. For that, we recall that 
the optimal control is given by $\varphi(t,x;\phi)1_{G_0}$, for $\varphi$ the 
averaged solution of</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
-\varphi_t-\alpha \Delta \varphi=0, &\text{ in } (0,T)\times G,\\
\varphi=0, & \text{ on } (0,T)\times\partial G,\\
\varphi(T,\cdot)=\phi,  & \text{ on } G.
\end{cases} %]]></script>

<p>and $\phi$ the state which minimizes the functional:</p>

<script type="math/tex; mode=display">J(\phi)= \frac{1}{2}\int_0^T\int_{G_0}
\left|\int_0^{+\infty}\varphi(t,x;\alpha,\phi)\rho(\alpha)d\alpha\right|^2dxdt 
 \\+\left\langle  y^0, \int_0^{+\infty}\varphi(0;\alpha,\phi)\rho(\alpha)d\alpha\right\rangle.</script>

<p>Due to the hardness of the numerical computations in higher dimensions and to get
better illustrations we work in $d=1$, and in particular in $G=(0,\pi)$.
We also consider $G_0=(1,2)$, $T=1$ and $y^0=\frac{1}{2}$. 
Moreover, to illustrate the difference between diffusivities inside and 
outside the null controllability regime, we consider $\rho=1_{(1,2)}$, which is inside,
and $\rho=1_{(0,1)}$, which is outside.</p>

<p>In order to numerically implement this problem, we approximate it by
minimizing $J$ in $V_M:=\langle e_i \rangle_{i=1}^M$ 
for ${e_i}$ the eigenfunctions of the Dirichlet Laplacian
 and for $M\in{40,50,60}$. 
Since $V_M$ is a finite dimensional space, computing the 
minimum of $J$ is equivalent to solving numerically a linear system,
which can be easily done by using any numerical computing environment
(in our case MATLAB). We have the following illustrations:</p>

<p>First, we illustrate in Figure 1 
(resp. in Figure 2)
the controls induced by the minimum of $J$ for $\rho=1_{(1,2)}$
(resp. for $\rho=1_{(0,1)}$).
For  $\rho=1_{(1,2)}$ the 
sequence of controls converges, which is something that can be seen in an even 
more clear way when $t\in[0,1/2]$. Of course, the closer the time is to $1$,
the more slowly the punctual values of the control converges pointwise with $M$ 
(and in $t=1$ it diverges),
which is a well-known behaviour when
controlling a parabolic dynamics (see, for instance,
[2], [3] and [4]).
 However, for $\rho=1_{(0,1)}$ the sequence of  controls 
diverges, which is something that we can appreciate in a more 
detailed way when $t\in[0,1/2]$.</p>

<center>
<table>
<tr>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph12V40.jpg" width="100%" /></th>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph12V40t05.jpg" width="100%" /></th>
</tr>
<tr>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph12V50.jpg" width="100%" /></th>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph12V50t05.jpg" width="100%" /></th>
</tr>
<tr>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph12V60.jpg" width="100%" /></th>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph12V60t05.jpg" width="100%" /></th>
</tr>
</table>


<strong> Figure 1: </strong>
 The optimal control for  $\rho=1_{(1,2)}$ and $y^0=\frac{1}{2}$ 
induced by the minimum of the functional $J$ in $V_{40}$, $V_{50}$
and $V_{60}$.
In the left column we illustrate the whole controls, whereas in the right 
column we illustrate the controls with the time variable zoomed in $[0,1/2]$.
</center>

<center>
<table>
<tr>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph01V40.jpg" width="100%" /></th>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph01V40t05.jpg" width="100%" /></th>
</tr>
<tr>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph01V50.jpg" width="100%" /></th>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph01V50t05.jpg" width="100%" /></th>
</tr>
<tr>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph01V60.jpg" width="100%" /></th>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph01V60t05.jpg" width="100%" /></th>
</tr>
</table>


<strong> Figure 2: </strong>
 The optimal control for  $\rho=1_{(0,1)}$ and $y^0=\frac{1}{2}$ 
induced by the minimum of the functional $J$ in $V_{40}$, $V_{50}$
and $V_{60}$.
In the left column we illustrate the whole controls, whereas in the right 
column we illustrate the controls with the time variable zoomed in $[0,1/2]$.
</center>

<p>Next, we show in Figure 3
the canonical prolongation of the previously obtained controls to $t=0$.
 Again, for $\rho=1_{(1,2)}$  we have a clear convergence,
whereas for $\rho=1_{(0,1)}$  it diverges.</p>

<center>
<table>
<tr>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph12t0.jpg" /></th>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph01t0.jpg" /></th>
</tr>
</table>

<strong> Figure 3: </strong>
The natural extensions to $t=0$ of the controls 
induced by the minimum of the functional $J$ in $V_{40}$, $V_{50}$ 
and $V_{60}$ with $y^0=\frac{1}{2}$. In the left figure
we have considered $\rho =1_{(1,2)}$ and in the right one $\rho=1_{(0,1)}$.
</center>

<p>Finally, we illustrate in Figure 4 the state at $t=1$
of the respective solutions of the averaged heat equation
 with the previously obtained controls.
For $\rho=1_{(1,2)}$ the solution converges smoothly to $0$,
whereas for $\rho=1_{(0,1)}$ the solution diverges.</p>

<center>
<table>
<tr>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph12t1.jpg" /></th>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0013/Graph01t1.jpg" /></th>
</tr>
</table>

<strong> Figure 4: </strong>
The state in time $t=1$ of the averaged solutions of the heat equation after
applying the control induced by the minimum of $J$ in $V_{40}$, $V_{50}$
and $V_{60}$ with $y^0=\frac{1}{2}$. In the left figure
we have considered $\rho =1_{(1,2)}$ and in the right one $\rho=1_{(0,1)}$.
</center>

<h3 id="bibliography">Bibliography</h3>
<p>[1] J. A. Bárcena-Petisco, E. Zuazua, <i> Averaged dynamics and control for heat equations with random diffusion </i>. Preprint <a href="https://hal.archives-ouvertes.fr/hal-02958671/">https://hal.archives-ouvertes.fr/hal-02958671/</a></p>

<p>[2] E. Fernández-Cara and A. Münch. <i>Strong convergent approximations of null controls for the 1D
heat equation.</i> SeMA journal, 61(1):49-78, 2013.</p>

<p>[3] R. Glowinski and J. L. Lions.<i> Exact and approximate controllability for distributed parameter
systems. </i> Acta Numer., 1:269-378, 1994.</p>

<p>[4] A. Münch and E. Zuazua. <i>Numerical approximation of null controls for the heat equation: illposedness
and remedies.</i> Inverse Probl., 26(8):085018, 2010.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h2 id="data-and-classification"&gt;Data and classification&lt;/h2&gt;
</code></pre>
</div>
<h3 id="supervised-learning">Supervised Learning</h3>

<p>Consider a dataset $\mathcal{D}$ consisting on $S$ distinct points ${x_i}_{i=1}^{S}$, each of them with a corresponding value $y_i$ such that</p>

<script type="math/tex; mode=display">\mathcal{D} = \{(x_i , y_i)\}_{i=1}^S</script>

<script type="math/tex; mode=display">y_i = \mathcal{F} (x_i) + \epsilon _i \quad \forall i \in \{1, ... S\}</script>

<p>where $\epsilon _i$ is included so as to consider, in principle, noisy data.</p>

<p>The aim of supervised learning is to recover the function $\mathcal{F}(\cdot)$ such that not only fits well in the database $\mathcal{D}$ but also generalises to previously unseen data.</p>

<p>That is, it is inferred the existence of</p>

<script type="math/tex; mode=display">\tilde{\mathcal{D}} = \{ (\tilde{x}_i , \tilde{y}_i) \}_{i=1}^{\infty}</script>

<p>where</p>

<script type="math/tex; mode=display">\tilde{y}_i \approx \mathcal{F}(\tilde{x}_i) \quad \forall i</script>

<p>being $\mathcal{F} (\cdot)$ the desired previous application, and $\mathcal{D} \subset \tilde{\mathcal{D}}$.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/generaliseddataset.jpg" alt="GeneralisedDataset" /></p>

<p><br /></p>

<h3 id="noisy-vs-noisless-data">Noisy vs. noisless data</h3>

<p>The generalised dataset $\tilde{\mathcal{D}}$ can be seen as the realisation of a random vector $(\mathbf{x}, \mathbf{y})$ generated by an unknown multivariate joint distribution between $\mathcal{X}$ and  $\mathcal{Y}$.</p>

<p>Then, the datasets used in Supervised Learning can be seen as a finite sample of the random vector $(\mathbf{x}, \mathbf{y})$, and so the underlying joint distribution between $\mathcal{X}$ and $\mathcal{Y}$ could be in principle recovered in the limit of infinitely many samples, $\tilde{\mathcal{D}}$ .</p>

<p>We refer to noisy data when the samples in our dataset $\mathcal{D}$ actually comes from a random vector $(\mathbf{x}, \mathbf{y})$ with a non-deterministic joint distribution, such that it is not possible to find a function $\mathcal{F}$ such that $\mathcal{F}(\mathbf{x}) = \mathbf{y}$.</p>

<p>The aim of supervised learning, in this case, would be to find a function such that $\mathcal{F}(\tilde{x}_i) \approx \tilde{y}_i$ for almost every sample, as with respect to a given loss function.</p>

<p>In case the data is considered to be noisless (which does not happen in most practical situations, but it makes things far simpler) then the joint distribution between $\mathcal{X}$ and $\mathcal{Y}$ of the random vector $(\mathbf{x}, \mathbf{y})$ is rather deterministic. In this case, it is possible to find a function $F$ such that $\mathcal{F}(\tilde{x}_i) = \tilde{y}_i \; \forall i$, or equivalently $\mathcal{F}(\mathbf{x}) = \mathbf{y}$.</p>

<p>Note that, given that the probability of a collision (of having two different data-points such that $x_i = x_j$ for $i \neq j$) is practically $0$, it is in principle possible to find a function $\mathcal{F}$ such that $\mathcal{F}(x_i)=y_i \; \forall i = { 1, …  ,S }$, even in the noisy case (i.e. we may use interpolation). 
However, the aim of <em>Supervised Learning</em> is to be able to generalise well to previously unseen data, $\tilde{\mathcal{D}}$, and so interpolation is not effective.</p>

<p>Some systems are often approximated as being noisless. Since the aim of supervised learning is finding functions $\mathcal{F}$, there is always the implicit assumption that the generalised dataset $\tilde{\mathcal{D}}$ can be approximately represented by a function $\mathcal{F}$, and so the noise is expected to be small, compared to the “real data”. Distinguishing data from noise is often far a from trivial issue.</p>

<p>The idea of working with noisy data can be recasted as a Mean-Field problem, as proposed by Weinan E. et al [2]. The idea is to control a distribution, instead of a set of points in an euclidean space. Although understanding Supervised Learning with noisless data from a Dynamical Control perspective is often enough ill-posed, considering noisy data unlocks the full theoretical experience.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/generalnoisless.gif" alt="Noisless" /></p>

<p><br /></p>

<h3 id="binary-classification">Binary classification</h3>
<p>In most cases, the data points $x_i$ are in $\mathbb{R}^{n}$. In general, $x_i \in X \; \forall i$, with $X \subset \mathbb{R}^{n}$. So as to ease the training of the models, it is usually considered $X = [-1,+1]^{n}$, with $n$ an arbitrary dimension. This is called <em>data normalization</em> in the Machine Learning literature.</p>

<p>There are different supervised learning problems depending on the space $Y$ of the corresponding labels, such that $y_i \in Y$.<br />
If $Y$ is discrete, such that $Y = { 0, … , L-1}$, then we are dealing with the problem of classification. If $L=2$, then it is a binary classification problem.</p>

<p>In this particular setting, the aim is to find a function $F (\cdot)$ such that it returns $0$ whenever the corresponding data point is of class $0$, and $1$ conversely. 
Note that such a function cannot be continuous except for trivial cases, given that  the data points in $X$ cover all the space $[-1, +1]$, due to the existence of a boundary between points of class $0$ and $1$.</p>

<h3 id="data-subspaces-and-manifolds">Data, subspaces and manifolds</h3>

<p>Considering $X^0$ the subset of $X$ such that $F(\tilde{x}_i) =0 \; \; \forall \tilde{x}_i \in X^0$ and $X^1$ s.t.  $\, F(\tilde{x}_i)=1 \; \; \forall \tilde{x}_i \in X^1$, it is often useful to consider $d(X^0 , X^1) &gt; \delta \in \mathbb{R}^{+}$. 
Consider that the $x-$points in the dataset $\tilde{\mathcal{D}}$ are in $X= X^0 \cup X^1$.</p>

<p>In this aforementioned case, it is in principle possible to find a continuous function $F(\cdot)$ such that $F(\tilde{x}_i) = \tilde{y}_i \; \forall i$ , since it does not need to be defined in the boundary (the boundary is not in $X$).</p>

<p>The simpler case is one in which $X^0$ and $X^1$ are connected spaces.</p>

<p><br /></p>

<h2 id="deep-learning">Deep Learning</h2>
<h3 id="neural-networks">Neural Networks</h3>

<p>The problem is now how to obtain the functions $\mathcal{F}$.</p>

<p>In classical settings, an hypothesis space is often proposed as</p>

<script type="math/tex; mode=display">\mathcal{H} = \left\{  f (\cdot \, ; \mathbf{\theta }) \; \bigg\vert  f(\cdot ; \theta ) = \phi \left(\sum_{i=1}^{m} a_i \psi _i (\cdot) \right) \right\}</script>

<p>where $\theta = { a_i }_{i=1}^{m}$ are the coefficients, ${ \psi _i}$ are the proposed functions (for example, they would be monomials if we are doing polynomial regression, sine and cosines if using Fourier, …) and the function $\phi$ is the terminal loss function, that is used to match the dimensionality of $f(x_i \; ;  \theta)$ with $y_i$; for example, in the case of binary classification, $\phi (  \cdot )$ can be chosen to be the function $sign ( \cdot )$, and so $\phi (\cdot ) : \mathbb{R} \to {0,1 }$.</p>

<p>The function $\mathcal{F}$ correspondent to the dataset $\mathcal{D}$ is then defined as</p>

<script type="math/tex; mode=display">\mathcal{F}(\cdot ) \equiv f(\cdot \, ; \theta ^*) \in \mathcal{H} \quad s.t. \quad \theta ^* = \arg \min \sum_{i=1}^{S} d(\phi (f(x_i \, ; \theta )) , y_i)</script>

<p>where $d ( , )$ is a distance defined by a loss function. 
That is, it is the function in the hypothesis space that minimizes the “distance” with the target function, which connects the datapoints $x_i$ with their correspondent labels $y_i$.</p>

<p>When using Neural Networks, the hypothesis space $\mathcal{H}$ is generated by the composition of functions, such that</p>

<script type="math/tex; mode=display">\mathcal{H} =  \left\{  \text{NN}(\cdot \, ; \Theta ) \; \bigg\vert  \text{NN}(\cdot ; \Theta ) = \phi \circ f_{\theta_L}^L \circ f_{\theta_{L-1}}^{L-1} \circ ... \circ f_{\theta_1}^1 (\cdot) \right\}</script>

<p>where $\Theta = { \theta_k }_{k=1}^{L}$ are the training weights of the network and $L$ the number of hidden layers.</p>

<h4 id="multilayer-perceptrons">Multilayer perceptrons</h4>

<p>In the case of the so-called multilayer perceptrons, the functions $f^k_{\theta_k}$ are constructed as</p>

<script type="math/tex; mode=display">f^k_{\theta_k} (\cdot) = \sigma (A^k  (\cdot) +  b^k)</script>

<p>being $A^k$ a matrix,$b^k$ a vector and $\sigma \in C^{0,1}(\mathbb{R})$ a fixed nondecreasing function.</p>

<p>Since we restrict to the case in which the number of neurons is constant through the layers, we have that $A^k \in \mathbb{R}^{d \times d}$ and $b^k \in \mathbb{R}^d$.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/multilayerdiagram.jpg" alt="Multilayer" /></p>

<h4 id="residual-neural-networks">Residual Neural Networks</h4>
<p>In the simple case of a Residual Neural Network (often referred to as ResNets) the functions $f_{\theta_k}^{k} (\cdot)$ are constructed as</p>

<script type="math/tex; mode=display">f_{\theta_k}^{k} (\cdot) = \mathbb{I} (\cdot) + \sigma (A^k  (\cdot) +  b^k)</script>

<p>where $\mathbb{I}$ is the identity function. The parameters $\sigma$, $A^k$ and $b^k$ are equivalent to those of the multilayer perceptrons.</p>

<p>It is sometimes convenient to numerically add a parameter $h$ to the residual block, such that</p>

<script type="math/tex; mode=display">f_{\theta_k}^{k} (\cdot) = \mathbb{I} (\cdot) + h  \, \sigma (A^k  (\cdot) +  b^k)</script>

<p>being $h \in \mathbb{R}$ a scalar.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/resnetsdiagram.jpg" alt="ResNet" /></p>

<h3 id="training-neural-networks">Training Neural Networks</h3>

<p>The aim is to find the weights ${ A, b }$ of every layer such that the final function represented by the Neural Network minimizes a given loss function.</p>

<p>The weights are initialized randomly, and the algorithms (i.e. gradient descent) are aimed at updating them, such that eventually the Neural Network represents a function  $\hat{F}$  such that $\hat{F} (x_i) \approx y_i \, \forall i$.</p>

<p><br /></p>

<h2 id="visualizing-deep-learning">Visualizing Deep Learning</h2>

<table style="width:100%">
  <tr>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/layertransformation0.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/layertransformation1.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/layertransformation2.gif" /></th>
  </tr>
  <tr>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/layertransformation3.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/layertransformation4.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/layertransformation5.gif" /></th>
  </tr>
</table>

<h3 id="classification">Classification</h3>

<p>When dealing with data classification, it is very useful to just assign a color / shape to every label, and so be able to visualize data in a lower-dimensional plot.</p>

<p>The aim of classification is to associate different classes to different regions of the initial space,
When using Neural Networks, the initial space $X$ is propagated by the Neural Network as $f ^L \circ  f^{L-1} \circ … \circ f^1 (X)$. 
Then the function $\phi$ would be the one in charge of associating different classes to different regions, but the functions $\phi$ are pretty simple (essentially linear separators)!</p>

<p>So, while it may be difficult to classificate the datapoints in the initial space $X$, the Neural Networks should make things simpler and just propagate the data so as to make it linearly separable (and we would see this in real action!).</p>

<h3 id="neural-networks-as-homeomorphisms">Neural Networks as homeomorphisms</h3>

<p><strong><em>Lemma 1.1</em></strong>
<em>A Neural Network represents a continuous function if each one of its blocks are continuous.</em></p>

<p><strong><em>Lemma 1.2</em></strong> 
<em>A Neural Network represents a bijection if each one of its blocks are bijective.</em></p>

<p>These come trivially from the fact that the composite of continuous functions is continuous, and that the composite of bijections is a bijection.</p>

<p><strong><em>Theorem 1</em></strong> <strong>(Sufficient condition for invertible ResNets [1]):</strong></p>

<p>Let $\hat{\mathcal{F}} \, : \, \mathbb{R}^{d} \rightarrow \mathbb{R}^{d}$ with $\hat{\mathcal{F}} (\cdot ) = ( L^{1}_{\theta} \, \circ … \circ \, L^{T}_{\theta}  )$ denote a <em>ResNet</em> with blocks defined by 
<script type="math/tex">L^{t} _{ \theta } = \mathbb{I} + h \cdot g_{\theta _t}</script></p>

<p>Then, the ResNet $\hat{\mathcal{F}}_{\theta}$ is invertible if</p>

<script type="math/tex; mode=display">% <![CDATA[
h \cdot \text{Lip} (g_{\theta_t}) < 1 \text{ for all } t = 1, ..., T %]]></script>

<p><strong><em>Proof</em></strong> 
Consider that each block of the <em>ResNet</em> is given by</p>

<script type="math/tex; mode=display">Z(x) =  x + h\cdot G(x)</script>

<p>where $x$ is the input of the block, and $G(x)$ given by the residual block.
That can be rewritten as</p>

<script type="math/tex; mode=display">x_{t+1} = x_t + g(x)</script>

<p>We can construct the inverse function of the block as</p>

<script type="math/tex; mode=display">x_t = x_{t+1} - g(x)</script>

<p>Which is not an explicit inverse, since $g(x)$ depends on $x$. Approximating the solution as an interation,</p>

<script type="math/tex; mode=display">x^{0}_{t}  \doteq x_{t+1} \quad \text{and} \quad x_t ^{k+1} \doteq x_{t+1} - g (x_{t}^{k})</script>

<p>where $\lim_{k \to \infty} x_t ^{k} = x_t$ if the iteration converges. 
Since $g(\cdot) : \mathbb{R}^{d} \to \mathbb{R}^{d}$ is an operator on a Banach space, due to the Banach fixed point theorem is it enough that $Lip(g) &lt; 1$, or equally that $Lip(h\cdot G) &lt;1$ for the iteration to converge, and so for the block of the <em>ResNet</em> to be invertible. [1]</p>

<p><strong><em>Comment:</em></strong> <em>In the limit $h \to 0$, and $G(x)$ Lipschitz, we have a trivial explicit expression of the inverse of the function represented by the ResNet.</em></p>

<p>Consider the <em>ResNet</em> as generated by the iteration of blocks</p>

<script type="math/tex; mode=display">Z(x) =  x + h\cdot G(x)</script>

<p>where $G(x)$ is generated by a residual block <a href=""></a>. We consider $G(x)$ Lipschitz.</p>

<p>Then,</p>

<script type="math/tex; mode=display">Z^{-1} (x) \equiv x - h\cdot G(x)</script>

<p>is an second order approximation of the inverse function of $Z$ in terms of $h$, since</p>

<script type="math/tex; mode=display">Z^{-1} (Z(x)) = Z^{-1}  (x + h\cdot G(x) ) =</script>

<script type="math/tex; mode=display">= x + h\cdot G(x) - h \cdot G(x + h \cdot G(x)) =</script>

<script type="math/tex; mode=display">= x + \mathcal{o}(h^2)</script>

<p>Indeed, if we express the residual blocks as</p>

<script type="math/tex; mode=display">x_{t+1} = x_{t} + h\cdot G(x_t)</script>

<p>the limit $h\to 0$ can be recasted as</p>

<script type="math/tex; mode=display">\lim_{h \to 0} \frac{x_{t+1}-x_{t}}{h} = \dot{x}_t = G(x_t)</script>

<p>and, since the discrete index $t$ becomes continuous in this limit, it is useful to express it as</p>

<script type="math/tex; mode=display">\dot{x}(t) = G(x(t), t)</script>

<p>where in this case we make explicit the dependence of $G$ on $t$, that was hidden in the previous notation.</p>

<p><br /></p>

<table style="width:100%">
  <tr>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/3dmultilayer_.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/3dmultilayer_spiral.gif" /></th>
  </tr>
</table>

<h2 id="setup">Setup</h2>

<p>Consider a binary classification problem with noisless data, such that</p>

<script type="math/tex; mode=display">\mathcal{D} =  \{ ( x_i , y_i = \mathcal{F}(x_i) )\} _{i=1}^{S}</script>

<script type="math/tex; mode=display">x_i \in [-1,+1]^{n} , \; \; y_i \in \{0,1\} \quad \forall i \in \{1, ... , S\}</script>

<table style="width:100%">
  <tr>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/2dbending0.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/2dbending1.gif" /></th>
  </tr>
  <tr>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/2dbending2.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/2dbending3.gif" /></th>
  </tr>
</table>

<p><br /></p>

<table style="width:100%">
  <tr>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/2dbendingspiral0.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/2dbendingspiral1.gif" /></th>
  </tr>
  <tr>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/2dbendingspiral2.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/2dbendingspiral3.gif" /></th>
  </tr>
</table>

<p><br /></p>

<table style="width:100%">
  <tr>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/3dbendingspiral2.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/3dbendingspiral3.gif" /></th>
  </tr>
</table>

<p><br /></p>

<table style="width:100%">
  <tr>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/bending0.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/bending1.gif" /></th>
  </tr>
  <tr>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/bending2.gif" /></th>
    <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/bending3.gif" /></th>
  </tr>
</table>

<p><br /></p>

<h2 id="open-questions-issues-and-perspectives">Open questions, issues and perspectives</h2>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0011/NoisyRing.gif" alt="NoisyDistribution" /></p>

<h2 id="references">References</h2>

<p>[1] J. Behrmann, W. Grathwohl, R. T. Q. Chen, D. Duvenaud, J. Jacobsen (2018). <i> Invertible Residual Networks</i> <a href="https://arxiv.org/abs/1811.00995">pdf</a></p>

<p>[2] Weinan E, Jiequn Han, Qianxiao Li, (2018). <i> A Mean-Field Optimal Control Formulation of Deep Learning</i>. volume 6. Research in the Mathematical Sciences<a href="https://doi.org/10.1007/s40687-018-0172-y">pdf</a></p>

<p>[3] S. Shalev-Shwartz, S. Ben-David, <i> The Understanding Machine Learning: From Theory to Algorithms </i>. <a href="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/">pdf</a></p>

<p>[4] B. Hanin, (2018). <i> Which Neural Net Architectures Give Rise to Exploding and Vanishing Gradients? </i>  <a href="https://arxiv.org/abs/1801.03744">pdf</a></p>

<p>[5] C. Olah, <i> Neural Networks, Manifolds and Topology </i>. <a href="https://colah.github.io/posts/2014-03-NN-Manifolds-Topology/">blog post</a></p>

<p>[6] G. Naitzat, A. Zhitnikov, L-H. Lim, (2020). <i> Topology of Deep Neural Networks </i> <a href="https://arxiv.org/abs/2004.06093">pdf</a></p>

<p>[7] Q. Li, T. Lin, Z. Shen, (2019). <i> Deep Learning via Dynamical Systems: An Approximation Perspective </i><a href="https://arxiv.org/abs/1912.10382">pdf</a></p>

<p>[8] B. Geshkovski, <i> The interplay of control and deep learning </i>. <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp01/P0010">blog post</a></p>

<p>[9] C. Fefferman, S. Mitter, H. Narayanan, <i> Testing the manifold hypothesis </i>. <a href="http://www.mit.edu/~mitter/publications/121_Testing_Manifold.pdf">pdf</a></p>

<p>[10] R. T. Q. Chen, Y. Rubanova, J. Bettencourt, D. Duvenaud, (2018). <i> Neural Ordinary Differential Equations </i> <a href="https://arxiv.org/abs/1806.07366">pdf</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;!-- Consideraremos el problema de clasificación MNIST --&gt;
</code></pre>
</div>
<h4>MNIST dataset</h4>
<p>Consideramos el problema de clasificación MNIST. Este problema tiene  datos de entrada tal que $x \in \mathcal{M}_{28 \times 28}(\mathbb{R})$ y datos de salida  tal que $y \in  \mathbb{R}^{10}$. Los elementos de la base canónica de $\mathbb{R}^{10}$, $ \{e_1,e_2,\dots,e_{10}\} $, representa el conjunto de dígitos $ \{0,1,2,\dots,8,9 \}$ en ese orden.</p>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0005/ex.png" width="75%" /></p>
<center><b>Figura 1.</b> Distintos datos de entrada $x \in \mathcal{M}_{28 \times 28}(\mathbb{R})$ y sus correspondientes datos de salida $y \in  \mathbb{R}^{10}$ en la parte superior de cada una.   </center>

<h4>2. Modelo</h4>
<p>Buscamos una función $f_{\Omega}: \mathcal{M}_{28 \times 28}(\mathbb{R}) \rightarrow \mathbb{R}^{10}$ que sea capaz de reproducir el comportamiento que vemos en los datos. Consideraremos el modelo $\color{red}{y} = f_\Omega (\color{green}{x})$ como:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{sys}
\color{red}{y} = \mathcal{P} z_T \leftarrow \begin{cases}z_{t+1} = z_{t} + dt \ \sigma(A_t z_t+ b_t) & t \in \{1,2,\dots,T\} \\
z_0 = A_0 \color{green}{x}
\end{cases}
\end{equation} %]]></script>

<p>Donde:</p>
<ol>
  <li>$\{z_t\}_{t=0}^{T} \in \mathbb{R}^n \ / \ n &lt; 28^2$.</li>
  <li>$\mathcal{P} \in \mathcal{M}_{n\times 10}$ es una matriz constante que proyecta el estado $z_t \in \mathbb{R}^n$ a $\mathbb{R}^{10}$</li>
  <li>Las variables $\Omega = \{ A_t,b_t\}_{t=0}^T$ pueden verse como variables de control del sistema (\ref{sys}).</li>
  <li>$A_0 \in \mathcal{M}_{28^2 \times n}(\mathbb{R})$ y $b_0 \in \mathbb{R}^{28^2}$; mientras que $ \{A_t\}_{t=1}^{N} \in \mathcal{M}_{n \times n}(\mathbb{R}) $ y los siguientes $b_t$ bias son $ \{b_t\}_{t=1}^N \in \mathbb{R}^n $</li>
</ol>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0005/arch.png" width="85%" /></p>
<center><b>Figura 2.</b> Arquitectura de la red </center>

<h4>3. Problema de Control</h4>
<p>Si llamamos $M$ al número total de datos de entrenamiento y considerando los datos de entrenamiento $\{ x_m,y_m\}_{m=1}^M$, podemos plantear el siguiente problema de control.</p>

<script type="math/tex; mode=display">\min_{\Omega} \Big[ \frac{1}{M}\sum_{m=1}^M\sum_{t=0}^T || \mathcal{P}z_t(x_m,\Omega) - y_m ||^2 + \beta || \Omega||^2 \Big] \\
suject \ to: (\ref{sys})</script>

<h4>4. Resultados numéricos</h4>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0005/solex.png" width="85%" /></p>
<center><b>Figura 3.</b> Comportamiento de la proyección $\mathcal{P}z_t$ para un dado de entrada concreto. </center>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0005/Proj.png" width="75%" /></p>
<center><b>Figura 4.</b> Evolución  $||\mathcal{P}z_t||_{L^2}^2$ para los distintos datos de entrada $x$ </center>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h2 id="reinforcement-learning"&gt;Reinforcement Learning&lt;/h2&gt;
</code></pre>
</div>

<p><strong>Reinforcement Learning</strong> (RL) is, together with Supervised Learning and Unsupervised Learning, one of the three fundamental learning paradigms in Machine Learning. The goal in RL is to enhance the manipulation of a controlled system by using data from past experiments. It differs from supervised learning and unsupervised learning because the algorithms are not trained with a fixed sampled dataset. Rather, they learn through trial and error.</p>

<p>In a generic RL problem, an <strong>agent</strong>, or decision maker, interacts with an unknown <strong>environment</strong> which is influenced and evolves according to the <strong>controls</strong>, or actions, that are chosen by the agent. The control chosen in each situation is then evaluated by means of a <strong>reward</strong> signal. Based on the experience acquired in previous trials, the algorithm has to learn what actions are better in each situation, in the sense that the accumulated long-time reward is maximized.</p>

<h3 id="an-optimal-control-problem">An optimal control problem</h3>

<p>From a mathematical viewpoint, we can see RL as an optimal control problem. The environment is described through a dynamical system of the form</p>

<script type="math/tex; mode=display">% <![CDATA[
\tag{1}
\left\{ \begin{array}{ll}
x_{t+1} =  f(x_t,u_t) & t= 0,1,2,\ldots \\
x_0 = x
\end{array}
\right. %]]></script>

<p>At each time-step, $x_t$ represents the state of the environment, which evolves according to the function $f: \mathbb{R}^n\times \mathcal{U} \to \mathbb{R}^n$. This function might be unknown by the agent, and depends on the current state $x_t$ and the control $u_t$ chosen by the agent. This choice is then evaluated by a reward $r_t = r(x_t,u_t)$.</p>

<p>The reward function $r: \mathbb{R}^n\times \mathcal{U}\to \mathbb{R}$ has to be designed in such a way that the <em>desired</em> behavior of the system is stimulated by providing greater rewards. It is important to note that the choice of $u_t$ not only affects the reward $r_t$. It also affects the future rewards as they will depend on future states of the system. The goal in RL is not to maximize the reward $r_t$ at each time-step, but rather to maximize the reward accumulated during a certain interval of time.</p>

<p>The optimal control problem that we are considering consists in maximizing, over the control strategy, the rewards accumulated during a process of infinite length</p>

<script type="math/tex; mode=display">\tag{2}
\max_{\{u_t\}_t} \sum_{t=0}^\infty \gamma^t r(x_t,u_t) \qquad \text{subject to (1)}.</script>

<p>The parameter $\gamma \in (0,1)$ is called a discount factor, and ensures that the sum of rewards over the time-steps is finite. This is the so-called discounted <em>infinite-horizon</em> problem. In many applications, the introduction of the discount factor is also motivated by the fact that the rewards obtained in the near future are considered to be more important than those obtained with a bigger delay.</p>

<p>It is to be pointed out that this general setting is not exhaustive, and other classes of optimal control problems can be considered in the application of RL techniques. For example, it is typical to consider stochastic dynamics,  which is very suitable when the environment is considered to be unknown, or is subject to changes that we cannot control. The reward functional (2) can also have a different form (finite-time horizon, terminal reward, no discount factor,…). Although the discrete-time setting is the most common in RL, continuous-time problems can also considered.</p>

<h3 id="the-value-function">The value function</h3>

<p>The probably most important element in Reinforcement Learning is the <strong>optimal value function</strong>, defined as</p>

<script type="math/tex; mode=display">V^\ast (x) := \max_{\{u_t\}_t} \left\{ \sum_{t=0}^\infty \gamma^t r(x_t,u_t); \quad \text{s.t. (1) with $x_0 = x$} \right\}</script>

<p>It represents the best total reward that one can expect if the initial state is $x$. The value function satisfies the following Dynamic Programming Principle, also known as Bellman equation.</p>

<script type="math/tex; mode=display">V^\ast (x) = \max_{u\in \mathcal{U}} \left\{ r(x,u) + \gamma V^\ast (f(x,u)) \right\}</script>

<p>It allows the design of an optimal control in a feedback form.</p>

<script type="math/tex; mode=display">\tag{3}
u^\ast (x) = \text{argmax}_{u\in \mathcal{U}} \left\{ r(x,u) + \gamma V^\ast (f(x,u)) \right\}</script>

<h3 id="the-q-function">The $Q$-function</h3>

<p>In view of (3), we can construct a nearly optimal feedback control by approximating the value function $V^\ast$. But even if we were able to exactly compute the value function, the feedback law given in (3) makes use of the dynamics $f$. This means that the choice of the optimal control at a given state relies on the possibility of making predictions of what will be the next state, and as we mentioned, it is not in general the case in RL.</p>

<p>Therefore, rather than approximating the value function, we may concentrate our efforts on approximating the $Q$-function, defined as</p>

<script type="math/tex; mode=display">Q(x,u) := r(x,u) + \gamma V^\ast (f(x,u))</script>

<p>It represents the best total reward that we can expect if the initial state is $x$ and the first control taken is $u$.</p>

<p>Observe that the optimal value function $V^\ast(x)$ determines how <em>good</em> is to be at a certain state $x$, whereas the function $Q(x,u)$ determines the <em>quality</em> of choosing $u$ given that the current state is $x$.</p>

<p>The $Q$-function allows the design of an optimal feedback control without using the dynamics $f$.</p>

<script type="math/tex; mode=display">u^\ast (x) = \text{argmax}_{u\in \mathcal{U}} Q(x,u)</script>

<p>Using the identity $V^\ast (x) = \max_{u\in \mathcal{U}} Q(x,u)$, we can deduce the Bellman equation for the $Q$-function.</p>

<script type="math/tex; mode=display">\tag{4}
Q(x,u) = r(x,u) + \gamma \max_{u\in \mathcal{U}} Q(x,u)</script>

<h2 id="q-learning">$Q$-learning</h2>

<p><strong>$Q$-learning</strong> is a RL algorithm, introduced by Watkins in 1989, that seeks to approximate the $Q$-function by exploring the state-control space $\mathbb{R}^n\times \mathcal{U}$. The exploration is made by running experiments of finite time-steps considering a randomized initial state. At each step, the approximation of the $Q$-function is improved by using the Dynamic Programming equation (4). During the learning process, an $\varepsilon$-greedy policy with respect to the current approximation of $Q$ is used. This policy ensures the exploration of the whole state-control space at the same time that it exploits the information obtained in previous experiments to enhance the approximation of $Q$ in regions that seem to be better in terms of total reward.</p>

<p>These are the main steps in the $Q$-learning algorithm.</p>
<ol>
  <li>Initialize an arbitrary $Q$-function, $\widehat{Q}_0(x,u)$.</li>
  <li>Run a number $N$ of experiments (episodes) of $T$ steps each one.</li>
  <li>In total there will be $N\, T$ number of steps.</li>
  <li><strong>$\varepsilon$-greedy policy:</strong></li>
</ol>

<script type="math/tex; mode=display">u_t = \max_{u\in\mathcal{U}}  \widehat{Q}_k(x_t,\, u)\quad \text{with probability $1-\varepsilon$}</script>

<p>and $u_k$ is chosen randomly with probability $\varepsilon$ (exploration vs exploitation).</p>

<ol>
  <li><strong>Improvement of $\widehat{Q}(x_t, u_t)$:</strong> after each time-step, we use the observed $(x_{t+1}, r_t)$ to improve the approximation of $Q(x_t,u_t)$ in the following way</li>
</ol>

<script type="math/tex; mode=display">\widehat{Q}_{k+1} (x_t,u_t) = (1-\alpha) \widehat{Q}_k(x_t,u_t) + \alpha \big(  r_t + \gamma \max_{u\in\mathcal{U}} \widehat{Q}_k(x_{t+1}, u) \big)</script>

<p>here, $\alpha&gt;0$ is called the learning rate.</p>

<center>
<table>
<tr>
<th> 
 <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/DP00/P0004/QlearningScheme.png" height="200" width="550" /> 
</th>
</tr>
<tr>
<th style="text-align:center"> Figure 1.</th>
</tr>
</table>
</center>

<h2 id="example">Example</h2>

<p>We illustrate the $Q$-learning algorithm through a simple example. In a given two-dimensional discrete domain, we consider the problem of finding the shortest path between any position of the domain and a prescribed target area.</p>

<p>Let us first define the environment. We consider a discretized rectangular domain:</p>

<script type="math/tex; mode=display">\Omega := \{ 1,2,3, \ldots, 40 \}^2</script>

<p>We want to find the shortest path between any starting position in the domain and the top center of the domain, white area in the video below. The position can be moved, at each time-step, one unit up, down, right or left, i.e. the underlying dynamics are given by</p>

<script type="math/tex; mode=display">\left\{ \begin{array}{l}
x_{t+1} = x_t + u_t \quad t = 0,1,2, \ldots ,\tau \\
x_0 = x
\end{array} \right.</script>

<p>where $\tau$ is the first time the state reaches the limits of the domain. The experiment is considered a success if the terminal position is in the target area, and a defeat otherwise. The possible controls are</p>

<script type="math/tex; mode=display">\mathcal{U}:= \{ (0,1), -(0,1), (1,0), -(1,0)  \}</script>

<p>We denote by $\partial \Omega$ the limits of the domain (blue squares in the video), i.e.</p>

<script type="math/tex; mode=display">\partial \Omega := \{ (i,j) \in \Omega\, ;  \text{with} \ \{ i, j\} \cap \{1,40\} \neq \emptyset \}</script>

<p>We denote by $\mathcal{T}$ the target area (white squares)</p>

<script type="math/tex; mode=display">\mathcal{T} := \{ (1,j) \in \Omega\, ;  j\in [18,22] \}</script>

<p>Now we need to define a reward that makes the agent move the position from the initial one $x$ to the target area in the minimum number of steps, without reaching the limits of the domain.</p>

<script type="math/tex; mode=display">% <![CDATA[
r(x_t,u_t):= \left\{ \begin{array}{ll}
-1 & \text{if} \ x_t \in \Omega \\
100 & \text{if} \ x_t \in \mathcal{T} \\
-100 & \text{if} \ x_t \in \partial\Omega \setminus \mathcal{T}
\end{array} \right. %]]></script>

<p>Giving a negative reward when $x_t\in \Omega$ stimulates the agent to take the minimum possible number of steps until the target area.</p>

<p>Since the state-space $\Omega$ and the set of possible actions $\mathcal{U}$ are both finite. The $Q$-function can be represented by a table with $40\times 40$ rows and $4$ columns. The entries in this table can be learned from experiments using the $Q$-learning algorithm described above. Once we have a good approximation of $Q$, for a given position $x$, we can determine the best possible action by looking at the corresponding row in the table and taking the action corresponding to the minimum value in that row.</p>

<p>In the following video we see the obtained behavior after applying the $Q$-learning algorithm with 10000 experiments, with a discount factor $\gamma =0.9$, learning rate $\alpha =0.9$ and an $\varepsilon-$greedy policy with $\varepsilon = 0.9$.
The plot represents the evolution of the success rate with the number of experiments during the training.</p>

<center>
<table>
<tr>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0004/video1.gif" width="90%" /></th>
<th> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0004/training_evolution1.png" width="90%" /></th>
</tr>
<tr>
<th style="text-align:center"> Figure 2a.</th>
<th style="text-align:center">Figure 2b.</th>
</tr>
</table>
</center>

<p>We can change the environment by adding a potential that moves the position to the right when it is in a certain region (dark green area)</p>

<script type="math/tex; mode=display">P: = \{ (i,j)\in \Omega \, ; j\in [5,15]  \}</script>

<p>In the new environment, the agent do not know how to get to the target area.</p>

<p>In the following video, the agent uses the $Q$-function obtained in the original environment. However, the new dynamics are given by</p>

<script type="math/tex; mode=display">% <![CDATA[
x_{t+1} = \left\{ \begin{array}{ll}
x_t + u_t & \text{if} \ x_t\in \Omega\setminus P \\
x_t +3+ u_t & \text{if} \ x_t\in P
\end{array} \right. %]]></script>

<center>
<table>
<tr>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0004/video2.gif" width="60%" />
</tr>
<tr>
<th style="text-align:center"> Figure 3.</th>
</tr>
</table>
</center>

<p>After training the $Q$-function in the new environment, it learns how to deal with the potential to get to the target area. Observe that the success rate never reaches one. This is due to the fact that there is a region in the domain (the dark green area near the right-hand limit of the domain) from which it is impossible to reach the target.</p>

<center>
<table>
<tr>
<th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0004/video3.gif" width="90%" /></th>
<th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0004/training_evolution2.png" width="90%" /></th>
</tr>
<tr>
<th style="text-align:center"> Figure 4a.</th>
<th style="text-align:center">Figure 4b.</th>
</tr>
</table>
</center>

<p>We can also add obstacles in the domain, or even combine obstacles with a potential.</p>

<center>
<table>
<tr>
<th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0004/video4.gif" width="90%" /></th>
<th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0004/video5.gif" width="90%" /></th>
</tr>
<tr>
<th style="text-align:center"> Figure 5a.</th>
<th style="text-align:center">Figure 5b.</th>
</tr>
</table>
</center>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;This tutorial shows how to implement the moving control strategy for the heat equation in the presence of a memory term.&lt;/p&gt;
</code></pre>
</div>

<p>The standard null controllability problem for the heat equation reads as follows</p>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior}
\begin{equation}
\begin{cases}
\begin{matrix}
  u_t = \Delta u + f(x,t) \chi_{\omega} \ & \ x \in \Omega & t \in [0,T] \\
  u(x,t) = 0    & x \in \partial \Omega  &  t \in [0,T] \\
  u(x,0) = u_0  & x \in \Omega
\end{matrix}
\end{cases},
\end{equation} %]]></script>

<p>where $\Omega$ is a bounded domain, $u_0\in L^2(\Omega)$ and the control $f$ acts on the subdomain $\omega\subset\Omega$. The objective is to steer the system from $u_0$ to zero in time $T$,</p>

<p>It is known that the null controllability of the heat equation holds in any positive time $T&gt;0$ and for any open control region $\omega$. Nevertheless, the situation changes when in the model appears a memory term:</p>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior_memory}
\begin{equation}
\begin{cases}
\begin{matrix}
  \displaystyle u_t = \Delta u + f(x,t) \chi_{\omega} + \int_0^t u(x,\tau) d\tau \ & \ x \in \Omega & t \in [0,T] \\
  u(x,t) = 0    & x \in \partial \Omega  &  t \in [0,T] \\
  u(x,0) = u_0  & x \in \Omega
\end{matrix}
\end{cases}
\end{equation} %]]></script>

<p>As a matter of fact, when the equation involes a memory term, it is impossible to achive null controllability in the classical sense, unless the control region coincides with the entire domain ($\omega=\Omega$).</p>

<p>This fact can be easily seen when applying a LQR control on both systems (\ref{heatinterior}) and (\ref{heatinterior_memory}). In the former case (without memory) the minimum of the LQR functional is an optimal control stabilizing the dynamics (Video 1), whereas when the memory enters into the model this minimum leaves the system far from the equilibrium (Vdeo 2).</p>

<hr />

<table>
    <tr>
        <th>
          <center>
            <video controls="" width="90%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0011/LQR_InteriorPoint_Heat_Equation.mp4"> </video>
          </center> 
        </th>
        <th>
          <center>
            <video controls="" width="90%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0011/LQR_InteriorPoint_Heat_Equation_with_memory.mp4"> </video>
          </center> 
        </th>
    </tr>
    <tr>
        <th>
          <center>
              <b>Video 1:</b> LQR in the heat equation (Equation \ref{heatinterior})
          </center> 
        </th>
        <th>
          <center>
              <b>Video 2:</b>  LQR in the heat equation with memory (Equation \ref{heatinterior_memory})
          </center> 
        </th>
    </tr> 
    <tr>
        <td colspan="2">
          <center>
              We can see the time evolution of the two models with a control region, $\chi_{\omega}$, located in the position of the blue ellipsoid in the simulation. We observe that the LQR control is effective for the heat equation but not for the heat equation with memory.
          </center> 
        </td>
    </tr> 
</table>

<p>To understand the reason behind the lack of null controllability for the memory-type equation (\ref{heatinterior_memory}), we can introduce the new variable</p>

<script type="math/tex; mode=display">z(x,t) = \int_0^t u(x,\tau) d\tau \Rightarrow z_t(x,t) = u(x,t)</script>

<p>In this way, (\ref{heatinterior_memory}) is transformed into a coupled PDE/ODE system:</p>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior_memory_z}
\begin{equation}
\begin{cases}
\begin{matrix}
  u_t = \Delta u + f(x,t) \chi_{\omega} + z,  &     z_t = u        & x \in \Omega & t \in [0,T] \\
  u(x,t) = 0,                        &  z(x,t) = 0   & x \in \partial \Omega  &  t \in [0,T] \\
  u(x,0) = 0                      &  z(x,0) = 0   & x \in \Omega
  \end{matrix}
\end{cases}
\end{equation} %]]></script>

<p>In (\ref{heatinterior_memory_z}), the equation $z_t = u$ is an infinte-dimensional ODE which, since it has no diffusion term, introduces non-propagation phenomena in the system. The non propagating components corresponding to this ODE are unable to reach the control region $\omega$ and, therefore, cannot be controlled.</p>

<p>A natural remedy to this issue is to operate with a moving control strategy. If the ODE components of the system cannot reach the control region $\omega$, then is the control region who needs to reach these components. Hence, our control region would be  function of the time variable, $\omega = \omega(t)$, and the corresponding model will be</p>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior_memory_z_moving}
\begin{equation}
\begin{cases}
\begin{matrix}
  u_t = \Delta u + f(x,t) \chi_{\omega(t)} + z,  &     z_t = u        & x \in \Omega & t \in [0,T] \\
  u(x,t) = 0,                        &  z(x,t) = 0   & x \in \partial \Omega  &  t \in [0,T] \\
  u(x,0) = 0                      &  z(x,0) = 0   & x \in \Omega
  \end{matrix}
\end{cases}
\end{equation} %]]></script>

<p>This moving control strategy has been proposed and succesfully applied in several contributions of our team [1,2,3,4].</p>

<p>Memory-type equations are one of the core topics of WP5 of the DyCon ERC project. An abridged presentation of this working package can be found at the following <a href="https://cmc.deusto.eus/dycon-working-package-5-memory-and-hybrid-pdeode-models">link</a>.</p>

<h2 id="numerical-implementation-of-the-moving-control-strategy">Numerical implementation of the moving control strategy</h2>

<p>We present here the numerical implementation of the moving control strategy for the memory-type heat equation (\ref{heatinterior_memory_z_moving}). All the simulations will be in $2D$.</p>

<h3 id="step-1-construction-of-the-control-region">STEP 1: construction of the control region</h3>

<p>The first step is to construct the moving control region $\omega(t)$, which requires to design the function $\chi_{\omega(t)}$. To this end, we made the assumption that the size and orientation of $\omega(t)$ do not change during the time interval $[0,T]$. Hence, once fixed the size and shape of the control region, we will obtain a function depending only on a point $x\in \Omega$.</p>

<p>In this simulation, we create the control region as a square which moves in the domain $\Omega$. This square can be constructed with a function $W(x)$ defined as</p>

<script type="math/tex; mode=display">W(x,a,b) = H(x-a) + H(x-b) \\  \{ a,b,x  \}\in \mathbb{R}, \quad a>b \\</script>

<p>where $H(x)$ is the Heaviside function. Nevertheless, the function $W$ constructed in this way would be non-differentialbe at the points $x=a$ and $x=b$. This would represent a problem when implementing the gradient method to compute the control. To bypass this issue, in the definition of $W(x,a,b)$ we will use a smooth approximation of $H$ (See Figure 1).</p>

<table>
  <tr>
    <th>
      <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0011/WTHETA.png" width="65%" />
    </th>
  </tr>
  <tr>
    <th>
      <center><b>Figure 1</b>: Graphicla representation of $W(x,a,b)$</center>
    </th>
  </tr>
</table>

<p>Moreover, the generalization of this function to dimension two is immediate</p>

<script type="math/tex; mode=display">W_{2D}(x,y,x_{min},x_{max},y_{min},y_{max}) = W(x,x_{min},x_{max})*W(x,y_{min},y_{max})</script>

<p>In this way, given $(x_{min}, x_{max}, y_{min}, y_{max})$, we obtain the corresponding characteristic function which only depends on the position of a single point.</p>

<h3 id="step-2-construction-of-the-dynamics">STEP 2: construction of the dynamics</h3>

<p>Since $\chi_{\omega}$ can move and, moreover, we want to obtain the optimal trajectory for the control, we will incorporate in our system a moving particle whose position and velocity are denoted by $\textbf{d} = (d_x,d_y)$ and $\textbf{v} = (v_x,v_y)$, respectively (Video 3).</p>

<table>
  <tr>
    <th>
      <video controls="" width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0011/BMatrix_Motion.mp4"> </video>
    </th>
  </tr>
  <tr>
    <th>
      <center><b>Video 3: Representación gráfica de</b>  $W_{2D}$</center>
    </th>
  </tr>
</table>

<p>Besides, we will add a control $\textbf{g}(t) = (g_x(t),g_y(t))$ which will act as an exterior force moving the subset $\chi_{\omega}$.</p>

<p>In this way, our model takes the final form</p>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior_memory_z_all}
\begin{equation}
\begin{cases}
\begin{matrix}
  u_t = \Delta u + f(x,t) \chi_{\omega(\textbf{d})} + z,  &     z_t = u        & x \in \Omega & t \in [0,T] \\
  u(x,t) = 0,                        &  z(x,t) = 0   & x \in \partial \Omega  &  t \in [0,T] \\
  u(x,0) = 0,                      &  z(x,0) = 0   & x \in \Omega \\
    \dot{\textbf{d}} = \textbf{v} & \textbf{d}(0) = \textbf{d}_0    & t \in [0,T]\\
  \dot{\textbf{v}} = \textbf{g}(t)  & \textbf{v}(0) = \textbf{v}_0  & t \in [0,T]\\
  \end{matrix}
\end{cases}
\end{equation} %]]></script>

<h3 id="step-3-optimal-control-problem">STEP 3: optimal control problem</h3>

<p>Following a standard optimal control strategy, the control function for our memory-type equation will be computed throught the minimization problem</p>

<script type="math/tex; mode=display">\min_{f(x,t),g(t)}  \|u(x,T)\|^2_{L^2(\Omega)} \\</script>

<script type="math/tex; mode=display">% <![CDATA[
\text{subject to: }\quad \begin{cases}
\begin{matrix}
  u_t = \Delta u + f(x,t) \chi_{\omega(\textbf{d})} + z,  &     z_t = u        & x \in \Omega & t \in [0,T] \\
  u(x,t) = 0,                        &  z(x,t) = 0   & x \in \partial \Omega  &  t \in [0,T] \\
  u(x,0) = 0,                      &  z(x,0) = 0   & x \in \Omega \\
    \dot{\textbf{d}} = \textbf{v} & \textbf{d}(0) = \textbf{d}_0    & t \in [0,T]\\
  \dot{\textbf{v}} = \textbf{g}(t)  & \textbf{v}(0) = \textbf{v}_0  & t \in [0,T]\\
  \end{matrix}
\end{cases} %]]></script>

<h2 id="simulations">Simulations</h2>

<p>All the simulations in this tutorial have been performed using the DyCon Toolbox and CasADi. Since CasADi is incorporated into the DyCon toolbox, we can install it in the following way:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">unzip</span><span class="p">(</span><span class="s1">'https://github.com/DeustoTech/DyCon-Computational-Platform/archive/master.zip'</span><span class="p">)</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="nb">cd</span><span class="p">,</span><span class="s1">'DyCon-toolbox-master'</span><span class="p">))</span>
<span class="n">StartDyconPlatform</span>
</code></pre>
</div>

<p>We shall now write the discrete version of equation (\ref{heatinterior_memory_z_all}):</p>

<script type="math/tex; mode=display">% <![CDATA[
\label{heatinterior_memory_z_all_discr}
\begin{equation}
\frac{d}{dt} \begin{bmatrix}\begin{array}{c|c}
\textbf{U} \\
\hline
\textbf{Z} \\
\hline
\textbf{D} \\
\hline
\textbf{V} \\
\end{array}
\end{bmatrix}
=
\begin{bmatrix}\begin{array}{c|c|c}
\mathcal{A} & \textbf{1} & \textbf{0} & \textbf{0} \\
\hline
\textbf{1} & \textbf{0}  & \textbf{0} & \textbf{0} \\
\hline
\textbf{0} & \textbf{0}  & \textbf{0} & \textbf{1} \\
\hline
\textbf{0} & \textbf{0}  & \textbf{0} & \textbf{0} \\
\end{array}
\end{bmatrix}
%%
\begin{bmatrix}\begin{array}{c|c}
\textbf{U} \\
\hline
\textbf{Z} \\
\hline
\textbf{D} \\
\hline
\textbf{V} \\
\end{array}
\end{bmatrix}
+
%%
\begin{bmatrix}\begin{array}{c|c}
\textbf{B}(\textbf{D})*\textbf{F}(t) \\
\hline
\textbf{0} \\
\hline
\textbf{0} \\
\hline
\textbf{G}(t) \\
\end{array}
\end{bmatrix}
\end{equation} %]]></script>

<p>Secondly, let us create the mesh variable</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">% Create the mesh variables</span>
<span class="nb">clear</span><span class="p">;</span>
<span class="n">Ns</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="n">xline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="p">);</span>
<span class="n">yline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="p">);</span>
<span class="p">[</span><span class="n">xms</span><span class="p">,</span><span class="n">yms</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">xline</span><span class="p">,</span><span class="n">yline</span><span class="p">);</span>
</code></pre>
</div>

<p>and the matrix $A$ containing the $2D$ Laplacian and the ODE dynamics</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">A</span>  <span class="o">=</span> <span class="n">FDLaplacial2D</span><span class="p">(</span><span class="n">xline</span><span class="p">,</span><span class="n">yline</span><span class="p">);</span>

<span class="n">Atotal</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
<span class="c1">%</span>
<span class="n">Atotal</span><span class="p">(</span> <span class="mi">1</span><span class="p">:</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span>  <span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span> <span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
<span class="c1">%</span>
<span class="n">Atotal</span><span class="p">(</span> <span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span>   <span class="p">,</span>   <span class="mi">1</span>    <span class="p">:</span>  <span class="n">Ns</span><span class="o">^</span><span class="mi">2</span>   <span class="p">)</span>  <span class="o">=</span>  <span class="nb">eye</span><span class="p">(</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Atotal</span><span class="p">(</span>    <span class="mi">1</span>   <span class="p">:</span>  <span class="n">Ns</span><span class="o">^</span><span class="mi">2</span>    <span class="p">,</span> <span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span>  <span class="p">)</span>  <span class="o">=</span>  <span class="mi">50</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span> <span class="c1">% z = 50*y</span>

<span class="n">RumbaMatrixDynamics</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="k">...</span>
                       <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="k">...</span>
                       <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="k">...</span>
                       <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="p">];</span>

<span class="n">Atotal</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">RumbaMatrixDynamics</span><span class="p">;</span>
<span class="n">Atotal</span> <span class="o">=</span> <span class="nb">sparse</span><span class="p">(</span><span class="n">Atotal</span><span class="p">);</span>
</code></pre>
</div>

<p>Finally, we create the function $B(\textbf{d}) = B(x_d,y_d)$ for the dynamics of the moving control</p>
<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%%</span>
<span class="c1">% We create the B() function</span>
<span class="n">xwidth</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
<span class="n">ywidth</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
<span class="n">B</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">xms</span><span class="p">,</span><span class="n">yms</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">)</span> <span class="n">WinWP05</span><span class="p">(</span><span class="n">xms</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">xwidth</span><span class="p">)</span><span class="o">.*</span><span class="n">WinWP05</span><span class="p">(</span><span class="n">yms</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">ywidth</span><span class="p">);</span>
<span class="n">Bmatrix</span> <span class="o">=</span>  <span class="o">@</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">)</span> <span class="p">[</span><span class="nb">diag</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="n">xms</span><span class="p">,</span><span class="n">yms</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span> <span class="p">;</span><span class="nb">zeros</span><span class="p">(</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="p">)];</span>
</code></pre>
</div>

<p>We now have everything we need to construct and solve the optimal control problem</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">opti</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Opti</span><span class="p">();</span>  <span class="c1">% CasADi optimization structure</span>

<span class="c1">% ---- Input variables ---------</span>
<span class="n">Ucas</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">% state trajectory</span>
<span class="n">Fcas</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">Ns</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">% control</span>

<span class="c1">% ---- Dynamic constraints --------</span>
<span class="n">dUdt</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="n">Atotal</span><span class="o">*</span><span class="n">u</span><span class="o">+</span> <span class="p">[</span><span class="n">Bmatrix</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="k">end</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span><span class="n">u</span><span class="p">(</span><span class="k">end</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">;</span> <span class="k">...</span>
                                         <span class="mi">0</span>                     <span class="p">;</span> <span class="k">...</span>
                                         <span class="mi">0</span>                     <span class="p">;</span> <span class="k">...</span>
                                     <span class="n">f</span><span class="p">(</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>                  <span class="p">;</span> <span class="k">...</span>
                                     <span class="n">f</span><span class="p">(</span><span class="k">end</span><span class="p">)</span>                    <span class="p">];</span> 

<span class="c1">% -----Euler backward method-------</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">% loop over control intervals</span>
   <span class="n">y_next</span> <span class="o">=</span> <span class="n">Ucas</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">T</span><span class="p">/</span><span class="n">Nt</span><span class="p">)</span><span class="o">*</span><span class="n">dUdt</span><span class="p">(</span><span class="n">Ucas</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">dUdt</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span> 
   <span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">Ucas</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">y_next</span><span class="p">);</span> <span class="c1">% close the gaps</span>
<span class="k">end</span>

<span class="c1">% ---- State constraints --------</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">Ucas</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="p">[</span><span class="n">Y0</span> <span class="p">;</span> <span class="mf">0.7</span> <span class="p">;</span> <span class="mf">0.7</span><span class="p">;</span> <span class="o">-</span><span class="mf">1.5</span> <span class="p">;</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">]);</span>

<span class="c1">% ---- Optimization objective  ----------</span>
<span class="n">Cost</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ucas</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">'*</span><span class="p">(</span><span class="n">Ucas</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>

<span class="n">opti</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">Cost</span><span class="p">);</span> <span class="c1">% minimizing L2 at the final time</span>

<span class="c1">% ---- initial guesses for solver ---</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">Ucas</span><span class="p">,</span> <span class="n">Unum_free</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">Fcas</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">% ---- solve NLP              ------</span>
<span class="n">p_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'expand'</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
<span class="n">s_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'acceptable_tol'</span><span class="p">,</span><span class="mf">1e-4</span><span class="p">,</span><span class="s1">'constr_viol_tol'</span><span class="p">,</span><span class="mf">1e-3</span><span class="p">,</span><span class="s1">'compl_inf_tol'</span><span class="p">,</span><span class="mf">1e-3</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="s1">'ipopt'</span><span class="p">,</span><span class="n">p_opts</span><span class="p">,</span><span class="n">s_opts</span><span class="p">);</span> <span class="c1">% set numerical backend</span>
<span class="nb">tic</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">solve</span><span class="p">();</span>   <span class="c1">% actual solve</span>
<span class="nb">toc</span>
</code></pre>
</div>

<p>The following video shows the results of our simulations, which allowed to compute an effective moving control steering the dynamics to rest at time $T$.</p>

<table>
<tr>
  <th>
    <center>
      <video controls="" width="90%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0011/MovilControl.mp4"> </video>
    </center>
  </th>
</tr>
<tr>
<th>
<center><b>Video 3</b></center>
</th>
</tr>
</table>

<h2 id="bibliography">Bibliography</h2>

<p>[1] U. Biccari and S. Micu, <em>Null-controllability properties of the wave equation with a second order memory term</em>, J. Differential Equations, 267(2), 2019, 1376-1422.</p>

<p>[2] U. Biccari and M. Warma, <em>Null-controllability properties of a fractional wave equation with a memory term</em>, Evol. Eq. Control The., 9(2), 2020, 399-430.</p>

<p>[3] F. W. Chaves-Silva, X. Zhang and E. Zuazua, <em>Controllability of evolution equations with memory</em>, SIAM J. Control Optim., 55(4), 2017, 2437–2459.</p>

<p>[4] Q. Lü, X. Zhang and E. Zuazua, <em>Null controllability for wave equations with memory</em>, J. Math. Pures Appl., 108 (4), 2017, 500-531.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;En este tutorial veremos como podemos implementar un problema de clasificación simple mediante la librería de control óptimo DyCon-Toolbox.&lt;/p&gt;
</code></pre>
</div>

<h2 id="generación-de-datos">Generación de datos</h2>

<p>Para resolver un problema de clasificación supervisada necesitamos datos de entrada ${ \vec{x}<em>{i} }</em>{i=1}^N$ y de salida ${ \vec{y}<em>{i} }</em>{i=1}^N$. Eso lo generaremos de manera sintéctica con las siguientes lineas de código</p>
<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clear</span><span class="p">;</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="n">xdata</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="n">ydata</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</code></pre>
</div>
<p>Podemos ver los datos generados</p>
<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="s1">'o-'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x-data'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'y-data'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Data'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'data.png'</span><span class="p">,</span><span class="s1">'-dpng'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0012/data.png" alt="" /></p>

<p>Ahora queremos una ecuación diferencial controlada para una variable $z(t)$ tal que cuando reciba una condición inicial $z(0) = x_i$ evolucione durante $t=1$, y devuelva $z(t)=y_i$, esto para $\forall i \in {1,\dots,N}$.</p>

<p>Es decir una ecuación diferencial, tal que</p>

<script type="math/tex; mode=display">\begin{gather*}
    \forall \{x_i,y_i\}
    \rightarrow
    \begin{cases}
        \dot{z(t)} = f(z(t),u(t)) \\
        z(0) = x_i \\
        z(1) = \mathcal{P} y_i 
    \end{cases}
\end{gather*}</script>

<p>Donde $\mathcal{P}$ es una proyección del 
Es decir es una</p>
<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">sigma</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="nb">tanh</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="c1">%% Dynamic definition</span>
<span class="nb">import</span> <span class="n">casadi</span><span class="o">.*</span>
<span class="n">As</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,[</span><span class="mi">2</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">bs</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'b'</span><span class="p">,[</span><span class="mi">2</span> <span class="mi">1</span><span class="p">]);</span>
<span class="n">zs</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'z'</span><span class="p">,[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span> <span class="mi">1</span><span class="p">]);</span>
<span class="c1">% Create a Big matrices</span>
<span class="n">Afull</span> <span class="o">=</span>  <span class="n">SX</span><span class="o">.</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">);</span>
<span class="k">for</span> <span class="nb">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
   <span class="n">ind</span> <span class="o">=</span> <span class="p">((</span><span class="nb">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">):(</span><span class="nb">i</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
   <span class="n">Afull</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span> <span class="o">=</span> <span class="n">As</span><span class="p">;</span> 
<span class="k">end</span>
<span class="c1">%</span>
<span class="n">bfull</span> <span class="o">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">% sym time</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'t'</span><span class="p">);</span>
<span class="c1">% this is the control</span>
<span class="n">us</span> <span class="o">=</span> <span class="p">[</span><span class="n">As</span><span class="p">(:);</span><span class="n">bs</span><span class="p">];</span>
<span class="c1">% define the dynamic equation</span>
<span class="n">Fs</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'F'</span><span class="p">,{</span><span class="n">ts</span><span class="p">,</span><span class="n">zs</span><span class="p">,</span><span class="n">us</span><span class="p">},{</span><span class="n">Afull</span><span class="o">*</span><span class="n">sigma</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span> <span class="o">+</span> <span class="n">bfull</span><span class="p">});</span>
</code></pre>
</div>
<p>Creamos el objeto <code class="highlighter-rouge">ode</code></p>
<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Nt</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="n">tspan</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="c1">%</span>
<span class="n">idyn</span> <span class="o">=</span> <span class="n">ode</span><span class="p">(</span><span class="n">Fs</span><span class="p">,</span><span class="n">zs</span><span class="p">,</span><span class="n">us</span><span class="p">,</span><span class="n">tspan</span><span class="p">);</span> <span class="c1">% &lt;- idyn is a ode object of DyCon Toolbox</span>
<span class="n">SetIntegrator</span><span class="p">(</span><span class="n">idyn</span><span class="p">,</span><span class="s1">'RK4'</span><span class="p">)</span> <span class="c1">% &lt;- For solve you need choose a numerical squeme</span>
<span class="c1">% initial condition</span>
<span class="n">z0</span>          <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">z0</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="o">=</span> <span class="n">xdata</span><span class="o">'</span><span class="p">;</span>
<span class="c1">% put in idyn object </span>
<span class="n">idyn</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="n">z0</span><span class="p">;</span>
</code></pre>
</div>
<h2 id="optimal-control-definition">Optimal Control Definition</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">% no optimize P</span>
<span class="n">Pfull</span> <span class="o">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Pzminusy</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="nb">reshape</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">ydata</span><span class="p">;</span> <span class="c1">% &lt;-- (P*z_i - y_i)</span>
<span class="n">L</span>   <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'L'</span><span class="p">,</span>  <span class="p">{</span><span class="n">ts</span><span class="p">,</span><span class="n">zs</span><span class="p">,</span><span class="n">us</span><span class="p">},{</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">As</span><span class="o">.^</span><span class="mi">2</span><span class="p">))</span>  <span class="o">+</span> <span class="n">bs</span><span class="o">'*</span><span class="n">bs</span>  <span class="p">});</span>
<span class="n">Psi</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'Psi'</span><span class="p">,{</span><span class="n">zs</span><span class="p">}</span>      <span class="p">,{</span> <span class="mf">1e5</span><span class="o">*</span><span class="p">(</span><span class="n">Pzminusy</span><span class="o">*</span><span class="n">Pzminusy</span><span class="o">'</span><span class="p">)</span> <span class="p">});</span>
<span class="c1">%</span>
<span class="n">iocp</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">(</span><span class="n">idyn</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">Psi</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="solve">Solve</h2>
<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">Uopt</span><span class="p">,</span><span class="n">Zopt</span><span class="p">]</span> <span class="o">=</span> <span class="n">IpoptSolver</span><span class="p">(</span><span class="n">iocp</span><span class="p">,</span><span class="n">ZerosControl</span><span class="p">(</span><span class="n">idyn</span><span class="p">));</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% Plot</span>
<span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">clf</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">l1</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">tspan</span><span class="p">,</span><span class="n">Zopt</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,:)</span><span class="s1">','</span><span class="n">b</span><span class="o">'</span><span class="p">);</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">l2</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">tspan</span><span class="p">,</span><span class="n">Zopt</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,:)</span><span class="s1">','</span><span class="n">r</span><span class="o">'</span><span class="p">);</span>
<span class="nb">legend</span><span class="p">([</span><span class="n">l1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">l2</span><span class="p">(</span><span class="mi">1</span><span class="p">)],{</span><span class="s1">'z_i^1(t)'</span><span class="p">,</span><span class="s1">'z_i^2(t)'</span><span class="p">},</span><span class="s1">'Location'</span><span class="p">,</span><span class="s1">'bestoutside'</span><span class="p">)</span>

<span class="nb">title</span><span class="p">(</span><span class="s1">'Optimal State'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'z_i(t)'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">)</span>

<span class="nb">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">tspan</span><span class="p">,</span><span class="n">Uopt</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,:)</span><span class="o">'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Optimal Control - A(t)'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">({</span><span class="s1">'A_1'</span><span class="p">,</span><span class="s1">'A_2'</span><span class="p">,</span><span class="s1">'A_3'</span><span class="p">,</span><span class="s1">'A_4'</span><span class="p">},</span><span class="s1">'Location'</span><span class="p">,</span><span class="s1">'bestoutside'</span><span class="p">)</span>

<span class="nb">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">tspan</span><span class="p">,</span><span class="n">Uopt</span><span class="p">(</span><span class="mi">5</span><span class="p">:</span><span class="k">end</span><span class="p">,:)</span><span class="o">'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Optimal Control - b(t)'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">({</span><span class="s1">'b_1'</span><span class="p">,</span><span class="s1">'b_2'</span><span class="p">},</span><span class="s1">'Location'</span><span class="p">,</span><span class="s1">'bestoutside'</span><span class="p">)</span>
</code></pre>
</div>
<p>Animation</p>
<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">fig</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>

<span class="nb">xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span> <span class="mi">5</span><span class="p">])</span>

<span class="nb">ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span> <span class="mi">5</span><span class="p">])</span>
<span class="k">for</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="k">if</span> <span class="n">ydata</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">color</span> <span class="o">=</span> <span class="s1">'r'</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">color</span> <span class="o">=</span> <span class="s1">'b'</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">ilines</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">Zopt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">Zopt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'Color'</span><span class="p">,</span><span class="n">color</span><span class="p">,</span><span class="s1">'Marker'</span><span class="p">,</span><span class="s1">'.'</span><span class="p">,</span><span class="s1">'MarkerSize'</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">jlines</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">Zopt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">Zopt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'Color'</span><span class="p">,</span><span class="n">color</span><span class="p">,</span><span class="s1">'Marker'</span><span class="p">,</span><span class="s1">'none'</span><span class="p">,</span><span class="s1">'MarkerSize'</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>

<span class="k">end</span>
<span class="c1">% </span>
<span class="k">for</span> <span class="n">it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">tspan</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="n">ilines</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="o">.</span><span class="n">XData</span> <span class="o">=</span> <span class="n">Zopt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">it</span><span class="p">);</span>
    <span class="n">ilines</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="o">.</span><span class="n">YData</span> <span class="o">=</span> <span class="n">Zopt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">it</span><span class="p">);</span>
    <span class="n">jlines</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="o">.</span><span class="n">XData</span> <span class="o">=</span> <span class="n">Zopt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">it</span><span class="p">);</span>
    <span class="n">jlines</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="o">.</span><span class="n">YData</span> <span class="o">=</span> <span class="n">Zopt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">it</span><span class="p">);</span>
   <span class="k">end</span>
    <span class="nb">pause</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h2 id="what-is-a-simultaneous-control-problem"&gt;What is a simultaneous control problem?&lt;/h2&gt;
</code></pre>
</div>

<p>Consider the following parameter-dependent linear control system</p>

<script type="math/tex; mode=display">% <![CDATA[
\left\{\begin{array}{ll}
\displaystyle x'_\nu(t) = \mathbf{A}_\nu x_\nu(t)+\mathbf{B} u(t), & 0<t<T,
\\[10pt]
x_\nu(0) = x^0,
\end{array}\right.\quad (1) %]]></script>

<p>with</p>

<script type="math/tex; mode=display">% <![CDATA[
\mathbf{A}_\nu=\left(\begin{array}{cccccc}
0 & 1 & 0 & \ldots & \ldots & 0
\\
0 & 0 & 1 & 0 & \ldots & 0
\\
\vdots & & & \ddots & \ddots & \vdots
\\
0 & \ldots & \ldots & \ldots & 1 & 0
\\
-\nu & 0 & \ldots & \ldots & \ldots & 0
\end{array}\right)\in \mathbb{R}^{N\times N}, \quad \mathbf{B} = \left(\begin{array}{c} 1 \\ 1 \\ \vdots \\ \vdots \\ 1\end{array}\right)\in \mathbb{R}^{N}. \quad(2) %]]></script>

<p>The matrix $\mathbf{A}_\nu$ is associated with the Brunovsky canonical form of the linear ODE</p>

<script type="math/tex; mode=display">x^{(N)}_\nu(t) + \nu x_\nu(t) = 0,</script>

<p>where $x^{(N)}_\nu(t)$ denotes the $N$-th derivative of the function $x(t)$.</p>

<p>In (1)-(2), $x_\nu(t)\in L^2(0,T;\mathbf{R}^N)$, $N\geq 1$, denotes the state, the $N\times N$ matrix $\mathbf{A}_\nu$ describes the dynamics, and the function $u(t)\in L^2(0,T;\mathbb{R}^M)$, $1\leq M\leq N$, is the $M$-component control acting on the system through the $N\times M$ matrix $\mathbf{B}$. Here 
<script type="math/tex">\nu\in \{ \nu_1,\nu_2,\ldots,\nu_{|\mathcal K|} \}=:\mathcal K</script>
 is a random parameter following a probability law $\mu$, with $(\mathcal K,\mathcal F,\mu)$ the corresponding complete probability space.</p>

<p>With <strong>simultaneous controllability</strong> we refer to the problem of designing a unique parameter-independent control function capable to steer all the different realizations of (1) to some prescribed final target in time $T$, that is (see <strong>Figure 1</strong> and <strong>Figure 2</strong>):</p>

<script type="math/tex; mode=display">x_\nu(T)=x^T\in\mathbb{R}^N, \quad \nu\in \mathcal{K} \;\;\;\;\mu-\text{a. e.}</script>

<p><img width="90%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0011/stateEvolution.png" /></p>

<center><b>Figure 1</b>: evolution of the free (left) and controlled (right) dynamics of (1)-(2) with $N=4$.</center>

<p><img width="70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0011/control.png" /></p>

<center><b>Figure 2</b>: parameter-independent control function.</center>

<h2 id="how-can-we-solve-a-simultaneous-controllability-problem">How can we solve a simultaneous controllability problem?</h2>

<p>The computation of a simultaneous control for (1)-(2) can be carried out through a standard optimal control methodology by solving the following minimization problem</p>

<script type="math/tex; mode=display">\begin{array}{l}
\displaystyle\widehat{u}=\min_{u\in L^2(0,T;\mathbb{R}^M)} F_{\nu}(u)
\\[10pt]
\displaystyle F_{\nu}(u):= \frac{1}{2} \mathbb{E}\left[\|x_\nu(T)-x^T\|_{\mathbb{R}^N}^2\right]+\frac{\beta}{2}\|u\|_{L^2(0,T;\mathbb{R}^M)}^2,
\end{array} \quad (3)</script>

<p>subject to the dynamics given by (1)-(2). Here $\mathbb{E}[\cdot]$ denotes the expectation operator.</p>

<p>Typical approaches to solve the optimization problem (3) are (see [3]):</p>

<ul>
  <li>The <strong>Gradient Descent (GD)</strong> algorithm: we find the minimizer $\widehat{u}$ as the limit $k\to +\infty$ of the following iterative process</li>
</ul>

<script type="math/tex; mode=display">\textbf{GD:} \quad u^{k+1} = u^k-\eta_k \left(\beta u^k - \frac{1}{|\mathcal K|}\sum_{\nu\in\mathcal K}\mathbf{B}^\top p_\nu^k\right),</script>

<p>where for all $\nu\in\mathcal K$ the pair $(x_\nu,p_\nu)$ solves the coupled system</p>

<script type="math/tex; mode=display">% <![CDATA[
\left\{\begin{array}{ll}
\displaystyle x'_\nu(t) = \mathbf{A}_\nu x_\nu(t)+\mathbf{B}u, & 0<t<T,
\\[6pt]
\displaystyle  p'_\nu(t) = -\mathbf{A}_\nu^\top p_\nu(t), & 0<t<T,
\\[6pt]
\displaystyle  x_\nu(0) = x^0, \quad p_\nu(T) = -(x_\nu(T)-x^T).
\end{array}\right. \quad(4) %]]></script>

<ul>
  <li>The <strong>Conjugate Gradient (CG)</strong> algorithm: the gradient $\nabla F_\nu$ is rewritten in the form</li>
</ul>

<script type="math/tex; mode=display">\displaystyle\nabla F_\nu(u) = \underbrace{(\beta I + \mathbb{E}[\mathcal L_{T,\nu}^\ast\mathcal L_{T,\nu}])}_{\mathbb{A}}u + \underbrace{\mathbb{E}[\mathcal L_{T,\nu}^\ast(y_\nu(T)-x^T)]}_{-b},</script>

<p>where the operators $\mathcal L_{T,\nu}$ and $\mathcal L_{T,\nu}^\ast$ are defined as</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{cccc}
\mathcal L_{T,\nu}: & U &\longrightarrow &\mathbb{R}^N
\\
& u & \longmapsto & z_\nu(T)
\end{array}, \quad \quad \quad
\begin{array}{cccc}
\mathcal L_{T,\nu}^\ast: & \mathbb{R}^N &\longrightarrow & U
\\
& p_{T,\nu} & \longmapsto & \mathbf{B}^\top p_\nu,
\end{array} %]]></script>

<p>with $U:=L^2(0,T;\mathbb{R}^M)$ and</p>

<script type="math/tex; mode=display">% <![CDATA[
\left\{\begin{array}{ll}
y'_\nu(t) = \mathbf{A}_\nu y_\nu(t), & 0<t<T,
\\[10pt]
y_\nu(0) = x_0
\end{array}\right. \quad
\begin{cases}
z'_\nu(t) = \mathbf{A}_\nu z_\nu(t) +\mathbf{B} u(t), & 0<t<T,
\\[10pt]
z_\nu(0) = 0.
\end{cases} %]]></script>

<p>We then use the conjugate gradient algorithm to solve the linear system $\mathbb{A}u = b$.</p>

<p>These two procedures are impractical when the cardinality of the parameter set $\mathcal K$ is large because they require repeated resolutions of the dynamics (4) for all $\nu\in \mathcal K$.</p>

<p>This issue can be bypassed by employing a stochastic optimization method. In particular, we can consider the following approaches:</p>

<ul>
  <li>The <strong>Stochastic Gradient Descent (SGD)</strong> algorithm (see [2]): it is a drastic simplification of the classical GD in which, instead of computing the gradient of the functional for all parameters $\nu\in\mathcal K$, in each iteration this gradient is estimated on the basis of a single randomly picked configuration. This translates in the following recursion process</li>
</ul>

<script type="math/tex; mode=display">\textbf{SGD:} \quad u^{k+1} = u^k-\eta_k \left(\beta u^k - \mathbf{B}^\top p_{\nu_k}^k\right). \quad (5)</script>

<p>with $\nu_k$ selected i.i.d. from $\mathcal K$.</p>
<ul>
  <li>The <strong>Continuous Stochastic Gradient (CSG)</strong> algorithm: it is a variant of SGD, based on the idea of reusing previously obtained information to improve the efficiency. The CSG recursion process for optimizing $F_\nu$ is given by</li>
</ul>

<script type="math/tex; mode=display">\textbf{CSG:} \quad u^{k+1} = u^k-\eta_k \sum_{\ell = 1}^k \alpha_\ell\left(\beta u^\ell - \mathbf{B}^\top p_{\nu_\ell}^\ell\right), \quad (6)</script>

<p>where the weights ${\alpha_\ell}_{\ell = 1}^k$ are obtained through the methodology presented in [4].</p>

<h2 id="experimental-results-comparison-of-the-algorithms">Experimental Results: comparison of the algorithms</h2>

<p>We can test the efficiency of each one of the four aforementioned algorithms by performing simulations for increasing values of 
<script type="math/tex">|\mathcal K|</script>.
 In these simulations, we have chosen the initial state $x^0 =(1,1,1,1)^\top$ and the final target $x^T=(0,0,0,0)^\top$. The time horizon is set to be $T=1s$. The parameter set is a $|\mathcal K|$ points partition of the interval $[1,6]$: 
<script type="math/tex">\mathcal K=\{\nu_1,\ldots,\nu_{|\mathcal K|}\}</script>
 with $\nu_1=1$ and $\nu_{|\mathcal K|}=6$.</p>

<p><strong>Figure 3</strong> displays the computational times (in logarithmic scale) the four algorithms need to compute a simultaneous control for (1)-(2).</p>

<p><img width="80%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0011/timePlotComparison.png" /></p>

<center><b>Figure 3</b>: computational time (in logarithmic scale) to converge to the tolerance $\varepsilon = 10^{-4}$ of the GD, CG, SGD and CSG algorithms applied to the problem (1)-(2) with different values of $|\mathcal K|$.</center>

<p>We can observe the following facts:</p>

<ul>
  <li>The GD algorithm is the one showing the worst performances. This because it has to copy with a high per-iteration cost but also with the fact that controllability problems are typically bad conditioned.</li>
  <li>The CG algorithm is the one requiring the lower number of iterations to converge. This implies that CG is the best approach among the one considered when dealing with a low and moderate amount of parameters.</li>
  <li>The stochastic approaches SGD and CSG appear to be insensitive to the cardinality of the parameter set. This fact is not surprising if we consider that, no matter how many parameters enter in our control problem, with SGD and CSG each iteration of the optimization process always requires only one resolution of the coupled system (4).</li>
  <li>The CSG algorithm always outperforms SGD in terms of the number of iterations it requires to converge and, consequently, of the total computational time. This because in CSG the approximated gradient is close to the full gradient $\nabla F_\nu$ of the objective functional when $k\to +\infty$. This translates in a less noisy optimization process with better convergence behavior (see <strong>Figure 4</strong>).</li>
</ul>

<p><img width="80%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0011/MeanErrorPlotHor.png" /></p>

<center><b>Figure 4</b>: convergence of the error for SGD and CSG. The plots correspond to $50$ launches of the two algorithms with a tolerance $\varepsilon = 10^{-4}$.
</center>

<p>All these considerations corroborate the fact that, when dealing with large parameter sets, a stochastic approach is preferable to a deterministic one to address the simultaneous controllability of (1)-(2).</p>

<p>A more complete discussion on the employment of stochastic optimization algorithms for simultaneous controllability can be found in [1].</p>

<h2 id="bibliography">Bibliography</h2>

<p>[1] U. Biccari, A. Navarro-Quiles and E. Zuazua, <em>Stochastic optimization methods for the simultaneous controllability of parameter-dependent systems</em>, preprint (2020).</p>

<p>[2] L. Bottou, F. E. Curtis and J. Nocedal, <em>Optimization methods for large-scale machine learning</em>, SIAM Rev., Vol. 60, No. 2 (2018), pp. 223-311.</p>

<p>[3] J. Nocedal and S. Wright, S, <em>Numerical optimization</em>, Springer Science &amp; Business Media, 2006.</p>

<p>[4] L. Pflug, N. Bernhardt, M. Grieshammer and M. Stingl, <em>A new stochastic gradient method for the efficient solution of structural optimization problems with infinitely many state problems</em>, preprint (2020).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;Consider the Kuramoto model for the synchronization of coupled oscillators&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">\begin{cases}
\displaystyle \dot{\theta}_i(t) = \omega_i + \frac{Ku(t)}{N}\sum_{j=1}^N \sin \big(\theta_j(t)-\theta_i(t)\big),\quad i = 1,\ldots,N,\quad t>0
\\
\theta_i(0) = \theta_i^0.
\end{cases}\quad (1)</script>

<p>Here $\theta_i(t)$, $i = 1,\ldots,N$, is the phase of the $i$-th oscillator, $\omega_i$ is its natural frequency and $K$ is the coupling strength. The frequencies $\omega_i$ are distributed with a given probability density $f(\omega)$, unimodal and symmetric around the mean frequency</p>

<script type="math/tex; mode=display">\Omega = \frac 1N \sum_{i=1}^N \omega_i,</script>

<p>that is, $f(\Omega+\omega) = f(\Omega-\omega)$.</p>

<p>It is known that, if the coupling $K$ is sufficiently strong, the oscillators will synchronize asymptotically, i.e.</p>

<script type="math/tex; mode=display">\lim_{t\to +\infty} |\dot{\theta}_i(t)-\dot{\theta}_j(t)| = 0, \quad \textrm{ for all }\; i,j = 1,\ldots,N,</script>

<p>We want to design a control capable to ensure synchronization in a final time horizon $T$, that is</p>

<script type="math/tex; mode=display">|\dot{\theta}_i(T)-\dot{\theta}_j(T)| = 0, \quad \textrm{ for all } i,j = 1,\ldots,N. \quad\quad\quad(2)</script>

<p>To compute this optimal control allowing us to reach the synchronized configuration (3) we can adopt a classical approach based on the resolution of the following optimization problem</p>

<script type="math/tex; mode=display">\begin{array}{l}
\displaystyle\widehat{u} = \min_{u\in L^2(0,T;\mathbb{R})} J(u)
\\[10pt]
\displaystyle J(u) = \frac{1}{2} \sum_{i,j=1}^N \sin^2\big(\theta_j(T)-\theta_i(T)\big) + \frac \beta2 \|u\|^2_{L^2(0,T;\mathbb{R})},
\end{array}\quad (3)</script>

<p>subject to the dynamics (1).</p>

<p>For the resolution of (3), we use the standard GD method, which looks for the minimum $u$ as the limit $k\to +\infty$ of the following iterative process</p>

<script type="math/tex; mode=display">u^{k+1} = u^k - \eta_k\nabla J(u^k). \quad (4)</script>

<p>This gradient technique is most often chosen because it is very easy to be implemented.</p>

<p>In order to fully define the iterative scheme (4), we need to compute the gradient $\nabla J(u)$. This can be done via the <strong>Pontryagin maximum principle</strong>.</p>

<p>To this end, let us first rewrite the dynamics (1) in a vectorial form as follows</p>

<script type="math/tex; mode=display">\begin{cases}
\dot{\Theta}(t) = \Omega + F\big(\Theta(t),u(t)\big), \quad t>0
\\
\Theta(0) = \Theta^0,
\end{cases}</script>

<p>with $\Theta :=(\theta_1,\ldots,\theta_N)^\top$, $\Theta^0:=(\theta_1^0,\ldots,\theta_N^0)^\top$ and $\Omega :=(\omega_1,\ldots,\omega_N)^\top$, and where $F$ is the vector field given by</p>

<script type="math/tex; mode=display">F = (F_1,\ldots,F_N), \quad F_i:= \frac{Ku(t)}{N}\sum_{j=1}^N\sin\big(\theta_j(t)-\theta_i(t)\big), \quad i=1,\ldots,N.</script>

<p>Using the notation just introduced, we obtain the following expression for the gradient of $J(u)$</p>

<script type="math/tex; mode=display">\nabla J(u) = \beta u + (\mathcal D_uF)^\top p, \quad(5)</script>

<p>where $\mathcal D_uF$ indicates the Jacobian of the vector field $F$, computed with respect to the variable $u$.</p>

<p>In (5), we denoted with $p = (p_1,\ldots,p_N)$ the solution of the adjoint equation associated with (1), which is given by</p>

<script type="math/tex; mode=display">\begin{cases}
-\dot{p} = (\mathcal D_{\Theta}F)^\top p
\\
p(T) = \nabla_{\Theta(T)}\phi(\Theta(T)),
\end{cases}</script>

<p>where $\mathcal D_\Theta F$ stands again for the Jacobian of the vector field $F$, this time computed with respect to the variable $\Theta$.</p>

<p>Taking into account the expression of the vector field $F$, we can then see that the iterative scheme (4) becomes</p>

<script type="math/tex; mode=display">u^{k+1} = u^k -\eta_k\left[\beta u^k + \frac KN\sum_{i=1}^N p_i\left(\sum_{j=1}^N \sin(\theta_j-\theta_i)\right)\right], \quad (6)</script>

<p>with</p>

<script type="math/tex; mode=display">\begin{cases}
\displaystyle-\dot{p}_i = -\frac{Kup_i}{N}\sum_{i\neq j=1}^N \cos\big(\theta_j-\theta_i\big) + \frac{Ku}{N}\sum_{i\neq j=1}^N p_j \cos\big(\theta_j-\theta_i\big),\quad i = 1,\ldots,N,\quad t>0
\\[20pt]
\displaystyle p_i(T) = \frac 12\sum_{i\neq j=1}^N \sin\big(2\theta_i(T)-2\theta_j(T)\big).
\end{cases}</script>

<p>We then see that, at each iteration $k$ the optimization scheme (6) requires to solve a $N$-dimensional non-linear dynamical system. This may rapidly become computationally very expensive, especially when the number $N$ of oscillators in our system is large.</p>

<p>In order to reduce this computational burden, we can combine the standard GD algorithm with the so-called <strong>Random Batch Method (RBM)</strong>, which is a recently developed approach (see [2]) allowing for an efficient numerical simulation of high-dimensional collective behavior problems. This technique is based on the following simple idea: at each time step $t_m = m\cdot dt$ in the mesh we employ to solve the dynamics, we divide randomly the $N$ particles into $n$ small batches with size $2\leq P&lt;N$, denoted by $C_q$, $q = 1,\ldots,n$, that is</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{l}
C_q = \{i_{q_1},\ldots,i_{q_P}\}\subset \{1,\ldots,N\}, & & for\; all\; q = 1,\ldots,n
\\[8pt]
C_q\cap C_r = \emptyset, & & for\; all\; q,r = 1,\ldots,n
\\[8pt]
\bigcup_{q = 1}^n C_q = \{1,\ldots,N\}.
\end{array} %]]></script>

<p>Once this partition of ${1,\ldots,N}$ has been performed, we solve the dynamics by interacting only particles within the same batch. In this way, we are now dealing with systems of lower dimension and the computational cost of the GD algorithm is reduced.</p>

<h2 id="numerical-simulations">Numerical simulations</h2>

<p>We can check the effectiveness of the proposed approach through some numerical simulations for the computation of the optimal control $\widehat{u}$.</p>

<p>Firstly, we can show that the optimization problem (3) indeed allows to compute an effective control function which is capable to steer the Kuramoto model (1) to a synchronized configuration.</p>

<p>In <strong>Figure 1-top</strong>, we show the evolution of the uncontrolled dynamics, which corresponds to taking $u\equiv 1$ in (1). As we can see, the oscillators are evolving towards a synchronized configuration, but synchronization is not reached in the short time horizon we are providing. In <strong>Figure 1-bottom</strong>, we show the evolution of the same dynamics, this time under the action of the control function $u$ computed through the minimization of $J(u)$. The subplot on the left corresponds to the simulations done with the GD approach, while the one on the right is done employing GD-RBM. We can clearly see how, in both cases, the oscillators are all synchronized at the final time $T=3s$. This means that both algorithms managed to compute an effective control.</p>

<p><img width="80%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0006/KuramotoFull.jpg" /></p>
<center>
  <b>Figure 1.</b> Top - evolution of the free dynamics of the Kuramoto model (1) with $N=10$ oscillators. Bottom - evolution of the controlled dynamics of the Kuramoto model (1) with $N=10$ oscillators. The control function $\widehat{u}$ is obtained with the GD (left) and the GD-RBM (right) approach.
</center>

<p>In <strong>Figure 2</strong>, we display the behavior of the control function $\widehat{u}$ computed via the GD-RBM algorithm. We can see how, at the beginning of the time interval we are considering, this control is close to one and it is increasing with a small slope. On the other hand, this growth becomes more pronounced as we get closer to the final time $T=3s$.</p>

<p><img width="80%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0006/control.jpg" /></p>
<center>
  <b>Figure 2.</b> control function $\widehat{u}$ obtained through the GD-RBM algorithm applied to the Kuramoto model (1) with $N=10$ oscillators.
</center>

<p>Notice that, in (1), $\widehat{u}$ enters as a multiplicative control which modifies the strength of the coupling $K$. Hence, according to the profile displayed in <strong>Figure 2</strong>, the control function $\widehat{u}$ we computed is initially letting the system evolving following its natural dynamics. Then, as the time evolves towards the horizon $T=3s$, $\widehat{u}$ enhances the coupling strength $K$ in order to reach the desired synchronized configuration (2).</p>

<p>We can now compare the performances of the GD and GD-RBM algorithms for the computation of the optimal control $\widehat{u}$. To this end, we can run simulations for increasing values of $N$, namely $N=10,50,100,250,1000$.</p>

<p>Figure <strong>Figure 3</strong> shows the computational times required by the two methodologies to solve the optimization problem (3).</p>

<p><img width="80%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0006/timePlotComparison.jpg" /></p>
<center>
  <b>Figure 3.</b> computational times required by the GD and GD-RBM algorithm to compute the optimal control $\widehat{u}$ with increasing values of $N$.
</center>

<p>Our simulations show how, for low values of $N$, the two approaches show similar behaviors. Nevertheless, when increasing the number of oscillators in our system, the advantages of the GD-RBM methodology with respect to GD become evident. In particular, the growth of the computational time for GD-RBM is significantly less pronounced than for GD. As a matter of fact, <strong>Figure 3</strong> is not considering the case of $N=1000$ oscillators with GD, since the behavior with smaller values of $N$ already suggested that this experiment would be computationally too expensive.</p>

<p>On the other hand, even with $N=1000$ oscillators in the system, the GD-RBM approach turns out to be able to compute an effective control for the Kuramoto model (1) in about $29$ seconds (see <strong>Figure 4</strong>).</p>

<p><img width="80%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0006/stateEvolutionStochN1000.jpg" /></p>
<center>
  <b>Figure 4.</b> evolution of the controlled dynamics of the Kuramoto model (1) with $N=1000$ oscillators. The control has been computed with the GD-RBM algorithm.
</center>

<p>More details on the contents of this post can be found in [1].</p>

<h2 id="bibliography">Bibliography</h2>

<p>[1] U. Biccari and E. Zuazua, <em>A stochastic approach to the synchronization of coupled oscillators</em>, to appear in Front. Energy Res.</p>

<p>[2] S. Jin, L. Li and J.-G. Liu, <em>Random Batch Methods (RBM) for nteracting particle systems</em>, J. Comput. Phys. 400 (2020), 108877.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;It is superfluous to state the impact deep learning has had on modern technology. From a mathematical point of view however, a large number of the employed models remain rather ad hoc.&lt;/p&gt;
</code></pre>
</div>

<p>When formulated mathematically, deep supervised learning roughly consists in solving an <em>optimal control problem</em> subject to a nonlinear discrete-time dynamical system, called an artificial neural network.</p>

<script type="math/tex; mode=display">\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}</script>

<hr />

<h2 id="1-setup">1. <strong>Setup</strong></h2>

<p>Deep supervised learning [1, 3] (and more generally, supervised machine learning), can be summarized by the following scheme. 
We are interested in approximating a function $f: \R^d \rightarrow \R^m$, of some class, which is unknown a priori. We have data: its values <script type="math/tex">\{ \vec{y}_i \}_{i=1}^S \in \R^{m\times S}</script>
at $S$ distinct points <script type="math/tex">\{ \vec{x}_i \}_{i=1}^S \in \R^{d\times S}</script> (possibly noisy).
We generally split the $S$ data points into training  data <script type="math/tex">\{ \vec{x}_i, \vec{y}_i \}_{i=1}^N</script> and testing data <script type="math/tex">\{ \vec{x}_i, \vec{y}_i \}_{i=N+1}^S</script>. In practice, $N\gg S-N-1$.</p>

<p>“Learning” generally consists in:</p>

<ol>
  <li>Proposing a candidate approximation 
 $f_\Theta( \cdot): \R^d \rightarrow \R^m$, depending on tunable parameters $\Theta$ and fixed hyper-parameters $L\geq 1$, ${ d_k}$;</li>
  <li>
    <p>Tune $\Theta$ as to minimize the empirical risk: <script type="math/tex">\sum_{i=1}^N \ell(f_\Theta(\vec{x}_i), \vec{y}_i),</script>
where $\ell \geq 0$, $\ell(x, x) = 0$ (e.g. $\ell(x, y) = |x-y|^2$). This is called <em>training</em>.</p>
  </li>
  <li>A posteriori analysis: check if test error <script type="math/tex">\sum_{i=N+1}^{S} \ell(f_\Theta(\vec{x}_i), \vec{y}_i)</script> is small. 
This is called <em>generalization</em>.</li>
</ol>

<p><strong>Remark:</strong></p>

<ul>
  <li>
    <p>There are two types of tasks in supervised learning:
classification ($\vec{y}_i \in {-1,1}^m$ or more generally, a discrete set), and regression ($\vec{y}_i \in \R^m$).
We will henceforth only present examples of binary classification, namely $\vec{y}_i \in {-1, 1}$, for simple presentation purposes.</p>
  </li>
  <li>
    <p>Point 3 is inherently linked with the size of the control parameters $\Theta$. 
Namely, a penalisation of the empirical risk in theory provides better generalisation.</p>
  </li>
</ul>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP01/P0010/overfitting.png" width="100%" />
</center>
<center> <strong>Figure 1.</strong> 
Underfitting, good generalization, and overfitting. We wish to recover the function $f(x) = \cos(\frac32 \pi x)$ (blue) on $(0, 1)$ from $S=20$ noisy data samples.
Constructed approximations using $N=12$ training data, while the remaining $8$ samples are used for testing the results. The most complicated model (right) is not necessarily the best (Occam's razor).
This is related to the Runge phenomenon.
</center>

<p><strong>Remark:</strong> It is at the point of generalisation where the objective of supervised learning differs slightly from classical optimisation/optimal control. Indeed, whilst in deep learning one too is interested in “matching” the labels $\vec{y}_i$ of the training set, one also needs to guarantee satisfactory performance on points oustide of the training set.</p>

<hr />

<h2 id="2-artificial-neural-networks">2. <strong>Artificial Neural Networks</strong></h2>

<p>There exists an entire jungle (see [1, 3]) of specific neural networks used in practice and studied in theory.
For the sake of presentation, we will discuss two of the most simple examples.</p>

<h3 id="21-multi-layer-perceptron"><strong>2.1. Multi-layer perceptron</strong></h3>

<p>We henceforth assume that we are given a training dataset 
<script type="math/tex">\{\vec{x}_i, \vec{y}_i\}_{i=1}^N \subset \R^{d\times N}\times \R^{m\times N}</script>.</p>

<hr />

<p><strong>Definition (Neural network):</strong>  Let <script type="math/tex">L\geq 1</script> and <script type="math/tex">\{ d_k \}_{k=1}^L \in \N^L</script> be given. Set $d_0 := d$ and $d_{L+1} :=m$.
A neural network with $L$ hidden layers is a map</p>

<script type="math/tex; mode=display">f_\Theta(\vec{x}) = \varphi(A^L z^L + b^L)</script>

<p>where $z^L = z^L_i \in \R^m$ being given by the scheme</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
z^{k+1} = \sigma(A^k z^k + b^k) &\text{ for } k = 0, \ldots, L-1 \\
z^0 = \vec{x}_i \in \R^d.
\end{cases} %]]></script>

<p>Here <script type="math/tex">\Theta = \{A^k, b^k\}_{k=0}^{L}</script> are given parameters such that $A^k \in \R^{d_{k+1}\times d_k}$ and $b^k \in \R^{d_k}$, and $\sigma \in C^{0, 1}(\R)$ is a fixed, non-decreasing function.</p>

<hr />

<p><strong>Remark:</strong> Several remarks are in order:</p>

<ul>
  <li>The above-defined neural network is usually referred to as the <em>multi-layer perceptron</em> (see <a href="https://en.wikipedia.org/wiki/Multilayer_perceptron">Multilayer_perceptron</a>)</li>
  <li>Observe that $z^k \in \R^{d_k}$ for <script type="math/tex">k \in \{0, \ldots, L\}</script>.</li>
  <li>The function $\sigma$ is always nonlinear in practice (as otherwise the optimisation problem roughly coincides with least squares for a linear regression). It is called the <em>activation function</em>.</li>
  <li>Generally, $\sigma(x) = \max(x, 0)$ or $\sigma(x) = \tanh(x)$ (but others work too).</li>
  <li>Deep learning means optimisation subject to a multi-layered neural net: $L\geq 2$ at least.</li>
</ul>

<hr />

<p>Let us denote $\Lambda_k x :=A^k x + b^k$.</p>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP01/P0010/graph.png" width="80%" />
</center>
<center> <strong>Figure 2.</strong> 
The commonly used graph representation for a neural net.
This figure essentially represents the discrete-time dynamics of a single datum from the training set through the nonlinear scheme.
</center>

<hr />

<p>An MLP scheme with $\sigma(x) = \tanh(x)$ can be coded in <code class="highlighter-rouge">pytorch</code> more or less as follows:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">torch.nn</span> <span class="kn">as</span> <span class="nn">nn</span>

<span class="k">class</span> <span class="nc">OneBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">OneBlock</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
			<span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">),</span>
			<span class="n">nn</span><span class="o">.</span><span class="n">Tanh</span><span class="p">()</span>
		<span class="p">)</span>
	<span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> 
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Perceptron</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">):</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">Perceptron</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span>
		<span class="n">_</span> <span class="o">=</span> \
			<span class="p">[</span><span class="n">OneBlock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_layers</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">_</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">projector</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

	<span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="n">_</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">projector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre>
</div>

<p>We can save this class in a file called <code class="highlighter-rouge">model.py</code>.
Then one may create an instance of a Perceptron model for practical usage as follows:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">torch</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s">'cpu'</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">model</span> <span class="kn">import</span> <span class="n">Perceptron</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">Perceptron</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_layers</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</code></pre>
</div>

<hr />

<p><strong>How it works.</strong></p>

<p>We now see, in some overly-simplified scenarios, how the forward propagation of the inputs in the context of binary classification.</p>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP01/P0010/0-1.png" width="95%" />
<table>
    <tr>
        <th><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP01/P0010/1-1.png" width="100%" /></th>
        <th><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP01/P0010/2-5-1.png" width="100%" /></th>
    </tr>
</table>
</center>
<center> <strong>Figure 3.</strong> 
Here $A^0 \in R^{2\times 1}$ and $b^0 \in \R^2$.
We see how the neural net essentially generates a nonlinear transform, such that the originally mixed points are now linearly separable.
</center>

<p>An interesting blog on visualising the transitions is the following: https://colah.github.io/posts/2014-03-NN-Manifolds-Topology/.</p>

<hr />

<h3 id="22-residual-neural-networks">2.2. <strong>Residual neural networks</strong></h3>

<p>We now impose that the dimensions of the iterations and the parameters stay fixed over each step.
This will allow us to add an addendum term in the scheme.</p>

<hr />

<p><strong>Definition (Residual neural network [2]):</strong>  Let <script type="math/tex">L\geq 1</script> and <script type="math/tex">\{ d_k \}_{k=1}^L \in \N^L</script> be given. Set $d_0 := d$ and $d_{L+1} :=m$.
A residual neural network (ResNet) with $L$ hidden layers is a map</p>

<script type="math/tex; mode=display">f_\Theta(\vec{x}) = \varphi(A^L z^L + b^L)</script>

<p>where $z^L = z^L_i \in \R^d$ being given by the scheme</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
z^{k+1} = z^k + \sigma(A^k z^k + b^k) &\text{ for } k = 0, \ldots, L-1 \\
z^0 = \vec{x}_i \in \R^d.
\end{cases} %]]></script>

<p>Here $\Theta = {A^k, b^k}_{k=0}^{L}$ are given parameters such that $A^k \in \R^{d\times d}$ and $b^k \in \R^{d}$ for $k&lt;L$ and $A^L \in \R^{m\times d}, b^L \in \R^m$, and $\sigma \in C^{0, 1}(\R)$ is a fixed, non-decreasing function.</p>

<hr />

<h2 id="3-training">3. <strong>Training</strong></h2>

<p>Training consists in solving the optimization problem:</p>

<script type="math/tex; mode=display">\min_{\Theta = \{ (A^k, b^k) \}_{k=0}^L } \sum_{i=1}^N | \vec{y}_i - f_\Theta(\vec{x}_i)|^2 + \frac{\epsilon}{2} |\Theta|^2;</script>

<ul>
  <li>$\epsilon&gt;0$ is a penalization parameter.</li>
  <li>It is a <strong>non-convex</strong> optimization problem because of the non-linearity of $f_L$.</li>
  <li>Existence of a minimizer may be shown by the direct method.</li>
</ul>

<p>Once training is done, and we have a minimizer $\widehat{\Theta}$, we consider $f_{\widehat{\Theta}}(\cdot)$ and use it on other points of interest $\vec{x} \in \R^d$ outside the training set.</p>

<h3 id="31-computing-the-minimizer">3.1. <strong>Computing the minimizer</strong></h3>

<p>The functional to be minimized is of the form</p>

<script type="math/tex; mode=display">J(\Theta) = \sum_{i=1}^N J_i(\Theta).</script>

<p>We could do gradient descent:</p>

<script type="math/tex; mode=display">\Theta^{n+1} := \Theta^n - \eta \nabla J(\Theta^n),</script>

<p>$\eta$ is step-size. But often $N \gg 1$ ($N=10^3$ or much more).</p>

<p>Stochastic gradient descent: (Robbins-Monro [7], Bottou et al [8]):</p>

<ol>
  <li>
    <p>pick $i \in {1, \ldots, N}$ uniformly at random</p>
  </li>
  <li>
    <p>$\Theta^{n+1} := \Theta^n - \eta \nabla J_{i}(\Theta^n)$</p>
  </li>
</ol>

<ul>
  <li>Mini-batch GD: can also be considered (pick a subset of data instead of just one point)</li>
  <li>Use chain rule and adjoints to compute these gradients (“backpropagation”)</li>
  <li>Issues: might not converge to global minimizer; also how does one initialize the weights in the iteration (usually done at random)?</li>
</ul>

<hr />

<p>We come back to the file <code class="highlighter-rouge">model.py</code>. Here is a snippet on how to call training modules.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Given generated data</span>
<span class="c"># Coded a function def optimize() witin</span>
<span class="c"># a class Trainer() which</span>
<span class="c"># does the optimization of paramterss</span>

<span class="n">epochs</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">perceptron</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">weight_decay</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>

<span class="n">trainer</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="n">perceptron</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
<span class="n">trainer</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">epochs</span><span class="p">)</span>
</code></pre>
</div>
<hr />

<h3 id="32-continuous-time-optimal-control-problem">3.2. <strong>Continuous-time optimal control problem</strong></h3>

<p>We begin by visualising how the flow map of a continuous-time neural net separates the training data in a linear fashion at time $1$ (even before in fact).</p>

<table>
  <tr>
   <th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP01/P0010/trajectory2.gif" width="100%" />
    </th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP01/P0010/trajectory11.gif" width="100%" />
 </th>
 </tr>
 </table>

<center> <strong>Figure 4.</strong> 
The time-steps play the role of layers. We are working with an ode on $(0, 1)$. We see that the points are linearly separable at the final time, so the flow map defines a "linearisation" of the training dataset.
</center>

<p>Recall that often $\varphi \equiv \sigma$ (classification)  or $\varphi(x) = x$ (regression).</p>

<p>It can be advantageous to consider the continuous-time optimal control problem:</p>

<script type="math/tex; mode=display">\inf_{u(t) \in U,\, (\alpha, \beta)} \sum_{i=1}^N |\vec{y}_i - \varphi(\alpha \, z(1)+\beta)|^2 + \frac{\epsilon}{2} \int_0^1 |(A(t), b(t))|^2 dt</script>

<p>where $z = z_i$ solves</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
	z'(t) &= \sigma(A(t)z(t)+b(t)) \quad \text{ in } (0, 1) \\
	z(0) &= \vec{x}_i \in \R^d.
\end{cases} %]]></script>

<hr />

<p><strong>Remark:</strong></p>

<p>The ResNet neural network can then be seen as the forward Euler discretisation with $\Delta t = 1$.
The relevance of this scale when passing from continuous to discrete has not been addressed in the litearature.</p>

<hr />

<p><em>Thus, in the continuous-time limit, deep supervised learning for ResNets can be seen as an optimal control problem for a parametrised, high-dimensional ODE.</em></p>

<p>This idea of viewing deep learning as finite dimensional optimal control was (mathematically) formulated in [12], and subsequently investigated from a theoretical and computational viewpoint in [11, 10, 5, 6, 13, 14], among others.</p>

<hr />

<p><strong>Remark:</strong></p>

<p>There are many tricks which can be used in the above ODE to improve performance.</p>

<ul>
  <li>For instance, we may embed the initial data in a higher dimensional space at the beginning, and consider the system in an even bigger dimension. It is rather intuitive that the bigger the dimension where the system evolves is, the easier it is to separate the points by a hyperplane.</li>
  <li>However, characterising the optimal dimension where one needs to consider the evolution of the neural net in terms of the topology of the training data is, up to the best of our knowledge, an open problem. 
The choice in practice is done by cross-validation.</li>
</ul>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP01/P0010/trajectory.gif" width="80%" />
</center>
<center> <strong>Figure 5.</strong> 
Analogous scenario as in Figure 4, this time in dimension 3.
</center>

<h2 id="references">References:</h2>

<p>[1] Ian Goodfellow and Yoshua Bengio and Aaron Courville. (2016). Deep Learning, MIT Press.</p>

<p>[2] He, K., Zhang, X., Ren, S., and Sun, J. (2016). Deep residual learning for image
recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages
770–778.</p>

<p>[3] LeCun, Y., Bengio, Y., and Hinton, G. (2015). Deep learning. Nature,
521(7553):436–444.</p>

<p>[4] LeCun, Y., Boser, B. E., Denker, J. S., Henderson, D., Howard, R. E., Hubbard,
W. E., and Jackel, L. D. (1990). Handwritten digit recognition with a back-propagation network. In
Advances in neural information processing systems, pages 396–404.</p>

<p>[5] Chen, T. Q., Rubanova, Y., Bettencourt, J., and Duvenaud, D. K. (2018). Neural
ordinary differential equations. In Advances in neural information processing systems, pages 6571–
6583.</p>

<p>[6] Dupont, E., Doucet, A., and Teh, Y. W. (2019). Augmented neural odes. In
Advances in Neural Information Processing Systems, pages 3134–3144.</p>

<p>[7] Herbert Robbins and Sutton Monro. A Stochastic Approximation Method. The Annals of Mathematical Statistics, 22(3):400–407, 1951</p>

<p>[8] Léon Bottou, Frank E. Curtis and Jorge Nocedal: Optimization Methods for Large-Scale Machine Learning, Siam Review, 60(2):223-311, 2018.</p>

<p>[9] Matthew Thorpe and Yves van Gennip. Deep limits of residual neural networks. arXiv preprint arXiv:1810.11741, 2018.</p>

<p>[10] Weinan, E., Han, J., and Li, Q. (2019). A mean-field optimal control formulation
of deep learning. Research in the Mathematical Sciences, 6(1):10.</p>

<p>[11] Li, Q., Chen, L., Tai, C., and Weinan, E. (2017). Maximum principle based algorithms
for deep learning. The Journal of Machine Learning Research, 18(1):5998–6026.</p>

<p>[12] Weinan, E. (2017). A proposal on machine learning via dynamical systems. Communications in Mathematics and Statistics, 5(1):1–11.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;div class="card" style="border: 1px solid black;padding:auto;margin:10px;background-color:#a6bdd1"&gt;
&lt;div class="card-body" style="margin: inherit;"&gt;
&lt;h5 class="card-title"&gt;Control of reaction-diffusion&lt;/h5&gt;
&lt;p class="card-text"&gt;This is a post in a collection of several on control of reaction-diffusion under state constraints&lt;/p&gt;
&lt;a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0007" class="btn btn-primary"&gt;See more ...&lt;/a&gt;
&lt;/div&gt;
</code></pre>
</div>
<p>&lt;/div&gt;</p>

<h3 id="equation-and-drift-effect">Equation and drift effect</h3>

<p>The equation under concern is:</p>

<script type="math/tex; mode=display">\begin{cases}
u_t-u_{xx}-2\frac{N_x}{N}u_x-=u(1-u)(u-\theta)\quad (x,t)\in (0,L)\times(0,T),\\
u(0,t)=a_1(t),\quad u(L,t)=a_2(t)\\
 0\leq u(x,0)\leq 1.
\end{cases}</script>

<p>where $N$ is a positive regular function.</p>

<p>The physical meaning of the equation is a reaction-diffusion process on the proportion $u$ of individuals along a static heterogeneous distribution $N$.</p>

<p>The effect of this heterogeneous drift can be qualitatively understood in Figure 1. The blue line in the figure is the distribution $N$ and the orange one the term $-2\frac{N_x}{N}$. In the picture in the left we have the Gaussian with variance $\sigma$, leading to a drift effect that is pushing $u$ towards the boundary. At the right, we have the function $e^{x^2/\sigma}$ leading to the contrary effect, the population in the boundary is pushed inside the domain.</p>

<p>From the discussion above we expect the boundary control to be enhanced in the case of $N(x)=e^{x^2/\sigma}$ while diminished in the case of $N(x)=e^{-x^2/\sigma}$.</p>

<center>
<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0008/figures/drift1.png" width="100%" />
        </th>
         <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0008/figures/drift2.png" width="100%" />
        </th>       
    </tr>
</table>
</center>
<center><b>Figure 1.</b> In blue the curves $N(x)=e^{\mp x^2/\sigma}$ and in orange the term $-2\frac{N_x}{N}$.</center>

<h3 id="slowly-varying-drifts-perturbed-stair-case-method">Slowly varying drifts: Perturbed Stair-case method</h3>

<p>Whenever the drift term $-2\frac{N_x}{N}$ is small enough, one can consider the already developed path in the homogeneous setting (see Blog <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0005">staircaise</a>), taka a sequence and apply the implicit function theorem to obtain a sequence close enough to guarantee the controllability (see [1] for details). This guarantees the controllability from the steady state $0$ to the target $\theta$.</p>

<p>In Figure 2 an intuitive sketch of this procedure is represented.</p>

<center>
<img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0008/figures/staircase_perturbed.png" width="60%" />
</center>
<center><b>Figure 2.</b> Perturbed staircase method.</center>

<h3 id="large-drifts-new-barriers">Large drifts: New Barriers</h3>

<p>One of the main concerns when state-constraints are present is whether or not barriers exist (see Blog <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0006">Barriers</a>). If $\theta&lt;\frac{1}{2}$ then, for large $L&gt;L_{\sigma}(0)&gt;0$ we will have obstructions to reach $\theta$ and $0$ from $1$.</p>

<p>In the homogeneous case, nontrivial elliptic solutions with boundary value $1$ do not exist. However, in the case of heterogeneous drift this is no longer true in general.</p>

<p>If we set $N(x)=e^{-x^2/\sigma}$ then for every $\sigma$ one can find an $L_{\sigma}(1)&gt;0$ big enough such that for every $L&gt;L_{\sigma}$ there is a nontrivial solution with boundary value $1$. This nontrivial solution does not correspond to a global minima of the associated energy functional since the trivial solution $u=1$ is the global minimizer.</p>

<p>In order to understand how this barrier can exist we have to study the following non-autonomous dynamics in the phase-plane:</p>

<script type="math/tex; mode=display">\begin{cases}
\frac{d}{dx}\begin{pmatrix}u\\ v \end{pmatrix}=\begin{pmatrix}v\\ -u(1-u)(u-\theta) \end{pmatrix}+\begin{pmatrix}0\\ \frac{4}{\sigma}xv \end{pmatrix}\\
\begin{pmatrix}u(0)\\ v(0) \end{pmatrix}=\begin{pmatrix}a\\ 0 \end{pmatrix}
\end{cases}</script>

<p>Any solution of the ODE above is an elliptic solution for some boundary condition. What we want to find is that there exist an $L_{\sigma}(1)$ such that the solution of the ODE at $L_{\sigma}(1)$ is $1$.</p>

<p>Making use of the energy of the ODE</p>

<script type="math/tex; mode=display">E=\frac{1}{2} v^2+\int u s(1-s)(s-\theta)ds</script>

<p>and seting $a$ small one can see that the trajectory of the dynamics will eventually cross $1$. See Figure 3.</p>

<center>
<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0008/figures/Drift-L=200a1.png" width="100%" />
        </th>
         <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0008/figures/Nontrivial-Drift-L=200a1.png" width="100%" />
        </th>       
    </tr>
</table>
</center>

<center><b>Figure 3.</b> At the left, the trajectory in the phase-plane associated with the elliptic solution. At the right, the resulting nontrivial solution.</center>

<p>In Figure 4 one can see the effect of the nontrivial solution in a simulation. The red lines are snapshots of the controlled trajectory, getting darker when advancing the time, the dotted blue line is the profile $N(x)$.</p>

<center>
<img width="60%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0008/figures/gaussto12.png" />
</center>
<center><b>Figure 4.</b> Simulation of the equation with control $a=1$ with $N(x)=e^{-x^2/\sigma}$.</center>

<h3 id="minimal-controllability-time-depending-on-the-drift">Minimal controllability time depending on the drift</h3>

<p>We have seen that the influence of the drift is key. Figure 5 shows the minimal controllability time for a fixed $L$ depending on the parameter $\frac{1}{\sigma}$. The initial state is the $0$ configuration and the target the constant steady state $\theta$.</p>

<p>When the variance is very big we tend to the homogeneous case, while when the variance decreases the opposite phenomena is observed; when the drift enhances the control the minimal controllability time is reduced making it tend to zero while, when the drift is pushing the population outside the minimal controllability time increases and eventually blows up with the emergence of the barrier.</p>

<center>
<table>
    <tr>
        <th>
            <img width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0008/figures/MincontroltimeWELL.png" />
        </th>
         <th>
            <img width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0008/figures/MincontroltimeGAUSSIAN.png" />
        </th>       
    </tr>
</table>
</center>

<center><b>Figure 5.</b> Minimal controllability time depending on the variance. At the left for $N(x)=e^{x^2/\sigma}$ and at the right for $N(x)=e^{-x^2/\sigma}$. </center>

<h3 id="references">References:</h3>
<p>[1] I. Mazari, D. Ruiz-Balet, and E. Zuazua, Constrained control of bistable reaction-diffusion equations: Gene-flow and spatially heterogeneous models, preprint: https://hal.archives-ouvertes.fr/hal-02373668/document (2019).</p>

<p>[2] D. Pighin, E. Zuazua, Controllability under positivity constraints of multi-d wave equations, in:
Trends in Control Theory and Partial Differential Equations, Springer, 2019, pp. 195–232.</p>

<p>[3] J.-M. Coron, E. Trélat, Global steady-state controllability of one-dimensional semilinear heat equa-
tions, SIAM J. Control. Optim. 43 (2) (2004) 549–569.</p>

<p>[4] C. Pouchol, E. Trélat, E. Zuazua, Phase portrait control for 1d monostable and bistable reac-
635
tion–diffusion equations, Nonlinearity 32 (3) (2019) 884–909.</p>

<p>[5]   D.  Ruiz-Balet  and  E.  Zuazua. Controllability  under  constraints  for  reaction-diffusionequations:   The  multi-dimensional  case.   Preprint  available  athttps://cmc.deusto.eus/domenec-ruiz-balet/.</p>

<p>[6] D.  Ruiz-Balet  and  E.  Zuazua. Control of certain parabolic models from biology and social sciences.   Preprint  available  at https://cmc.deusto.eus/domenec-ruiz-balet/.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;div class="card" style="border: 1px solid black;padding:auto;margin:10px;background-color:#a6bdd1"&gt;
&lt;div class="card-body" style="margin: inherit;"&gt;
&lt;h5 class="card-title"&gt;Control of reaction-diffusion&lt;/h5&gt;
&lt;p class="card-text"&gt;This is a post in a collection of several on control of reaction-diffusion under state constraints&lt;/p&gt;
&lt;a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0007" class="btn btn-primary"&gt;See more ...&lt;/a&gt;
&lt;/div&gt;
</code></pre>
</div>
<p>&lt;/div&gt;</p>

<p>In this tutorial we will observe different phenomena that arise in the control with state-constraints and moreover we will observe different ways to approach a desired target.</p>

<h1 id="observation-of-several-phenomena">Observation of several phenomena</h1>

<p>In the simulations below, we will consider the following optimal control problem:</p>

<script type="math/tex; mode=display">\begin{cases}
\displaystyle \min_{0\leq a(t)\leq 1}\|u(x,T)-u_1\|_{L^2}\\
u_t-u_{xx}=u(1-u)(u-0.33)\\
u(0,t)=u(L,t)=a(t)\\
u(x,0)\equiv u_0\in\{0,1\}
\end{cases}</script>

<p>In Figure 1, the initial state was $u_0=1$ and we can observe how the solution has been successfully driven to the target $u_1=0.33$. For this length of the domain there is no barrier (see <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0006">Barriers</a>)), for this reason the optimal solution can achieve the target.</p>

<p>The trajectory of the control can also be understood from the theoretical understanding of the controllability under state constraints.</p>

<p>In the first phase, the control takes values that are below the target $u_1=0.33$. This behavior is necessary because for this length of the domain there exist nontrivial solutions with boundary value $0.33$ that are between $0$ and $1$.</p>

<p>These nontrivial solutions do not constitute an intrinsic obstruction since we know that the equation is controllable for this length of the domain (see [1,3] and <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0005">Staircase post</a> and <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0006">Barriers post</a>). However, the strategy of setting boundary equal to $0.33$ for a long time and then doing a local control will not work.</p>

<p>The second oscillatory phase has been already observed in the unconstrained case (see [4]).</p>

<center>
<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/ContrState-1.png" width="100%" />
        </th>
         <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/Contr-1.png" width="100%" />
        </th>       
    </tr>
</table>
</center>

<center><b>Figure 1.</b> At the left, the controlled state, at the right, the control function. $u_0=1$ and $u_1=0.33$. </center>

<p>Another important feature is the existence of a minimal controllability time. In Figure 2, $u_0=0$ and the target is $u_1=0.33$. From the theoretical perspective, if the time horizon is large enough we are always able to go from the initial state to the target. This is due to the existence of an admissible continuous path of steady states (<a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0005">Staircase post</a>).</p>

<p>However, in Figure 2, one observes that the target $u_1=0.33$ has been not achieved. The reason is that $T$ is not large enough for the equation to be controllable.</p>

<center>
<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/ContrState-4.png" width="100%" />
        </th>
         <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/State-4.png" width="100%" />
        </th>       
    </tr>
</table>
</center>

<center><b>Figure 2.</b> At the left, the controlled state displayed in space-time, at the right, different snapshots of the state, darker curves are associated with larger times. $u_0=0$ and $u_1=0.33$ .</center>

<p>The other phenomenology already mentioned above and in the blog post <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0006">Barriers</a> is the lack of controllability due to the emergence of nontrivial solutions. In Figure 3, the initial state is $u_0=1$ and the target is $u_1=0$. We can observe how the state gets stuck to the barrier.</p>

<center>
<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/ContrState-2.png" width="100%" />
        </th>
         <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/State-2.png" width="100%" />
        </th>       
    </tr>
</table>
</center>

<center><b>Figure 3.</b> At the left, the controlled state displayed in space-time, at the right, different snapshots of the state, darker curves are associated with larger times. $u_0=1$ and $u_1=0$ .</center>

<h2 id="exploration">Exploration</h2>

<p>Now we turn our attention to the exploration of different control strategies.</p>

<h3 id="quasistatic">Quasistatic</h3>

<p>In Figure 4, we seek to find a control that is quasistatic, for doing so we penalize the time derivative of the control in the discrete level and we add the restriction $u(x,T)=0.33$.</p>

<script type="math/tex; mode=display">\begin{cases}
\min_{0\leq a(t)\leq 1}\|a_t\|_{L^2}\\
u_t-u_{xx}=u(1-u)(u-0.33)\\
u(0,t)=u(L,t)=a(t)\\
u(x,0)\equiv 0\\
u(x,T)\equiv 0.33
\end{cases}</script>

<center>
<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/ContrState-6.png" width="100%" />
        </th>
         <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/Contr-6.png" width="100%" />
        </th>       
    </tr>
</table>
</center>

<center><b>Figure 4.</b> At the left, the controlled state displayed in space-time, at the right, the control function. $u_0=0$ and $u_1=0.33$ . </center>

<h1 id="minimal-control-time">Minimal control time</h1>

<p>In Figure 5, we compute the control in minimal time by minimizing the functional:</p>

<script type="math/tex; mode=display">\begin{cases}
\min_{0\leq a(t)\leq 1}T\\
u_t-u_{xx}=u(1-u)(u-0.33)\\
u(0,t)=u(L,t)=a(t)\\
u(x,0)\equiv 0\\
u(x,T)\equiv 0.33
\end{cases}</script>

<center>
<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/ContrState-5.png" width="100%" />
        </th>
         <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/Contr-5.png" width="100%" />
        </th>       
    </tr>
</table>
</center>

<center><b>Figure 5.</b> At the left, the controlled state displayed in space-time, at the right, the control function. $u_0=0$ and $u_1=0.33$ .</center>

<p>Figure 5 points out that the control in minimal time has the bang-bang property.</p>

<h3 id="minimal-flow-control">Minimal flow control</h3>

<p>In Figure 6, we compute the control with minimal flow by minimizing the functional:</p>

<script type="math/tex; mode=display">\begin{cases}
\min_{0\leq a(t)\leq 1} \|u_x(0,t)\|_L^2+\|u_x(L,t)\|_L^2 \\
u_t-u_{xx}=u(1-u)(u-0.33)\\
u(0,t)=u(L,t)=a(t)\\
u(x,0)\equiv 0\\
u(x,T)\equiv 1-\epsilon
\end{cases}</script>

<center>
<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/ContrState-8.png" width="100%" />
        </th>
         <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/Contr-8.png" width="100%" />
        </th>       
    </tr>
</table>
</center>

<center><b>Figure 6.</b> </center>

<h2 id="references">References:</h2>

<p>[1] D.  Ruiz-Balet  and  E.  Zuazua. Control of certain parabolic models from biology and social sciences.   Preprint  available  at https://cmc.deusto.eus/domenec-ruiz-balet/.</p>

<p>[2] J.-M. Coron, E. Trélat, Global steady-state controllability of one-dimensional semilinear heat equa-
tions, SIAM J. Control. Optim. 43 (2) (2004) 549–569.</p>

<p>[3] C. Pouchol, E. Trélat, E. Zuazua, Phase portrait control for 1d monostable and bistable reac
tion–diffusion equations, Nonlinearity 32 (3) (2019) 884–909.</p>

<p>[4]  R. Glowinski, J. L. Lions and J. He. “Exact and approximate controllability for distributed parameter systems: a numerical approach.” Encyclopedia of Mathematics and its Applications (2008).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3 id="background-and-motivation"&gt;Background and motivation&lt;/h3&gt;
</code></pre>
</div>

<p>We consider the initial-value problem for a Hamilton-Jacobi equation of the form</p>

<script type="math/tex; mode=display">% <![CDATA[
\tag{HJ}
\left\{ \begin{array}{ll}
\partial_t u + H(D_x u) = 0, & \text{in} \ [0,T]\times \mathbb{R}^n, \\
u(0,x) = u_0(x), & \text{in} \ \mathbb{R}^n,
\end{array}\right. %]]></script>

<p>where $u_0\in C^{0,1}(\mathbb{R}^n)$ and the Hamiltonian $H: \mathbb{R}^n\rightarrow\mathbb{R}$ is assumed to satisfy the following hypotheses:</p>

<script type="math/tex; mode=display">\tag{2}
H\in C^2(\mathbb{R}^n), \quad H_{pp}(p) >0, \ \forall p\in\mathbb{R}^n, \quad \text{and} \quad 
\lim_{|p|\to\infty} \dfrac{H(p)}{|p|} = +\infty.</script>

<p>Here, the unknown $u$ is a function $[0,T]\times\mathbb{R}^n\longrightarrow\mathbb{R}$,
and the inequality $H_{pp}(p)&gt;0$ means that the Hessian matrix of $H$ at $p$ is positive definite.
The study of Hamilton-Jacobi equations
arises in the context of optimal control theory and calculus of variations,
where the value function satisfies, in a weak sense, a Hamilton-Jacobi equation.
In this context, Hamilton-Jacobi equations have applications in a wide range of fields such as
economics, physics, mathematical finance, traffic flow and geometrical optics.</p>

<p>Our goal in this tutorial is to study the <strong>inverse design problem</strong> associated to (HJ).
More precisely, for a given <strong>target function</strong> $u_T$ and a <strong>time horizon</strong> $T&gt;0$,
we want to construct all the <strong>initial conditions</strong> $u_0$ such that the viscosity solution of (HJ) coincides with $u_T$ at time $T$.</p>

<p>The study of this problem can also be motivated by considering the following question:</p>

<p><em>Given an observation of the solution to (HJ) at time $T&gt;0$, can we construct all the possible initial data that agree we the observation at time $T$ ?</em></p>

<p>For this purpose, for a fixed $T&gt;0$, 
we define the following nonlinear operator, which associates to any initial condition $u_0$, the function
$u(T,\cdot)$, where $u$ is the viscosity solution of (HJ):</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{cccl}
S^+_T : & C^{0,1}(\mathbb{R}^n) & \longrightarrow & C^{0,1}(\mathbb{R}^n) \\
 & u_0 & \longmapsto & S^+_T u_0 := u(T,\cdot)
\end{array} %]]></script>

<p>The inverse design problem that we are considering is then reduced to, for $u_T$ and $T&gt;0$ given,
characterize all the initial conditions $u_0$ satisfying $S_T^+ u_0 =u_T$.</p>

<h3 id="reachability-of-the-target">Reachability of the target</h3>

<p>The first thing one notices when addressing this problem is that not all the Lipschitz targets are reachable.
Indeed, as it is well known, the viscosity solution to (HJ) is always a semiconcave function (see [2,4]). 
Therefore, an obvious necessary (but not sufficient) condition for the reachability of $u_T$ is that it must be a semiconcave function.
See Figures 1 and 2 for some examples of unreachable targets in dimension 1 and 2 respectively. Observe that, in particular, they are not semiconcave functions.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/01_Fig11.png" alt="1D unreachable targets" height="250" width="650" /> 
</figure>
</center>

<center>
<strong> Figure 1: </strong> Two unreachable target functions in dimension 1.
</center>

<p>We then start our study by characterizing the set of targets that are reachable.
In other words, for a given $u_T$ and $T&gt;0$, we aim to determine whether or not there exists at least one initial condition $u_0$ satisfying $S_T^+ u_0=u_T$.
The natural candidate is the one obtained by reversing the time in the equation, considering $u_T$ as terminal condition. Here, we have to consider the class of backward viscosity solutions, for which the terminal-value problem associated to (HJ) is well-posed (see for example [1]).</p>

<p>We then define the <strong>backward operator</strong> as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{cccl}
S^-_T : & C^{0,1}(\mathbb{R}^n) & \longrightarrow & C^{0,1}(\mathbb{R}^n) \\
 & u_T & \longmapsto & S^-_T u_T := w(0,\cdot)
\end{array} %]]></script>

<p>which associates to any terminal condition $u_T$, the function $w(0,\cdot)$,
i.e. the unique backward viscosity solution at time $0$, with terminal condition $u_T$.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/07_Fig21.png" alt="2D unreachable targets" height="200" width="600" /> 
</figure>
</center>

<center>
<strong> Figure 2: </strong> Two unreachable target functions in dimension 2.
</center>

<p>Let us introduce, for a target $u_T$ and a time horizon $T&gt;0$, the set</p>

<script type="math/tex; mode=display">I_T (u_T) := \left\{ u_0\in C^{0,1}(\mathbb{R}^n) \, ; \ S_T^+ u_0 = u_T\right\}</script>

<p>of initial conditions $u_0$ satisfying $S_T^+ u_0 = u_T$.
We say that a target $u_T$ is <strong>reachable</strong> for the time horizon $T$ if $I_T(u_T)\neq \emptyset$.
We can equivalently say that $u_T$ is an <strong>admissible observation</strong> at time $T&gt;0$.</p>

<p>Here we give a result that identifies the set of reachable targets (or admissible observations) at time $T$,
with the fix-points of the composition operator $S_T^+\circ S_T^-$.</p>

<hr />

<p><strong>Theorem 1:</strong> Let $H$ satisfy (2), $u_T\in C^{0,1}(\mathbb{R}^n)$ and $T&gt;0$. Then, the set $I_T(u_T)$ is nonempty 
if and only if  $S_T^+ \left( S_T^- u_T\right) = u_T.$</p>

<hr />

<p>In other words, a target is reachable if and only if the initial condition $\tilde{u}_0:= S_T^- u_T$, obtained by applying the backward operator, satisfies $\tilde{u}_0\in I_T(u_T)$.
Or equivalently, an observation $u_T$ at time $T$ is admissible if and only if $S_T^+ \left( S_T^- u_T\right) = u_T.$</p>

<h3 id="projection-on-the-set-of-reachable-targets">Projection on the set of reachable targets</h3>

<p>In the case the observation $u_T$ at time $T$ is <strong>not admissible</strong>, maybe due to noise effects or to errors in the measurements, we can actually project it on the set of admissible observations by applying the operator $S_T^+\circ S_T^-$. For a given $u_T\in C^{0,1}(\mathbb{R}^n)$, we define this projection as follows:</p>

<script type="math/tex; mode=display">u_T^\ast := S_T^+(S_T^- u_T).</script>

<p>Observe that $I_T(u_T^\ast)\neq \emptyset$ for any $u_T\in C^{0,1}(\mathbb{R}^n)$. 
Indeed, $\tilde{u}_0:=S_T^- u_T\in I_T (u_T^\ast)$ by definition.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/02_Vid11.gif" alt="1D backward-forward" height="450" width="450" /> 

 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/02_Vid12.gif" alt="1D backward-forward" height="450" width="450" /> 
</figure>
</center>

<center>
<strong> Video 1: </strong> Projection of the examples in Figure 1 on the set of admissible observations at times $T=0.3$ and $T=0.8$ respectively.
</center>

<p>In the Videos 1 and 2, we observe how the examples in Figures 1 and 2 are projected on the set of reachable targets.
We recall that the projection is obtained by solving the problem (HJ) backward in time and the forward.
Observe that, when the time goes backward, the solution is semiconvex, while in the forward resolution, it becomes semiconcave. See [1,4] for the classical results concerning this regularizing effect and [2] for the definition and properties of semiconcave and semiconvex functions.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/08_Vid41.gif" alt="2D backward-forward" height="300" width="400" /> 

 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/08_Vid42.gif" alt="2D backward-forward" height="300" width="400" /> 
</figure>
</center>

<center>
<strong> Video 2: </strong> Projection of the examples in Figure 2 on the set of admissible observations at time $T=1$.
</center>

<h3 id="construction-of-initial-data">Construction of initial data</h3>

<p>Once we have projected the observation $u_T$ on the set of reachable targets at time $T$, we proceed to the construction of all the initial data $u_0$ satisfying $S_T^+ u_0 = u_T^\ast$.
This construction is contained in the recent work [3], and reads as follows:</p>

<hr />

<p><strong>Theorem 2:</strong> Let $H$ satisfy (2) and $T&gt;0$.
Let $u_T\in C^{0,1}(\mathbb{R}^n)$ and define the functions</p>

<script type="math/tex; mode=display">u_T^\ast := S_T^+(S_T^- u_T) \qquad \text{and} \qquad \tilde{u}_0 := S_T^- u^\ast_T.</script>

<p>Then, for any $u_0\in C^{0,1} (\mathbb{R}^n)$, the two following statements are equivalent:</p>
<ol>
  <li>$u_0\in I_T(u_T^\ast)$;</li>
  <li>$u_0(x)\geq \tilde{u}_0 (x), \ \forall x\in \mathbb{R}^n \quad \text{and} \quad u_0(x) = \tilde{u}_0(x), \ \forall x\in X_T(u_T^\ast),$</li>
</ol>

<p>where $X_T(u_T^\ast)$ is the subset of $\mathbb{R}^n$ given by</p>

<script type="math/tex; mode=display">X_T(u_T^\ast) : = \left\{ z- T\, H_p (\nabla u_T^\ast(z)); \ \forall z\in\mathbb{R}^n \ \text{such that} \ 
u_T^\ast(\cdot) \ \text{is differentiable at} \ z\right\}.</script>

<hr />

<p>In view of this result, we observe that, for a given admissible observation $u_T^\ast$ at time $T$,
the construction of the possible initial data can be carried out after obtaining the two following ingredients:</p>
<ul>
  <li>the function $\tilde{u}_0 = S_T^- u_T^\ast$, obtained as the backward viscosity solution to (HJ) with terminal condition $u_T^\ast$;</li>
  <li>and the set $X_T(u_T^\ast)\subset \mathbb{R}^n$, that can be deduced from the differentiability points of $u_T^\ast$.</li>
</ul>

<p>In Figures 3 and 4 below, we can see the scheme of the construction of all the initial data for the projection $u_T^\ast = S_T^+ (S_T^- u_T)$ of the non-admissible observations in Figure 1.
Observe that all the initial data in $I_T(u_T^\ast)$ must coincide with $\tilde{u}_0$ on the red region, while on the black region, they must be greater or equal than $\tilde{u}_0$.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/03_Fig12.png" alt="1D reconstruction 1" height="250" width="550" /> 
</figure>
</center>

<center>
<strong> Figure 3: </strong> Reconstruction scheme for the admissible target obtained in Video 1 at the left.
</center>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/04_Fig13.png" alt="1D reconstruction 2" height="220" width="550" /> 
</figure>
</center>

<center>
<strong> Figure 4: </strong> Reconstruction scheme for the admissible target obtained in Video 1 at the right.
</center>

<p>An important consequence of Theorem 2 is that the initial data in $I_T(u_T^\ast)$ are not unique whenever $X_T(u_T^\ast) \neq \mathbb{R}^n$.
Indeed, the set $I_T(u_T^\ast)$ can be given in the following way:</p>

<script type="math/tex; mode=display">I_T(u_T) = \left\{ \tilde{u}_0 + \varphi \, ; \, \varphi\in C^{0,1}(\mathbb{R}^n)\ 
\text{such that} \ \varphi\geq 0\ \text{and}\ \text{supp} (\varphi) \subset \mathbb{R}^n\setminus X_T(u_T)\right\}.</script>

<p>In the case of the examples illustrated in Figures 3 and 4,
we can see in the videos 3 below, examples of different initial conditions whose solution coincides with $u_T^\ast$ at time $T$.
These exmaples have been generated randomly by adding to $\tilde{u}_0$ a nonegative a Lipschitz function vanishing in $X_T(u_T^\ast)$.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/05_Vid2.gif" alt="1D random examples" height="300" width="400" /> 
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/06_Vid3.gif" alt="1D random examples 2" height="300" width="400" /> 
</figure>
</center>

<center>
<strong> Video 3: </strong> Examples of initial data $u_0\in I_T(u_T^\ast)$ for the reconstruction schemes depicted in Figures 3 and 4.
</center>

<p>A possible interpretation of this reconstruction result is that the initial datum can only be reconstructed in the region $X_T(u_T^\ast)$, where it is uniquely determined by $\tilde{u}_0$,
while in the region $\mathbb{R}^n\setminus X_T(u_T^\ast)$, only a lower bound can be deduced.
In this last region, we can say that the information of the initial data has been partially lost after the time-interval $[0,T]$.
In the case of smooth solutions (when they exists) we have backward uniqueness, i.e. $I_T(u_T)$ is either empty or a singleton (see [1]).
In this case it holds that $X_T(u_T)=\mathbb{R}^n$.</p>

<p>Next, we see the reconstruction schemes for the examples depicted in Video 2, that correspond to the projection on the set of admissible observations of $u_T$ from Figure 2.
Observe the different structure of the set $\mathbb{R}^n\setminus X_T(u_T^\ast)$ (white region in the plot at the right)
in the surrounding area of bumps and wells of $u_T^\ast$.</p>
<ul>
  <li>Near a bump, the set where $u_T^\ast$ is not differentiable is an isolated point, and then, it produces a ball for the set $\mathbb{R}^n\setminus X_T(u_T^\ast)$.</li>
  <li>Near a well, $u_T^\ast$ is non-differentiable on a circumference. This produces an annulus for the set $\mathbb{R}^n\setminus X_T(u_T^\ast)$.</li>
</ul>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/09_Fig22.png" alt="2D reconstruction 1" height="200" width="700" /> 
</figure>
</center>

<center>
<strong> Figure 5: </strong> Reconstruction scheme for the admissible target obtained in Video 2 at the left.
</center>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/10_Fig23.png" alt="2D reconstruction 2" height="200" width="700" /> 
</figure>
</center>

<center>
<strong> Figure 6: </strong> Reconstruction scheme for the admissible target obtained in Video 2 at the right.
</center>

<h3 id="evolution-of-x_tu_t">Evolution of $X_T(u_T)$</h3>

<p>As we have seen in the previous section, given an admissible observation $u_T$ of the solution at time $T$,
the initial datum can only be reconstructed in a region $X_T(u_T)$, while in its complementary, only a lower bound can be obtained.
Here, we are interested in the  the role that $T$ plays in this reconstruction issue.
For this purpose, we fix an initial datum $u_0$ and then, for each $T&gt;0$,
we construct the set $X_T(u_T)$, where $u_T := S_T^+ u_0$.</p>

<p>Our goal is to observe how $X_T(u_T)$ evolves as we increase $T$,
or in other words, we want to know what information from $u_0$ can be recoverd when the solution is observed at time $T$.
As we see in the following videos, $X_T(u_T)$ becomes smaller as we increase $T$, meaning that less information from the initial datum can be recovered if the observation is made after a long time interval.</p>

<p>In Figure 7 we fix two initial data in dimension 1.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/11_Fig31.png" alt="1D initial data" height="200" width="700" /> 
</figure>
</center>

<center>
<strong> Figure 7: </strong> Two initial data in dimension 1.
</center>

<p>Next, we can see in in Video 4, how the reconstruction scheme for $u_0$ (at the left in Figure 7) evolves as we increase the observation time.
For $T$ small, very little information is lost, however, for $T$ large, $X_T(u_T)$ only intersects the nonpositive region of $u_0$, and therefore, the two bumps can no longer be reconstructed.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/12_Vid5Gif.gif" alt="1D reconstruction evolution" height="200" width="700" /> 
</figure>
</center>

<center>
<strong> Video 4: </strong> Evolution of the target and the reconstruction scheme for the initial datum at the left in Figure 7.
</center>

<p>In Video 5, we see the evolution of the reconstruction scheme for $u_0$ at the right in Figure 7.
In this case, $u_0$ is constituted of two wells, however, if the observation is made at time $T$ large enough, only the deepest well can be identified.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/13_Vid6Gif.gif" alt="1D reconstruction evolution2" height="200" width="700" /> 
</figure>
</center>

<center>
<strong> Video 5: </strong> Evolution of the target and the reconstruction scheme for the initial datum at the right in Figure 7.
</center>

<p>We end this blog post with three examples in the two-dimensional case.
Here we have the three examples of initial data that we have considered.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/14_Fig41.png" alt="2D initial data" height="200" width="700" /> 
</figure>
</center>

<center>
<strong> Figure 8: </strong> Three initial data in dimension 2.
</center>

<p>In Video 6, we see the evolution of the reconstruction scheme for our first 2-dimensional example.
In this case, $u_0$ has a well and a bump. We observe that, as we increase the observation time $T$,
the white region, which corresponds to $\mathbb{R}^n\setminus X_T(u_T)$ becomes bigger and bigger.
This corresponds to the fact that, when the observation is made after a long time-interval, less information from the initial datum can be recovered. In addition, if we look at $u_T^\ast$ and $\tilde{u}_0$ in the two first plots, we see that the bump disappears for $T$ large enough.
This implies that after a long time-interval, the bump cannot be reconstructed.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/15_Vid7Gif.gif" alt="2D reconstruction evolution 1" height="250" width="750" /> 
</figure>
</center>

<center>
<strong> Video 6: </strong> Evolution of the reconstruction scheme for the first initial datum in Figure 8.
</center>

<p>In Video 7, we see the evolution of the reconstruction scheme for the second example in Figure 8.
Here, the initial datum has two bumps of different height but same shape and size in their support.
Observe that, when $T$ is large enough, both bumps look the same, and therefore we cannot guess which one was taller at $t=0$. In fact, only the shape of their support can be reconstructed.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/16_Vid8Gif.gif" alt="2D reconstruction evolution 2" height="250" width="750" /> 
</figure>
</center>

<center>
<strong> Video 7: </strong> Evolution of the reconstruction scheme for the second initial datum in Figure 8.
</center>

<p>In Video 8, we see the evolution of the reconstruction scheme for the third example in Figure 8.
Here, the initial datum has two wells of different depth.
We observe the same behaviour as in Video 5, where only the information of the deepest well is preserved for $T$ large enough.</p>

<center>
<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0010/17_Vid9Gif.gif" alt="2D reconstruction evolution 3" height="250" width="750" /> 
</figure>
</center>

<center>
<strong> Video 8: </strong> Evolution of the reconstruction scheme for the third initial datum in Figure 8.
</center>

<h3 id="references">References</h3>

<p>[1] E. Barron, P. Cannarsa, R. Jensen, C. Sinestrari, <i> Regularity of Hamilton-Jacobi equations when forward is backward</i>. Indiana University mathematics journal, pages 385-409, 1999.</p>

<p>[2] P. Cannarsa, C. Sinestrari, <i> Semiconcave functions, Hamilton-Jacobi equations, and optmial control</i>. volume 58. Springer Science &amp; Business Media, 2004.</p>

<p>[3] C. Esteve, E. Zuazua, <i> The inverse problem for Hamilton-Jacobi equations and semiconcave envelopes</i>. Preprint &lt;https://arxiv.org/abs/2003.06914</p>

<p>[4] P.L. Lions, <i> Generalized solutions of Hamilton-Jacobi equations</i>. volume 69. London Pitman, 1982.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;div class="card" style="border: 1px solid black;padding:auto;margin:10px;background-color:#a6bdd1"&gt;
&lt;div class="card-body" style="margin: inherit;"&gt;
&lt;h5 class="card-title"&gt;Control of reaction-diffusion&lt;/h5&gt;
&lt;p class="card-text"&gt;This is a post in a collection of several on control of reaction-diffusion under state constraints&lt;/p&gt;
&lt;a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0007" class="btn btn-primary"&gt;See more ...&lt;/a&gt;
&lt;/div&gt;
</code></pre>
</div>
<p>&lt;/div&gt;</p>

<p>In this tutorial, we will present how to generate admissible paths of steady states for the homogeneous reaction-diffusion equation:</p>

<script type="math/tex; mode=display">\begin{cases}
u_t-\Delta u=u(1-u)(u-\theta)\quad (x,t)\in \Omega\times(0,T),\\
u=a(x,t)\qquad \qquad\qquad\qquad(x,t)\in \partial\Omega\times(0,T),\\
 0\leq u(x,0)\leq 1.
\end{cases}</script>

<p>This a key argument for ensuring controllability that has been studied in [2,3,4,5].</p>

<h2 id="stair-case-method">Stair-case method</h2>
<p>The stair-case method (see [1]) guarantees the following:</p>

<p>If we have an admissible continuous path of steady states, for any initial datum in the path, any target function in the path and for $T&gt;0$ sufficiently large, there exists a function $a$ such that drives the system from the initial datum to the target fulfilling the state-constraints along the trajectory.</p>

<center>
<img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0005/figures/Plot_Staircase.png" width="350" height="300" />
</center>
<center><b>Figure 1.</b> Qualitative understanding of the Stair-case method. When we have a continuous admissible path of steady-states, one can find a control that is connecting the initial steady state with the target by "jumping" along the continuous path.</center>

<h2 id="extension-to-ball-and-the-phase-plane-analysis">Extension to ball, and the phase-plane analysis</h2>

<p>We will restrict ourselves to the construction of paths that connect the steady state $w\equiv 0$ with the steady state $w\equiv \theta$. For doing such example with our model bistable equation.</p>

<p>In order to construct the paths we will use phase-plane techniques for which we use radial coordinates. Our original domain might not be a ball, for this reason we extend it to a ball and firstly construct the path there.</p>

<center>
<img width="25%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0005/figures/ballE-1.png" />
</center>
<center><b>Figure 2.</b> Extension of our domain to a ball.</center>

<p>Remind that the important issue is to be able to guarantee that for every domain $w\equiv0$ and $w\equiv\theta$ are connected in an admissable way and this is seen in the phase plane representation of the elliptic equation.</p>

<p><script type="math/tex">-u_{rr}-\frac{N-1}{r}u_r=u(1-u)(u-\theta),</script>
<script type="math/tex">u(0)=a,</script>
<script type="math/tex">u_r(0)=0.</script></p>

<p>Now, considering the energy
<script type="math/tex">E(u,v)=\frac{1}{2}v^2+F(u)</script></p>

<p>where $F(u)=\int_0^u f(s)ds$, one can see that the radial ODE dissipates.</p>

<p>Define the following region:
<script type="math/tex">D:=\left\{(u,v)\in\mathbb{R}^2 \quad \text{such that}\quad E(u,v)\leq 0\right\}</script>
Let $\theta_1$ be defined as:
<script type="math/tex">\theta_1=\min_{s>0}\{F(s)=0\}</script></p>

<p>Note that the region defined by 
<script type="math/tex">\Gamma:=\left\{(u,v)\in[0,\theta_1]\times\mathbb{R}\quad\text{such that}\quad |v|\leq \sqrt{-2F(u)}\right\}</script>
Note that $\Gamma\subset D$.</p>

<p>Take $(u_0,0)\in \Gamma$, then the solution of the radial equation with initial
datum $(u_0,0)$ satisfies:</p>

<script type="math/tex; mode=display">% <![CDATA[
\frac{d}{dr}E(u,v)=vv_r+f(u)v=-\frac{N-1}{r}v^2<0 %]]></script>

<p>So $(u,v)\in\Gamma$ for all $r&gt;0$.</p>

<p>We have that the blue line (the border of $\Gamma$) in the following figure determines a positively invariant region.</p>

<p>Then, making $a$ change continuously from $0$ to $\theta$ we generate a continuous path (by the Gromwall inequality) that is admissible since the invariant region $\Gamma$ is inside the admissible set.</p>

<center>
<img width="60%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0005/figures/ContinuousPathinthePhaseSpace-1.png" />
</center>
<center><b>Figure 3.</b> Invariant region and construction of the path.</center>

<h2 id="animation-of-the-path">Animation of the path</h2>

<center>
<video width="80%" controls="">
  <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0005/figures/video.mp4" type="video/mp4" />
</video>
</center>
<center><b>Figure 4.</b> Path of steady states.</center>

<p>If our domain is not a ball we restrict our path to the original domin to obtain the desired path.</p>

<h2 id="other-features">Other features</h2>

<p>General existence of admisible paths is not true due to the comparison principle. Non-trivial steady states can exist that block any possibity to control.</p>

<p>Here we restrict ourselves in the one dimensional case. In the following figure one can see how can we connect the steady state $w\equiv 0$ with the first nontrivial solution with boundary value $0$.</p>

<center>

<table>
    <tr>
        <th>
            <img width="80%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0005/figures/Lcomp-1.png" />
        </th>
         <th>
            <img width="80%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0005/figures/Lcomp2-1.png" />
                    </th>       
    </tr>
</table>
</center>

<center><b>Figure 5.</b> Path of steady states.</center>

<p>However, since this path touches the boundary of the admissible set controllability cannot be guaranteed due to the comparison principle.</p>

<p>Another important remark to be mentioned is that if we forget about the state constraints, more paths can be generated, provided that the ODE representation of the elliptic equation does not blow up. The following figure is an example of a path connecting $w\equiv 0$ with $w\equiv 1$ that violates the constraints:</p>

<center>
<table>
    <tr>
        <th>
            <img width="80%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0005/figures/completepath02L12-1.png" />
        </th>
         <th>
            <img width="80%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0005/figures/Completepath01L12-1.png" />
                    </th>       
    </tr>
</table>
</center>
<center><b>Figure 6.</b> Path of steady states violating constraints.</center>

<h2 id="references">References:</h2>

<p>[1] D. Pighin, E. Zuazua, Controllability under positivity constraints of multi-d wave equations, in:
Trends in Control Theory and Partial Differential Equations, Springer, 2019, pp. 195–232.</p>

<p>[2] J.-M. Coron, E. Trélat, Global steady-state controllability of one-dimensional semilinear heat equa-
tions, SIAM J. Control. Optim. 43 (2) (2004) 549–569.</p>

<p>[3] C. Pouchol, E. Trélat, E. Zuazua, Phase portrait control for 1d monostable and bistable reac-
635
tion–diffusion equations, Nonlinearity 32 (3) (2019) 884–909.</p>

<p>[4]   D.  Ruiz-Balet  and  E.  Zuazua. Controllability  under  constraints  for  reaction-diffusionequations:   The  multi-dimensional  case.   Preprint  available  athttps://cmc.deusto.eus/domenec-ruiz-balet/.</p>

<p>[5] D.  Ruiz-Balet  and  E.  Zuazua. Control of certain parabolic models from biology and social sciences.   Preprint  available  at https://cmc.deusto.eus/domenec-ruiz-balet/.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this tutorial, we present how to use Pontryagin environment to control a consensus system that models the complex emergent dynamics over a given network. The control basically minimize the cost functional which contains the running cost and desired final state.&lt;/p&gt;
</code></pre>
</div>

<h3 id="setup">Setup</h3>

<p>In this tutorial we need <a href="https://deustotech.github.io/dycon-toolbox-documentation/">DyCon Toolbox</a>, to install it we will have to write the following in our MATLAB console:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">unzip</span><span class="p">(</span><span class="s1">'https://github.com/DeustoTech/DyCon-Computational-Platform/archive/master.zip'</span><span class="p">)</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="nb">cd</span><span class="p">,</span><span class="s1">'DyCon-toolbox-master'</span><span class="p">)))</span>
<span class="n">StartDyConToolbox</span>    
</code></pre>
</div>

<p>You can see the code of this tutorial write the following line:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">open</span> <span class="n">T06ODET0004_Kuramoto</span>   
</code></pre>
</div>
<h3 id="model">Model</h3>

<p>The Kuramoto model describes the phases $\theta_i$ of active oscillators, which is described by the following dynamics:</p>

<script type="math/tex; mode=display">\dot \theta_i = \omega_i + \frac{1}{N}\sum_{j=1}^N K_{i,j} \sin(\theta_j-\theta_i),\quad i =1,\cdots,N.</script>

<p>Here, the first constant terms $\omega_i$ denote the natural oscillatory behaviors, and the interactions are nonlinearly affected by the relative phases. The amplitude and connections of interactions are determined by the coupling strength, $K_{i,j}$.</p>

<h3 id="control-strategy">Control strategy</h3>

<p>The control interface is on the coupling strength as follows:</p>

<script type="math/tex; mode=display">\dot \theta_i(t) = \omega_i + \frac{u(t)}{N}\sum_{j=1}^N K_{i,j} \sin(\theta_j(t)-\theta_i(t)),\quad i =1,\cdots,N.</script>

<p>This is a nonlinear version of bi-linear control problem for the Kuramoto interactions. The idea is as follows;</p>

<ol>
  <li>
    <p>There are $N$ number of oscillators, oscillating with their own natural frequencies.</p>
  </li>
  <li>
    <p>We want to make a collective behavior using their own decision process. The interaction is given by the Kuramoto model, or may follow other interaction rules. The network can be given or flexible with control.</p>
  </li>
  <li>
    <p>The cost of control will be related to the collective dynamics we want, such as the variance of frequencies or phases.</p>
  </li>
</ol>

<h3 id="numerical-simulation">Numerical simulation</h3>

<p>Here, we consider a simple problem: we control the all-to-all network system to get gathered phases at final time $T$. We first need to define the system of ODEs in terms of symbolic variables.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clear</span> <span class="nb">all</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>  <span class="c1">%% [m]: number of oscillators.</span>

<span class="nb">import</span> <span class="n">casadi</span><span class="o">.*</span>

<span class="n">t</span>     <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'t'</span><span class="p">);</span>
<span class="n">symTh</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'y'</span><span class="p">,</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>   <span class="c1">%% [y] :  phases of oscillators, $\theta_i$.</span>
<span class="n">symOm</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'om'</span><span class="p">,</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">%% [om]:  natural frequencies of osc., $\omega_i$.</span>
<span class="n">symK</span>  <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'K'</span><span class="p">,[</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">]);</span>    <span class="c1">%% [K] :  the coupling network matrix, $K_{i,j}$.</span>
<span class="n">symU</span>  <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'u'</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>    <span class="c1">%% [u] :  the control function along time, $u(t)$.</span>


<span class="n">syms</span> <span class="n">Vsys</span><span class="p">;</span>    <span class="c1">%% [Vsys]: the vector fields of ODEs.</span>
<span class="n">symThth</span> <span class="o">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">symTh</span><span class="p">,[</span><span class="mi">1</span> <span class="n">m</span><span class="p">]);</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Vsys</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'V'</span><span class="p">,{</span><span class="n">symOm</span><span class="p">,</span><span class="n">symK</span><span class="p">,</span><span class="n">symTh</span><span class="p">,</span><span class="n">symU</span><span class="p">},</span> <span class="k">...</span>
<span class="p">{</span> <span class="n">symOm</span> <span class="o">+</span> <span class="p">(</span><span class="n">symU</span><span class="o">.</span><span class="p">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">symK</span><span class="o">.*</span><span class="nb">sin</span><span class="p">(</span><span class="nb">repmat</span><span class="p">(</span><span class="n">symTh</span><span class="p">,[</span><span class="mi">1</span> <span class="n">m</span><span class="p">])</span><span class="o">.'</span> <span class="o">-</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">symTh</span><span class="p">,[</span><span class="mi">1</span> <span class="n">m</span><span class="p">])),</span><span class="mi">2</span><span class="p">)</span> <span class="p">});</span> 
</code></pre>
</div>

<p>The parameter $\omega_i$ and $K_{i,j}$ should be specified for the calculations. Practically, $K_{i,j}u(t) &gt; \vert \max\Omega - \min\Omega \vert$ leads to the synchronization of frequencies. We normalize the coupling strength to 1, and give random values for the natural frequencies from the normal distribution $N(0,0.1)$. We also choose initial data from $N(0,\pi/4)$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">rng</span><span class="p">(</span><span class="s1">'default'</span><span class="p">);</span>
<span class="nb">rng</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">'twister'</span><span class="p">);</span>
<span class="n">Om_init</span> <span class="o">=</span> <span class="n">normrnd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Om_init</span> <span class="o">=</span> <span class="n">Om_init</span> <span class="o">-</span> <span class="nb">mean</span><span class="p">(</span><span class="n">Om_init</span><span class="p">);</span>  <span class="c1">%% Mean zero frequencies</span>
<span class="n">Th_init</span> <span class="o">=</span> <span class="n">normrnd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">pi</span><span class="p">/</span><span class="mi">8</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">K_init</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">);</span>                 <span class="c1">%% Constant coupling strength, 1.</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>                              <span class="c1">%% We give enough time for the frequency synchronization.</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">symF</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'F'</span><span class="p">,{</span><span class="n">t</span><span class="p">,</span><span class="n">symTh</span><span class="p">,</span><span class="n">symU</span><span class="p">},{</span><span class="n">Vsys</span><span class="p">(</span><span class="n">Om_init</span><span class="p">,</span><span class="n">K_init</span><span class="p">,</span><span class="n">symTh</span><span class="p">,</span><span class="n">symU</span><span class="p">)});</span>

<span class="n">tspan</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="mi">110</span><span class="p">);</span>
<span class="n">odeEqn</span> <span class="o">=</span> <span class="n">ode</span><span class="p">(</span><span class="n">symF</span><span class="p">,</span><span class="n">symTh</span><span class="p">,</span><span class="n">symU</span><span class="p">,</span><span class="n">tspan</span><span class="p">);</span>
<span class="n">SetIntegrator</span><span class="p">(</span><span class="n">odeEqn</span><span class="p">,</span><span class="s1">'RK4'</span><span class="p">)</span>
<span class="n">odeEqn</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="n">Th_init</span><span class="p">;</span>
</code></pre>
</div>

<p>We next construct cost functional for the control problem.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">PathCost</span>  <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'L'</span>  <span class="p">,{</span><span class="n">t</span><span class="p">,</span><span class="n">symTh</span><span class="p">,</span><span class="n">symU</span><span class="p">},{</span> <span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">symU</span><span class="o">'*</span><span class="n">symU</span><span class="p">)</span>           <span class="p">});</span>
<span class="n">FinalCost</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'Psi'</span><span class="p">,{</span><span class="n">symTh</span><span class="p">}</span>      <span class="p">,{</span>  <span class="mf">1e5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">m</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">symThth</span><span class="o">.'</span> <span class="o">-</span> <span class="n">symThth</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">))</span>  <span class="p">});</span>

<span class="n">iCP_1</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">(</span><span class="n">odeEqn</span><span class="p">,</span><span class="n">PathCost</span><span class="p">,</span><span class="n">FinalCost</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="solve-gradient-descent">Solve Gradient descent</h3>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">tic</span>
<span class="n">ControlGuess</span> <span class="o">=</span> <span class="n">ZerosControl</span><span class="p">(</span><span class="n">odeEqn</span><span class="p">);</span>
<span class="p">[</span><span class="n">OptControl_1</span> <span class="p">,</span><span class="n">OptThetaVector_1</span><span class="p">]</span> <span class="o">=</span>  <span class="n">ArmijoGradient</span><span class="p">(</span><span class="n">iCP_1</span><span class="p">,</span><span class="n">ControlGuess</span><span class="p">);</span>
<span class="nb">toc</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Length Step has been change: LenghtStep = 0.00025
iter: 001 | error: 2.215e+02 | LengthStep: 5.00e-04 | J: 1.16893e+03 | Distance2Target: NaN 
iter: 002 | error: 2.214e+02 | LengthStep: 1.00e-03 | J: 1.16780e+03 | Distance2Target: NaN 
iter: 003 | error: 2.212e+02 | LengthStep: 2.00e-03 | J: 1.16554e+03 | Distance2Target: NaN 
iter: 004 | error: 2.207e+02 | LengthStep: 4.00e-03 | J: 1.16103e+03 | Distance2Target: NaN 
iter: 005 | error: 2.198e+02 | LengthStep: 8.00e-03 | J: 1.15206e+03 | Distance2Target: NaN 
iter: 006 | error: 2.180e+02 | LengthStep: 1.60e-02 | J: 1.13430e+03 | Distance2Target: NaN 
iter: 007 | error: 2.144e+02 | LengthStep: 3.20e-02 | J: 1.09950e+03 | Distance2Target: NaN 
iter: 008 | error: 2.074e+02 | LengthStep: 6.40e-02 | J: 1.03270e+03 | Distance2Target: NaN 
iter: 009 | error: 1.938e+02 | LengthStep: 1.28e-01 | J: 9.09692e+02 | Distance2Target: NaN 
iter: 010 | error: 1.682e+02 | LengthStep: 2.56e-01 | J: 7.01968e+02 | Distance2Target: NaN 
iter: 011 | error: 1.235e+02 | LengthStep: 5.12e-01 | J: 4.10547e+02 | Distance2Target: NaN 
iter: 012 | error: 6.257e+01 | LengthStep: 1.02e+00 | J: 1.47399e+02 | Distance2Target: NaN 
Length Step has been change: LenghtStep = 0.256
iter: 013 | error: 4.113e+01 | LengthStep: 5.12e-01 | J: 1.20852e+02 | Distance2Target: NaN 
iter: 014 | error: 2.215e+01 | LengthStep: 1.02e+00 | J: 9.58348e+01 | Distance2Target: NaN 
Length Step has been change: LenghtStep = 0.256
Length Step has been change: LenghtStep = 0.064
Length Step has been change: LenghtStep = 0.016
Length Step has been change: LenghtStep = 0.004
Length Step has been change: LenghtStep = 0.001
Length Step has been change: LenghtStep = 0.00025
Length Step has been change: LenghtStep = 6.25e-05
Length Step has been change: LenghtStep = 1.5625e-05
Length Step has been change: LenghtStep = 3.9063e-06
Length Step has been change: LenghtStep = 9.7656e-07
Length Step has been change: LenghtStep = 2.4414e-07
Length Step has been change: LenghtStep = 6.1035e-08
Length Step has been change: LenghtStep = 1.5259e-08
Length Step has been change: LenghtStep = 3.8147e-09

    Mininum Length Step have been achive !! 

Elapsed time is 2.131655 seconds.

</code></pre>
</div>

<h3 id="visualization">Visualization</h3>

<p>First, we present the dynamics without control,</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">FreeThetaVector</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">odeEqn</span><span class="p">,</span><span class="n">ControlGuess</span><span class="p">);</span>
<span class="n">FreeThetaVector</span> <span class="o">=</span> <span class="nb">full</span><span class="p">(</span><span class="n">FreeThetaVector</span><span class="p">);</span>
<span class="nb">figure</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">FreeThetaVector</span><span class="o">'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [rad]'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'The dynamics without control (incoherence)'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0007/copiaRM_01.png" alt="" /></p>

<p>and see the controled dynamics.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">OptThetaVector_1</span><span class="o">'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [rad]'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="err">"</span><span class="n">The</span> <span class="n">dynamics</span> <span class="n">under</span> <span class="n">control</span> <span class="n">L</span><span class="o">^</span><span class="mi">2</span> <span class="o">|</span> <span class="n">N_</span><span class="p">{</span><span class="n">osc</span><span class="p">}</span><span class="o">=</span><span class="err">"</span><span class="o">+</span><span class="n">m</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0007/copiaRM_02.png" alt="" /></p>

<p>We also can plot the control function along time.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">OptControl_1</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="err">"</span><span class="nb">norm</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">=</span> <span class="err">"</span><span class="o">+</span><span class="nb">norm</span><span class="p">(</span><span class="n">OptControl_1</span><span class="p">))</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'u(t)'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'The control function'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0007/copiaRM_03.png" alt="" /></p>

<h3 id="the-problem-with-different-regularization">The problem with different regularization</h3>

<p>In this part, we change the regularization into $L^1$-norm and see the difference.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">PathCost</span>  <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'L'</span>  <span class="p">,{</span><span class="n">t</span><span class="p">,</span><span class="n">symTh</span><span class="p">,</span><span class="n">symU</span><span class="p">},{</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">symU</span><span class="o">.^</span><span class="mi">2</span><span class="o">+</span><span class="mf">1e-3</span><span class="p">)});</span>
<span class="n">iCP_2</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">(</span><span class="n">odeEqn</span><span class="p">,</span><span class="n">PathCost</span><span class="p">,</span><span class="n">FinalCost</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">tic</span>
<span class="p">[</span><span class="n">OptControl_2</span> <span class="p">,</span><span class="n">OptThetaVector_2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">ArmijoGradient</span><span class="p">(</span><span class="n">iCP_2</span><span class="p">,</span><span class="n">ControlGuess</span><span class="p">);</span>
<span class="nb">toc</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Length Step has been change: LenghtStep = 0.00025
iter: 001 | error: 2.363e+01 | LengthStep: 5.00e-04 | J: 1.11735e+02 | Distance2Target: NaN 
iter: 002 | error: 2.363e+01 | LengthStep: 1.00e-03 | J: 1.11730e+02 | Distance2Target: NaN 
iter: 003 | error: 2.361e+01 | LengthStep: 2.00e-03 | J: 1.11720e+02 | Distance2Target: NaN 
iter: 004 | error: 2.359e+01 | LengthStep: 4.00e-03 | J: 1.11699e+02 | Distance2Target: NaN 
iter: 005 | error: 2.353e+01 | LengthStep: 8.00e-03 | J: 1.11659e+02 | Distance2Target: NaN 
iter: 006 | error: 2.343e+01 | LengthStep: 1.60e-02 | J: 1.11579e+02 | Distance2Target: NaN 
iter: 007 | error: 2.322e+01 | LengthStep: 3.20e-02 | J: 1.11420e+02 | Distance2Target: NaN 
iter: 008 | error: 2.282e+01 | LengthStep: 6.40e-02 | J: 1.11109e+02 | Distance2Target: NaN 
iter: 009 | error: 2.208e+01 | LengthStep: 1.28e-01 | J: 1.10509e+02 | Distance2Target: NaN 
iter: 010 | error: 2.081e+01 | LengthStep: 2.56e-01 | J: 1.09388e+02 | Distance2Target: NaN 
iter: 011 | error: 1.890e+01 | LengthStep: 5.12e-01 | J: 1.07391e+02 | Distance2Target: NaN 
iter: 012 | error: 1.674e+01 | LengthStep: 1.02e+00 | J: 1.04033e+02 | Distance2Target: NaN 
iter: 013 | error: 1.607e+01 | LengthStep: 2.05e+00 | J: 9.86861e+01 | Distance2Target: NaN 
iter: 014 | error: 4.081e+01 | LengthStep: 4.10e+00 | J: 9.24707e+01 | Distance2Target: NaN 
Length Step has been change: LenghtStep = 1.024
Length Step has been change: LenghtStep = 0.256
Length Step has been change: LenghtStep = 0.064
Length Step has been change: LenghtStep = 0.016
Length Step has been change: LenghtStep = 0.004
Length Step has been change: LenghtStep = 0.001
Length Step has been change: LenghtStep = 0.00025
Length Step has been change: LenghtStep = 6.25e-05
Length Step has been change: LenghtStep = 1.5625e-05
Length Step has been change: LenghtStep = 3.9063e-06
Length Step has been change: LenghtStep = 9.7656e-07
Length Step has been change: LenghtStep = 2.4414e-07
Length Step has been change: LenghtStep = 6.1035e-08
Length Step has been change: LenghtStep = 1.5259e-08
Length Step has been change: LenghtStep = 3.8147e-09

    Mininum Length Step have been achive !! 

Elapsed time is 2.494788 seconds.

</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span>

<span class="nb">line</span><span class="p">(</span><span class="n">tspan</span><span class="p">,</span><span class="n">OptThetaVector_2</span><span class="o">'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [rad]'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="err">"</span><span class="n">The</span> <span class="n">dynamics</span> <span class="n">under</span> <span class="n">control</span> <span class="n">L</span><span class="o">^</span><span class="mi">1</span> <span class="o">|</span> <span class="n">N_</span><span class="p">{</span><span class="n">osc</span><span class="p">}</span><span class="o">=</span><span class="err">"</span><span class="o">+</span><span class="n">m</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0007/copiaRM_04.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">OptControl_1</span><span class="p">)</span>
<span class="nb">line</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">OptControl_2</span><span class="p">),</span><span class="n">OptControl_2</span><span class="p">,</span><span class="s1">'Color'</span><span class="p">,</span><span class="s1">'red'</span><span class="p">)</span>

<span class="n">Psi_1</span> <span class="o">=</span> <span class="nb">norm</span><span class="p">(</span><span class="nb">sin</span><span class="p">(</span><span class="n">OptThetaVector_1</span><span class="p">(:,</span><span class="k">end</span><span class="p">)</span><span class="o">.</span><span class="s1">' - OptThetaVector_1(:,end)),'</span><span class="n">fro</span><span class="o">'</span><span class="p">);</span>
<span class="n">Psi_2</span> <span class="o">=</span> <span class="nb">norm</span><span class="p">(</span><span class="nb">sin</span><span class="p">(</span><span class="n">OptThetaVector_2</span><span class="p">(:,</span><span class="k">end</span><span class="p">)</span><span class="o">.</span><span class="s1">' - OptThetaVector_2(:,end)),'</span><span class="n">fro</span><span class="o">'</span><span class="p">);</span>

<span class="nb">legend</span><span class="p">(</span><span class="err">"</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">with</span> <span class="n">L</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="nb">norm</span><span class="p">;</span> <span class="n">Terminal</span> <span class="n">cost</span> <span class="o">=</span> <span class="err">"</span><span class="o">+</span><span class="n">Psi_1</span><span class="p">,</span><span class="err">"</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">with</span> <span class="n">L</span><span class="o">^</span><span class="mi">1</span><span class="o">-</span><span class="nb">norm</span><span class="p">;</span> <span class="n">Terminal</span> <span class="n">cost</span> <span class="o">=</span> <span class="err">"</span><span class="o">+</span><span class="n">Psi_2</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'The coupling strength (u(t))'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'The comparison between two different control cost functionals'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0007/copiaRM_05.png" alt="" /></p>

<p>As one can expected from the regularization functions, the control function from $L^2$-norm acting more smoothly from $0$ to the largest value. The function from $L^2$-norm draws much stiff lines.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">YFr</span> <span class="o">=</span> <span class="n">FreeThetaVector</span><span class="o">'</span><span class="p">;</span>
<span class="n">YL1</span> <span class="o">=</span> <span class="n">OptThetaVector_1</span><span class="o">'</span><span class="p">;</span>
<span class="n">YL2</span> <span class="o">=</span> <span class="n">OptThetaVector_2</span><span class="o">'</span><span class="p">;</span>
<span class="c1">%%</span>
<span class="n">animationpendulums</span><span class="p">({</span><span class="n">YFr</span><span class="p">,</span><span class="n">YL1</span><span class="p">,</span><span class="n">YL2</span><span class="p">},</span><span class="n">tspan</span><span class="p">,{</span><span class="s1">'Free'</span><span class="p">,</span><span class="s1">'L^2 Control'</span><span class="p">,</span><span class="s1">'L^1 Control'</span><span class="p">})</span>
</code></pre>
</div>

<p>Finally, we can see the behavior of the two control types against the evolution of free dynamics.</p>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0007/animation.gif" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this tutorial we will present a simultaneous control problem in a linear system dependent on parameters. We will use the MATLAb DyCon Toolbox library.&lt;/p&gt;
</code></pre>
</div>

<h3 id="setup">Setup</h3>

<p>In this tutorial we need <a href="https://deustotech.github.io/dycon-toolbox-documentation/">DyCon Toolbox</a>, to install it we will have to write the following in our MATLAB console:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">unzip</span><span class="p">(</span><span class="s1">'https://github.com/DeustoTech/DyCon-Computational-Platform/archive/master.zip'</span><span class="p">)</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="nb">cd</span><span class="p">,</span><span class="s1">'DyCon-toolbox-master'</span><span class="p">)))</span>
<span class="n">StartDyConToolbox</span>    
</code></pre>
</div>
<p>You can see the code of this tutorial write the following line:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">open</span> <span class="n">T06ODET0002_Simultaneous</span>   
</code></pre>
</div>
<h3 id="problem-definition">Problem definition</h3>

<p>The simultaneous control problem is defined as:</p>

<script type="math/tex; mode=display">\min _{u \in L^2(0,T)} \mathcal{J}\left( u\right) = 
\min _{u \in L^2(0,T)} \frac{1}{2}  \sum_{\nu \in \mathcal{K}}  || x\left( T, \nu \right) - x_T ||_{\mathbb{R}^ N}^2  + 
\frac{\beta}{2} \int_0^T u^2 \mathrm{d}t \quad \beta \in \mathbb{R}^+</script>

<p>subject to:</p>

<script type="math/tex; mode=display">% <![CDATA[
\left\{
\begin{array}{ll}
x^\prime \left( t \right) = A \left( \nu \right) x \left( t \right) + B \left( \nu \right) u \left( t \right), \quad 0 < t <T, \\
x\left( 0 \right) = x^0.
\end{array}
\right. %]]></script>

<p>where:</p>

<script type="math/tex; mode=display">\mathcal{K}= \left\{ \nu_i \in \mathbb{R}, \enspace 1\leq i \leq K \right\}</script>

<h3 id="numerical-implementation">Numerical Implementation</h3>

<p>First we import the CasAdi library in order to create symbolic variables</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">import</span> <span class="n">casadi</span><span class="o">.*</span>
<span class="c1">%% In this case $\nu_i$ are</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="n">nu</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="n">M</span><span class="p">);</span>
</code></pre>
</div>
<p>Then we create the matrices of linear dynamics.</p>

<script type="math/tex; mode=display">% <![CDATA[
A_\nu = \begin{bmatrix}
  -\nu & 1 \\
  0    & -\nu
\end{bmatrix} \ \ \ 
B_\nu = \begin{bmatrix}
0 \\
1 
\end{bmatrix} %]]></script>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">]</span> <span class="o">=</span> <span class="n">GenMatSim</span><span class="p">(</span><span class="n">nu</span><span class="p">);</span>
</code></pre>
</div>

<p>With these matrices we create the <code class="highlighter-rouge">ode</code> object</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Nt</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span><span class="n">T</span>  <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
<span class="n">tspan</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="c1">%% create linear dynamic</span>
<span class="n">iode</span> <span class="o">=</span> <span class="n">linearode</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">tspan</span><span class="p">);</span>
<span class="c1">%% set initial condition</span>
<span class="n">Y0</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">iode</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">Y0</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>then we create the optimal control problem</p>
<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">% Get Symbolical variable</span>
<span class="n">Ys</span>  <span class="o">=</span> <span class="n">iode</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">sym</span><span class="p">;</span>
<span class="n">Us</span>  <span class="o">=</span> <span class="n">iode</span><span class="o">.</span><span class="n">Control</span><span class="o">.</span><span class="n">sym</span><span class="p">;</span>
<span class="n">ts</span>  <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'t'</span><span class="p">);</span> <span class="c1">%% &lt;= Create a symbolical time</span>
<span class="c1">% Set Target</span>
<span class="n">YT</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span><span class="n">YT</span> <span class="o">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">YT</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">%</span>
<span class="n">PathCost</span>  <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'L'</span>  <span class="p">,{</span><span class="n">ts</span><span class="p">,</span><span class="n">Ys</span><span class="p">,</span><span class="n">Us</span><span class="p">},{</span> <span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Us</span><span class="o">'*</span><span class="n">Us</span><span class="p">)</span>           <span class="p">});</span>
<span class="n">FinalCost</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'Psi'</span><span class="p">,{</span><span class="n">Ys</span><span class="p">}</span>      <span class="p">,{</span>  <span class="mf">1e7</span><span class="o">*</span><span class="p">((</span><span class="n">Ys</span><span class="o">-</span><span class="n">YT</span><span class="p">)</span><span class="o">.'*</span><span class="p">(</span><span class="n">Ys</span><span class="o">-</span><span class="n">YT</span><span class="p">))</span> <span class="p">});</span>
<span class="c1">% Create the optimal control</span>
<span class="n">iocp</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">(</span><span class="n">iode</span><span class="p">,</span><span class="n">PathCost</span><span class="p">,</span><span class="n">FinalCost</span><span class="p">);</span>
</code></pre>
</div>

<p>Solve Optimal Control Problem with ipopt solver</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">U0</span> <span class="o">=</span> <span class="n">ZerosControl</span><span class="p">(</span><span class="n">iode</span><span class="p">);</span>
<span class="p">[</span><span class="n">Uopt</span> <span class="p">,</span><span class="n">Yopt</span><span class="p">]</span> <span class="o">=</span>  <span class="n">IpoptSolver</span><span class="p">(</span><span class="n">iocp</span><span class="p">,</span><span class="n">U0</span><span class="p">);</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>This is Ipopt version 3.12.3, running with linear solver mumps.
NOTE: Other linear solvers might be more efficient (see Ipopt documentation).

Number of nonzeros in equality constraint Jacobian...:   199700
Number of nonzeros in inequality constraint Jacobian.:        0
Number of nonzeros in Lagrangian Hessian.............:      600

Total number of variables............................:    50500
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:    50000
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.0000000e+09 1.12e-02 7.88e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  4.0934345e+06 1.26e-13 5.63e-09  -1.0 1.66e+02    -  1.00e+00 1.00e+00f  1

Number of Iterations....: 1

                                   (scaled)                 (unscaled)
Objective...............:   2.0467172272726700e+01    4.0934344545453396e+06
Dual infeasibility......:   5.6305735629536002e-09    1.1261147125907198e-03
Constraint violation....:   1.2612133559741778e-13    1.2612133559741778e-13
Complementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00
Overall NLP error.......:   5.6305735629536002e-09    1.1261147125907198e-03


Number of objective function evaluations             = 2
Number of objective gradient evaluations             = 2
Number of equality constraint evaluations            = 2
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 2
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 1
Total CPU secs in IPOPT (w/o function evaluations)   =      1.391
Total CPU secs in NLP function evaluations           =      0.027

EXIT: Optimal Solution Found.
               t_proc [s]   t_wall [s]    n_eval
       nlp_f     0.000381      0.00038         2
       nlp_g       0.0042       0.0042         2
  nlp_grad_f      0.00167      0.00167         3
  nlp_hess_l      0.00331      0.00332         1
   nlp_jac_g        0.026        0.026         3
      solver         1.48         1.36         1
Elapsed time is 3.853462 seconds.

</code></pre>
</div>

<p>Compute Free solution</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Yfree</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">iode</span><span class="p">,</span><span class="n">U0</span><span class="o">*</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Yfree</span> <span class="o">=</span> <span class="nb">full</span><span class="p">(</span><span class="n">Yfree</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="visualization">Visualization</h3>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">fig</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="n">fig</span><span class="o">.</span><span class="n">Units</span> <span class="o">=</span> <span class="s1">'norm'</span><span class="p">;</span><span class="n">fig</span><span class="o">.</span><span class="n">Position</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span> <span class="mf">0.1</span> <span class="mf">0.6</span> <span class="mf">0.5</span><span class="p">];</span>
<span class="c1">%%</span>
<span class="n">plotSimu</span><span class="p">(</span><span class="n">tspan</span><span class="p">,</span><span class="n">Yfree</span><span class="p">,</span><span class="n">Yopt</span><span class="p">,</span><span class="n">Uopt</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP01/P0009/copiaRM_01.png" alt="" /></p>

<center><b>Figure 1. </b>The different colors represent the dynamic system under different parameters. It can be seen how the same control is obtained acting for all the dynamic systems is capable of driving the systems to the target.</center>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;div class="card" style="border: 1px solid black;padding:auto;margin:10px;background-color:#a6bdd1"&gt;
&lt;div class="card-body" style="margin: inherit;"&gt;
&lt;h5 class="card-title"&gt;Control of reaction-diffusion&lt;/h5&gt;
&lt;p class="card-text"&gt;This is a post in a collection of several on control of reaction-diffusion under state constraints&lt;/p&gt;
&lt;a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0007" class="btn btn-primary"&gt;See more ...&lt;/a&gt;
&lt;/div&gt;
</code></pre>
</div>
<p>&lt;/div&gt;</p>

<p>This tutorial is focused on the understanding of of the problem</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
   -\Delta u=f(u)      &   x\in\Omega     \\
    0< u< 1            &   x\in\Omega              \\
    u=a\in\{0,\theta\} &   x\in\partial\Omega 
\end{cases} %]]></script>

<p>The solutions for $a=0$ constitute an intrinsic obstruction to the controllability with state-constraints due to the comparison principle [1]. Indeed, for any control function $0\leq a(x,t)\leq 1$
the solution of the problem:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
    v_t-\Delta v=f(v) & x\in\Omega\times(0,T) \\
 v=a(x,t) & x\in\partial\Omega\times(0,T) \\
 v(x,0)\geq u & x\in\Omega
\end{cases} %]]></script>

<p>where $u$ is an elliptic nontrivial solution satisfies that $v(x,t)\geq u(x)$. Therefore, we cannot expect to control to any function below $u$.</p>

<p>This is why the understanding of the existence or non-existence of nontrivial solutions is of main importance for the controllability under state-constraints.</p>

<p>Non-trivial solutions around the boundary value $a=\theta$ do not constitute an intrinsic obstruction to the controllability because the boundary value $\theta$ is not in the border of the admissible set. However, the existence of such solutions create a technical difficulty for achieving the controllability to the steady state $w\equiv \theta$ which can be solved by constructing paths of steady states (See <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0005">this blog entry </a>).</p>

<p>Elliptic nontrivial solutions with boundary value 1 do not exist. This can be related to the fact that the traveling waves for the Cauchy problem in the real line are approaching the steady state $w\equiv 1$ [2]</p>

<p>The existence of non-trivial solutions can be done either by comparison principles or by understanding the critical points of a functional (see [3]).</p>

<p>Any critical point of the functional:</p>

<script type="math/tex; mode=display">J: H^1_0\to  \mathbb{R}</script>

<script type="math/tex; mode=display">J(u)=\int_\Omega \frac{1}{2}|\nabla u|^2-\int_0^uf(s)ds dx</script>

<p>is a weak solution of the main equation.</p>

<p>In order to guarantee that the solution will be between $0$ and $1$, one can extend $f$ by $0$ outside of the interval $[0,1]$.</p>

<p>Restricting ourselves in the one dimensional case (the argument also holds in several dimensions) and making the spatial change fo variables $x\to \frac{x}{L}$, where $L$ is the length of the domain the functional reads:</p>

<script type="math/tex; mode=display">J(u)=\int_0^1 \frac{1}{2}| u_x|^2-L^2\int_0^uf(s)ds dx</script>

<p>In the expression above we see that if $L$ is small the convex part dominates while if $L$ is large and $\int_0^1f(s)ds&gt;0$ it might not be convex.</p>

<p>In the videos below one can see the evolution of the functional depending on the parameter $\lambda=L^2$. The representation is the evaluation of the functional along the first and the third eigenfunction, i.e. $e_1=\sin(\pi x)$ and $e_3=\sin(3\pi x)$,</p>

<script type="math/tex; mode=display">J(\alpha e_1+\beta e_3)=\int_0^1 \frac{1}{2}| (\alpha e_1+\beta e_3)_x|^2-L^2\int_0^{\alpha e_1+\beta e_3}f(s)ds dx</script>

<p>Here, one can see the evolution of the functional for $a=0$ and for $a=\theta=1/3$ for values of $\alpha$ and $\beta$.</p>

<table>
    <tr>
        <th>
            <video width="100%" controls="">
            <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0006/figures/barrier0.mp4" type="video/mp4" />
            </video>    
        </th>
         <th>
            <video width="100%" controls="">
            <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0006/figures/barriertheta.mp4" type="video/mp4" />
            </video>
        </th>       
    </tr>
</table>
<center><b>Figure 1.</b> Animation of the functional $J$ for diferent values of $\lambda=L^2$. At the left the boundary value is $0$ while at the right the boundary value is $\theta$.</center>

<p>In the next figure a qualitative bifurcation diagram is represented, the red curve represents the nontrivial solutions with boundary value $\theta$ and the blue one the boundary value $0$. $\lambda^\ast$ is the minimum $\lambda=L^2$ for which a nontrivial solution around $0$ exists, analogously $\lambda^*_\theta$.</p>

<center>
<img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0006/figures/bistablenonsymetric-1.png" width="60%" />
</center>
<center><b>Figure 2.</b> Bifurcation diagram . The blue line represents the maximum of the nontrivial solutions with boundary value $0$. The red curve represents some nontrivial solutions with boundary value $\theta$, the red line is the maximum of the nontrivial solution whenever the line is above $\theta$ and represents the minimum when the red line is below $\theta$.</center>

<p>The value $\frac{\lambda_1}{f’(\theta)}$ is the critical value for which the stationary solution $\theta$ becomes unstable. After this situation we have a nontrivial solution above and below $\theta$.</p>

<p>There will be further bifurcations around the boundary value $\theta$ when we increase $\lambda$. These bifuractions will lead to oscillatory nontrivial solutions that can be well understood in the phase-plane, see [2].</p>

<p>Here one can see different non-trivial solutions for different boundary values. The green curve corresponds to a section of the nontrivial solution in the whole $\mathbb{R}$:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}-\Delta u=f(u) &\qquad x\in \mathbb{R} \\
 0< u< 1 &\qquad x\in  \mathbb{R} \\
\displaystyle \lim_{x\to \pm \infty}u=0 \end{cases} %]]></script>

<center>
<img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0006/figures/ellipticL20DEF-1.png" width="60%" />
</center>
<center><b>Figure 3.</b> Several nontrivial solutions, in blue the ones with boundary value $0$, the red ones have boundary value $\theta$ and the green one is the solution in the whole $\mathbb{R}$. $\theta_1$ is the number such that $\int_0^{\theta_1} f(s)ds = 0 $.</center>

<h2 id="references">References:</h2>

<p>[1] M.H. Protter and H.F. Weinberger, Maximum principles in differential equations, Springer Science &amp; Business Media, 2012.</p>

<p>[2] D.  Ruiz-Balet  and  E.  Zuazua. Control of certain parabolic models from biology and social sciences.   Preprint  available  at https://cmc.deusto.eus/domenec-ruiz-balet/.</p>

<p>[3]  P.L. Lions, On the existence of positive solutions of semilinear elliptic equations, SIAM Rev. 24 (1982), no. 4, 441–467.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;Reaction-diffusion equations appear frequently in natural phenomena such as:&lt;/p&gt;
</code></pre>
</div>
<ul>
  <li>Population dynamics and invasion of species (see [1]).</li>
  <li>Neuroscience, where models for neuronal impulses exhibit traveling waves (see [2]).</li>
  <li>Chemical Reactions: modeling the evolution of concentrations of chemicals (see [3]).</li>
  <li>In evolutionary game theory  (see [4, 5]).</li>
  <li>Magnetic systems in material science and their phase transitions (see [6]).</li>
  <li>Linguistics, we refer to [7] where the authors consider reaction-diffusion for analyzing language shift by means of a traveling wave.</li>
</ul>

<p>In the majority of the systems mentioned above, the state $u$ of an equation of the type</p>

<script type="math/tex; mode=display">u_t-\Delta u=f(u)</script>

<p>represents a population, concentration or proportion. For this reason, any model intending to predict the behavior of such quantity must fulfill a maximum principle [8].</p>

<p>In this group of tutorials, our aim is to explain the phenomenology arising when considering a control problem in the contexts mentioned above.</p>

<p>In general, the controllability of parabolic equations has been widely studied (for instance [9,10,11]). However, in this literature, the requirement that the trajectory has to be positive or between prescribed bounds was not a concern.</p>

<p>In Figure 1 one can see a boundary control of the semilinear equation</p>

<script type="math/tex; mode=display">\begin{cases}
u_t-u_{xx}=u(1-u)(u-0.33)\\
u(-L,t)=u(L,t)=a(t)\\
u(t=0,x)=0
\end{cases}</script>

<p>with $a$ being the control and the target function $v\equiv 0.33$.</p>

<center>
<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0007/figures/violation.png" width="100%" />
        </th>
         <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0007/figures/violation2.png" width="100%" />
        </th>       
    </tr>
</table>

</center>
<center>Control from $u(0)\equiv 0$ to $u(T)\equiv 0.33$.</center>

<p>This model models the evolution of a proportion, and we observe that the control does not preserve the positivity of the state neither the meaningful upper bound.</p>

<p>From the application point of view of several of the applications mentioned, any control action proposed must fulfill that the associated trajectory has meaning.</p>

<p>The ideas exposed in this tutorial group are the following:</p>

<div class="container">
  <div class="col-md-10 col-md-offset-0">
    
    <ul style="padding-inline-start: 0px">
    
        <li>The presence of state-constraints can create intrinsic obstructions for achieving the controllability. This is due to the emergence on non-trivial solutions and the comparison principle. The topic is treated in this blog.</li>
        <div class="post-preview shadowbox">
  <div class="post-avatar-wp">
  
    <img src="https://deustotech.github.io/DyCon-Blog//assets/imgs/WP03/P0006/figures/ellipticL20DEF-1.png" />
  
  </div>
  <div class="post-info">
    <a href="/DyCon-Blog/tutorial/wp03/P0006" class="display-block">
      <h4 class="post-preview-title ellipsis-two-lines"> Control of reaction-diffusion under state constraints - Barriers </h4>
    </a>

    <div class="post-preview-subtitle ellipsis-two-lines">
      This tutorial is part of the control under state constraints. We will show how obstructions to the state constraint controllability can appear.
    </div>

    <div style="display: flex;margin-top: 10px;">
        <div class="post-preview-authors ellipsis-one-line">
          Author:
          
          
            
              <a href="https://deustotech.github.io/DyCon-Blog/author/DomenecR">Domenec Ruiz</a>
          
          - 31 March 2020
        </div>
        
        <button onclick="window.location.href='https://deustotech.github.io/DyCon-Blog/projects/search.bycode'" type="button" class="btn btn-danger btn-sm" style="margin-left: auto;">MATLAB-CasADi</button>
    
    </div>

  </div>
</div>

    
        <li>In order to prove the existence of controls one can use the stair-case method. This method relies on the construction of paths of steady-states that the controlled trajectory can follow. One can find more information about these constructions in this blog.</li>
        <div class="post-preview shadowbox">
  <div class="post-avatar-wp">
  
    <img src="https://deustotech.github.io/DyCon-Blog//assets/imgs/WP03/P0005/figures/completepath02L12-1.png" />
  
  </div>
  <div class="post-info">
    <a href="/DyCon-Blog/tutorial/wp03/P0005" class="display-block">
      <h4 class="post-preview-title ellipsis-two-lines"> Control of reaction-diffusion under state constraints - Application of the staircase method </h4>
    </a>

    <div class="post-preview-subtitle ellipsis-two-lines">
      In this tutorial, we will present how to generate admissible paths of steady states for the homogeneous reaction-diffusion equation
    </div>

    <div style="display: flex;margin-top: 10px;">
        <div class="post-preview-authors ellipsis-one-line">
          Author:
          
          
            
              <a href="https://deustotech.github.io/DyCon-Blog/author/DomenecR">Domenec Ruiz</a>
          
          - 03 April 2020
        </div>
        
        <button onclick="window.location.href='https://deustotech.github.io/DyCon-Blog/projects/search.bycode'" type="button" class="btn btn-danger btn-sm" style="margin-left: auto;">MATLAB-CasADi</button>
    
    </div>

  </div>
</div>

    
        <li>In contrast to the unconstrained case, the presence of constraints induces a minimal controllability time. However, the construction done with the path of steady-states is only a way to control and it requires typically a large time, much larger than the minimal one.  In this blog post, we explore different ways to control the system, a minimal controllability time control, a quasistatic control and we explore numerically the effect of the presence of barriers in an optimal control framework.</li>
        <div class="post-preview shadowbox">
  <div class="post-avatar-wp">
  
    <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0009/figures/ContrState-4.png" />
  
  </div>
  <div class="post-info">
    <a href="/DyCon-Blog/tutorial/wp03/P0009" class="display-block">
      <h4 class="post-preview-title ellipsis-two-lines"> Control of reaction-diffusion under state constraints - Numerical exploration of controls </h4>
    </a>

    <div class="post-preview-subtitle ellipsis-two-lines">
      This tutorial is part of the control under state constraints. We will simulate different control strategies to the same target by minimizing different functionals.
    </div>

    <div style="display: flex;margin-top: 10px;">
        <div class="post-preview-authors ellipsis-one-line">
          Author:
          
          
            
              <a href="https://deustotech.github.io/DyCon-Blog/author/DomenecR">Domenec Ruiz</a>
          
          - 04 April 2020
        </div>
        
        <button onclick="window.location.href='https://deustotech.github.io/DyCon-Blog/projects/search.bycode'" type="button" class="btn btn-danger btn-sm" style="margin-left: auto;">MATLAB-CasADi</button>
    
    </div>

  </div>
</div>

    
        <li>Many models in population dynamics take care about spatial heterogeneity, this can lead for example to new types obstructions. In the blog, we explain the main features and the influence of an heterogeneous drift in a bistable equation called gene-flow. The heterogeneity in the drift comes from an approximation of a system of a system of two equations with an heterogeneous environment.</li>
        <div class="post-preview shadowbox">
  <div class="post-avatar-wp">
  
    <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0008/figures/staircase_perturbed.png" />
  
  </div>
  <div class="post-info">
    <a href="/DyCon-Blog/tutorial/wp03/P0008" class="display-block">
      <h4 class="post-preview-title ellipsis-two-lines"> Control of reaction-diffusion under state constraints - Heterogeneous setting: Gene-flow. </h4>
    </a>

    <div class="post-preview-subtitle ellipsis-two-lines">
      This tutorial is part of the control under state constraints. We will present the main features regarding the controllability of bistable reaction-diffusion equations with heterogeneous drifts.
    </div>

    <div style="display: flex;margin-top: 10px;">
        <div class="post-preview-authors ellipsis-one-line">
          Authors:
          
          
            
              <a href="https://deustotech.github.io/DyCon-Blog/author/DomenecR">Domenec Ruiz</a>,
          
            
              <a href="https://deustotech.github.io/DyCon-Blog/author/IdrissM">Idriss Mazari</a>
          
          - 19 April 2020
        </div>
        
        <button onclick="window.location.href='https://deustotech.github.io/DyCon-Blog/projects/search.bycode'" type="button" class="btn btn-danger btn-sm" style="margin-left: auto;">MATLAB-CasADi</button>
    
    </div>

  </div>
</div>

    
    </ul>
  </div>
</div>

<h2 id="references">References:</h2>

<p>[1] A. Kolmogorov, Étude de l’équation de la diffusion avec croissance de la quantité de matière et son
application à un problème biologique, Bull. Univ. Moskow, Ser. Internat., Sec. A 1 (1937) 1–25.</p>

<p>[2] J. Evans, Nerve axon equations 4: the stable and unstable impulse, Indiana Univ. Math. J. 24 (12)
(1975) 1169–1190.</p>

<p>[3] B. Perthame, Parabolic equations in biology : growth, reaction, movement and diffusion, Lecture
notes on mathematical modelling in the life sciences, 2015.</p>

<p>[4] Travelling waves for games in economics and biology, Nonlinear Analysis: Theory, Methods and
Applications 30 (2) (1997) 1235 – 1244, proceedings of the Second World Congress of Nonlinear
Analysts.</p>

<p>[5] V. Hutson, K. Mischaikow, G. T. Vickers, Multiple travelling waves in evolutionary game dynamics,
Japan Journal of Industrial and Applied Mathematics 17 (3) (2000) 341.</p>

<p>[6] A. De Masi, P. Ferrari, J. Lebowitz, Reaction diffusion equations for interacting particle systems, J.
Stat. Phys. 44 (3-4) (1986) 589–644.</p>

<p>[7] K. Prochazka, G. Vogl, Quantifying the driving factors for language shift in a bilingual region 114 (17) (2017) 4365–4369.</p>

<p>[8] M.H. Protter and H.F. Weinberger, Maximum principles in differential equations, Springer Science &amp; Business Media, 2012.</p>

<p>[9] G. Lebeau, L. Robbiano, Contrôle exact de léquation de la chaleur, Communications in Partial
Differential Equations 20 (1-2) (1995) 335–356.</p>

<p>[10] E. Fernández-Cara and E. Zuazua, Null and approximate controllability for weakly blowing up semilinear heat equations, Ann. Inst. H. Poincaré Anal. Non Linéaire 17 (2000), no. 5, 583 – 616.</p>

<p>[11] A.V. Fursikov and O.Y. Imanuvilov, Controllability of evolution equations, no. 34, Seoul National University, 1996.</p>

<p>[12] D.  Ruiz-Balet  and  E.  Zuazua. Control of certain parabolic models from biology and social sciences.   Preprint  available  at https://cmc.deusto.eus/domenec-ruiz-balet/.</p>

<p>[13]  P.L. Lions, On the existence of positive solutions of semilinear elliptic equations, SIAM Rev. 24 (1982), no. 4, 441–467.</p>

<p>[14] D. Pighin, E. Zuazua, Controllability under positivity constraints of multi-d wave equations, in:
Trends in Control Theory and Partial Differential Equations, Springer, 2019, pp. 195–232.</p>

<p>[15] J.-M. Coron, E. Trélat, Global steady-state controllability of one-dimensional semilinear heat equa-
tions, SIAM J. Control. Optim. 43 (2) (2004) 549–569.</p>

<p>[16] C. Pouchol, E. Trélat, E. Zuazua, Phase portrait control for 1d monostable and bistable reac-
635 tion–diffusion equations, Nonlinearity 32 (3) (2019) 884–909.</p>

<p>[17]   D.  Ruiz-Balet  and  E.  Zuazua. Controllability  under  constraints  for  reaction-diffusionequations:   The  multi-dimensional  case (2019).   Preprint  available  athttps://cmc.deusto.eus/domenec-ruiz-balet/.</p>

<p>[18] I. Mazari, D. Ruiz-Balet, and E. Zuazua, Constrained control of bistable reaction-diffusion equations: Gene-flow and spatially heterogeneous models, preprint: https://hal.archives-ouvertes.fr/hal-02373668/document (2019).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this tutorial we will apply the DyCon toolbox to find a control to the semi-discrete semi-linear heat equation.&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">y_t-N^2Ay=G(y)+Bu</script>

<p>where $N^2A$ is the discretization of the Laplacian in 1d in $N$ nodes. We are looking for a control that after time $T$ steers the system near zero.</p>

<h3 id="setup">Setup</h3>

<p>In this tutorial we need <a href="https://deustotech.github.io/dycon-toolbox-documentation/">DyCon Toolbox</a>, to install it we will have to write the following in our MATLAB console:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">unzip</span><span class="p">(</span><span class="s1">'https://github.com/DeustoTech/DyCon-Computational-Platform/archive/master.zip'</span><span class="p">)</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="nb">cd</span><span class="p">,</span><span class="s1">'DyCon-toolbox-master'</span><span class="p">)))</span>
</code></pre>
</div>
<h3 id="methodology">Methodology</h3>
<p>In order to do so we will frame the problem as a minimization of a functional and we will apply gradient descent to find it. Note that the convexity of the functional is not proven, therefore, we will obtain a local minima for the functional. The functional considered will be:</p>

<script type="math/tex; mode=display">J(\boldsymbol{y},\boldsymbol{u})= | \boldsymbol{y}(t) |_{L^2}^2+\int_0^T | \boldsymbol{u}(t) |_{L^2}^2 dt</script>

<p>where by $| \cdot |_{L^2}$ we understand the discrete $L^2$ norm.</p>

<p>Once this control is computed for a certain N, we will think on a dynamical system that models an opinion dynamics with $N$ agents communicating through a chain.</p>

<p>\begin{equation}\label{m1}y_t-\frac{1}{N}Ay=G(y)+Bv\end{equation}</p>

<p>The goal will be to compute also the control $v$ thinking model \eqref{m1} as if it was a semidiscretization of a heat equation with diffusivity $\frac{1}{N^3}$. Furthermore we will also compute the control for model \eqref{m1} with the non-linearity being non-homogeneous on $N$ and a time horizon being $T_N=N^3T$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clear</span> <span class="nb">all</span>
<span class="nb">import</span> <span class="n">casadi</span><span class="o">.*</span>
</code></pre>
</div>

<p>Definition of the time</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">ts</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'t'</span><span class="p">);</span>
<span class="c1">%% Discretization of the space</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">xi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">xline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">xf</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
</code></pre>
</div>

<p>Interior Control region between 0.5 and 0.8</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">w1</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span> <span class="n">w2</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
<span class="n">D</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">GetABmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">w1</span><span class="p">,</span><span class="n">w2</span><span class="p">,</span><span class="n">D</span><span class="p">);</span>
</code></pre>
</div>

<p>we define symbolically the vectors of the state and the control</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Ys</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'y'</span><span class="p">,[</span><span class="n">N</span> <span class="mi">1</span><span class="p">]);</span>
<span class="n">Us</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'u'</span><span class="p">,[</span><span class="n">count</span> <span class="mi">1</span><span class="p">]);</span>
</code></pre>
</div>

<p>We create the ODE object Our ODE object will have the semi-discretization of the semilinear heat equation. We set also initial conditions, define the non linearity and the interaction of the control to the dynamics.</p>

<p>Initial condition</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Y0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">xline</span><span class="o">'</span><span class="p">);</span>
</code></pre>
</div>

<p>Diffusion part: the discretization of the 1d Laplacian</p>

<p>Definition of the non-linearity <script type="math/tex">\partial_y[-5\exp(-y^2)]</script></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">G</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'NLT'</span><span class="p">,{</span><span class="n">Ys</span><span class="p">},{</span><span class="mi">10</span><span class="o">*</span><span class="n">Ys</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Ys</span><span class="o">.^</span><span class="mi">2</span><span class="p">)});</span><span class="c1">%%</span>
</code></pre>
</div>

<p>and we define the part of the dynamics corresponding to the nonlinearity</p>

<p>Putting all the things together</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">F</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'F'</span><span class="p">,{</span><span class="n">ts</span><span class="p">,</span><span class="n">Ys</span><span class="p">,</span><span class="n">Us</span><span class="p">},{</span><span class="n">A</span><span class="o">*</span><span class="n">Ys</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">Us</span> <span class="o">+</span> <span class="n">G</span><span class="p">(</span><span class="n">Ys</span><span class="p">)});</span>
<span class="c1">%% Creation of the ODE object</span>
<span class="c1">%% Time horizon</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre>
</div>

<p>We create the ODE-object and we change the resolution to $dt=0.01$ in order to see the variation in a small time scale. We will get the values of the solution in steps of size odeEqn.dt, if we do not care about modifying this parameter in the object, we might get the solution in certain time steps that will hide part of the dynamics.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Nt</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">tspan</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="n">ipde</span> <span class="o">=</span> <span class="n">semilinearpde1d</span><span class="p">(</span><span class="n">Ys</span><span class="p">,</span><span class="n">Us</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span><span class="n">xline</span><span class="p">);</span>
<span class="n">ipde</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="n">Y0</span><span class="p">;</span>
</code></pre>
</div>

<p>We solve the equation and we plot the free solution applying solve to odeEqn and we plot the free solution.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Yfree</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">ipde</span><span class="p">,</span><span class="n">ZerosControl</span><span class="p">(</span><span class="n">ipde</span><span class="p">));</span>
<span class="n">Yfree</span> <span class="o">=</span> <span class="nb">full</span><span class="p">(</span><span class="n">Yfree</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">Yfree</span><span class="s1">','</span><span class="n">EdgeColor</span><span class="s1">','</span><span class="n">none</span><span class="o">'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Free Dynamics'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'space discretization'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="n">yticks</span><span class="p">([</span><span class="mi">1</span> <span class="n">Nt</span><span class="p">])</span>
<span class="n">yticklabels</span><span class="p">([</span><span class="n">tspan</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">tspan</span><span class="p">(</span><span class="k">end</span><span class="p">)])</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0008/copiaRM_01.png" alt="" /></p>

<p>We create the object that collects the formulation of an optimal control problem  by means of the object that describes the dynamics odeEqn, the functional to minimize Jfun and the time horizon T</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">L</span>   <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'L'</span>  <span class="p">,{</span><span class="n">ts</span><span class="p">,</span><span class="n">Ys</span><span class="p">,</span><span class="n">Us</span><span class="p">},{</span> <span class="n">Us</span><span class="o">.'*</span><span class="n">Us</span>  <span class="p">});</span>
<span class="n">Psi</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Psi'</span><span class="p">,{</span><span class="n">Ys</span><span class="p">}</span>      <span class="p">,{</span> <span class="mf">1e6</span><span class="o">*</span><span class="p">(</span><span class="n">Ys</span><span class="o">.'*</span><span class="n">Ys</span><span class="p">)</span> <span class="p">});</span>

<span class="n">iocp</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">(</span><span class="n">ipde</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">Psi</span><span class="p">);</span>
</code></pre>
</div>

<p>We apply the steepest descent method to obtain a local minimum (our functional might not be convex).</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">U0</span> <span class="o">=</span><span class="n">ZerosControl</span><span class="p">(</span><span class="n">ipde</span><span class="p">);</span>
<span class="p">[</span><span class="n">OptControl</span> <span class="p">,</span><span class="n">OptState</span><span class="p">]</span>  <span class="o">=</span> <span class="n">IpoptSolver</span><span class="p">(</span><span class="n">iocp</span><span class="p">,</span><span class="n">U0</span><span class="p">);</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>This is Ipopt version 3.12.3, running with linear solver mumps.
NOTE: Other linear solvers might be more efficient (see Ipopt documentation).

Number of nonzeros in equality constraint Jacobian...:    19236
Number of nonzeros in inequality constraint Jacobian.:        0
Number of nonzeros in Lagrangian Hessian.............:     3900

Total number of variables............................:     3900
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:     3000
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  3.0000000e+07 9.05e+00 9.67e-01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  2.4544321e+05 1.22e-01 7.92e+00  -1.0 3.10e+01  -2.0 1.00e+00 1.00e+00f  1
   2  1.8219937e+06 4.24e-03 1.73e+00  -1.0 1.31e+01  -1.6 1.00e+00 1.00e+00h  1
   3  7.1220860e+04 1.67e-02 2.92e+00  -1.0 9.12e+00  -2.1 1.00e+00 1.00e+00f  1
   4  8.9356500e+03 3.97e-04 8.51e-02  -1.0 2.41e+00  -2.5 1.00e+00 1.00e+00f  1
   5  3.1075917e+03 1.06e-04 3.19e-03  -2.5 2.96e+00  -3.0 1.00e+00 1.00e+00f  1
   6  1.3016546e+03 5.20e-05 1.19e-03  -3.8 3.60e+00  -3.5 1.00e+00 1.00e+00h  1
   7  4.5871538e+02 5.64e-05 4.84e-04  -5.7 4.41e+00  -4.0 1.00e+00 1.00e+00h  1
   8  1.6346578e+02 6.55e-05 1.92e-04  -5.7 5.26e+00  -4.4 1.00e+00 1.00e+00h  1
   9  9.7049320e+01 1.20e-04 3.78e-05  -5.7 3.10e+00  -4.9 1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  4.0069187e+01 9.26e-03 1.98e-05  -5.7 1.48e+01    -  1.00e+00 5.00e-01h  2
  11  1.6748754e+01 4.28e-04 2.92e-06  -5.7 4.34e+00    -  1.00e+00 1.00e+00h  1
  12  1.6371256e+01 4.58e-06 9.87e-09  -5.7 1.88e-01    -  1.00e+00 1.00e+00h  1
  13  1.6367177e+01 1.03e-11 1.11e-13  -8.6 7.84e-04    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 13

                                   (scaled)                 (unscaled)
Objective...............:   8.1835886066017175e-04    1.6367177213203433e+01
Dual infeasibility......:   1.1096830919432588e-13    2.2193661838865175e-09
Constraint violation....:   1.0345974077452524e-11    1.0345974077452524e-11
Complementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00
Overall NLP error.......:   1.0345974077452524e-11    2.2193661838865175e-09


Number of objective function evaluations             = 19
Number of objective gradient evaluations             = 14
Number of equality constraint evaluations            = 19
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 14
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 13
Total CPU secs in IPOPT (w/o function evaluations)   =      0.436
Total CPU secs in NLP function evaluations           =      0.057

EXIT: Optimal Solution Found.
               t_proc [s]   t_wall [s]    n_eval
       nlp_f     0.000826     0.000828        19
       nlp_g      0.00916      0.00917        19
  nlp_grad_f      0.00139      0.00139        15
  nlp_hess_l       0.0175       0.0174        13
   nlp_jac_g       0.0333       0.0333        15
      solver        0.507        0.501         1
Elapsed time is 0.636870 seconds.

</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">plotSHE</span><span class="p">(</span><span class="n">OptState</span><span class="p">,</span><span class="n">OptControl</span><span class="p">,</span><span class="n">Yfree</span><span class="p">,</span><span class="n">YT</span><span class="p">,</span><span class="n">xline</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span><span class="n">Nt</span><span class="p">)</span>
</code></pre>
</div>

<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0008/copiaRM_02.png" />
        </th>
         <th>
            <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0008/copiaRM_03.png" />
        </th>       
    </tr>
</table>

<h3 id="collective-behavior-dynamics">Collective behavior dynamics</h3>

<p>Now we apply the same procedure for the collective behavior dynamics. We will employ a function that does the algorithm explained before for the semilinear heat equation having the chance to set a diffusivity constant.</p>

<p>For the simulation of the model in collective behavior we will employ a diffusivity $D=\frac{1}{N^3}$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/(</span><span class="n">N</span><span class="o">^</span><span class="mi">3</span><span class="p">);</span>
<span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">GetABmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">w1</span><span class="p">,</span><span class="n">w2</span><span class="p">,</span><span class="n">D</span><span class="p">);</span>
<span class="c1">%%</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'NLT'</span><span class="p">,{</span><span class="n">Ys</span><span class="p">},{</span><span class="mi">10</span><span class="o">*</span><span class="n">Ys</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Ys</span><span class="o">.^</span><span class="mi">2</span><span class="p">)});</span><span class="c1">%%</span>
<span class="c1">%%</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">Nt</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">tspan</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="c1">%%</span>
<span class="n">ipde</span> <span class="o">=</span> <span class="n">semilinearpde1d</span><span class="p">(</span><span class="n">Ys</span><span class="p">,</span><span class="n">Us</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span><span class="n">xline</span><span class="p">);</span>
<span class="n">ipde</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="n">Y0</span><span class="p">;</span>
<span class="c1">%%</span>
<span class="n">iocp</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">(</span><span class="n">ipde</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">Psi</span><span class="p">);</span>
</code></pre>
</div>

<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0008/copiaRM_05.png" />
        </th>
         <th>
            <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0008/copiaRM_06.png" />
        </th>       
    </tr>
</table>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">U0</span> <span class="o">=</span><span class="n">ZerosControl</span><span class="p">(</span><span class="n">ipde</span><span class="p">);</span>
<span class="c1">%%[OptControl ,OptState]  = ArmijoGradient(iocp,U0,'MaxIter',200);</span>
<span class="p">[</span><span class="n">OptControl</span> <span class="p">,</span><span class="n">OptState</span><span class="p">]</span>  <span class="o">=</span> <span class="n">IpoptSolver</span><span class="p">(</span><span class="n">iocp</span><span class="p">,</span><span class="n">U0</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">This</span> <span class="nb">is</span> <span class="n">Ipopt</span> <span class="nb">version</span> <span class="mf">3.12</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="n">running</span> <span class="n">with</span> <span class="n">linear</span> <span class="n">solver</span> <span class="n">mumps</span><span class="o">.</span>
<span class="n">NOTE</span><span class="p">:</span> <span class="n">Other</span> <span class="n">linear</span> <span class="n">solvers</span> <span class="n">might</span> <span class="n">be</span> <span class="nb">more</span> <span class="n">efficient</span> <span class="p">(</span><span class="n">see</span> <span class="n">Ipopt</span> <span class="n">documentation</span><span class="p">)</span><span class="o">.</span>

<span class="n">Number</span> <span class="n">of</span> <span class="nb">nonzeros</span> <span class="n">in</span> <span class="n">equality</span> <span class="n">constraint</span> <span class="n">Jacobian</span><span class="k">...</span><span class="c">:    19236</span>
<span class="n">Number</span> <span class="n">of</span> <span class="nb">nonzeros</span> <span class="n">in</span> <span class="n">inequality</span> <span class="n">constraint</span> <span class="n">Jacobian</span><span class="o">.</span><span class="p">:</span>        <span class="mi">0</span>
<span class="n">Number</span> <span class="n">of</span> <span class="nb">nonzeros</span> <span class="n">in</span> <span class="n">Lagrangian</span> <span class="n">Hessian</span><span class="k">...</span><span class="c">..........:     3900</span>

<span class="n">Total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">variables</span><span class="k">...</span><span class="c">.........................:     3900</span>
                     <span class="n">variables</span> <span class="n">with</span> <span class="n">only</span> <span class="nb">lower</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>
                <span class="n">variables</span> <span class="n">with</span> <span class="nb">lower</span> <span class="nb">and</span> <span class="nb">upper</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>
                     <span class="n">variables</span> <span class="n">with</span> <span class="n">only</span> <span class="nb">upper</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>
<span class="n">Total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">equality</span> <span class="n">constraints</span><span class="k">...</span><span class="c">..............:     3000</span>
<span class="n">Total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">inequality</span> <span class="n">constraints</span><span class="k">...</span><span class="c">............:        0</span>
        <span class="n">inequality</span> <span class="n">constraints</span> <span class="n">with</span> <span class="n">only</span> <span class="nb">lower</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>
   <span class="n">inequality</span> <span class="n">constraints</span> <span class="n">with</span> <span class="nb">lower</span> <span class="nb">and</span> <span class="nb">upper</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>
        <span class="n">inequality</span> <span class="n">constraints</span> <span class="n">with</span> <span class="n">only</span> <span class="nb">upper</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>

<span class="n">iter</span>    <span class="n">objective</span>    <span class="n">inf_pr</span>   <span class="n">inf_du</span> <span class="n">lg</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>  <span class="o">||</span><span class="n">d</span><span class="o">||</span>  <span class="n">lg</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span> <span class="n">alpha_du</span> <span class="n">alpha_pr</span>  <span class="nb">ls</span>
   <span class="mi">0</span>  <span class="mf">3.0000000e+07</span> <span class="mf">1.00e+00</span> <span class="mf">9.72e-01</span>  <span class="o">-</span><span class="mf">1.0</span> <span class="mf">0.00e+00</span>    <span class="o">-</span>  <span class="mf">0.00e+00</span> <span class="mf">0.00e+00</span>   <span class="mi">0</span>
   <span class="mi">1</span>  <span class="mf">1.1211823e+08</span> <span class="mf">6.93e-02</span> <span class="mf">1.07e+01</span>  <span class="o">-</span><span class="mf">1.7</span> <span class="mf">1.75e+00</span>   <span class="mf">0.0</span> <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
   <span class="mi">2</span>  <span class="mf">1.0201471e+08</span> <span class="mf">2.53e-02</span> <span class="mf">2.23e+00</span>  <span class="o">-</span><span class="mf">1.7</span> <span class="mf">3.50e+00</span>  <span class="o">-</span><span class="mf">0.5</span> <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">f</span>  <span class="mi">1</span>
   <span class="mi">3</span>  <span class="mf">8.8642262e+07</span> <span class="mf">4.18e-02</span> <span class="mf">5.31e-01</span>  <span class="o">-</span><span class="mf">1.7</span> <span class="mf">2.13e+02</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">f</span>  <span class="mi">1</span>
   <span class="mi">4</span>  <span class="mf">8.2505158e+07</span> <span class="mf">1.39e+00</span> <span class="mf">3.13e+00</span>  <span class="o">-</span><span class="mf">1.7</span> <span class="mf">2.72e+03</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">F</span>  <span class="mi">1</span>
   <span class="mi">5</span>  <span class="mf">7.9212105e+07</span> <span class="mf">9.68e+00</span> <span class="mf">5.20e+00</span>  <span class="o">-</span><span class="mf">1.7</span> <span class="mf">1.38e+03</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">f</span>  <span class="mi">1</span>
   <span class="mi">6</span>  <span class="mf">7.8291279e+07</span> <span class="mf">6.94e-02</span> <span class="mf">2.84e+00</span>  <span class="o">-</span><span class="mf">1.7</span> <span class="mf">2.05e+03</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">f</span>  <span class="mi">1</span>
   <span class="mi">7</span>  <span class="mf">7.8090072e+07</span> <span class="mf">1.57e+00</span> <span class="mf">4.98e-01</span>  <span class="o">-</span><span class="mf">1.7</span> <span class="mf">7.87e+02</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">f</span>  <span class="mi">1</span>
   <span class="mi">8</span>  <span class="mf">7.8026943e+07</span> <span class="mf">1.54e-01</span> <span class="mf">8.25e-02</span>  <span class="o">-</span><span class="mf">1.7</span> <span class="mf">3.33e+02</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">f</span>  <span class="mi">1</span>
   <span class="mi">9</span>  <span class="mf">7.8491521e+07</span> <span class="mf">4.41e-02</span> <span class="mf">7.64e+00</span>  <span class="o">-</span><span class="mf">2.5</span> <span class="mf">2.10e+00</span>  <span class="o">-</span><span class="mf">1.0</span> <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
<span class="n">iter</span>    <span class="n">objective</span>    <span class="n">inf_pr</span>   <span class="n">inf_du</span> <span class="n">lg</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>  <span class="o">||</span><span class="n">d</span><span class="o">||</span>  <span class="n">lg</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span> <span class="n">alpha_du</span> <span class="n">alpha_pr</span>  <span class="nb">ls</span>
<span class="k">...</span>
<span class="k">...</span>
  <span class="mi">54</span>  <span class="mf">7.8022238e+07</span> <span class="mf">4.03e-07</span> <span class="mf">8.33e-10</span>  <span class="o">-</span><span class="mf">5.7</span> <span class="mf">2.15e-02</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
  <span class="mi">55</span>  <span class="mf">7.8022238e+07</span> <span class="mf">9.83e-12</span> <span class="mf">1.82e-12</span>  <span class="o">-</span><span class="mf">8.6</span> <span class="mf">1.02e-04</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>

<span class="n">Number</span> <span class="n">of</span> <span class="n">Iterations</span><span class="k">...</span><span class="c">.: 55</span>

                                   <span class="p">(</span><span class="n">scaled</span><span class="p">)</span>                 <span class="p">(</span><span class="n">unscaled</span><span class="p">)</span>
<span class="n">Objective</span><span class="k">...</span><span class="c">............:   3.9011119130960064e+03    7.8022238261920124e+07</span>
<span class="n">Dual</span> <span class="n">infeasibility</span><span class="k">...</span><span class="c">...:   1.8189894035458565e-12    3.6379788070917130e-08</span>
<span class="n">Constraint</span> <span class="n">violation</span><span class="k">...</span><span class="c">.:   9.8296371042749797e-12    9.8296371042749797e-12</span>
<span class="n">Complementarity</span><span class="k">...</span><span class="c">......:   0.0000000000000000e+00    0.0000000000000000e+00</span>
<span class="n">Overall</span> <span class="n">NLP</span> <span class="nb">error</span><span class="k">...</span><span class="c">....:   9.8296371042749797e-12    3.6379788070917130e-08</span>


<span class="n">Number</span> <span class="n">of</span> <span class="n">objective</span> <span class="k">function</span> <span class="n">evaluations</span>             <span class="o">=</span> <span class="mi">111</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">objective</span> <span class="nb">gradient</span> <span class="n">evaluations</span>             <span class="o">=</span> <span class="mi">56</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">equality</span> <span class="n">constraint</span> <span class="n">evaluations</span>            <span class="o">=</span> <span class="mi">111</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">inequality</span> <span class="n">constraint</span> <span class="n">evaluations</span>          <span class="o">=</span> <span class="mi">0</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">equality</span> <span class="n">constraint</span> <span class="n">Jacobian</span> <span class="n">evaluations</span>   <span class="o">=</span> <span class="mi">56</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">inequality</span> <span class="n">constraint</span> <span class="n">Jacobian</span> <span class="n">evaluations</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">Lagrangian</span> <span class="n">Hessian</span> <span class="n">evaluations</span>             <span class="o">=</span> <span class="mi">55</span>
<span class="n">Total</span> <span class="n">CPU</span> <span class="n">secs</span> <span class="n">in</span> <span class="n">IPOPT</span> <span class="p">(</span><span class="n">w</span><span class="p">/</span><span class="n">o</span> <span class="k">function</span> <span class="n">evaluations</span><span class="p">)</span>   <span class="o">=</span>      <span class="mf">1.374</span>
<span class="n">Total</span> <span class="n">CPU</span> <span class="n">secs</span> <span class="n">in</span> <span class="n">NLP</span> <span class="k">function</span> <span class="n">evaluations</span>           <span class="o">=</span>      <span class="mf">0.308</span>

<span class="n">EXIT</span><span class="p">:</span> <span class="n">Optimal</span> <span class="n">Solution</span> <span class="n">Found</span><span class="o">.</span>
               <span class="n">t_proc</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>   <span class="n">t_wall</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>    <span class="n">n_eval</span>
       <span class="n">nlp_f</span>      <span class="mf">0.00624</span>      <span class="mf">0.00627</span>       <span class="mi">111</span>
       <span class="n">nlp_g</span>       <span class="mf">0.0634</span>       <span class="mf">0.0633</span>       <span class="mi">111</span>
  <span class="n">nlp_grad_f</span>      <span class="mf">0.00762</span>      <span class="mf">0.00768</span>        <span class="mi">57</span>
  <span class="n">nlp_hess_l</span>       <span class="mf">0.0868</span>       <span class="mf">0.0846</span>        <span class="mi">55</span>
   <span class="n">nlp_jac_g</span>        <span class="mf">0.149</span>        <span class="mf">0.149</span>        <span class="mi">57</span>
      <span class="n">solver</span>         <span class="mf">1.74</span>         <span class="mf">1.73</span>         <span class="mi">1</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="nb">is</span> <span class="mf">1.874814</span> <span class="n">seconds</span><span class="o">.</span>

</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">plotSHE</span><span class="p">(</span><span class="n">OptState</span><span class="p">,</span><span class="n">OptControl</span><span class="p">,</span><span class="n">Yfree</span><span class="p">,</span><span class="n">YT</span><span class="p">,</span><span class="n">xline</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span><span class="n">Nt</span><span class="p">)</span>
</code></pre>
</div>

<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0008/copiaRM_07.png" />
        </th>
         <th>
            <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0008/copiaRM_08.png" />
        </th>       
    </tr>
</table>

<p>Now we will change also the time horizon and we will incorporate a non-homogeneous non-linearity, we will just divide the non-linearity $G$ by $N^3$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/(</span><span class="n">N</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
<span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">GetABmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">w1</span><span class="p">,</span><span class="n">w2</span><span class="p">,</span><span class="n">D</span><span class="p">);</span>
<span class="c1">%%</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s1">'NLT'</span><span class="p">,{</span><span class="n">Ys</span><span class="p">},{</span><span class="mi">10</span><span class="o">*</span><span class="n">Ys</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Ys</span><span class="o">.^</span><span class="mi">2</span><span class="p">)/</span><span class="n">N</span><span class="o">^</span><span class="mi">2</span><span class="p">}</span> <span class="p">);</span><span class="c1">%%</span>
<span class="c1">%%</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>  <span class="n">Nt</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">tspan</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="c1">%%</span>
<span class="n">ipde</span> <span class="o">=</span> <span class="n">semilinearpde1d</span><span class="p">(</span><span class="n">Ys</span><span class="p">,</span><span class="n">Us</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span><span class="n">xline</span><span class="p">);</span>
<span class="n">ipde</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="n">Y0</span><span class="p">;</span>
<span class="c1">%%</span>
<span class="n">iocp</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">(</span><span class="n">ipde</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">Psi</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">U0</span> <span class="o">=</span><span class="n">ZerosControl</span><span class="p">(</span><span class="n">ipde</span><span class="p">);</span>
<span class="p">[</span><span class="n">OptControl</span> <span class="p">,</span><span class="n">OptState</span><span class="p">]</span>  <span class="o">=</span> <span class="n">IpoptSolver</span><span class="p">(</span><span class="n">iocp</span><span class="p">,</span><span class="n">U0</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">This</span> <span class="nb">is</span> <span class="n">Ipopt</span> <span class="nb">version</span> <span class="mf">3.12</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="n">running</span> <span class="n">with</span> <span class="n">linear</span> <span class="n">solver</span> <span class="n">mumps</span><span class="o">.</span>
<span class="n">NOTE</span><span class="p">:</span> <span class="n">Other</span> <span class="n">linear</span> <span class="n">solvers</span> <span class="n">might</span> <span class="n">be</span> <span class="nb">more</span> <span class="n">efficient</span> <span class="p">(</span><span class="n">see</span> <span class="n">Ipopt</span> <span class="n">documentation</span><span class="p">)</span><span class="o">.</span>

<span class="n">Number</span> <span class="n">of</span> <span class="nb">nonzeros</span> <span class="n">in</span> <span class="n">equality</span> <span class="n">constraint</span> <span class="n">Jacobian</span><span class="k">...</span><span class="c">:    19236</span>
<span class="n">Number</span> <span class="n">of</span> <span class="nb">nonzeros</span> <span class="n">in</span> <span class="n">inequality</span> <span class="n">constraint</span> <span class="n">Jacobian</span><span class="o">.</span><span class="p">:</span>        <span class="mi">0</span>
<span class="n">Number</span> <span class="n">of</span> <span class="nb">nonzeros</span> <span class="n">in</span> <span class="n">Lagrangian</span> <span class="n">Hessian</span><span class="k">...</span><span class="c">..........:     3900</span>

<span class="n">Total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">variables</span><span class="k">...</span><span class="c">.........................:     3900</span>
                     <span class="n">variables</span> <span class="n">with</span> <span class="n">only</span> <span class="nb">lower</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>
                <span class="n">variables</span> <span class="n">with</span> <span class="nb">lower</span> <span class="nb">and</span> <span class="nb">upper</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>
                     <span class="n">variables</span> <span class="n">with</span> <span class="n">only</span> <span class="nb">upper</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>
<span class="n">Total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">equality</span> <span class="n">constraints</span><span class="k">...</span><span class="c">..............:     3000</span>
<span class="n">Total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">inequality</span> <span class="n">constraints</span><span class="k">...</span><span class="c">............:        0</span>
        <span class="n">inequality</span> <span class="n">constraints</span> <span class="n">with</span> <span class="n">only</span> <span class="nb">lower</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>
   <span class="n">inequality</span> <span class="n">constraints</span> <span class="n">with</span> <span class="nb">lower</span> <span class="nb">and</span> <span class="nb">upper</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>
        <span class="n">inequality</span> <span class="n">constraints</span> <span class="n">with</span> <span class="n">only</span> <span class="nb">upper</span> <span class="n">bounds</span><span class="p">:</span>        <span class="mi">0</span>

<span class="n">iter</span>    <span class="n">objective</span>    <span class="n">inf_pr</span>   <span class="n">inf_du</span> <span class="n">lg</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>  <span class="o">||</span><span class="n">d</span><span class="o">||</span>  <span class="n">lg</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span> <span class="n">alpha_du</span> <span class="n">alpha_pr</span>  <span class="nb">ls</span>
   <span class="mi">0</span>  <span class="mf">3.0000000e+07</span> <span class="mf">9.05e+00</span> <span class="mf">1.17e+02</span>  <span class="o">-</span><span class="mf">1.0</span> <span class="mf">0.00e+00</span>    <span class="o">-</span>  <span class="mf">0.00e+00</span> <span class="mf">0.00e+00</span>   <span class="mi">0</span>
   <span class="mi">1</span>  <span class="mf">2.8754020e+04</span> <span class="mf">1.48e-01</span> <span class="mf">4.01e+00</span>  <span class="o">-</span><span class="mf">1.0</span> <span class="mf">2.73e+00</span>   <span class="mf">0.0</span> <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">f</span>  <span class="mi">1</span>
   <span class="mi">2</span>  <span class="mf">3.0839145e+03</span> <span class="mf">1.91e-02</span> <span class="mf">3.08e-01</span>  <span class="o">-</span><span class="mf">1.0</span> <span class="mf">9.19e-01</span>  <span class="o">-</span><span class="mf">0.5</span> <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
   <span class="mi">3</span>  <span class="mf">9.2703794e+02</span> <span class="mf">1.17e-03</span> <span class="mf">2.31e-02</span>  <span class="o">-</span><span class="mf">1.7</span> <span class="mf">2.08e-01</span>  <span class="o">-</span><span class="mf">1.0</span> <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
   <span class="mi">4</span>  <span class="mf">4.2707593e+02</span> <span class="mf">2.49e-03</span> <span class="mf">9.65e-03</span>  <span class="o">-</span><span class="mf">3.8</span> <span class="mf">2.61e-01</span>  <span class="o">-</span><span class="mf">1.4</span> <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
   <span class="mi">5</span>  <span class="mf">2.2851845e+02</span> <span class="mf">1.36e-03</span> <span class="mf">2.60e-03</span>  <span class="o">-</span><span class="mf">3.8</span> <span class="mf">2.10e-01</span>  <span class="o">-</span><span class="mf">1.9</span> <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
   <span class="mi">6</span>  <span class="mf">1.5158663e+02</span> <span class="mf">1.25e-03</span> <span class="mf">9.80e-04</span>  <span class="o">-</span><span class="mf">3.8</span> <span class="mf">2.38e-01</span>  <span class="o">-</span><span class="mf">2.4</span> <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
   <span class="mi">7</span>  <span class="mf">1.0229631e+02</span> <span class="mf">2.37e-03</span> <span class="mf">4.26e-04</span>  <span class="o">-</span><span class="mf">5.7</span> <span class="mf">3.11e-01</span>  <span class="o">-</span><span class="mf">2.9</span> <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
   <span class="mi">8</span>  <span class="mf">8.6220145e+01</span> <span class="mf">1.84e-01</span> <span class="mf">3.73e-04</span>  <span class="o">-</span><span class="mf">5.7</span> <span class="mf">2.84e+01</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.25e-01</span><span class="n">h</span>  <span class="mi">4</span>
   <span class="mi">9</span>  <span class="mf">1.6663658e+00</span> <span class="mf">6.98e-02</span> <span class="mf">4.71e-05</span>  <span class="o">-</span><span class="mf">5.7</span> <span class="mf">2.20e+00</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
<span class="n">iter</span>    <span class="n">objective</span>    <span class="n">inf_pr</span>   <span class="n">inf_du</span> <span class="n">lg</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>  <span class="o">||</span><span class="n">d</span><span class="o">||</span>  <span class="n">lg</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span> <span class="n">alpha_du</span> <span class="n">alpha_pr</span>  <span class="nb">ls</span>
  <span class="mi">10</span>  <span class="mf">1.1303218e-01</span> <span class="mf">1.61e-02</span> <span class="mf">9.28e-07</span>  <span class="o">-</span><span class="mf">5.7</span> <span class="mf">4.53e-01</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
  <span class="mi">11</span>  <span class="mf">3.7959122e-02</span> <span class="mf">7.79e-03</span> <span class="mf">2.54e-08</span>  <span class="o">-</span><span class="mf">5.7</span> <span class="mf">2.84e-01</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
  <span class="mi">12</span>  <span class="mf">2.1316195e-02</span> <span class="mf">1.77e-03</span> <span class="mf">4.98e-09</span>  <span class="o">-</span><span class="mf">5.7</span> <span class="mf">1.39e-01</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
  <span class="mi">13</span>  <span class="mf">1.8447375e-02</span> <span class="mf">6.30e-06</span> <span class="mf">5.26e-11</span>  <span class="o">-</span><span class="mf">5.7</span> <span class="mf">8.15e-03</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>
  <span class="mi">14</span>  <span class="mf">1.8440851e-02</span> <span class="mf">2.26e-09</span> <span class="mf">9.54e-15</span>  <span class="o">-</span><span class="mf">8.6</span> <span class="mf">1.61e-04</span>    <span class="o">-</span>  <span class="mf">1.00e+00</span> <span class="mf">1.00e+00</span><span class="n">h</span>  <span class="mi">1</span>

<span class="n">Number</span> <span class="n">of</span> <span class="n">Iterations</span><span class="k">...</span><span class="c">.: 14</span>

                                   <span class="p">(</span><span class="n">scaled</span><span class="p">)</span>                 <span class="p">(</span><span class="n">unscaled</span><span class="p">)</span>
<span class="n">Objective</span><span class="k">...</span><span class="c">............:   9.2204254694796125e-07    1.8440850938959225e-02</span>
<span class="n">Dual</span> <span class="n">infeasibility</span><span class="k">...</span><span class="c">...:   9.5381182640930876e-15    1.9076236528186175e-10</span>
<span class="n">Constraint</span> <span class="n">violation</span><span class="k">...</span><span class="c">.:   2.2559639156760625e-09    2.2559639156760625e-09</span>
<span class="n">Complementarity</span><span class="k">...</span><span class="c">......:   0.0000000000000000e+00    0.0000000000000000e+00</span>
<span class="n">Overall</span> <span class="n">NLP</span> <span class="nb">error</span><span class="k">...</span><span class="c">....:   2.2559639156760625e-09    2.2559639156760625e-09</span>


<span class="n">Number</span> <span class="n">of</span> <span class="n">objective</span> <span class="k">function</span> <span class="n">evaluations</span>             <span class="o">=</span> <span class="mi">19</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">objective</span> <span class="nb">gradient</span> <span class="n">evaluations</span>             <span class="o">=</span> <span class="mi">15</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">equality</span> <span class="n">constraint</span> <span class="n">evaluations</span>            <span class="o">=</span> <span class="mi">19</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">inequality</span> <span class="n">constraint</span> <span class="n">evaluations</span>          <span class="o">=</span> <span class="mi">0</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">equality</span> <span class="n">constraint</span> <span class="n">Jacobian</span> <span class="n">evaluations</span>   <span class="o">=</span> <span class="mi">15</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">inequality</span> <span class="n">constraint</span> <span class="n">Jacobian</span> <span class="n">evaluations</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Number</span> <span class="n">of</span> <span class="n">Lagrangian</span> <span class="n">Hessian</span> <span class="n">evaluations</span>             <span class="o">=</span> <span class="mi">14</span>
<span class="n">Total</span> <span class="n">CPU</span> <span class="n">secs</span> <span class="n">in</span> <span class="n">IPOPT</span> <span class="p">(</span><span class="n">w</span><span class="p">/</span><span class="n">o</span> <span class="k">function</span> <span class="n">evaluations</span><span class="p">)</span>   <span class="o">=</span>      <span class="mf">0.415</span>
<span class="n">Total</span> <span class="n">CPU</span> <span class="n">secs</span> <span class="n">in</span> <span class="n">NLP</span> <span class="k">function</span> <span class="n">evaluations</span>           <span class="o">=</span>      <span class="mf">0.065</span>

<span class="n">EXIT</span><span class="p">:</span> <span class="n">Optimal</span> <span class="n">Solution</span> <span class="n">Found</span><span class="o">.</span>
               <span class="n">t_proc</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>   <span class="n">t_wall</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>    <span class="n">n_eval</span>
       <span class="n">nlp_f</span>     <span class="mf">0.000898</span>     <span class="mf">0.000903</span>        <span class="mi">19</span>
       <span class="n">nlp_g</span>      <span class="mf">0.00904</span>      <span class="mf">0.00905</span>        <span class="mi">19</span>
  <span class="n">nlp_grad_f</span>       <span class="mf">0.0017</span>      <span class="mf">0.00169</span>        <span class="mi">16</span>
  <span class="n">nlp_hess_l</span>       <span class="mf">0.0214</span>       <span class="mf">0.0214</span>        <span class="mi">14</span>
   <span class="n">nlp_jac_g</span>       <span class="mf">0.0354</span>        <span class="mf">0.035</span>        <span class="mi">16</span>
      <span class="n">solver</span>        <span class="mf">0.489</span>        <span class="mf">0.487</span>         <span class="mi">1</span>
<span class="n">Elapsed</span> <span class="n">time</span> <span class="nb">is</span> <span class="mf">0.616536</span> <span class="n">seconds</span><span class="o">.</span>

</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">plotSHE</span><span class="p">(</span><span class="n">OptState</span><span class="p">,</span><span class="n">OptControl</span><span class="p">,</span><span class="n">Yfree</span><span class="p">,</span><span class="n">YT</span><span class="p">,</span><span class="n">xline</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span><span class="n">Nt</span><span class="p">)</span>
</code></pre>
</div>

<table>
    <tr>
        <th>
            <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0008/copiaRM_11.png" />
        </th>
         <th>
            <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP06/P0008/copiaRM_10.png" />
        </th>       
    </tr>
</table>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h1 id="burgers-equation"&gt;Burgers equation&lt;/h1&gt;
</code></pre>
</div>

<p>For a given viscosity parameter $\nu$ and for time $t&gt;0$, we consider the 2D Burgers equation on the unit square</p>

<script type="math/tex; mode=display">\frac {\partial}{\partial t}u + (u\nabla)u - \nu \Delta u = 0</script>

<p>with zero Neumann boundary conditions and initial condition</p>

<script type="math/tex; mode=display">u\bigr| _ {t=0}(x _ 1, x _ 2) = 
\begin{bmatrix}
 1 \\\\ 1 
\end{bmatrix}
e ^ {-3(x _ 1^2 + x _ 2^2)}</script>

<p>and its numerical approximation using</p>

<ol>
  <li>Finite Elements in space and Runge-Kutta in time,</li>
  <li>a POD reduction of the FEM model, and</li>
  <li>a DMD reduced order model.</li>
</ol>

<p>We present the basic ideas and how they are realized in a basic <em>Python</em> script.</p>

<h1 id="0-the-setup">0. The Setup</h1>

<p>Please download and run the python file <a href="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0009/burgers.py"><code class="highlighter-rouge">burgers.py</code></a> to check the
implementation, to reproduce the presented results, and to the behavior of the
routines for different parameters.</p>

<p>Here is the start of the script that lists the modules on which the
implementation bases on.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dolfin</span>

<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="kn">as</span> <span class="nn">spla</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">from</span> <span class="nn">spacetime_galerkin_pod.ldfnp_ext_cholmod</span> <span class="kn">import</span> <span class="n">SparseFactorMassmat</span>
</code></pre>
</div>

<p>The code uses <code class="highlighter-rouge">dolfin</code> which is the python interface to
<a href="https://fenicsproject.org/">FEniCS</a> while the other modules <code class="highlighter-rouge">scipy</code>, <code class="highlighter-rouge">numpy</code>,
and <code class="highlighter-rouge">matplotlib</code> are standard in python, I would say. The module
<code class="highlighter-rouge">ldfnp_ext_cholmod</code> is a little wrapper for the sparsity optimizing Cholesky
decomposition of <a href="https://github.com/scikit-sparse/scikit-sparse"><em>sksparse</em></a>.
It is available from my <a href="https://github.com/highlando/spacetime_galerkin_pod">github
repository</a> and falls back
to <code class="highlighter-rouge">numpy</code> routines, in the case that <code class="highlighter-rouge">sksparse</code> is not available.</p>

<h1 id="1-the-fem-discretization">1. The FEM Discretization</h1>

<h2 id="the-spatial-discretization-in-fenics">The spatial discretization in FEniCS</h2>

<p>First, the mesh is defined – here a uniform triangulation of the unit square
controlled by the parameter <code class="highlighter-rouge">N</code>. For the value <code class="highlighter-rouge">N=80</code> and for globally smooth
and piecewise quadratic ansatz functions, the resulting dimension of the system
is 51842.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># The mesh</span>

<span class="n">pone</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ptwo</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">RectangleMesh</span><span class="p">(</span><span class="n">pone</span><span class="p">,</span> <span class="n">ptwo</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

<span class="n">V</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">'CG'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c">### The FENICS FEM Discretization</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</code></pre>
</div>

<p>Next, the discrete linear operators are defined and exported as a <em>SciPy</em> sparse
matrix. Also, we factorize the mass matrix <code class="highlighter-rouge">mmat</code> for later use and define the
norm that is weighted with the mass matrix as this is the discrete $L^2$ norm.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># ## the mass matrix</span>

<span class="n">mform</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">dolfin</span><span class="o">.</span><span class="n">dx</span>
<span class="n">massm</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">mform</span><span class="p">)</span>
<span class="n">mmat</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">as_backend_type</span><span class="p">(</span><span class="n">massm</span><span class="p">)</span><span class="o">.</span><span class="n">sparray</span><span class="p">()</span>
<span class="n">mmat</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

<span class="c"># factorize it for later</span>


<span class="n">mfac</span> <span class="o">=</span> <span class="n">SparseFactorMassmat</span><span class="p">(</span><span class="n">mmat</span><span class="p">)</span>

<span class="c"># norm induced by the mass matrix == discrete L2-norm</span>

<span class="k">def</span> <span class="nf">mnorm</span><span class="p">(</span><span class="n">uvec</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">uvec</span><span class="p">,</span> <span class="n">mmat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uvec</span><span class="p">)))</span>

<span class="c"># ## the stiffness matrix</span>
<span class="c"># as a form in FEniCS</span>

<span class="n">aform</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="n">dolfin</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">dolfin</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dolfin</span><span class="o">.</span><span class="n">dx</span>
<span class="n">aassm</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">aform</span><span class="p">)</span>

<span class="c"># as a sparse matrix</span>

<span class="n">amat</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">as_backend_type</span><span class="p">(</span><span class="n">aassm</span><span class="p">)</span><span class="o">.</span><span class="n">sparray</span><span class="p">()</span>
<span class="n">amat</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
</code></pre>
</div>

<p>Then we define the convective term as function of the velocity <code class="highlighter-rouge">u</code> both in terms
of an FE-function and as a function of the associated coefficient vector.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># ## the convective term</span>

<span class="c"># as a function in FEniCS</span>

<span class="k">def</span> <span class="nf">burgers_nonl_func</span><span class="p">(</span><span class="n">ufun</span><span class="p">):</span>
    <span class="n">cform</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">dolfin</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">ufun</span><span class="p">)</span><span class="o">*</span><span class="n">ufun</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dolfin</span><span class="o">.</span><span class="n">dx</span>
    <span class="n">cass</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">cform</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cass</span>

<span class="c"># as a vector to form map</span>

<span class="k">def</span> <span class="nf">burgers_nonl_vec</span><span class="p">(</span><span class="n">uvec</span><span class="p">):</span>
    <span class="n">ufun</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">ufun</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">set_local</span><span class="p">(</span><span class="n">uvec</span><span class="p">)</span>
    <span class="n">bnlform</span> <span class="o">=</span> <span class="n">burgers_nonl_func</span><span class="p">(</span><span class="n">ufun</span><span class="p">)</span>
    <span class="n">bnlvec</span> <span class="o">=</span> <span class="n">bnlform</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">bnlvec</span>
</code></pre>
</div>

<h2 id="the-runge-kutta-time-integration">The Runge-Kutta Time Integration</h2>

<p>To apply standard time integration schemes (here, <code class="highlighter-rouge">RK23</code> turned out to be most
efficient), we define the <em>right hand side</em> $f_h$ of the spatially discretized problem</p>

<script type="math/tex; mode=display">\dot u_h = f_h (t_h, u_h).</script>

<p>In this case the <em>right hand side</em> is an application of the discrete diffusion
and convection operator and the inverse of the mass matrix that, simply
speaking, maps a (discrete) form onto a discrete function. Note that there is no
explicit time dependency in the Burgers equation, but <em>SciPy</em>’s <code class="highlighter-rouge">solve_ivp</code>
requires this parameter. Also, we define the initial value here. The time grid
is used to store the solution for the snapshots needed later, but the time
integrator uses his internal time grid.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">inivstrg</span> <span class="o">=</span> <span class="s">'exp(-3.*(x[0]*x[0]+x[1]*x[1]))'</span>
<span class="n">inivexpr</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">Expression</span><span class="p">((</span><span class="n">inivstrg</span><span class="p">,</span> <span class="n">inivstrg</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">inivfunc</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">inivexpr</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">inivvec</span> <span class="o">=</span> <span class="n">inivfunc</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>

<span class="n">burgsol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="n">brhs</span><span class="p">,</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">tE</span><span class="p">),</span> <span class="n">inivvec</span><span class="p">,</span> <span class="n">t_eval</span><span class="o">=</span><span class="n">timegrid</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'RK23'</span><span class="p">)</span>
<span class="n">fullsol</span> <span class="o">=</span> <span class="n">burgsol</span><span class="o">.</span><span class="n">y</span>
</code></pre>
</div>

<p>Here is the result. Note the sharp front that develops towards the end of the time
integration.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0009/fullsol.png" /></p>
<center>Solution snapshots of the full FEM model </center>

<h1 id="2-pod-reduced-model">2. POD Reduced Model</h1>

<p>If one has snapshots of the solution $v _ h$ at some time instances $t _ i$ one
may well think that the span of the matrix of snapshots</p>

<script type="math/tex; mode=display">% <![CDATA[
X = 
\begin{bmatrix}
v _ h(t_0) & v _ h(t_1) & \dotsm & v _ h(t_k)
\end{bmatrix} %]]></script>

<p>is a good candidate for a space in which the solution evolves in. One may even
go further and look for a low-dimensional basis of this space. The span of a
matrix is best approximated by its dominant singular vectors. And this is the idea of
<em>Proper Orthogonal Decomposition</em> (POD) – use the leading singular vectors as a
basis for the solution space.</p>

<p>We use the <code class="highlighter-rouge">Nts=101</code> snapshots of the FEM solutions to setup the matrix of
measurements $X$ and to compute the POD modes as $M^{-1/2}v _ k$, where $v _ k$
is the $k$-th leading left singular vector of $M^{1/2}X$. This procedure gives a
low-dimensional orthogonal (in the discrete $L^2$ inner product) basis that
optimally parametrizes the subspace of $L^2$ that is spanned by the solution
snapshots<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>. In this example, we use the <code class="highlighter-rouge">poddim=25</code> leading singular vectors
to define the reduced model.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">snapshotmat</span> <span class="o">=</span> <span class="n">mfac</span><span class="o">.</span><span class="n">Ft</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">burgsol</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="n">podmodes</span><span class="p">,</span> <span class="n">svals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">snapshotmat</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">selected_podmodes</span> <span class="o">=</span> <span class="n">podmodes</span><span class="p">[:,</span> <span class="p">:</span><span class="n">poddim</span><span class="p">]</span>
<span class="n">podvecs</span> <span class="o">=</span> <span class="n">mfac</span><span class="o">.</span><span class="n">solve_Ft</span><span class="p">(</span><span class="n">selected_podmodes</span><span class="p">)</span>
</code></pre>
</div>
<p>In this implementation we use a sparse factor of the mass matrix instead of the
square root. The singular values (in particular those that correspond to the
discarded directions) give an indication of how good the approximation is.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0009/svs.png" /></p>
<center>The singular values of the snapshot matrix </center>

<p>Here, the decay is comparatively slow, so that a one should not expect a good
low dimensional approximation by POD.</p>

<p>For the simulation, the state is parametrized by $u_h (t) \approx V \tilde
u_h(t)$ where $V$ is the matrix of the POD modes (in the code $V$ denoted by
<code class="highlighter-rouge">podvecs</code>), which gives a system in $\tilde u _ h$ with 25 degrees of freedom
(as opposed to the 51842 of the full order model).</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">redamat</span> <span class="o">=</span> <span class="n">podvecs</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">amat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">podvecs</span><span class="p">))</span>  <span class="c"># the projected stiffness</span>

<span class="k">def</span> <span class="nf">redbrhs</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">redvec</span><span class="p">):</span>
    <span class="n">inflatedv</span> <span class="o">=</span> <span class="n">podvecs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">redvec</span><span class="p">)</span>
    <span class="n">redconv</span> <span class="o">=</span> <span class="n">podvecs</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">burgers_nonl_vec</span><span class="p">(</span><span class="n">inflatedv</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">redamat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">redvec</span><span class="p">)</span> <span class="o">-</span> <span class="n">redconv</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
</code></pre>
</div>

<p>Here we define the projected stiffness matrix and the reduced nonlinearity
through</p>

<ol>
  <li>inflating the reduced state to full dimension</li>
  <li>applying the nonlinearity</li>
  <li>projecting down the result.</li>
</ol>

<p>This means that our model is not completely independent of the full dimension.
For this problem there are <em>hyperreduction</em> techiques like DEIM.</p>

<p>Thus, the <em>right hand side</em> is readily defined the more that the projected mass
matrix is the identity. Why?</p>

<p>Finally, the initial value is projected into the reduced coordinates and the
reduced system is integrated in time.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">redburgsol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="n">redbrhs</span><span class="p">,</span> <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">tE</span><span class="p">),</span> <span class="n">prjinivvec</span><span class="p">,</span>
                       <span class="n">t_eval</span><span class="o">=</span><span class="n">timegrid</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'RK23'</span><span class="p">)</span>
<span class="n">podredsol</span> <span class="o">=</span> <span class="n">redburgsol</span><span class="o">.</span><span class="n">y</span>
</code></pre>
</div>

<p>In the solution we see that the reduced order model gives a decent approximation
in the smooth regime in the beginning and has its troubles approximating the front as can be seen in the error (log) plot.</p>

<!-- < figure src="assets/imgs/WP04/P0009/podsol.png" title="Snapshots of the solution of the reduced system" lightbox="true" > -->
<!-- < figure src="assets/imgs/WP04/P0009/podfullerrlog.png" title="Snapshots of the log of the error between the full and the POD solution" lightbox="true" > -->
<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0009/podsol.png" /></p>
<center>Snapshots of the solution of the reduced system </center>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0009/podfullerrlog.png" /></p>
<center>Snapshots of the log of the error between the full and the POD solution</center>

<h1 id="3-dmd-reduced-model">3. DMD Reduced Model</h1>

<p>POD is partially data driven – it uses data to create a basis but still
uses (a projection of) the model. If only snapshots but no model is given, one
may use the method of <em>Dynamic Mode Decomposition</em><sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> (DMD) that tries to identify
a matrix $A$ that evolves the state like</p>

<script type="math/tex; mode=display">A v _ h (t_i) = v _ h (t _ {i+1})</script>

<p>In practice, one uses a set of snapshots and the two measurement matrices</p>

<script type="math/tex; mode=display">% <![CDATA[
X = 
\begin{bmatrix}
v _ h(t_0) & v _ h(t_2) & \dotsm & v _ h(t _ {k-1})
\end{bmatrix} %]]></script>

<p>and</p>

<script type="math/tex; mode=display">% <![CDATA[
X' =
\begin{bmatrix}
v _ h(t_1) & v _ h(t_2) & \dotsm & v _ h(t _ {k})
\end{bmatrix}. %]]></script>

<p>Note that $X’$ is basically $X$ shifted by one time step.</p>

<p>Then the DMD matrix can be found by solving the linear regression problem</p>

<script type="math/tex; mode=display">\min _ P \| X' - PX \| _ F.</script>

<p>For the reduced DMD model we use the same snapshot matrix as for the POD. The
regression problem is solved via SVD to compute the needed pseudo inverse since
this naturally allows for a rank reduction and a factored representation of the
DMD matrix.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># ### dmd using truncated svd inverse</span>

<span class="n">fburgsol</span> <span class="o">=</span> <span class="n">burgsol</span><span class="o">.</span><span class="n">y</span>
<span class="n">Xmat</span> <span class="o">=</span> <span class="n">fburgsol</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Xdsh</span> <span class="o">=</span> <span class="n">fburgsol</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
<span class="n">ux</span><span class="p">,</span> <span class="n">sx</span><span class="p">,</span> <span class="n">vxh</span> <span class="o">=</span> <span class="n">spla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">Xmat</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">uxr</span><span class="p">,</span> <span class="n">sxr</span><span class="p">,</span> <span class="n">vxhr</span> <span class="o">=</span> <span class="n">ux</span><span class="p">[:,</span> <span class="p">:</span><span class="n">poddim</span><span class="p">],</span> <span class="n">sx</span><span class="p">[:</span><span class="n">poddim</span><span class="p">],</span> <span class="n">vxh</span><span class="p">[:</span><span class="n">poddim</span><span class="p">,</span> <span class="p">:]</span>

<span class="c"># compute the dmd matrix in factored form: `dmda = dmdaone * dmdatwo`</span>

<span class="n">dmdaone</span> <span class="o">=</span> <span class="n">Xdsh</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vxhr</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">dmdatwo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sxr</span><span class="p">),</span> <span class="n">uxr</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</code></pre>
</div>

<p>Once the DMD matrix $A$ is determined, the simulation of the DMD reduced model
is only a repeated multiplication by $A$.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># simulation of the dmd reduced model</span>

<span class="n">dmdxo</span> <span class="o">=</span> <span class="n">inivvec</span>
<span class="n">dmdsol</span> <span class="o">=</span> <span class="p">[</span><span class="n">dmdxo</span><span class="p">]</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nts</span><span class="p">):</span>
    <span class="n">dmdsol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dmdaone</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmdatwo</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmdsol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>

<span class="n">dmdsol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dmdsol</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</code></pre>
</div>

<p>As can be seen from the results and the error plots, DMD does a good job in the
initial phase but fails in the region with the sharp front.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0009/dmdsol.png" /></p>
<center>Snapshots of the DMD solution</center>
<!-- < figure src="assets/imgs/WP04/P0009/dmdfullerrlog.png" title="Error (log) plot with respect to the full FEM solution" lightbox="true" > -->

<h1 id="4-remarks">4. Remarks</h1>

<p>It is commonly accepted that POD does not work well for transport dominated
problems – like the current case with the low viscosity parameter <code class="highlighter-rouge">nu=1e-4</code>.</p>

<p>So, I think that the results for POD are quite good noting that the reduced
order model has 25 degrees of freedom whereas the full model has 51842.
Nonetheless, in my tests, increasing the number of basis functions did not help
much. One can use a larger <code class="highlighter-rouge">nu</code> to get better POD approximations.</p>

<p>The DMD approach shows a similar performance. If compared to POD, the
qualitative approximation looks less good but the numbers are slightly better.
All in all, the DMD approximation seems less reliable as for some parameter
choices, the performance severely deteriorated.</p>

<p>Differential Equations.* <a href="https://arxiv.org/abs/1611.04050">arXiv:1611.04050</a></p>

<p>Decomposition: Theory and Applications* <a href="https://arxiv.org/abs/1312.0041">arXiv:1312.0041</a></p>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>See, e.g., Lemma 2.5 of Baumann, Benner, and Heiland (2018): *Space-Time Galerkin POD with Application in Optimal Control of Semi-linear Parabolic Partial <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>See, e.g., Tu, Rowley, Luchtenburg, Brunton, Kutz (2013): *On Dynamic Mode <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h1&gt;The problem&lt;/h1&gt;
</code></pre>
</div>

<p>We consider the following one-dimensional Burgers equation</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq} 
\left\{ \begin{array}{l}
\partial_t u(t,x)+\partial_x f(u(t,x))=0, \quad (t,x)\in \mathbb{R}^+ \times \mathbb{R}, \\
u(0,x)=u_0(x),
\end{array}\right.
\end{equation}</script>

<p>where $u$ is the state, $u_0$ is the initial state and  the flux function $f$ is defined by $f(u)=\frac{u^2}{2}$. Kruzkov’s theory  provides existence and uniqueness of a  solution  of \eqref{eq} with initial datum $u_0 \in L^{\infty}(\mathbb R)$. This solution is called a weak-entropy solution, denoted by $(t,x) \to S_t^+(u_0)(x)$. For a given target function $u^T$, we introduce the backward entropy  solution $(t,x) \to S^-_{t}(u^T)(x)$  as follows: 
for every $t\in [0,T]$, for a.e $x\in \mathbb R$,</p>

<script type="math/tex; mode=display">S^-_{t}(u^T)(x)= S^+_{t}(x\to u^T(-x))(-x).</script>

<p>We study the problem of inverse design for \eqref{eq}. This problem consists in  identifying the set of initial data evolving to a given target at a final time.</p>

<p>Due to the time-irreversibility of the Burgers equation, some target functions are unattainable from weak-entropy solutions of this equation, making the inverse problem under consideration ill-posed. To get around this issue, we introduce the following  optimal control problem</p>

<script type="math/tex; mode=display">\begin{equation} \tag{$\mathcal{O}_T$}\label{opt2} \inf_{u_0\in \mathcal{U}^0_{\text{ad}}} J_0(u_0):=\Vert u^T(\cdot)-S_T^+(u_0)(\cdot)\Vert_{L^2(\mathbb R)},\end{equation}</script>

<p>where $u^T$ is a given target function and the class of admissible initial data $\mathcal{U}^0_{\text{ad}}$ in \eqref{opt2} is defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \label{admissible_set}\mathcal{U}^0_{\text{ad}}=\{u_0\in BV(\mathbb R) \text{ such that } \Vert u_0 \Vert_{BV( \mathbb R)} < C \,  \text{and } \text{supp}(u_0)\subset K_0\}.\end{equation} %]]></script>

<p>Above, <script type="math/tex">BV</script> stands for functions of bounded variation and  $C&gt;0$ is a constant large enough. The study of \eqref{opt2} is motivated by the minimization of the sonic boom effects generated by supersonic aircrafts [2].</p>

<p>To solve the optimal control problem \eqref{opt2}, some difficulties arise from a  theoretical  and  numerical point of view.</p>
<ul>
  <li>Since the  entropy solution $u$ of \eqref{eq} may contain shocks even if the initial datum is a smooth function, this generates important added difficulties that have been the object of intensive study in the past, see  [3,4] and the references therein. In particular, the authors make sense of the derivative of $J_0$ in \eqref{opt2} in a weak way by requiring  strong conditions on the set of initial data. This leads to require that entropy solutions of \eqref{eq} have a finite number of non-interacting jumps.</li>
  <li>When $J_0$ is weakly differentiable,  gradient descent  methods have been implemented in [1,5,6] to solve numerically the optimal problem \eqref{opt2}. In the cases where it was applied successfully, only one possible initial datum emerges, namely the backward entropy solution $S_T^-(u^T)$. This is mainly due to the numerical viscosity that numerical schemes introduce to gain stability. To find some multiple minimizers, the authors in  [8]  use a filtering step in the backward adjoint solution.</li>
</ul>

<p>Dans [9], we fully characterize the set of minimizers of the optimal control problem \eqref{opt2}.</p>

<p><b>Theorem 1.</b>  Let $u^T\in BV(\mathbb R)$. The optimal control problem \eqref{opt2}  admits multiple optimal solutions. Moreover, for a.e $T&gt;0$, the initial datum $u_0\in BV(\mathbb R)$ is an optimal solution of \eqref{opt2} if and only if $u_0 \in BV(\mathbb R)$ verifies $S_T^+(u_0)=S_T^+ (S_T^-(u^T))$.</p>

<p>A characterisation of the set <script type="math/tex">\{u_0 \in BV(\mathbb R), S_T^+(u_0)=S_T^+ (S_T^-(u^T))\}</script> is given in [7]. An illustration of Theorem 1. is given in Figure 1.</p>

<p><img width="50%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/Projection2.png" /></p>
<center>Figure 1: The backward-forward  solution $S_T^+(S_T^-(u^T))$ is the projection of $u^T$ onto the set of attainable target functions. The shaded area in red at time $t=0$ represents the set of minimizers of \eqref{opt2} </center>

<p>The proof of Theorem 1 is structured as follows. From [7, Theorem 3.1, Corollary 3.2] or [8, Corollary 1], there exists $u_0\in BV(\mathbb R)$ such that <script type="math/tex">S^+_T(u_0)=q</script> if and only if <script type="math/tex">q</script> satisfies  the one-sided Lipschitz condition, i.e 
<script type="math/tex">\begin{equation*}\partial_x q \leq \frac{1}{T}  \text{ in } \mathcal{D}'(\mathcal{R}).\end{equation*}</script>
 Thus, the optimal problem \eqref{opt2} can be rewritten as  follows.</p>

<script type="math/tex; mode=display">\begin{equation} \label{opt5} \min_{q\in \mathcal{U}^T_{\text{ad}}} J_1(q):=\Vert u^T-q \Vert_{L^2(\mathcal{R})},  \end{equation}</script>

<p>where the admissible set $\mathcal{U}^T_{\text{ad}}$ is defined by</p>

<script type="math/tex; mode=display">\begin{equation} \mathcal{U}^T_{\text{ad}}=\{ q\in BV(\mathbb R) \text{ such that } \, \, \partial_x q \leq \frac{1}{T} \,  \, \text{and } \Vert q \Vert_{BV( \mathbb R)} \leq C \, \text{and }\text{Supp}(q)\subset K_1 \}.\end{equation}</script>

<p>Above, $K_1$ an open bounded interval large enough.  Note that the optimal problem \eqref{opt5} is not related to the PDE model \eqref{eq}. We prove that $q=S_T^+ (S_T^-(u^T))$ is a critical point of \eqref{opt5} using the first-order optimality conditions applied to \eqref{opt5} and the full characterization of the set <script type="math/tex">\{u_0 \in BV(\mathbb R) \text{ such that } S_T^-(u_0)=S_T^-(u^T)\}</script> given in [9, Theorem A.2].</p>

<h1>Numerical simulations</h1>

<p>In [9,Section 3], we  implement a wave-front tracking algorithm to construct numerically the set of  minimizers of \eqref{opt2}.  We consider for instance, a target function <script type="math/tex">u^T</script>  defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \label{uT} u^T(x)=\left\{\begin{array}{ll}
2 &\text{if} \, \,x\in (-0.2,1.1)\bigcup(2,3.1)\bigcup (4.1,5.3)\bigcup (6.1,7.2), \\
-1 & \text{otherwise}.
\end{array}\right.
\end{equation} %]]></script>

<p>From Theorem 1,  the backward solution <script type="math/tex">S_T^-(u^T)</script> is an  optimal solution of \eqref{opt2} and  <script type="math/tex">u_0</script> is an optimal solution of \eqref{opt2} if and only if  <script type="math/tex">S_T^+(u_0)=S_T^+ (S_T^-(u^T))</script>. In Figure 2, the target function <script type="math/tex">u^T</script>, the backward solution <script type="math/tex">S_T^-(u^T)</script> and  the backward-forward solution <script type="math/tex">S_T^+ (S_T^-(u^T))</script> are plotted.</p>

<center>
<table>
    <tr>
        <td>
        <img width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/ex_Stmoins.png" />
        </td>
        <td>
        <img width="90%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/WFTforward.png" />
        </td>
    </tr>
    <tr>
        <td>
        <center>$x\to S^{-}_T(u^T)(x)$ </center>
        </td>
        <td>
        <center>$(t,x)\to S^{+}_t(S^{-}_T(u^T))(x)$ </center>
         </td>
    </tr>
</table>
</center>

<p><img width="50%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/ex_final.png" /></p>
<center>$u^T$  and $\color{red}{x\to S^{+}_T(S^{-}_T(u^T))(x)}$ </center>
<p>$ $</p>
<center>Figure 2. Plotting of the target function $u^T$ defined in \eqref{uT}, the optimal solution $S_T^-(u^T)$ and the backward-forward solution $\color{red}{S^{+}_T(S^{-}_T(u^T))}$.</center>

<p>Note that <script type="math/tex">S_T^+(S_T^-(u^T))</script> has four different shocks located at $x=1.1$, $x=3.1$, $x=5.3$ and $x=7.2$. If we use a conservative numerical method as Godunov scheme,  the approximate solution of <script type="math/tex">S_T^+(S_T^-(u^T))</script> doesn’t have shocks because of numerical viscosity that numerical schemes introduced, see Video 1.</p>

<center>
<table>
    <tr>
        <td>
            <video width="98%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_God_WFT.mov" controls=""></video>
        </td>
        <td>
            <video width="98%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_God_WFT_zoom.mov" controls=""></video>
        </td>
    </tr>
</table>
</center>
<center>Video 1. Approximate solution of $S_T^+(u_0)$ with $u_0$ an $N$-wave constructed with $ \color{red}{\text{a wave-front tracking algorithm}}$ and $\color{blue}{\text{a Godunov scheme}}$ </center>

<p>This implies that only one minimizer of \eqref{opt2} can be constructed using a Godunov scheme, which is the backward entropy solution $S_T^-(u^T)$. When a wave-front tracking algorithm is implemented, the approximate solution of $S_T^+(S_T^-(u^T))$ has shocks since we track the possible discontinuities from $u^T$ to  $S_T^+(S_T^-(u^T))$. This implies that all initial data $u_0$ that coincide with the approximate solution of $S_T^+ (S_T^-(u^T))$ can be recovered, see [9,Section 3].</p>

<p>In Video 2, we show that the weak-entropy solution of \eqref{eq}  with initial data $S_T^-(u^T)$ coincides with $S_T^+ (S_T^-(u^T))$ at time $T$.</p>
<center>
<video width="50%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_0.mov" controls=""></video></center>
<center>Video 2. Approximate solution of $(t,x) \to S_t^+(S_T^-(u^T))(x)$  using a wave-front tracking algorithm. </center>

<p>In Video 3, three other approximate optimal solutions $u_0$ of \eqref{opt2} are constructed. In particular, we show that  $S_T^+ (u_0)=S_T^+ (S_T^-(u^T))$.</p>

<center>
<table>
    <tr>
        <th>
            <video width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_1.mov" controls=""></video>
        </th>
        <th>
            <video width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_3.mov" controls=""></video>
        </th>
    </tr>
<table>
    <tr>
                
            <video width="50%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_4.mov" controls=""></video>
    
    </tr>
</table>
</table>
</center>
<center>Video 3. Three approximate optimal solutions of \eqref{opt2} constructed using a wave-front tracking algorithm </center>

<p>[1] Navid Allahverdi,  Alejandro Pozo and Enrique Zuazua. Numerical aspects of large-time optimal control of Burgers equation. ESAIM: Mathematical Modelling and Numerical Analysis, 50 (5):1371-1401,2016.</p>

<p>[2]  Navid Allahverdi,  Alejandro Pozo and Enrique Zuazua. Numerical aspects of sonic-boom minimization. A panorama of Mathematics: Pure and Applied, 658:267,2016.</p>

<p>[3] François Bouchut and François James. One-dimensional transport equations with discontinuous coefficients. Nonlinear Analysis, 32(7):891,1998.</p>

<p>[4] Alberto Bressan and Andrea Marson. A maximum principle for optimally controlled systems of conservation laws. Rendiconti del Seminario Matematico della Universita di Padova, 94:79-94, 1995.</p>

<p>[5] Carlos Castro, Francisco Palacios and Enrique Zuazua. An alternating descent method for the optimal control of the inviscid Burgers equation in the presence of shocks. Mathematical Models and Methods in Applied Sciences, 18(03):369-416,2008.</p>

<p>[6] Carlos Castro, Francisco Palacios and Enrique Zuazua. Optimal control and vanishing viscosity for the Burgers equation. In Integral Methods in Science and Engineering, Volume 2, pages 65-90. Springer, 2010.</p>

<p>[7] Rinaldo Colombo and Vincent Perrollaz. Initial data identification in conservation laws and Hamilton-Jacobi equations. arXiv preprint arXiv:1903.06448,2019.</p>

<p>[8] Laurent Gosse and Enrique Zuazua. Filtered gradient algorithms for inverse design problems of one-dimensional Burgers equation. In Innovative algorithm and analysis, pages 197-227. Springer, 2017.</p>

<p>[9] Thibault Liard and Enrique Zuazua. Inverse design for the one-dimensional Burgers equation. Submitted (2019).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;The inverse design of hyperbolic transport equations can be addressed by using gradient-adjoint methodologies. Recently, Morales-Hernandez and Zuazua [1] investigated the convenience of using low order numerical schemes for the adjoint resolution in the gradient-adjoint method. They focused on hyperbolic transport scalar equations with an heterogeneous time-independent vector field.&lt;/p&gt;
</code></pre>
</div>

<p>Morales-Hernandez and Zuazua analysed the numerical resolution of the adjoint equation by means of two methods: a First Order Upwind $(FOU)$ scheme and a Second Order Upwind $(SOU)$ scheme. They concluded that the $FOU$ scheme is the best choice when dealing with smooth functions once the $SOU$ scheme introduces some spurious oscillations. In addition, the $FOU$ scheme requires shorter computational time than the $SOU$ scheme. The non-linear transport problems in which sharp interfaces or discontinuities may appear in the functions has remained to be studied.</p>

<p>The numerical scheme for the adjoint equation determines the direction of descent in the iteration procedure, and consequently the $CPU$ time consumed by the solver. As the $CPU$ time is a decisive factor, we propose an eulerian-lagrangian scheme that uses the Modified Method of Characteristics ($MMOC$) [2] for solving the transport and adjoint equations. The $MMOC$ method is based on the characteristic curves, and so very computationally competitive for linear hyperbolic transport equations. The $MMOC$ was initially developed performing the resolution in a forward sense. In this work, the eulerian-lagrangian scheme is used for the transport and adjoint resolution, employing it in both forward and backward senses.</p>

<p>We perform numerical tests in order to investigate the accuracy and efficiency of the eulerian-lagrangian scheme to solve the problem of inverse design of linear and non-linear hyperbolic transport scalar equations.</p>

<h1 id="the-gradient-adjoint-method">The gradient-adjoint method</h1>

<p>Consider the following hyperbolic transport scalar equation with a vector flux function ${\bf f} (u)$:</p>

<p>\begin{equation}\label{eq1}
\frac{\partial u}{\partial t} + \nabla \cdot {\bf f} (u) = 0, ~ ~ u({\bf x},0) = u_0.
\end{equation}</p>

<p>Given a target function $u^* \in \bf H$, $\bf H$ being a Hilbert space, the problem of inverse design consists of achieving $u_0 \in \bf H$ such that the solution of the former evolution equation satisfies $u(T) = u^*$. This problem is solved via the minimization of the functional</p>

<p>\begin{equation}\label{eq2}
J(u_0) = \frac{1}{2} \int_{0}^{T} \int_{\Omega} (u(T) - u^*)^2 d\Omega dt
\end{equation}</p>

<p>by means of the gradient descent method:</p>

<p>\begin{equation}\label{eq3}
{u_0}^{k+1} = {u_0}^k -  \epsilon {\nabla J}^k,
\end{equation}</p>

<p>where $\epsilon$ is the step size, and the gradient $\nabla J = \sigma (0)$, in which $\sigma$ is the adjoint variable . The gradient $\sigma (0)$ is achieved by solving the adjoint equation:</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq4}
\frac{\partial \sigma}{\partial t} - {\bf f}^\prime (u) \cdot \nabla \sigma = 0, ~ ~ \sigma (T) = u(T) - u^* .
\end{equation}</script>

<p>The gradient-adjoint method is based on iterating a loop, where the transport equation (\ref{eq1}) is solved in a forward sense, while the adjoint equation (\ref{eq4}), which is of hyperbolic nature as well, is solved backwards in time.</p>

<h1 id="the-mmoc-in-forward-sense">The $MMOC$ in forward sense</h1>

<p>Eulerian-lagrangian approaches provide computationally efficient techniques for approximating the solution of hyperbolic transport equations. Douglas and Russel [2] introduced an eulerian-lagrangian method based on the characteristic curve - the $MMOC$ - to develop fast solvers for hyperbolic transport equations. Despite the $MMOC$ does not provide a local conservation of the identity associated with the function, it present good performance for linear hyperbolic transport equations.</p>

<p>We use the $MMOC$ method for solving the transport and adjoint equations in the context of the problem of inverse design of hyperbolic transport equations. In this problem, the adjoint equation is always a linear differencial equation, worthing the use of the eulerian-lagrangian scheme. The gradient-adjoint iteration requires the adjoint equation to be solved in backward sense. We employ an eulerian-lagrangian scheme that uses the $MMOC$, considering procedures in forward and backward senses.</p>

<p>Consider a scalar hyperbolic transport equation determining the initial value problem</p>

<p>\begin{equation}\label{eq5}
\frac{\partial u}{\partial t} + \nabla \cdot {\bf f} (u) = 0, ~ ~ u({\bf x},0) = u_0 ,
\end{equation}</p>

<p>where ${\bf f} (u)$ is a vector flux function. Rewriting the Eq. (\ref{eq5}) in nondivergence form,</p>

<p>\begin{equation}\label{eq6}
\frac{\partial u}{\partial t} + {\bf f}^\prime (u) \cdot \nabla u  = 0 .
\end{equation}</p>

<p>The solution of Eq. (\ref{eq6}) is essentially along the characteristic curves of the transport operator $\partial / \partial t + {\bf f}^\prime (u) \cdot \nabla$, so that it is appropriate to introduce differentiation in this characteristic direction. Let</p>

<p>\begin{equation}\label{eq7}
\partial / \partial t + {\bf f}^\prime (u) \cdot \nabla = \psi \frac{\partial}{\partial \tau} , ~~\psi (u) = \sqrt {1 + {\left \lVert {\bf f}^\prime (u) \right \rVert}^2} , <br />
\end{equation}</p>

<p>in which the direction $\tau$ depends on $\bf x$.</p>

<p>Let us consider the discretization of  Eq. (\ref{eq6}) in time. Denote the time step $\Delta t &gt; 0$ and consider the approximation of the solution at times $t^n = n \Delta t$. In the standard $MMOC$, the characteristic derivative is approximated by</p>

<p>\begin{equation}\label{eq8}
\psi \frac{\partial u}{\partial \tau} \approx \psi (u({\bf x}, t^{n-1})) \frac {u({\bf x}, t^{n}) - u(\overline {\bf x}^n, t^{n-1})}{\sqrt {\left \lVert {\bf x} - \overline {\bf x}^n \right \rVert^2 + (\Delta t)^2 }} =  \frac {u({\bf x}, t^{n}) - u(\overline {\bf x}^n, t^{n-1})}{\Delta t} ,<br />
\end{equation}</p>

<p>where</p>

<p>\begin{equation}\label{eq9}
\overline {\bf x}^n =  \overline {\bf x}^n ({\bf x}) = {\bf x} - {\bf f}^\prime (u({\bf x}, t^{n-1}) \Delta t .
\end{equation}</p>

<p>Let $U^n ({\bf x})$ denote the approximations to $u({\bf x},t^n)$. For a predecessor position</p>

<p>\begin{equation}\label{eq10}
\overline {\bf X}^n ({\bf x}) = {\bf x} - {\bf f}^\prime (U^{n-1} ({\bf x})) \Delta t,
\end{equation}</p>

<p>the transported function is defined as</p>

<p>\begin{equation}\label{eq11}
\overline {U}^n ({\bf x}) =  u (\overline {\bf X}^n ({\bf x}), t^{n-1}) .
\end{equation}</p>

<p>As the continuous in space approximation for Eq. (\ref{eq6}) is</p>

<p>\begin{equation}\label{eq12}
\frac{U^n ({\bf x}) - \overline U^{n} ({\bf x})}{\Delta t} = 0 ,
\end{equation}</p>

<p>the $MMOC$ scheme is given by</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq13}
U^n (\textbf{x}) =  \overline U^{n} (\textbf{x}) 
\end{equation}</script>

<h1 id="preliminary-results">Preliminary results</h1>

<p>The performance of the $MMOC$ scheme is checked in numerical tests, where two hyperbolic transport problems are considered. The results by $MMOC$ are compared with the ones by the Lax-Wendroff ($LW$), which is a second-order central scheme.</p>

<h3 id="2d-doswell-frontogenesis">2D Doswell frontogenesis</h3>

<p>The first test case symbolizes the presence of horizontal temperature gradients and fronts in the context of meteorological dynamics. In this linear problem the flux function is</p>

<p>\begin{equation}
{\bf f} (u) =  {\bf v} (x,y)~ u ,
\end{equation}</p>

<p>where ${\bf v} (x,y)= g~(-y,~x)$, $g = \frac{1}{r}2.59807~sech^2(r)~tanh(r)$, and $r = \sqrt{x^2 + y^2}$. The exact solution of this problem is given by</p>

<p>\begin{equation}
u (x,y,t) = tanh(y~cos(gt) - x~sin(gt)).
\end{equation}</p>

<p>The domain $\Omega = [-5,5]^2$ is discretized in 40000 square cells, a step size $\epsilon = 0.5$ is selected and the Courant number is set to $CFL = 1.0$. The results are shown in Fig.1 for the initial condition and target function at $T = 4s$. The target function in a vortex-type profile is presented by both the $LW$ and $MMOC$ schemes.</p>

<center>
<table style="text-align:center;">
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0008/bilbao_LW_0.jpg" />
        </th>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0008/bilbao_LW_4.jpg" />
        </th>
    </tr>
    <tr>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0008/bilbao_MMOC_0.jpg" />
        </th>
        <th>
            <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0008/bilbao_MMOC_4.jpg" />
        </th>
    </tr>
</table>
</center>

<center> <b>Figure 1.</b> The initial condition and target function by $LW$ (top) and MMOC (bottom).   
</center>

<p>Results of $CPU$ time and $L_2$ norm of the numerical initial condition with respect to the exact initial condition are displayed in Table [1]. The results are quite the same for the $LW$ and $MMOC$, since we have a linear transport equation.</p>

<center>
<table style="text-align:center;">
<tr>
    <th>
		  $Scheme$ 
    </th>
    <th>
         $CPU~ time~ (s)$ 
    </th>
    <th>
        $L_2~ norm$ 
    </th>


</tr>
<tr>
        <th>
		  $LW$ 
    </th>
    <th>
         49.0
    </th>
    <th>
        4.07
    </th>
</tr>
<tr>
        <th>
		  $MMOC$ 
    </th>
    <th>
         80.8
    </th>
    <th>
        3.96
    </th>
</tr>
</table>
</center>

<center><b>Table 1.</b> Performance for initial condition in the Doswell frontogenesis.</center>

<h3 id="inviscid-burgers-equation">Inviscid Burgers equation</h3>

<p>We consider the Burgers equation with zero viscosity term which is called the inviscid Burgers equation. This equation is one of the most useful formulation of the behaviour of the shock waves in which nonlinear advection can be observed. In this nonlinear problem the flux function is</p>

<p>\begin{equation}
f (u) =  \frac{1}{2} u^2 .
\end{equation}</p>

<p>The exact solution of this problem is given by</p>

<p>\begin{equation}
u(x,t) = sin(x - ut) .
\end{equation}</p>

<p>The domain $\Omega = [0,32]^2$ is discretized in 4096 square cells, a step size $\epsilon = 0.01$ is selected and the Courant number is set to $CFL = 0.1$. The exact and $MMOC$ initial conditions are shown in Fig 2 considering zero values as a guess initial condition. Only with the $MMOC$ scheme the numerical solver was able to converge to the initial condition for the selected step size.</p>

<table style="text-align:center;">
    <tr>
    <th>
        <img width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0008/burger_exact_0.jpg" />
    </th>
    <th>
        <img width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0008/burger_MMOC_0.jpg" />
    </th>
    </tr>
</table>
<center>     <b>Figure 2.</b>The exact (left) and $MMOC$ (right) initial conditions.
</center>

<p>In order to observe the convergence to the initial condition, we set $u_0(x) = \beta sin(x)$ as a guess initial condition, where $\beta$ is a constant. As $\beta$ is next to one, the guess initial conditions is closer to the exact initial condition. Table 2 displays the $CPU$ time and $L_2$ norm of the numerical initial condition with respect to the exact initial condition for several $\beta$ values. The numerical solver using $MMOC$ scheme converged for any $\beta$ value, showing that the norm is smaller as the $\beta$ is increased.</p>

<center>
<table style="text-align:center;">
    <tr>
        <th>$\beta$ </th>   <th>$LW$</th>  <th>$MMOC$</th>
    </tr>
    <tr>
        <th>0.1 </th>   <th>3.68</th>  <th>3.39</th>
    </tr>
    <tr>
        <th>0.5 </th>   <th>2.82</th>  <th>2.70</th>
    </tr>    
    <tr>
        <th>0.9 </th>   <th>0.95</th>  <th>1.19</th>
    </tr>
</table>
</center>

<center>
<b>Table 2. </b>Performance for initial condition by $MMOC$ in the Burgers problem.
</center>

<h1 id="conclusions">Conclusions</h1>

<p>The results achieved and presented here are preliminary ones. The $MMOC$ is a promising eulerian-lagrangian scheme for the problem of inverse design of nonlinear transport equations. More complex problems and another eulerian-lagrangian scheme are to be tested. The next steps are the follows:</p>

<ul>
  <li>simulate and investigate the Buckley-Leverett problem;</li>
  <li>simulate and investigate the miscible tracer flow; and</li>
  <li>use the $LCELM$ eulerian-lagrangian scheme [3].</li>
</ul>

<h1 id="references">References</h1>

<p>[1] M. Morales-Hernandez, E. Zuazua, Adjoint computational methods for 2d inverse design of linear transport equations on unstructured grids, Computational and Applied Mathematics (2019)</p>

<p>[2] J. Douglas, T. F. Russell, Numerical methods for convection dominated diffusion problems based on combining the method of characteristics with finite element or finite difference procedures, SIAM J.
Numer. Anal. (1982)</p>

<p>[3] J. Douglas, F. Pereira, L.-M. Yeh, A locally conservative euleriana lagrangian numerical method and its application to nonlinear transport in porous media, Computational Geosciences (2000)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;The finite-dimensional dynamical system given by a pendulum on a cart (cartpole) is widely considered as a benchmark for comparing the performance of different control strategies. In this blog post, we consider a double pendulum on a cart and we solve the problem of swinging up the pendulum from the downward position to the upward position using optimal control techniques.&lt;/p&gt;
</code></pre>
</div>

<h3>Setup</h3>

<p>In this tutorial we need <a href="https://deustotech.github.io/dycon-toolbox-documentation/">DyCon Toolbox</a>, to install it we will have to write the following in our MATLAB console:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">unzip</span><span class="p">(</span><span class="s1">'https://github.com/DeustoTech/DyCon-Computational-Platform/archive/master.zip'</span><span class="p">)</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="nb">cd</span><span class="p">,</span><span class="s1">'DyCon-toolbox-master'</span><span class="p">)))</span>
<span class="n">StartDyConToolbox</span>    
</code></pre>
</div>
<p>You can see the code of this tutorial write the following line:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">open</span> <span class="n">T06ODET0006_Double_pend</span>   
</code></pre>
</div>
<h3>Equations of motion</h3>

<p><img width="50%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0008/sch.png" /></p>
<center>
  <b>Figure 1. Scheme of system dynamics</b>
</center>

<p>The physical system defined by the double pendulum in a cart can be modelled as a system of six ordinary differential equations, whose state at each instant of time $t \geq 0$ is the vector $y(t) = \left( x(t), \theta_{1}(t), \theta_{2}(t), v(t), \omega_{1}(t), \omega_{2}(t) \right)$, where:</p>

<ul>
  <li>$x(t) \in \mathbb{R}$ is the position of the cart.</li>
  <li>$\theta_{i}(t) \in [0, 2\pi]$ is the angle of the $i$-th pendulum.</li>
  <li>$v(t) \in \mathbb{R}$ is the velocity of the cart.</li>
  <li>$\omega_{i}(t) \in \mathbb{R}$ is the angular velocity of the $i$-th pendulum.</li>
</ul>

<p>The equations of motion of the system can be derived using the Lagrangian formalism of classical mechanics and are given by:</p>

<script type="math/tex; mode=display">(1)
  \begin{cases}
  \dot{x}(t) = v(t) \\
  \dot{\theta}_{1}(t) = \omega_{1}(t) \\
  \dot{\theta}_{2}(t) = \omega_{2}(t) \\
  M(\theta_1(t),\theta_2(t)) \cdot \begin{bmatrix} 
         \dot{v}(t) \\ \dot{\omega}_1(t) \\ \dot{\omega}_2(t) 
    \end{bmatrix} = G(\theta_1(t),\theta_2(t),\omega_1(t),\omega_2(t))  -  \begin{bmatrix}
      d_1 \cdot v(t) \\ d_2 \cdot \omega_1(t) \\ d_3 \cdot \omega_2(t)
    \end{bmatrix} + \begin{bmatrix}
      u(t) \\ 0 \\ 0
    \end{bmatrix}
    \end{cases}</script>

<p>where, for each $t \geq 0$, we define:</p>

<script type="math/tex; mode=display">G(\theta_1(t),\theta_2(t),\omega_1(t),\omega_2(t)) = \begin{bmatrix}
    l_1(m_1+m_2) \cdot \omega_1(t)^2 \sin(\theta_1(t)) + m_2l_2\cdot \omega_2(t)^2 \sin(\omega_2(t)) \\
    -l_1l_2m_2\cdot\omega_2(t)^2 \sin(\theta_1(t)-\theta_2(t)) + g(m_1+m_2)l_1 \cdot \sin(\theta_1(t)) \\
    l_1l_2m_2 \cdot \omega_1(t)^2\sin(\theta_1(t)-\theta_2(t)) + g l_2 m_2 \cdot \sin(\theta_2(t))
  \end{bmatrix}</script>

<p>and</p>

<script type="math/tex; mode=display">% <![CDATA[
M(\theta_1(t),\theta_2(t)) = \begin{bmatrix}
      m+m_1+m_2 & l_1(m_1 +m_2 )\cdot\cos(\theta_1(t)) & m_2l_2\cdot\cos(\theta_2(t)) \\
      l_1(m_1+m_2)\cdot\cos(\theta_1(t)) & l_1^2(m_1+m_2) & l_1l_2m_2\cdot \cos(\theta_1(t)-\theta_2(t)) \\
      l2 m_2\cdot\cos(\theta_2(t)) & l_1 l_2 m_2 \cos(\theta_1(t)-\theta_2(t)) & l_2^2 m_2
    \end{bmatrix} %]]></script>

<p>We have the fixed parameters:</p>

<ul>
  <li>$d_{i} \in [0,1]$ are damping coefficients.</li>
  <li>$m &gt; 0$ is the mass of the cart and $m_{i} &gt; 0$ is the mass of the $i$-th pendulum.</li>
  <li>$l_{i} &gt; 0$ is the length of the $i$-th pendulum.</li>
</ul>

<p>The function $u \in L^{\infty}(0,\infty; \mathbb{R})$ is a time-dependent control that acts on the acceleration term $\dot{v}(t)$ of the cart, and can thus be interpreted as a force that is exerted on the cart.</p>

<p>This dynamical system shows chaotic behaviour. The following animation displays the evolution of the double pendulum on a cart with control $u = 0$ and starting at the two different initial conditions</p>

<script type="math/tex; mode=display">y_{0,1} = (0, 0, 0.1, 0, 0.5, 0.5)</script>

<script type="math/tex; mode=display">y_{0,2} = (0, 0, 0.05, 0, 0.5, 0.5)</script>

<center>
<video controls="" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0008/doble_pendulum_thetadiff.mp4">
</video>
</center>
<center>
  <b>Figure 2. Chaotics behaviour</b>
</center>

<h3>  Optimal Control Problem </h3>

<p>We will solve the problem of steering the state of the pendulum from the downward position $y_{0} = (0, \pi, \pi, 0, 0, 0)$ to the upward position $z = (0, 0, 0, 0, 0, 0)$ in a fixed time horizon $T &gt; 0$ using a control $u(t)$.</p>

<p>One way to look for solutions to this problem is to minimize the following functional:</p>

<script type="math/tex; mode=display">J(u) =  \int_0^T ||y(t)||^2 dt +  ||y(T)||^2  + \alpha \int_0^T ||u(t)||^2dt</script>

<p>Where $\alpha &gt;0$ is a fixed parameter, the state vector $y(t)$ is subject to the system of differential equations (1) and $y(0) = y_0$.</p>

<h3>  Numerical simulation </h3>

<p>We start by implementing the dynamical system defined in (1) as a MATLAB function. We fix the lengths $l_{i} = 1$, and the mass of the cart $M = 50$. The damping coefficients are set to $d_{i} = 0.1$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code>  <span class="o">&gt;&gt;</span> <span class="nb">type</span> <span class="n">cartpole_dynamics</span><span class="o">.</span><span class="n">m</span>

<span class="k">function</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">cartpole_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
    <span class="n">L1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="n">L2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.8</span><span class="p">;</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">m1</span><span class="p">;</span>    <span class="n">m2</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">m2</span><span class="p">;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="mf">1e-1</span><span class="p">;</span>    <span class="n">d2</span> <span class="o">=</span> <span class="mf">1e-1</span><span class="p">;</span>    <span class="n">d3</span> <span class="o">=</span> <span class="mf">1e-1</span><span class="p">;</span>
    <span class="c1">%%%%%%%%%%%%%%%%%%%%%5%%%</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">class</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="c1">%</span>
    <span class="n">q</span>      <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>    <span class="n">theta1</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">theta2</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>    <span class="n">dq</span>     <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">dtheta1</span><span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>    <span class="n">dtheta2</span><span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> 
    <span class="c1">% q</span>
    <span class="n">ds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">dq</span> <span class="o">-</span><span class="n">q</span><span class="p">;</span>
    <span class="c1">% theta 1</span>
    <span class="n">ds</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">dtheta1</span><span class="p">;</span>
    <span class="c1">% theta 2</span>
    <span class="n">ds</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">dtheta2</span><span class="p">;</span>
    <span class="c1">%</span>
    <span class="n">Mt</span> <span class="o">=</span> <span class="p">[</span> <span class="n">M</span><span class="o">+</span><span class="n">m1</span><span class="o">+</span><span class="n">m2</span>                  <span class="n">L1</span><span class="o">*</span><span class="p">(</span><span class="n">m1</span><span class="o">+</span><span class="n">m2</span><span class="p">)</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span>     <span class="n">m2</span><span class="o">*</span><span class="n">L2</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span> <span class="p">;</span> <span class="k">...</span>
          <span class="n">L1</span><span class="o">*</span><span class="p">(</span><span class="n">m1</span><span class="o">+</span><span class="n">m2</span><span class="p">)</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span>     <span class="n">L1</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">m1</span><span class="o">+</span><span class="n">m2</span><span class="p">)</span>             <span class="n">L1</span><span class="o">*</span><span class="n">L2</span><span class="o">*</span><span class="n">m2</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta1</span><span class="o">-</span><span class="n">theta2</span><span class="p">)</span> <span class="p">;</span> <span class="k">...</span>
          <span class="n">L2</span><span class="o">*</span><span class="n">m2</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span>          <span class="n">L1</span><span class="o">*</span><span class="n">L2</span><span class="o">*</span><span class="n">m2</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta1</span><span class="o">-</span><span class="n">theta2</span><span class="p">)</span>  <span class="n">L2</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">m2</span>        <span class="p">];</span>
    <span class="c1">% v</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">L1</span><span class="o">*</span><span class="p">(</span><span class="n">m1</span><span class="o">+</span><span class="n">m2</span><span class="p">)</span><span class="o">*</span><span class="n">dtheta1</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span> <span class="o">+</span> <span class="n">m2</span><span class="o">*</span><span class="n">L2</span><span class="o">*</span><span class="n">theta2</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span>      <span class="o">-</span> <span class="n">d1</span><span class="o">*</span><span class="n">dq</span> <span class="o">+</span> <span class="n">u</span>  <span class="p">;</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="o">-</span><span class="n">L1</span><span class="o">*</span><span class="n">L2</span><span class="o">*</span><span class="n">m2</span><span class="o">*</span><span class="n">dtheta2</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">theta1</span><span class="o">-</span><span class="n">theta2</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="o">*</span><span class="p">(</span><span class="n">m1</span><span class="o">+</span><span class="n">m2</span><span class="p">)</span><span class="o">*</span><span class="n">L1</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span>  <span class="o">-</span> <span class="n">d2</span><span class="o">*</span><span class="n">dtheta1</span><span class="p">;</span>
    <span class="n">f3</span> <span class="o">=</span>  <span class="n">L1</span><span class="o">*</span><span class="n">L2</span><span class="o">*</span><span class="n">m2</span><span class="o">*</span><span class="n">dtheta1</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">theta1</span><span class="o">-</span><span class="n">theta2</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="o">*</span><span class="n">L2</span><span class="o">*</span><span class="n">m2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span>       <span class="o">-</span> <span class="n">d3</span><span class="o">*</span><span class="n">dtheta2</span><span class="p">;</span> 

    <span class="n">ds</span><span class="p">(</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">\[</span><span class="n">f1</span><span class="p">;</span><span class="n">f2</span><span class="p">;</span><span class="n">f3</span><span class="p">];</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This optimal control problem is solved using CasADi with the IPOPT solver. MATLAB’s symbolic toolbox has been used to implement the system dynamics in CasADi.</p>

<p>The time horizon is set to $T = 10$ and the system (1) has been discretized using a Crank-Nicolson scheme. The use of an implicit discretization method with good behaviour with respect to the number of mesh points has been crucial to speed up the optimization process.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">import</span> <span class="n">casadi</span><span class="o">.*</span>
<span class="c1">% define optimal </span>

<span class="n">Ss</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'x'</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="n">As</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'u'</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="n">ts</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s1">'t'</span><span class="p">);</span>
<span class="c1">%</span>
<span class="n">EvolutionFcn</span> <span class="o">=</span>  <span class="n">cartpole_dynamics</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">Ss</span><span class="p">,</span><span class="n">As</span><span class="p">,</span><span class="n">params</span><span class="p">)</span> <span class="p">;</span>
<span class="c1">%</span>
<span class="n">dynamics_obj</span> <span class="o">=</span> <span class="n">ode</span><span class="p">(</span><span class="n">EvolutionFcn</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">Ss</span><span class="p">,</span><span class="n">As</span><span class="p">,</span><span class="n">tspan</span><span class="p">);</span>
<span class="n">dynamics_obj</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="n">s0</span><span class="p">;</span>
<span class="c1">%</span>
<span class="n">PathCost</span>  <span class="o">=</span>  <span class="p">(</span><span class="n">Ss</span><span class="o">.</span><span class="s1">'*Ss) + 1e-5*(As.'</span><span class="o">*</span><span class="n">As</span><span class="p">)</span> <span class="p">;</span>
<span class="n">FinalCost</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ss</span><span class="o">.'*</span><span class="n">Ss</span> <span class="p">)</span> <span class="p">;</span>

<span class="n">ocp_obj</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">(</span><span class="n">dynamics_obj</span><span class="p">,</span><span class="n">PathCost</span><span class="p">,</span><span class="n">FinalCost</span><span class="p">);</span>
<span class="c1">%</span>
<span class="n">U0</span> <span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">tspan</span><span class="p">;</span>
<span class="p">[</span><span class="n">OptControl</span> <span class="p">,</span><span class="n">OptState</span><span class="p">]</span> <span class="o">=</span> <span class="n">IpoptSolver</span><span class="p">(</span><span class="n">ocp_obj</span><span class="p">,</span><span class="n">U0</span><span class="p">,</span><span class="s1">'integrator'</span><span class="p">,</span><span class="s1">'CrankNicolson'</span><span class="p">);</span>

</code></pre>
</div>

<p>The following animation displays the resulting evolution of the system’s state:</p>

<center>
<video controls="" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0008/doble_pendulum_control.mp4">
</video>
</center>
<center>
  <b>Figure 3. Optimal solution </b>
</center>

<p>Interestingly, due to the chaotic character of system (1), the IPOPT routine yields different controlled trajectories if we change the initial guess of the control:</p>

<center>
<video width="80%" controls="" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0008/doble_pendulum_control_rand.mp4">
</video>
</center>
<center>
  <b>Figure 4. Several initial guess of optimization</b>
</center>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;We use DyCon Toolbox for solving numerically the following control problem: given any $T&amp;gt;0$, find a control function $g\in L^2( ( -1 , 1) \times (0,T))$ such that the corresponding solution to the parabolic problem&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{frac_heat}   \begin{cases}       z_t+(d_x^2)^s z = g\chi_\omega, & (x,t)\in(-1,1)\times(0,T) \\       z = 0, & (x,t)\in[\mathbb{R}\setminus(-1,1)]\times(0,T) \\       z(x,0) = z_0(x), & x\in(-1,1)   \end{cases} \end{equation} %]]></script>

<p>satisfies $z(x,T)=0$.</p>

<p>Here, for all $s\in(0,1)$, $(-d_x^2)^s$ denotes the one-dimensional fractional Laplace operator, defined as the following singular integral</p>

<script type="math/tex; mode=display">\begin{equation*}   (-d_x^2)^s z(x) = c_s P.V. \int_{\mathbb{R}}   \frac{z(x)-z(y)}{|x-y|^{1+2s}}\,dy. \end{equation*}</script>

<h2 id="discretization-of-the-problem">Discretization of the problem</h2>

<p>As a first thing, we need to discretize \eqref{frac_heat}. Hence, let us consider a uniform N-points mesh on the interval $(-1,1)$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">70</span><span class="p">;</span>
<span class="n">xi</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">xf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">xline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">xf</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">xline</span> <span class="o">=</span> <span class="n">xline</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>Out of that, we can construct the FE approxiamtion of the fractional Lapalcian, using the program FEFractionalLaplacian developped by our team, which implements the methodology described in [1].</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">FEFractionalLaplacian</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">MassMatrix</span><span class="p">(</span><span class="n">xline</span><span class="p">);</span>
</code></pre>
</div>

<p>Moreover, we build the matrix $B$ defining the action of the control, by using the program “BInterior” (see below).</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">BInterior</span><span class="p">(</span><span class="n">xline</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="s1">'Mass'</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
</code></pre>
</div>

<p>We can then define a final time and an initial datum</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">FinalTime</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">Y0</span> <span class="o">=</span><span class="nb">sin</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">xline</span><span class="o">'</span><span class="p">);</span>
</code></pre>
</div>

<p>and construct the system</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{abstract_syst}   \begin{cases}       Y'(t) = AY(t)+BU(t), & t\in(0,T)       Y(0) = Y0.   \end{cases} \end{equation} %]]></script>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">tspan</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">FinalTime</span><span class="p">,</span><span class="mi">200</span><span class="p">);</span>
<span class="n">dynamics</span> <span class="o">=</span> <span class="n">linearpde1d</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span><span class="n">xline</span><span class="p">);</span>

<span class="n">dynamics</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="n">Y0</span><span class="p">;</span>
<span class="n">dynamics</span><span class="o">.</span><span class="n">MassMatrix</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Y0</span> <span class="o">=</span><span class="nb">cos</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">xline</span><span class="o">'</span><span class="p">);</span>
<span class="n">Y0</span><span class="p">(</span><span class="n">xline</span> <span class="o">&gt;</span> <span class="mf">0.2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Y0</span><span class="p">(</span><span class="n">xline</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">dynamics</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="n">Y0</span><span class="p">;</span>

<span class="n">U0</span> <span class="o">=</span> <span class="n">ZerosControl</span><span class="p">(</span><span class="n">dynamics</span><span class="p">);</span>
<span class="n">solve</span><span class="p">(</span><span class="n">dynamics</span><span class="p">,</span><span class="n">U0</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">ssline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">0.99</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>

<span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ssline</span>
    <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">FEFractionalLaplacian</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
    <span class="n">dynamics</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
    <span class="p">[</span><span class="n">Ysolution</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dynamics</span><span class="p">,</span><span class="n">U0</span><span class="p">);</span>
    <span class="n">Data</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="o">.</span><span class="n">Y</span> <span class="o">=</span> <span class="n">Ysolution</span><span class="o">'</span><span class="p">;</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">animation_FLD</span><span class="p">(</span><span class="n">ssline</span><span class="p">,</span><span class="n">Data</span><span class="p">,</span><span class="n">xline</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0014/ss.gif" /></p>

<h2 id="references">References</h2>

<p>[1] U. Biccari and V. Hernández-Santamaría - <em>Controllability     of a one-dimensional fractional heat equation: theoretical and     numerical aspects</em>, IMA J. Math. Control. Inf., to appear</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this tutorial, we present an optimal control problem related to the Fokker-Planck equation.&lt;/p&gt;
</code></pre>
</div>

<h2 id="description-of-the-problem">Description of the problem</h2>

<h3 id="the-fokker-planck-equation">The Fokker Planck Equation</h3>

<p>Let $\Omega$ be an open, bounded, regular subset of $\mathbb{R}^{n}$. Let $T&gt;0$ and denote by $u\in L^2(0,T;H^{1}(\Omega))^n$ a time-dependent vector field in $\Omega$. Consider a particle in $\Omega$ that moves with velocity $u(x,t)$ at each point $x\in\Omega$ in time $t\in(0,T)$. Suppose furthermore that the particle is subject to additive Brownian noise.</p>

<p>Let $p_0(x)$ be the probability density of the position of the particle at time $t=0$. Then, at every time $t&gt;0$, the probability density $p(x,t)$ of the particle satisfies the Fokker-Planck equation [1]:</p>

<script type="math/tex; mode=display">\begin{cases}
\partial_t p - \Delta p + \mathrm{div}(pu) = 0 \quad \mathrm{in}\,\,\Omega\times(0,T)\\
p(x,0) = p_0(x) \quad \mathrm{in}\,\,\Omega\\
(\nabla p-pu)\cdot\mathrm{n} = 0 \quad \mathrm{on}\,\,\partial\Omega\times(0,T)
\end{cases}</script>

<p>Where $\mathrm{n}$ is the outward unit normal vector field on $\partial\Omega$.</p>

<p>Fix a positive real number $a&gt;0$ and introduce the family of admissible controls:</p>

<script type="math/tex; mode=display">% <![CDATA[
\mathcal{U}_{\mathrm{ad}}:=\{u\in L^{2}(0,T;H^{1}(\Omega))^n : -a < u(x,t) < a\,\,\mathrm{a.e.}\,\,\mathrm{in}\,\,\Omega\times(0,T)\} %]]></script>

<p>For every non-negative initial data $p_0\in H^{1}(\Omega)$ and every admissible control $u\in\mathcal{U}_{\mathrm{ad}}$, there is a unique solution $p\in\mathcal{C}([0,T];L^{2}(\Omega))\cap L^{2}(0,T;H^{1}(\Omega))$ to the previous problem such that $p(x,t)\geq 0$ for every $t\geq 0$ and almost every $x\in\Omega$ [2].</p>

<p>If, besides, $\int_{\Omega}p_{0}(x)dx=1$, then integrating by parts it’s easy to check that $\int_{\Omega}p(x,t)dx=1$ for every $t\geq 0$, so $p(.,t)$ is indeed a probability density on $\Omega$ for every $t\geq 0$.</p>

<h3 id="optimal-control">Optimal Control</h3>

<p>Fix a smooth reference trajectory $z:[0,T]\rightarrow\Omega$. Our objective is to find an admissible control $u\in\mathcal{U}_{\mathrm{ad}}$ that minimizes the following functional:</p>

<script type="math/tex; mode=display">J(u):=\alpha\int_{0}^{T}\int_{\Omega}\Vert x-z(t)\Vert^2p(x,t)dxdt+\beta\int_{\Omega}\Vert x - z(T)\Vert^2p(x,T)dx + \gamma \int_{0}^{T}\int_{\Omega}\vert u(x,t)\vert^2p(x,t)dxdt</script>

<p>subject to:</p>

<script type="math/tex; mode=display">\begin{cases}
\partial_t p - \Delta p + \mathrm{div}(pu) = 0 \quad \mathrm{in}\,\,\Omega\times(0,T)\\
p(x,0) = p_0(x) \quad \mathrm{in}\,\,(-6,6)\\
(\nabla p-pu)\cdot\mathrm{n} = 0 \quad \mathrm{on}\,\,\partial\Omega\times(0,T)
\end{cases}</script>

<p>where $\alpha,\beta$ and $\gamma$ are non-negative real 
numbers. In [2] it is proven that there always exists a $u^{*}\in\mathcal{U}_{\mathrm{ad}}$ minimizing the previous functional among the family of admissible controls.</p>

<h2 id="numerical-simulation">Numerical Simulation</h2>

<p>In the numerical example that we will present in this post, we will work over the one-dimensional domain $\Omega = (-6,6)$ with time horizon $T = 5$, and the oscillating reference trajectory $z(t) = 4\sin(2t)$. We also fix $\alpha=\beta=\gamma=1$, so that our objective will be to minimize the functional:</p>

<script type="math/tex; mode=display">J(u) = \int_{0}^{T}\int_{\Omega}\vert x - 4\sin(2t)\vert^2 p(x,t)dxdt + \int_{\Omega}\vert x - 4sin(2T)\vert^2p(x,T)dx + \int_{0}^{T}\int_{\Omega}\vert u(x,t)\vert^{2}dxdt</script>

<p>subject to</p>

<script type="math/tex; mode=display">(1)
\begin{cases}
\partial_t p - \partial_x^2 p + \partial_x(pu) = 0 \quad \mathrm{in}\,\, (-6,6)\times(0,T)\\
p(x,0) = p_0(x) \quad \mathrm{in}\,\,(0,T)\\
\partial_x^{-}p(6,t) - u(6,t)p(6,t) = 0 \quad \mathrm{in} \,\,(0,T)\\
\partial_x^{+}p(6,t) - u(6,t)p(6,t) = 0 \quad \mathrm{in} \,\,(0,T)
\end{cases}</script>

<p><img width="80%" src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP05/P0013/ref.png" /></p>

<p>We consider the initial probability density function</p>

<script type="math/tex; mode=display">p_0(x) = \frac{1}{C}\exp(-2x^2)</script>

<p>where $C&gt;0$ is chosen so that $\int_{-6}^{6}p_0(x)dx=1$.</p>

<p><img width="80%" src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP05/P0013/init.png" /></p>

<p>We start by defining the mesh sizes and parameters. We discretize the spatial domain with $20$ points and the temporal domain with $80$ points.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% mesh sizes and parameters</span>

<span class="c1">% spatial mesh</span>
<span class="n">X_max</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">% length of space domain</span>
<span class="n">Nx</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">% number of mesh points</span>
<span class="n">x_line</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">X_max</span><span class="p">,</span><span class="n">X_max</span><span class="p">,</span><span class="n">Nx</span><span class="p">);</span> <span class="c1">% discretization of the space domain</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x_line</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">x_line</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">% space increment</span>

<span class="c1">% temporal mesh</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">% time horizon</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">% number of mesh points</span>
<span class="n">t_line</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span> <span class="c1">% discretization of the time domain</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t_line</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">t_line</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">% time increment</span>

<span class="c1">% parameters</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">dt</span><span class="p">/(</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">dt</span><span class="p">/(</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">);</span>
</code></pre>
</div>

<p>We define the reference trajectory $z(t)=4\sin(2t)$:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% reference trajectory</span>

<span class="n">ref</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">t_line</span><span class="p">);</span>
</code></pre>
</div>

<p>We define the initial probability density $p_0(x) = \frac{1}{C}\exp(-2x^2)$. We compute $C$ using $C = \int_{-6}^{6}\exp(-2x^2)dx = \sqrt{\frac{\pi}{2}}\mathrm{erf}(6\sqrt{2})$, where $\mathrm{erf}$ is the error function.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% initial density</span>

<span class="n">y0</span> <span class="o">=</span> <span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x_line</span><span class="o">.^</span><span class="mi">2</span><span class="p">);</span>

<span class="n">C</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="nb">pi</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="nb">erf</span><span class="p">(</span><span class="nb">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">X_max</span><span class="p">);</span> <span class="c1">% normalizing constant</span>
<span class="n">y0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">C</span><span class="p">)</span> <span class="o">*</span> <span class="n">y0</span><span class="o">'</span><span class="p">;</span> <span class="c1">% normalized initial density</span>
</code></pre>
</div>

<p>The uncontrolled evolution of this probability density is given by the following heat equation with Neumann boundary conditions:</p>

<script type="math/tex; mode=display">(2)
\begin{cases}
\partial_t p - \partial_{x}^{2}p = 0 \quad \mathrm{in}\,\,(-6,6)\times(0,T)\\
p(x,0)=p_0(x)\quad\mathrm{in}\,\,(-6,6)\\
\partial_{x}^{-}p(6,t) = 0\quad\mathrm{in}\,\,(0,T)\\
\partial_{x}^{+}p(-6,t) = 0\quad\mathrm{in}\,\,(0,T)
\end{cases}</script>

<p>We discretize and solve this equation:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% uncontrolled solution</span>

<span class="n">Yf</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="n">Yf</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">y0</span><span class="p">;</span>

<span class="k">for</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">Nt</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="nb">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">Nx</span><span class="o">-</span><span class="mi">1</span>
        <span class="c1">% euler step</span>
        <span class="n">Yf</span><span class="p">(</span><span class="nb">j</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Yf</span><span class="p">(</span><span class="nb">j</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span>  <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">Yf</span><span class="p">(</span><span class="nb">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">Yf</span><span class="p">(</span><span class="nb">j</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">Yf</span><span class="p">(</span><span class="nb">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">));</span>
    <span class="k">end</span>
    <span class="c1">% zero flux boundary conditions</span>
    <span class="n">Yf</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Yf</span><span class="p">(</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> 
    <span class="n">Yf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Yf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="k">end</span>
</code></pre>
</div>
<p>We display the uncontrolled solution:</p>

<table>
  <tr>
      <th>
        <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP05/P0013/unctrb.png" />
      </th>
      <th>
        <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP05/P0013/unctrbab.png" />
      </th>
  </tr>
</table>

<p>The solution $p(x,t)$ of the Heat equation (2) is the probability density associated to a one-dimensional Brownian motion on the real line. This is a particular case of a more general phenomenon: there is a correspondence between certain second order parabolic equations and solutions of stochastic ordinary differential equations [3]. Using the computed value of $p(x,t)$, we can simulate sample paths of a Brownian motion on the real line: the following animation displays the evolution of $100$ Brownian particles without control:</p>

<center>
<video controls="" width="80%" src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP05/P0013/JMALLOWITHOUT.mp4"></video>
</center>

<p>We now set up the optimal control problem in CasADi:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% optimal control problem</span>

<span class="n">opti</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Opti</span><span class="p">();</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span> <span class="c1">% state variable</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span> <span class="c1">% control variable</span>
</code></pre>
</div>

<p>We specify the system dynamics, discretizing the Fokker-Planck equation using central differences for the spatial derivatives and a forward Euler scheme for the time derivative:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% system dynamics</span>

<span class="k">for</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">Nt</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="nb">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">Nx</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">term1</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">Y</span><span class="p">(</span><span class="nb">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">(</span><span class="nb">j</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="n">Y</span><span class="p">(</span><span class="nb">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">));</span>
        <span class="n">term2</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="n">Y</span><span class="p">(</span><span class="nb">j</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="nb">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">U</span><span class="p">(</span><span class="nb">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">));</span>
        <span class="n">term3</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="n">U</span><span class="p">(</span><span class="nb">j</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Y</span><span class="p">(</span><span class="nb">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">Y</span><span class="p">(</span><span class="nb">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">));</span>
        <span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">Y</span><span class="p">(</span><span class="nb">j</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">Y</span><span class="p">(</span><span class="nb">j</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">term1</span> <span class="o">-</span> <span class="n">term2</span> <span class="o">-</span> <span class="n">term3</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We now set the initial condition and zero flux boundary conditions as constraints:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% initial conditions and zero flux boundary conditions</span>

<span class="c1">% initial condition</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y0</span><span class="p">);</span> 

<span class="c1">% zero flux boundary conditions</span>
<span class="k">for</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">Nt</span>
    <span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">Y</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">Y</span><span class="p">(</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)/(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="o">*</span><span class="n">U</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">n</span><span class="p">)));</span>
    <span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">Y</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">Y</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="p">)/(</span><span class="mi">1</span><span class="o">+</span><span class="n">dx</span><span class="o">*</span><span class="n">U</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)));</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We set the constraints on the control, taking $a = 2$:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% admissible control constraints</span>

<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">&lt;=</span><span class="n">U</span><span class="p">(:)</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">);</span>
</code></pre>
</div>

<p>We declare the cost functional:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% cost functional</span>

<span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">% running cost</span>
<span class="k">for</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">Nt</span> 
    <span class="k">for</span> <span class="nb">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">Nx</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_line</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">-</span><span class="n">ref</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="c1">% terminal cost</span>
<span class="k">for</span> <span class="nb">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">Nx</span> 
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_line</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">-</span><span class="n">ref</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="k">end</span>

<span class="c1">% control cost</span>
<span class="k">for</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">Nt</span> <span class="c1">% control cost</span>
    <span class="k">for</span> <span class="nb">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">Nx</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost</span> <span class="o">+</span> <span class="n">Y</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">U</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We solve the optimization problem using the IPOPT software:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% solution of the optimization problem</span>

<span class="c1">% set optimization objective</span>
<span class="n">opti</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">cost</span><span class="p">);</span>

<span class="c1">% solution of the optimization problem</span>
<span class="n">p_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'expand'</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
<span class="n">s_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'max_iter'</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span> 
<span class="n">opti</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="s1">'ipopt'</span><span class="p">,</span><span class="n">p_opts</span><span class="p">,</span><span class="n">s_opts</span><span class="p">);</span> 

<span class="nb">tic</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">solve</span><span class="p">();</span> 
<span class="nb">toc</span>
</code></pre>
</div>

<p>Obtaining the following display:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>This is Ipopt version 3.12.3, running with linear solver mumps.
NOTE: Other linear solvers might be more efficient (see Ipopt documentation).

Number of nonzeros in equality constraint Jacobian...:    10448
Number of nonzeros in inequality constraint Jacobian.:     1600
Number of nonzeros in Lagrangian Hessian.............:     6204

Total number of variables............................:     3200
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:     1600
Total number of inequality constraints...............:     1600
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:     1600
        inequality constraints with only upper bounds:        0

Number of Iterations....: 39

                                   (scaled)                 (unscaled)
Objective...............:  7.2472498957747769e+002   9.6893349411152292e+002
Dual infeasibility......:  1.0060574595627259e-010   1.3450657609300798e-010
Constraint violation....:  1.1102230246251565e-016   1.1102230246251565e-016
Complementarity.........:  2.5059036929760477e-009   3.3503108849024674e-009
Overall NLP error.......:  2.5059036929760477e-009   3.3503108849024674e-009


Number of objective function evaluations             = 40
Number of objective gradient evaluations             = 40
Number of equality constraint evaluations            = 40
Number of inequality constraint evaluations          = 40
Number of equality constraint Jacobian evaluations   = 40
Number of inequality constraint Jacobian evaluations = 40
Number of Lagrangian Hessian evaluations             = 39
Total CPU secs in IPOPT (w/o function evaluations)   =      1.062
Total CPU secs in NLP function evaluations           =      0.047

EXIT: Optimal Solution Found.
      solver  :   t_proc      (avg)   t_wall      (avg)    n_eval
       nlp_f  |   3.00ms ( 75.00us)   3.00ms ( 75.00us)        40
       nlp_g  |  14.00ms (350.00us)  13.99ms (349.85us)        40
  nlp_grad_f  |   5.00ms (121.95us)   5.00ms (121.90us)        41
  nlp_hess_l  |  10.00ms (256.41us)  10.01ms (256.74us)        39
   nlp_jac_g  |  15.00ms (365.85us)  15.98ms (389.78us)        41
       total  |   1.11 s (  1.11 s)   1.11 s (  1.11 s)         1
Elapsed time is 1.561797 seconds.
</code></pre>
</div>

<p>The following pictures display the temporal evolution of the controlled solution. The solution follows an oscillatory pattern similar to the one given by the reference trajectory:</p>

<table>
  <tr>
      <th>
        <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP05/P0013/ctrb.png" />
      </th>
      <th>
        <img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP05/P0013/ctrbab.png" />
      </th>
  </tr>
</table>

<p>Again, by the correspondence between second order parabolic equations and solutions to stochastic ordinary differential equations, the solution $p(x,t)$ to equation (2) is the probability density of a brownian particle on the real line that is subject to the velocity field $u(x,t)$. We use the values of $p(x,t)$ that we have just computed to simulate sample paths of this controlled brownian motion: the following animation displays the evolution of $100$ Brownian particles subject to the control $u(x,t)$:</p>

<center>
<video controls="" width="80%" src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP05/P0013/JMALLO.mp4"></video>
</center>
<h2 id="references">References</h2>

<p>[1] Hannes Risken, Till Frank. The Fokker-Planck Equation: Methods of Solution and Applications, Second Edition. Springer-Verlag Berlin Heidelberg, 1996</p>

<p>[2] Roy, S., Annunziato, M., Borzì, A., and Klingenberg, C. (2018). A Fokker–Planck approach to control collective motion. Computational Optimization and Applications, 69(2), 423-459.</p>

<p>[3] Stroock, Daniel W., Varadhan, S.R.S. Multidimensional Diffusion Processes. Springer-Verlag Berlin Heidelberg, Reprint of the 1997 Edition (Grundlehren der mathematischen Wissenschaften, Vol. 233).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h1&gt;The problem&lt;/h1&gt;
</code></pre>
</div>

<p>We consider the following one-dimensional Burgers equation</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq} 
\left\{ \begin{array}{l}
\partial_t u(t,x)+\partial_x f(u(t,x))=0, \quad (t,x)\in \mathbb{R}^+ \times \mathbb{R}, \\
u(0,x)=u_0(x),
\end{array}\right.
\end{equation}</script>

<p>where $u$ is the state, $u_0$ is the initial state and  the flux function $f$ is defined by $f(u)=\frac{u^2}{2}$. Kruzkov’s theory  provides existence and uniqueness of a  solution  of \eqref{eq} with initial datum $u_0 \in L^{\infty}(\mathbb R)$. This solution is called a weak-entropy solution, denoted by $(t,x) \to S_t^+(u_0)(x)$. For a given target function $u^T$, we introduce the backward entropy  solution $(t,x) \to S^-_{t}(u^T)(x)$  as follows: 
for every $t\in [0,T]$, for a.e $x\in \mathbb R$,</p>

<script type="math/tex; mode=display">S^-_{t}(u^T)(x)= S^+_{t}(x\to u^T(-x))(-x).</script>

<p>We study the problem of inverse design for \eqref{eq}. This problem consists in  identifying the set of initial data evolving to a given target at a final time.</p>

<p>Due to the time-irreversibility of the Burgers equation, some target functions are unattainable from weak-entropy solutions of this equation, making the inverse problem under consideration ill-posed. To get around this issue, we introduce the following  optimal control problem</p>

<script type="math/tex; mode=display">\begin{equation} \tag{$\mathcal{O}_T$}\label{opt2} \inf_{u_0\in \mathcal{U}^0_{\text{ad}}} J_0(u_0):=\Vert u^T(\cdot)-S_T^+(u_0)(\cdot)\Vert_{L^2(\mathbb R)},\end{equation}</script>

<p>where $u^T$ is a given target function and the class of admissible initial data $\mathcal{U}^0_{\text{ad}}$ in \eqref{opt2} is defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \label{admissible_set}\mathcal{U}^0_{\text{ad}}=\{u_0\in BV(\mathbb R) \text{ such that } \Vert u_0 \Vert_{BV( \mathbb R)} < C \,  \text{and } \text{supp}(u_0)\subset K_0\}.\end{equation} %]]></script>

<p>Above, <script type="math/tex">BV</script> stands for functions of bounded variation and  $C&gt;0$ is a constant large enough. The study of \eqref{opt2} is motivated by the minimization of the sonic boom effects generated by supersonic aircrafts [2].</p>

<p>To solve the optimal control problem \eqref{opt2}, some difficulties arise from a  theoretical  and  numerical point of view.</p>
<ul>
  <li>Since the  entropy solution $u$ of \eqref{eq} may contain shocks even if the initial datum is a smooth function, this generates important added difficulties that have been the object of intensive study in the past, see  [3,4] and the references therein. In particular, the authors make sense of the derivative of $J_0$ in \eqref{opt2} in a weak way by requiring  strong conditions on the set of initial data. This leads to require that entropy solutions of \eqref{eq} have a finite number of non-interacting jumps.</li>
  <li>When $J_0$ is weakly differentiable,  gradient descent  methods have been implemented in [1,5,6] to solve numerically the optimal problem \eqref{opt2}. In the cases where it was applied successfully, only one possible initial datum emerges, namely the backward entropy solution $S_T^-(u^T)$. This is mainly due to the numerical viscosity that numerical schemes introduce to gain stability. To find some multiple minimizers, the authors in  [8]  use a filtering step in the backward adjoint solution.</li>
</ul>

<p>Dans [9], we fully characterize the set of minimizers of the optimal control problem \eqref{opt2}.</p>

<p><b>Theorem 1.</b>  Let $u^T\in BV(\mathbb R)$. The optimal control problem \eqref{opt2}  admits multiple optimal solutions. Moreover, for a.e $T&gt;0$, the initial datum $u_0\in BV(\mathbb R)$ is an optimal solution of \eqref{opt2} if and only if $u_0 \in BV(\mathbb R)$ verifies $S_T^+(u_0)=S_T^+ (S_T^-(u^T))$.</p>

<p>A characterisation of the set <script type="math/tex">\{u_0 \in BV(\mathbb R), S_T^+(u_0)=S_T^+ (S_T^-(u^T))\}</script> is given in [7]. An illustration of Theorem 1. is given in Figure 1.</p>

<p><img width="50%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/Projection2.png" /></p>
<center>Figure 1: The backward-forward  solution $S_T^+(S_T^-(u^T))$ is the projection of $u^T$ onto the set of attainable target functions. The shaded area in red at time $t=0$ represents the set of minimizers of \eqref{opt2} </center>

<p>The proof of Theorem 1 is structured as follows. From [7, Theorem 3.1, Corollary 3.2] or [8, Corollary 1], there exists $u_0\in BV(\mathbb R)$ such that <script type="math/tex">S^+_T(u_0)=q</script> if and only if <script type="math/tex">q</script> satisfies  the one-sided Lipschitz condition, i.e 
<script type="math/tex">\begin{equation*}\partial_x q \leq \frac{1}{T}  \text{ in } \mathcal{D}'(\mathcal{R}).\end{equation*}</script>
 Thus, the optimal problem \eqref{opt2} can be rewritten as  follows.</p>

<script type="math/tex; mode=display">\begin{equation} \label{opt5} \min_{q\in \mathcal{U}^T_{\text{ad}}} J_1(q):=\Vert u^T-q \Vert_{L^2(\mathcal{R})},  \end{equation}</script>

<p>where the admissible set $\mathcal{U}^T_{\text{ad}}$ is defined by</p>

<script type="math/tex; mode=display">\begin{equation} \mathcal{U}^T_{\text{ad}}=\{ q\in BV(\mathbb R) \text{ such that } \, \, \partial_x q \leq \frac{1}{T} \,  \, \text{and } \Vert q \Vert_{BV( \mathbb R)} \leq C \, \text{and }\text{Supp}(q)\subset K_1 \}.\end{equation}</script>

<p>Above, $K_1$ an open bounded interval large enough.  Note that the optimal problem \eqref{opt5} is not related to the PDE model \eqref{eq}. We prove that $q=S_T^+ (S_T^-(u^T))$ is a critical point of \eqref{opt5} using the first-order optimality conditions applied to \eqref{opt5} and the full characterization of the set <script type="math/tex">\{u_0 \in BV(\mathbb R) \text{ such that } S_T^-(u_0)=S_T^-(u^T)\}</script> given in [9, Theorem A.2].</p>

<h1>Numerical simulations</h1>

<p>In [9,Section 3], we  implement a wave-front tracking algorithm to construct numerically the set of  minimizers of \eqref{opt2}.  We consider for instance, a target function <script type="math/tex">u^T</script>  defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \label{uT} u^T(x)=\left\{\begin{array}{ll}
2 &\text{if} \, \,x\in (-0.2,1.1)\bigcup(2,3.1)\bigcup (4.1,5.3)\bigcup (6.1,7.2), \\
-1 & \text{otherwise}.
\end{array}\right.
\end{equation} %]]></script>

<p>From Theorem 1,  the backward solution <script type="math/tex">S_T^-(u^T)</script> is an  optimal solution of \eqref{opt2} and  <script type="math/tex">u_0</script> is an optimal solution of \eqref{opt2} if and only if  <script type="math/tex">S_T^+(u_0)=S_T^+ (S_T^-(u^T))</script>. In Figure 2, the target function <script type="math/tex">u^T</script>, the backward solution <script type="math/tex">S_T^-(u^T)</script> and  the backward-forward solution <script type="math/tex">S_T^+ (S_T^-(u^T))</script> are plotted.</p>

<center>
<table>
    <tr>
        <td>
        <img width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/ex_Stmoins.png" />
        </td>
        <td>
        <img width="90%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/WFTforward.png" />
        </td>
    </tr>
    <tr>
        <td>
        <center>$x\to S^{-}_T(u^T)(x)$ </center>
        </td>
        <td>
        <center>$(t,x)\to S^{+}_t(S^{-}_T(u^T))(x)$ </center>
         </td>
    </tr>
</table>
</center>

<p><img width="50%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/ex_final.png" /></p>
<center>$u^T$  and $\color{red}{x\to S^{+}_T(S^{-}_T(u^T))(x)}$ </center>
<p>$ $</p>
<center>Figure 2. Plotting of the target function $u^T$ defined in \eqref{uT}, the optimal solution $S_T^-(u^T)$ and the backward-forward solution $\color{red}{S^{+}_T(S^{-}_T(u^T))}$.</center>

<p>Note that <script type="math/tex">S_T^+(S_T^-(u^T))</script> has four different shocks located at $x=1.1$, $x=3.1$, $x=5.3$ and $x=7.2$. If we use a conservative numerical method as Godunov scheme,  the approximate solution of <script type="math/tex">S_T^+(S_T^-(u^T))</script> doesn’t have shocks because of numerical viscosity that numerical schemes introduced, see Video 1.</p>

<center>
<table>
    <tr>
        <td>
            <video width="98%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_God_WFT.mov" controls=""></video>
        </td>
        <td>
            <video width="98%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_God_WFT_zoom.mov" controls=""></video>
        </td>
    </tr>
</table>
</center>
<center>Video 1. Approximate solution of $S_T^+(u_0)$ with $u_0$ an $N$-wave constructed with $ \color{red}{\text{a wave-front tracking algorithm}}$ and $\color{blue}{\text{a Godunov scheme}}$ </center>

<p>This implies that only one minimizer of \eqref{opt2} can be constructed using a Godunov scheme, which is the backward entropy solution $S_T^-(u^T)$. When a wave-front tracking algorithm is implemented, the approximate solution of $S_T^+(S_T^-(u^T))$ has shocks since we track the possible discontinuities from $u^T$ to  $S_T^+(S_T^-(u^T))$. This implies that all initial data $u_0$ that coincide with the approximate solution of $S_T^+ (S_T^-(u^T))$ can be recovered, see [9,Section 3].</p>

<p>In Video 2, we show that the weak-entropy solution of \eqref{eq}  with initial data $S_T^-(u^T)$ coincides with $S_T^+ (S_T^-(u^T))$ at time $T$.</p>
<center>
<video width="50%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_0.mov" controls=""></video></center>
<center>Video 2. Approximate solution of $(t,x) \to S_t^+(S_T^-(u^T))(x)$  using a wave-front tracking algorithm. </center>

<p>In Video 3, three other approximate optimal solutions $u_0$ of \eqref{opt2} are constructed. In particular, we show that  $S_T^+ (u_0)=S_T^+ (S_T^-(u^T))$.</p>

<center>
<table>
    <tr>
        <th>
            <video width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_1.mov" controls=""></video>
        </th>
        <th>
            <video width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_3.mov" controls=""></video>
        </th>
    </tr>
<table>
    <tr>
                
            <video width="50%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0006/animation_4.mov" controls=""></video>
    
    </tr>
</table>
</table>
</center>
<center>Video 3. Three approximate optimal solutions of \eqref{opt2} constructed using a wave-front tracking algorithm </center>

<p>[1] Navid Allahverdi,  Alejandro Pozo and Enrique Zuazua. Numerical aspects of large-time optimal control of Burgers equation. ESAIM: Mathematical Modelling and Numerical Analysis, 50 (5):1371-1401,2016.</p>

<p>[2]  Navid Allahverdi,  Alejandro Pozo and Enrique Zuazua. Numerical aspects of sonic-boom minimization. A panorama of Mathematics: Pure and Applied, 658:267,2016.</p>

<p>[3] François Bouchut and François James. One-dimensional transport equations with discontinuous coefficients. Nonlinear Analysis, 32(7):891,1998.</p>

<p>[4] Alberto Bressan and Andrea Marson. A maximum principle for optimally controlled systems of conservation laws. Rendiconti del Seminario Matematico della Universita di Padova, 94:79-94, 1995.</p>

<p>[5] Carlos Castro, Francisco Palacios and Enrique Zuazua. An alternating descent method for the optimal control of the inviscid Burgers equation in the presence of shocks. Mathematical Models and Methods in Applied Sciences, 18(03):369-416,2008.</p>

<p>[6] Carlos Castro, Francisco Palacios and Enrique Zuazua. Optimal control and vanishing viscosity for the Burgers equation. In Integral Methods in Science and Engineering, Volume 2, pages 65-90. Springer, 2010.</p>

<p>[7] Rinaldo Colombo and Vincent Perrollaz. Initial data identification in conservation laws and Hamilton-Jacobi equations. arXiv preprint arXiv:1903.06448,2019.</p>

<p>[8] Laurent Gosse and Enrique Zuazua. Filtered gradient algorithms for inverse design problems of one-dimensional Burgers equation. In Innovative algorithm and analysis, pages 197-227. Springer, 2017.</p>

<p>[9] Thibault Liard and Enrique Zuazua. Inverse design for the one-dimensional Burgers equation. Submitted (2019).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;This code needs the installation of CasADi 3.4.5: &lt;a href="https://web.casadi.org/get/"&gt;https://web.casadi.org/get/&lt;/a&gt;&lt;/p&gt;
</code></pre>
</div>

<p>The objectives of this post are twofold, one is to introduce CasADi (with IpOpt) to simulate optimal control problem, and the other is to introduce the concept of the structural controllability, as an example, for the 2D heat equation.</p>

<h1 id="controllability-of-the-2d-heat-equation">Controllability of the 2D heat equation</h1>

<p>In this post, we simulate structural controllability for the two-dimensional heat equation. First, we start with the finite difference scheme of the 2D Heat equation and the control on one boundary of the square domain $[0,1]^2$.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} \displaystyle\frac{dz_{i,j}}{dt} = (N+1)^2(z_{i+1,j}+z_{i-1,j}+z_{i,j+1}+z_{i,j-1}-4z_{i,j}) + u_{i,j}\delta(i-1), & i,j = 1,\ldots,N,~ t \in (0,T) \\ z_{i,j}(t) = 0, & i = 0, N+1, ~\text{or}~ j=0, N+1,~ t \in (0,T) \\ z_{i,j}(0)=z^0_{i,j}, & i,j=1,\ldots,N. \end{cases} %]]></script>

<p>A similar problem has been treated in another <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/WP03-P0022">DyCon Blog post</a> using AMPL and IpOpt, which deals with the one-dimensional fractional heat equation under positivity constraints. Here we use CasADi and IpOpt in Matlab language.</p>

<p>We will consider the problem of steering the initial datum:</p>

<script type="math/tex; mode=display">z^0_{i,j} = \sin(\pi x_i)\sin(\pi y_j),\quad x_i = i/(N+1) \quad\text{and}\quad y_j = j/(N+1).</script>

<p>to the final target $(1.5 \cdot \bar z_{i,j}(T))$, where $\bar z_{i,j}(T)$ is a reference solution from $z^0_{i,j}$ without control.</p>

<h2 id="problem-formulation">Problem formulation</h2>

<p>Parameters for the problem:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">N_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">%% Space discretization for 1D</span>
<span class="n">Nx</span> <span class="o">=</span> <span class="n">N_size</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span> <span class="c1">%% Space discretization for 2D</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">%% Time discretization</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c1">%% Final time</span>

<span class="c1">%% Discretization of the Space</span>
<span class="n">xline_</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="p">[</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">xline_</span><span class="p">,</span><span class="n">xline_</span><span class="p">);</span>
<span class="n">xline</span> <span class="o">=</span> <span class="n">xline_</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">[</span><span class="n">xms</span><span class="p">,</span><span class="n">yms</span><span class="p">]</span>   <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">xline</span><span class="p">,</span><span class="n">xline</span><span class="p">);</span>

<span class="n">dx</span> <span class="o">=</span> <span class="n">xline</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">xline</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">%% Initial data</span>
<span class="n">Y0_2d</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="p">);</span>
<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span>
    <span class="k">for</span> <span class="nb">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span>
        <span class="n">Y0_2d</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="nb">j</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="n">xline</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">*</span><span class="nb">pi</span><span class="p">)</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">xline</span><span class="p">(</span><span class="nb">j</span><span class="p">)</span><span class="o">*</span><span class="nb">pi</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="n">Y0</span> <span class="o">=</span> <span class="n">Y0_2d</span><span class="p">(:);</span>


<span class="c1">%% Definition of the dynamics : Y' = AY+BU</span>
<span class="n">B</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span> <span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span><span class="p">)</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N_size</span><span class="p">);</span> <span class="c1">%% control for i=1,...,N_size.</span>

<span class="n">A1_mat</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">A2_mat</span> <span class="o">=</span> <span class="nb">spdiags</span><span class="p">([</span><span class="n">A1_mat</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">A1_mat</span> <span class="n">A1_mat</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">],</span> <span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">I_mat</span>  <span class="o">=</span> <span class="nb">speye</span><span class="p">(</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">A_mat</span>  <span class="o">=</span> <span class="nb">kron</span><span class="p">(</span><span class="n">I_mat</span><span class="p">,</span><span class="n">A2_mat</span><span class="p">)</span><span class="o">+</span><span class="nb">kron</span><span class="p">(</span><span class="n">A2_mat</span><span class="p">,</span><span class="n">I_mat</span><span class="p">);</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">A_mat</span><span class="p">;</span> <span class="c1">%% A: Discrete Laplacian in 2D with uniform squared mesh</span>

<span class="c1">%% Discretization of the time : we need to check CFL condition to change 'Nt'.</span>
<span class="n">tline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%%uniform time mesh</span>

<span class="n">dt</span> <span class="o">=</span> <span class="n">tline</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">tline</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>The interactions between nodes (grid points) can be displayed as follows:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">options_plot_graphs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">'DisplayName'</span><span class="p">,</span><span class="s1">'off'</span><span class="p">,</span><span class="s1">'NodeColor'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">'ArrowSize'</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="s1">'MarkerSize'</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="s1">'NodeLabel'</span><span class="p">,{}};</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">digraph</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="s1">'XData'</span><span class="p">,</span><span class="n">xms</span><span class="p">(:)</span><span class="s1">','</span><span class="n">YData</span><span class="s1">',yms(:)'</span><span class="p">,</span><span class="n">options_plot_graphs</span><span class="p">{:});</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xms</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="n">yms</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'b.'</span><span class="p">,</span><span class="s1">'MarkerSize'</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span> <span class="c1">%% Blue dots are controlled nodes</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x-axis'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'y-axis'</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span><span class="o">.^</span><span class="mi">2</span>
    <span class="nb">text</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">XData</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">+</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">YData</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">+</span><span class="mf">0.02</span><span class="p">,</span> <span class="nb">num2str</span><span class="p">(</span><span class="nb">i</span><span class="p">),</span> <span class="s1">'FontSize'</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">end</span>
</code></pre>
</div>

<p><img style="width:70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_01.png" /></p>

<center><p>Fig 1. The interaction network of 'A_mat'. The controlled nodes are colored blue.</p></center>

<p>Now we may simulate the reference trajectory without control.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% Simulation of the uncontrolled trajectory</span>
<span class="n">M</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">/</span><span class="n">dx</span><span class="o">.^</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">/</span><span class="n">dx</span><span class="o">.^</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">B</span><span class="p">;</span>

<span class="n">Y</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

<span class="n">Y</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Y0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">%% loop over time intervals</span>
   <span class="c1">%% Crank-Nicolson method without control</span>
   <span class="n">Y</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">M</span><span class="p">\</span><span class="n">L</span><span class="o">*</span><span class="n">Y</span><span class="p">(:,</span><span class="n">k</span><span class="p">);</span>
<span class="k">end</span>
<span class="n">YT</span> <span class="o">=</span> <span class="n">Y</span><span class="p">(:,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

<span class="n">ratio</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">;</span>
<span class="n">Y1</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">*</span><span class="n">YT</span><span class="p">;</span> <span class="c1">%% Target data</span>

<span class="nb">clf</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">;</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Z</span><span class="p">,</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">)];</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">;</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Z</span><span class="p">,</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">)];</span>
<span class="n">jsurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">jsurf</span><span class="o">.</span><span class="n">Parent</span><span class="o">.</span><span class="n">Color</span> <span class="o">=</span> <span class="s1">'none'</span><span class="p">;</span>
<span class="nb">lightangle</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">({</span><span class="s1">'Initial Condition'</span><span class="p">,</span><span class="s1">'Final Data'</span><span class="p">})</span>
</code></pre>
</div>

<p><img style="width:70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_02.png" /></p>
<center><p>Fig 2. The initial condition and the final data of uncontrolled dynamics.</p></center>

<h2 id="optimization-problem">Optimization problem</h2>

<p>From now on, we use CasADi to consider an exact control problem.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">opti</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Opti</span><span class="p">();</span>  <span class="c1">%% CasADi function</span>

<span class="c1">%% ---- Input variables ---------</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% state trajectory</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">N_size</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">%% control</span>

<span class="c1">%% ---- Dynamic constraints --------</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">%% loop over control intervals</span>
   <span class="c1">%% Crank-Nicolson method : this helps us to boost the optimization</span>
   <span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">X</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span> <span class="n">L</span><span class="o">*</span><span class="n">X</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">U</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">U</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)));</span>
<span class="k">end</span>

<span class="c1">%% ---- State constraints --------</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">X</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">Y0</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">X</span><span class="p">(:,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">Y1</span><span class="p">);</span>

<span class="c1">%% ---- Optimization objective  ----------</span>
<span class="n">Cost</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">U</span><span class="o">.^</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="p">/</span><span class="n">Nt</span><span class="p">));</span>
<span class="n">opti</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">Cost</span><span class="p">);</span> <span class="c1">%% minimizing L2 over time</span>

<span class="c1">%% ---- initial guesses for solver ---</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">%% ---- solve NLP              ------</span>
<span class="n">p_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'expand'</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
<span class="n">s_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'max_iter'</span><span class="p">,</span><span class="mi">10000</span><span class="p">);</span> <span class="c1">%% iteration limitation</span>

<span class="n">opti</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="s1">'ipopt'</span><span class="p">,</span><span class="n">p_opts</span><span class="p">,</span><span class="n">s_opts</span><span class="p">);</span> <span class="c1">%% set numerical backend</span>
<span class="nb">tic</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">solve</span><span class="p">();</span>   <span class="c1">%% actual solve</span>
<span class="nb">toc</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>This is Ipopt version 3.12.3, running with linear solver mumps.
NOTE: Other linear solvers might be more efficient (see Ipopt documentation).

Number of nonzeros in equality constraint Jacobian...:     2752
Number of nonzeros in inequality constraint Jacobian.:        0
Number of nonzeros in Lagrangian Hessian.............:       84

Total number of variables............................:      420
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:      352
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  0.0000000e+00 6.69e-02 0.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.6511358e+02 6.66e-16 7.31e-07  -2.5 8.68e+01    -  1.00e+00 1.00e+00h  1
   2  1.6511358e+02 6.66e-16 2.39e-12  -8.6 5.47e-09    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 2

                                   (scaled)                 (unscaled)
Objective...............:   1.6511358437684962e+02    1.6511358437684962e+02
Dual infeasibility......:   2.3874235921539366e-12    2.3874235921539366e-12
Constraint violation....:   6.6613381477509392e-16    6.6613381477509392e-16
Complementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00
Overall NLP error.......:   4.0210221040688533e-13    2.3874235921539366e-12


Number of objective function evaluations             = 3
Number of objective gradient evaluations             = 3
Number of equality constraint evaluations            = 3
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 3
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 2
Total CPU secs in IPOPT (w/o function evaluations)   =      0.822
Total CPU secs in NLP function evaluations           =      0.000

EXIT: Optimal Solution Found.
               t_proc [s]   t_wall [s]    n_eval
       nlp_f      1.9e-05      1.9e-05         3
       nlp_g     0.000103     0.000105         3
  nlp_grad_f      3.7e-05      3.4e-05         4
  nlp_hess_l      1.4e-05      1.3e-05         2
   nlp_jac_g     0.000185     0.000195         4
      solver         1.09        0.676         1
Elapsed time is 0.757156 seconds.

</code></pre>
</div>

<h2 id="post-processing">Post-processing</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Sol_x</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">X</span><span class="p">);</span> <span class="c1">%% solved controlled trajectory</span>
<span class="n">Sol_u</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">U</span><span class="p">);</span> <span class="c1">%% solved control function</span>

<span class="nb">clf</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Sol_x</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">jsurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">*</span><span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="nb">plot3</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'k*'</span><span class="p">)</span>

<span class="n">jsurf</span><span class="o">.</span><span class="n">Parent</span><span class="o">.</span><span class="n">Color</span> <span class="o">=</span> <span class="s1">'none'</span><span class="p">;</span>
<span class="nb">lightangle</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>

<span class="nb">legend</span><span class="p">({</span><span class="s1">'Controlled final data'</span><span class="p">,</span><span class="s1">'Uncontrolled final data'</span><span class="p">,</span><span class="s1">'Target'</span><span class="p">})</span>
</code></pre>
</div>

<p><img style="width:70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_03.png" /></p>

<center><p>Fig 3. The final data of controlled and uncontrolled dynamics. The controlled data coinside with the target points.</p></center>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% Free and controlled dynamics in animation</span>

<span class="n">Result_ref</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% displaying variable</span>
<span class="n">Result_ref</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,:),[</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>

<span class="n">Result_con2d</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% displaying variable</span>
<span class="n">Result_con2d</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Sol_x</span><span class="p">(:,:),[</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="c1">%% Free dynamics</span>
<span class="n">fig</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="n">isurf2</span><span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="k">end</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Free dynamics'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Target'</span><span class="p">,</span><span class="s1">'Solution'</span><span class="p">)</span>
<span class="nb">zlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="nb">pause</span><span class="p">;</span>
<span class="k">for</span> <span class="n">it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span>
   <span class="n">isurf</span><span class="o">.</span><span class="n">ZData</span> <span class="o">=</span>  <span class="n">Result_ref</span><span class="p">(:,:,</span><span class="n">it</span><span class="p">);</span>
    <span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1">%% Controlled dynamics</span>
<span class="nb">clf</span>
<span class="n">fig</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="n">isurf2</span><span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="k">end</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">Result_con2d</span><span class="p">(:,:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Controlled dynamics'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Target'</span><span class="p">,</span><span class="s1">'Solution'</span><span class="p">)</span>
<span class="nb">zlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="nb">pause</span><span class="p">;</span>
<span class="k">for</span> <span class="n">it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span>
   <span class="n">isurf</span><span class="o">.</span><span class="n">ZData</span> <span class="o">=</span>  <span class="n">Result_con2d</span><span class="p">(:,:,</span><span class="n">it</span><span class="p">);</span>
    <span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<table>
   <tr>
      <th>
         <center><video controls="" width="95%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_04-c.mp4"></video></center>
      </th>
      <th>
        <center><video controls="" width="95%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_05-c.mp4"> </video></center>
      </th>
   </tr>
</table>

<center><p><b>Fig 4-5.</b> Animations for the free and controlled dynamics. The target surface is also drawn in both dynamics, where free dynamics goes below than the target.</p></center>

<h1 id="structural-controllability-of-the-2d-heat-equation">Structural controllability of the 2D heat equation</h1>

<p>For the second part, we simulate another linear system to check the structural controllability of the 2D heat equation. It is known that its interacting <a href="https://en.wikipedia.org/wiki/Network_controllability">network is structurally controllable</a> by one sole node.</p>

<p>The following matrix ‘AS_mat’ links the nodes in a line, for example, 1-2-3-6-5-4-7-8-9 for $N=3$, which is a part of interactions in ‘A_mat’:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">AC_mat</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">N_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="nb">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="n">N_size</span><span class="o">-</span><span class="mi">2</span>
    <span class="n">AC_mat</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">AC_mat</span><span class="p">,</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">N_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">AC_mat</span><span class="p">(</span><span class="k">end</span><span class="p">,</span><span class="k">end</span><span class="o">-</span><span class="n">N_size</span><span class="p">)</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">N_size</span><span class="o">==</span><span class="mi">2</span>
        <span class="k">break</span>
    <span class="k">end</span>
    <span class="n">AC_mat</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">AC_mat</span><span class="p">,</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">N_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">AC_mat</span><span class="p">(</span><span class="k">end</span><span class="o">-</span><span class="n">N_size</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="k">end</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">N_size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="k">end</span>
<span class="k">if</span> <span class="nb">length</span><span class="p">(</span><span class="n">AC_mat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">N_size</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">AC_mat</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">AC_mat</span><span class="p">,</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">N_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">AC_mat</span><span class="p">(</span><span class="k">end</span><span class="p">,</span><span class="k">end</span><span class="o">-</span><span class="n">N_size</span><span class="p">)</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="k">end</span>

<span class="n">AS_mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">AC_mat</span> <span class="o">+</span> <span class="n">AC_mat</span><span class="o">'</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">Nx</span><span class="p">);</span>

<span class="n">options_plot_graphs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">'DisplayName'</span><span class="p">,</span><span class="s1">'off'</span><span class="p">,</span><span class="s1">'NodeColor'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">'ArrowSize'</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="s1">'MarkerSize'</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="s1">'NodeLabel'</span><span class="p">,{}};</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">digraph</span><span class="p">(</span><span class="n">AS_mat</span><span class="p">),</span><span class="s1">'XData'</span><span class="p">,</span><span class="n">xms</span><span class="p">(:)</span><span class="s1">','</span><span class="n">YData</span><span class="s1">',yms(:)'</span><span class="p">,</span><span class="n">options_plot_graphs</span><span class="p">{:});</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x-axis'</span><span class="p">);</span><span class="nb">ylabel</span><span class="p">(</span><span class="s1">'y-axis'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xms</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">yms</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'b.'</span><span class="p">,</span><span class="s1">'MarkerSize'</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span> <span class="c1">%% Blue dots are controlled nodes</span>
<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_size</span><span class="o">.^</span><span class="mi">2</span>
    <span class="nb">text</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">XData</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">+</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">YData</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">+</span><span class="mf">0.02</span><span class="p">,</span> <span class="nb">num2str</span><span class="p">(</span><span class="nb">i</span><span class="p">),</span> <span class="s1">'FontSize'</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">end</span>

<span class="nb">title</span><span class="p">(</span><span class="s1">'Network'</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
</code></pre>
</div>

<p><img style="width:70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_06.png" /></p>

<center><p>Fig 6. The interaction network of the new matrix 'AS_mat'. The controlled nodes are colored blue.</p></center>

<p>Since the 1D heat equation is controllable, ‘AS_mat’ is controllable by one node. However, it gets more and more difficult as the number of nodes increases, since it has different scale with the standard 1D heat equation. The length of the 1D domain grows as $N$ since it eventually become space filling curve in $[0,1]^2$.</p>

<p>Note also that ‘AS_mat’ has the nonzero elements in the positions that ‘A_mat’ has. By deleting several interactions of ‘A_mat’, ‘AS_mat’ is now exactly controllable with smaller controlled nodes. This is the idea of the structural controllability in the network system, called ‘network control’.</p>

<h2 id="problem-formulation-1">Problem formulation</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">B</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">N_size</span><span class="o">.^</span><span class="mi">2</span><span class="o">*</span><span class="n">AS_mat</span><span class="p">;</span>
<span class="c1">%% Y' = AY + BU</span>

<span class="n">T</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">tline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%%uniform time mesh</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">tline</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">tline</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">%% Simulation of the uncontrolled trajectory</span>
<span class="n">M</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">/</span><span class="n">dx</span><span class="o">.^</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">/</span><span class="n">dx</span><span class="o">.^</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">B</span><span class="p">;</span>

<span class="n">Y</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Y</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Y0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">%% loop over time intervals</span>
   <span class="c1">%% Crank-Nicolson method without control</span>
   <span class="n">Y</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">M</span><span class="p">\</span><span class="n">L</span><span class="o">*</span><span class="n">Y</span><span class="p">(:,</span><span class="n">k</span><span class="p">);</span>
<span class="k">end</span>
<span class="n">YT</span> <span class="o">=</span> <span class="n">Y</span><span class="p">(:,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Y1</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">*</span><span class="n">YT</span><span class="p">;</span>
</code></pre>
</div>

<h2 id="optimization-problem-in-casadi">Optimization problem in CasADi</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">opti</span> <span class="o">=</span> <span class="n">casadi</span><span class="o">.</span><span class="n">Opti</span><span class="p">();</span>  <span class="c1">%% CasADi function</span>

<span class="c1">%% ---- Input variables ---------</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% state trajectory</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">%% control</span>

<span class="c1">%% ---- Dynamic constraints --------</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">%% loop over control intervals</span>
   <span class="c1">%% Crank-Nicolson method</span>
   <span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">X</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span> <span class="n">L</span><span class="o">*</span><span class="n">X</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">U</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">U</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)));</span>
<span class="k">end</span>

<span class="c1">%% ---- State constraints --------</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">X</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">Y0</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">subject_to</span><span class="p">(</span><span class="n">X</span><span class="p">(:,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">Y1</span><span class="p">);</span>

<span class="c1">%% ---- Optimization objective  ----------</span>
<span class="n">Cost</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">U</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="p">/</span><span class="n">Nt</span><span class="p">));</span> <span class="c1">%%1e3*dx^2*sum(sum((X(:,Nt+1)-Y1).^2))+;</span>
<span class="n">opti</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">Cost</span><span class="p">);</span> <span class="c1">%% minimizing L2 at the final time</span>

<span class="c1">%% ---- Initial guess ----</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
<span class="n">opti</span><span class="o">.</span><span class="n">set_initial</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">%% ---- solve NLP              ------</span>
<span class="n">p_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'expand'</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
<span class="n">s_opts</span> <span class="o">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s1">'max_iter'</span><span class="p">,</span><span class="mf">1e5</span><span class="p">);</span> <span class="c1">%% cut down the algorithm at the 1000-th iteration.</span>
<span class="n">opti</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="s1">'ipopt'</span><span class="p">,</span><span class="n">p_opts</span><span class="p">,</span><span class="n">s_opts</span><span class="p">);</span> <span class="c1">%% set numerical backend</span>
<span class="nb">tic</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">solve</span><span class="p">();</span>   <span class="c1">%% actual solve</span>
<span class="nb">toc</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>This is Ipopt version 3.12.3, running with linear solver mumps.
NOTE: Other linear solvers might be more efficient (see Ipopt documentation).

Number of nonzeros in equality constraint Jacobian...:     2852
Number of nonzeros in inequality constraint Jacobian.:        0
Number of nonzeros in Lagrangian Hessian.............:       31

Total number of variables............................:      527
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:      512
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  0.0000000e+00 1.04e-01 0.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  2.9522421e+04 1.33e-15 6.25e-02  -2.5 1.08e+03    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 1

                                   (scaled)                 (unscaled)
Objective...............:   2.9522420557910038e+04    2.9522420557910038e+04
Dual infeasibility......:   6.2500000000000000e-02    6.2500000000000000e-02
Constraint violation....:   1.3322676295501878e-15    1.3322676295501878e-15
Complementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00
Overall NLP error.......:   1.4002321948103652e-12    6.2500000000000000e-02


Number of objective function evaluations             = 2
Number of objective gradient evaluations             = 2
Number of equality constraint evaluations            = 2
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 2
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 1
Total CPU secs in IPOPT (w/o function evaluations)   =      0.516
Total CPU secs in NLP function evaluations           =      0.000

EXIT: Optimal Solution Found.
               t_proc [s]   t_wall [s]    n_eval
       nlp_f      6.2e-05      1.4e-05         2
       nlp_g     0.000212       0.0001         2
  nlp_grad_f      4.3e-05      2.9e-05         3
  nlp_hess_l      3.2e-05      3.3e-05         1
   nlp_jac_g     0.000147     0.000148         3
      solver        0.668        0.573         1
Elapsed time is 0.638270 seconds.
</code></pre>
</div>

<h2 id="post-processing-1">Post-processing</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Sol_x</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">X</span><span class="p">);</span> <span class="c1">%% solved controlled trajectory</span>
<span class="n">Sol_u</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">U</span><span class="p">);</span> <span class="c1">%% solved control</span>
<span class="c1">%%Sol_x = opti.debug.value(X);</span>
<span class="c1">%%Sol_u = opti.debug.value(U); %% final data if algorithm stops with error</span>

<span class="c1">%%</span>
<span class="nb">clf</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Sol_x</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="n">jsurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">jsurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">Z</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">*</span><span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,</span><span class="k">end</span><span class="p">),</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">);</span>
<span class="nb">plot3</span><span class="p">(</span><span class="n">xmsf</span><span class="p">,</span><span class="n">ymsf</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s1">'k*'</span><span class="p">)</span>

<span class="n">jsurf</span><span class="o">.</span><span class="n">Parent</span><span class="o">.</span><span class="n">Color</span> <span class="o">=</span> <span class="s1">'none'</span><span class="p">;</span>
<span class="nb">lightangle</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>

<span class="nb">legend</span><span class="p">({</span><span class="s1">'Controlled final data'</span><span class="p">,</span><span class="s1">'Uncontrolled final data'</span><span class="p">,</span><span class="s1">'Target'</span><span class="p">})</span>
</code></pre>
</div>

<p><img style="width:70%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_07.png" /></p>

<center><p>Fig 7. The initial condition and the final data of uncontrolled dynamics. It has a different structure compared to Fig 2.</p></center>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% Free and controlled dynamics in animation</span>

<span class="n">Result_ref</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% displaying variable</span>
<span class="n">Result_ref</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">(:,:),[</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>

<span class="n">Result_con2d</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">N_size</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% displaying variable</span>
<span class="n">Result_con2d</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Sol_x</span><span class="p">(:,:),[</span><span class="n">N_size</span><span class="p">,</span><span class="n">N_size</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>

<span class="n">fig</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="n">isurf2</span><span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="k">end</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Free dynamics'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Target'</span><span class="p">,</span><span class="s1">'Solution'</span><span class="p">)</span>
<span class="nb">zlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="nb">pause</span><span class="p">;</span>
<span class="k">for</span> <span class="n">it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span>
   <span class="n">isurf</span><span class="o">.</span><span class="n">ZData</span> <span class="o">=</span>  <span class="n">Result_ref</span><span class="p">(:,:,</span><span class="n">it</span><span class="p">);</span>
    <span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">%%</span>
<span class="nb">clf</span>

<span class="n">fig</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="n">isurf2</span><span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="n">Result_ref</span><span class="p">(:,:,</span><span class="k">end</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf2</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">isurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">Result_con2d</span><span class="p">(:,:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.7</span><span class="p">);</span>
<span class="n">isurf</span><span class="o">.</span><span class="n">CData</span> <span class="o">=</span> <span class="n">isurf</span><span class="o">.</span><span class="n">CData</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Controlled dynamics'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Target'</span><span class="p">,</span><span class="s1">'Solution'</span><span class="p">)</span>
<span class="nb">zlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="nb">pause</span><span class="p">;</span>
<span class="k">for</span> <span class="n">it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span>
   <span class="n">isurf</span><span class="o">.</span><span class="n">ZData</span> <span class="o">=</span>  <span class="n">Result_con2d</span><span class="p">(:,:,</span><span class="n">it</span><span class="p">);</span>
    <span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<table>
   <tr>
      <th>
         <center><video controls="" width="95%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_08-c.mp4"></video></center>
      </th>
      <th>
        <center><video controls="" width="95%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0006/copiaRM_09-c.mp4"> </video></center>
      </th>
   </tr>
</table>
<center><p><b>Fig 8-9.</b> Animations for the free and controlled dynamics. The target surface is also drawn in both dynamics, where free dynamics goes below than the target.</p></center>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this tutorial, we propose the Hum method to approximate numerically the control in a null controllability problem for a non linear population dynamics model structuring in age and spatial diffusion.&lt;/p&gt;
</code></pre>
</div>

<p>For given the positive function $F$, we consider the following Population Dynamics Model Structuring by age and spatial diffusion:</p>

<script type="math/tex; mode=display">% <![CDATA[
(1):\left\{ 
\begin{array}{ccc}
\partial_{t} y+\partial_{a}y-Δ y+\mu y&=\chi_{\Theta}V&\text{ in }\Omega\times(0,A)\times (0,T) ,\\ 
\dfrac{\partial y}{\partial \nu}&=0& \partial \Omega \times (0,A)\times (0,T)\\
y\left( x,0,t\right) &=F\left(\int_{0}^{A}\beta(a)yda\right) &\text{ in }  \Omega\times(0,T) \\
y\left(x,a,0\right)&=y_{0}&
\text{ in } \Omega\times(0,A).
\end{array}
\right. %]]></script>

<p>where, $\Omega$ is a boundary subset of $\mathbb{R}^{N}$, $A$ is the maximal age and $T&gt;0$ the final time. Also, $\Theta=\omega× (a_1,a_2)× (0,T),$ is the control support. Here, $\beta$ is the fertility rate depending also the age a, $\mu$ the mortality rate depending of the age a, $y_0$ the initial condition in $L^2(\Omega× (0,A)),$ $V$ is the control term and $y$ represent the density of the population of age $a$ at time $t$ and location $x∈ \Omega.$</p>

<p>We assume that the fertility rate $\beta$ and the mortality rate $\mu$ satisfy the demographic property:</p>

<script type="math/tex; mode=display">(H_1)=
\left\{
\begin{array}{c}
\mu(a)\geq 0 \text{ for every } a\in (0,A)\\
\mu\in L^{1}_{loc}(0,A)\quad \int_{0}^{A}\mu(a)da=+\infty
\end{array} \right.,</script>

<p>and</p>

<script type="math/tex; mode=display">(H_2)=\left\{
\begin{array}{ccc}
\beta(a)\geq 0\quad a.e \quad (0,A)\\
\beta(a)\in C^{1}([0,A])\\
	\beta(a)=0 \text{ } \forall a\in (0,\hat{a}) \text{ where } \hat{a}\in (0,A), \\
\end{array}
\right.</script>

<p>where</p>

<script type="math/tex; mode=display">% <![CDATA[
0≤ a_1<a_2≤ A \text{ and }  a_1≤ \hat{a}. %]]></script>

<p>The function $F,$ verify:</p>

<script type="math/tex; mode=display">(H_3)=
\left\{
\begin{array}{c}
F \quad \text{ positive, globally Lipchitz }\\
F(0)=0,\quad F \text{ continuous and differentiable in } 0.
\end{array} \right..</script>

<h1 id="numerical-simulations">Numerical Simulations</h1>

<p>In this part, the objective is to illustrate numerically the approximate null controllability of the nonlinear problem.</p>

<p>Indeed, we consider the following system:</p>

<script type="math/tex; mode=display">% <![CDATA[
(4):\left\{ 
\begin{array}{ccc}
\partial_{t} y+\partial_{a}y-\partial^{2}_{xx}y+\mu y&=\chi_{\Theta}V&\text{ in }(0,1)\times(0,A)\times (0,T) ,\\ 
y'(0)=y'(1)&=0& \text{ in } (0,A)\times (0,T)\\
y\left( x,0,t\right) &=F\left(\int_{0}^{A}\beta(a)yda\right) &\text{ in }  (0,1)\times(0,T) \\
y\left(x,a,0\right)&=y_{0}&
\text{ in } (0,1)\times(0,A).
\end{array}
\right. %]]></script>

<h3 id="discretization-and-simulation-of-uncontrolled-system">Discretization and simulation of uncontrolled system</h3>

<p>The idea in this part is to highlight the numerical simimulation of the nonlinear problem. The first parts is to reduce the PDE to the finite dimensional system of the form</p>

<script type="math/tex; mode=display">\dot{U_l}=A_lU_l+vectorF+BV,</script>

<p>where $A_l$ and $B$ are matrices, and</p>

<script type="math/tex; mode=display">\begin{pmatrix}
U_l(t) \\
V(t) \\
\end{pmatrix}</script>

<p>is the finite dimensional state and control vector. Here, VectorF is the contribution of the nonlinear part, which comes from births. So let’s consider the following system</p>

<script type="math/tex; mode=display">% <![CDATA[
(5):\left\{ 
\begin{array}{ccc}
\dfrac{\partial y}{\partial t}+\textbf{A}y+\mu y&=\chi_{\Theta}V&\text{ in }\Omega\times(0,A)\times (0,T) ,\\ 
\dfrac{\partial y}{\partial \nu}&=0& \partial \Omega \times (0,A)\times (0,T)\\
y\left( x,0,t\right) &=F\left(\int_{0}^{A}\beta(a)yda\right) &\text{ in }  \Omega\times(0,T) \\
y\left(x,a,0\right)&=y_{0}&
\text{ in } \Omega\times(0,A).
\end{array}
\right. %]]></script>

<p>where</p>

<script type="math/tex; mode=display">\textbf{A}y=\partial_{a}y-\partial^{2}_{xx}y.</script>

<p>To solve $(4)$, the space (dimension 1) and age discretization is performed with finite difference method on rectangular grid 
on $[0,L]\times [0,A]$. For a given rectangular grid $\mathcal{T}$ with vertex $(x_i,a_j)\quad 1\leq i\leq N,\quad 1\leq j\leq M$ and uniform step size (without loss of generality) $\Delta x$ in $x-$direction and $\Delta a$ in $a-$direction, we denote by  the diameter of the grid
The finite difference approximation of the diffusion term of the operator $\textbf{A}$ is given by</p>

<script type="math/tex; mode=display">\dfrac{\partial^2 y}{\partial x^2}(x_i,a_j,t)=\dfrac{y(x_{i+1},a_j,t)-2y(x_i,a_j,t)+y(x_{i-1},a_j,t)}{(\Delta x)^2}.</script>

<p>The finite difference approximation of the aging term of the operator A is given by</p>

<script type="math/tex; mode=display">\dfrac{\partial y}{\partial a}(x_i,a_j,t)=\dfrac{y(x_{i},a_{j},t)-y(x_i,a_{j-1},t)}{\Delta a}.</script>

<p>Let $y_{i,j}(t)$ be the approximation of $y(x_i,a_j)$ and</p>

<script type="math/tex; mode=display">U_{l}(t) = (y_{i,j}(t))_{1\leq i\leq N,\quad 1\leq j\leq M}</script>

<p>where $y_{i,j}$ is at the position $i+j*(N-1)$ and $A_l$ the matrix of the mortality approximation, the diffusion approximation and the aging approximation.</p>

<h3 id="take-into-account-the-newborns">Take into account the newborns</h3>

<p>We denote by $\beta(a),$ the fertility rate, the newborn is given by:</p>

<script type="math/tex; mode=display">y(x,0,t)=F\left(\int_{0}^{A}\beta(a)y(x,a,t)da\right).</script>

<p>We approximate $\int_{0}^{A}\beta(a)y(x,a,t)da$ by</p>

<script type="math/tex; mode=display">\int_{0}^{A}\beta(a)y(x,a,t)da=(A/n)\sum_{j=1}^{n-1}\beta(a_j)y(x,a_j,t)+\dfrac{\beta(0)y(x,0,t)+\beta(A)y(x,A,t)}{2}.</script>

<p>Then</p>

<script type="math/tex; mode=display">y_{i,0}=A/n\sum_{k=1}^{n-1}\beta(a_k)y(x_i,a_k,t)+\dfrac{\beta(0)y(x_i,0,t)+\beta(A)y(x_i,A,t)}{2}\text{ for } i=1:n.</script>

<p>But as</p>

<script type="math/tex; mode=display">\dfrac{\partial y_{i,1}(t)}{\partial a}=\dfrac{y_{i,1}(t)-y_{i,0}(t)}{\Delta a}\text{ } i=1:n,</script>

<p>then</p>

<script type="math/tex; mode=display">\dfrac{\partial y_{i,1}(t)}{\partial a}=\dfrac{-A/n\sum_{k=1}^{n-1}\beta(a_k)y_{i,k}(t)+y_{i,1}(t)+\dfrac{\beta(0)y(x_i,0,t)+\beta(A)y(x_i,A,t)}{2}}{\Delta a}\quad i=1:n,</script>

<p>We create also the nonlinear vectorF from the births. Indeed, if we denote by</p>

<script type="math/tex; mode=display">(N_l)_{1\leq i\leq n*n;\leq j\leq n*n}</script>

<p>the matrix of the births,</p>

<script type="math/tex; mode=display">P_l=N_lU_l\quad where\quad  \left(\dfrac{A\sum_{k=1}^{n-1}\beta(a_k)y_{i,k}(t)+\dfrac{\beta(0)y(x_i,0,t)+\beta(A)y(x_i,A,t)}{2}}{n\Delta a}\right)_{1\leq i\leq n}=\left(P_l\right)_{1\leq i\leq n}\text{ } and \text{ } 
\left(P_l\right)_{n+1\leq i\leq n*n}=0</script>

<p>and we define the vectorF by:</p>

<script type="math/tex; mode=display">vectorF=F(N_lU_l).</script>

<p>The corresponding discrete system is given for a continuous initial solution $y_0$ by</p>

<script type="math/tex; mode=display">\dfrac{dU_l}{dt}=A_lU_l+vectorF\quad y(0)=y_0(x,a)</script>

<h3 id="example-1">Example 1</h3>

<h4 id="simulation-of-the-uncontrolled-system">Simulation of the uncontrolled system:</h4>

<p>For the simulation, we take $L=1,\text{ } A=10\text{, }\Delta x=1/54\quad \Delta a= 5/54$ and $T=40$. Moreover $F(t)=t\Phi(t)$ a Globally Lipchitz function where</p>

<script type="math/tex; mode=display">\Phi(t)=0.75\exp(-t)</script>

<p>The fertility $\beta$ is given by:</p>

<script type="math/tex; mode=display">% <![CDATA[
\beta(a) = 
 \begin{cases}
0 & \text { if } a<A/18 \\
 \frac{\alpha(a-5/18)^{\gamma-1}e^{-(a-5/18)/v}}{v^{\gamma}\Gamma(\gamma)}
\text{ if } A/18\leq a\leq 17A/18\\
 0 &\text{ if } a>17A/18.
  \end{cases} %]]></script>

<p>here $v=1$, $\gamma=5$, $\alpha=7$ and the mortality rate $\mu$ by</p>

<script type="math/tex; mode=display">\mu(a)=\dfrac{1}{10(A-a)}</script>

<hr />

<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/uncontrolled stat1.mp4" width="80%" controls=""></video>
</center>

<center><strong>Video 1.</strong> Evolution of the state of the uncontrolled system between t=0 and t=30 </center>

<p>We observe in this video the growth (aging) of news borns over time. We also notice the high birth rate of this population.</p>

<h2 id="construction-of-the-control-and-numerical-simulation">Construction of the control and numerical simulation</h2>

<p>We construct the control problem, which consists in minimizing the functional and we choose the classical Hum functional and the control matrix $B=\chi_{\Theta}$ where $\Theta=(x_1,x_2)\times (a_1,a_2)\times (0,T),$ and we suppose that $U_T$ is the desired state:</p>

<script type="math/tex; mode=display">J_{\epsilon}(U_l,V_l)=\dfrac{1}{\epsilon}\int_{0}^{A}\int_{0}^{L}\left(U_l(x,a,T)-U_T\right)^2dxda+\int_{0}^{T}\int_{a_1}^{a_2}\int_{x_1}^{x_2}V_{l}^{2}dxdadt.</script>

<p>Here $U_T=0.$\
The approximate null controllability become the minimization of  the functional $J,$ where $(U_l,V_l)$ verify the following system</p>

<script type="math/tex; mode=display">\dfrac{dU_l}{dt}=A_lU_l+vectorF+BV_l\quad U_l(0)=(y_0(x_i,a_j))_{1\leq i\leq N,1\leq j\leq M}</script>

<p>In this part the fertility $\beta$ is given by:</p>

<script type="math/tex; mode=display">% <![CDATA[
\beta(a) = 
 \begin{cases}
0 & \text { if } a<A/5 \\
 \frac{\alpha(a-/8)^{\gamma-1}e^{-(a-/8)/v}}{v^{\gamma}\Gamma(\gamma)}
\text{ if } A/5\leq a\leq 4A/5\\
 0 &\text{ if } a> 4A/5,
  \end{cases} %]]></script>

<p>here $v=1$, $\gamma=5$, $\alpha=7$
 and</p>

<script type="math/tex; mode=display">\mu(a)=\dfrac{1}{15(A-a)}</script>

<p>and $VectorF=(P_lU_l).^2$.This means that we consider that $F(t)=t^2$ which is globally lipchizt on a compact which is our case.</p>

<p>The system becomes:</p>

<script type="math/tex; mode=display">\dfrac{dU_l}{dt}=A_lU_l+(P_lU_l).^2+BV_l\quad U_l(0)=(y_0(x_i,a_j))_{1\leq i\leq N,1\leq j\leq M}.</script>

<h3 id="example-2">Example 2</h3>

<p>In this example, we take $ε=0.05$, $\Delta x=0.05$ and $\Delta a= 0.5$, with the initial condition</p>

<script type="math/tex; mode=display">y_0(x,a)=e^{-(10(a-3/10)^2+70(x-4/10))}</script>

<p>the following numerical results were obtained for $T=12$ and $\Delta t=120$.</p>

<p>Evolution of the control V between t=0 and t=12.</p>
<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/example2stat.mp4" width="80%" controls=""></video>
</center>
<center><strong>Video 2.</strong> Evolution of the state of controlled system between t=0 and t=12 </center>

<p>We notice that, with a control domain that takes into account the most populated part of the domain, the Hum method applied to the Casadi algorithm gives us an interesting approximative controllability result while maintaining the positivity of the density.
Evolution of the controlled state (density of the population) between t=0 and t=12.</p>
<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/example2cont.mp4" width="80%" controls=""></video>
</center>

<center><strong>Video 3.</strong> Evolution of the control function between t=0 and t=12 </center>

<h3 id="example-3">Example 3</h3>

<p>Here, we keep the same parameters of the Example 1 but we change the final time (here T=20) , and we take $\Delta x=1/18$, $Δ a=5/18$, $\epsilon=0.05$ the following numerical results were obtained:</p>
<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/videofinalc.mp4" width="80%" controls=""></video>
</center>
<center><strong>Video 4.</strong> Evolution of the state of the controlled system between t=0 and t=20 </center>

<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/ccc.mp4" width="80%" controls=""></video>
</center>

<center><strong>Video 4.</strong> Evolution of the state of the controlled system between t=0 and t=20 </center>

<h3 id="example-4">Example 4</h3>

<p>In this part we consider a smaller control domain. Indeed we take 
$\Theta =(0,2/5)\times(0,4)\times(0,T)$. 
In addition we also remove $\epsilon=0.001$ and $T=20.$ The rest is identical to the data of example 2.</p>

<p>We obtain the following numerical results:</p>

<p>Evolution of the control V between t=0 and t=20.</p>

<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/example4stat.mp4" width="80%" controls=""></video>
</center>

<center><strong>Video 4.</strong> Evolution of the state of the controlled system between t=0 and t=20 </center>

<p>Here although the result is acceptable, we notice that the state of the controlled system is negative for most of the time.\
Evolution of the controlled state (the density of the population) between t=0 and t=20.</p>

<center>
<video src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0012/example4cont.mp4" width="80%" controls=""></video>
</center>

<center><strong>Video 5.</strong> Evolution of the control function between t=0 and t=20 </center>
<p>We notice here that the solution to the final time tends to 0, but during the time of control much of the state of the system was negative.
We notice that numerically we have approximation and the positivity of the state, if the support of the control covers the most populated part of the domain (space, age).</p>

<p>However it should be noted that we could not take a positivity constraint in our simulations. It should be noted that we have better approximations when we do not consider the cost of control.</p>

<h2 id="references">References</h2>
<p>[1] Dycon Toolbox</p>

<p>[2] CasaDi toolbox</p>

<p>[3] Luca Gerardo-Giorda: NUMERICAL APPROXIMATION OF DENSITY DEPENDENT DIFFUSION IN AGE-STRUCTURED POPULATION DYNAMICS</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;En esta entrada veremos como podremos estimar  el sistema dinámico apartir de datos sobre la evolución de este sistema.&lt;/p&gt;
</code></pre>
</div>

<p>Lo primero que haremos es inspeccionar de que datos disponemos</p>
<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="nb">whos</span>
</code></pre>
</div>
<div class="language-matlab highlighter-rouge"><pre class="highlight"><code>  <span class="n">Name</span>               <span class="n">Size</span>                  <span class="n">Bytes</span>  <span class="n">Class</span>     <span class="n">Attributes</span>

  <span class="n">solution</span>         <span class="mi">100</span><span class="n">x200x50</span>            <span class="mi">8000000</span>  <span class="nb">double</span>              
  <span class="n">tspan</span>              <span class="mi">1</span><span class="n">x200</span>                  <span class="mi">1600</span>  <span class="nb">double</span>    
</code></pre>
</div>
<p>En este caso tenemos 100 simulaciones de una ecuación diferencial</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h2 id="background-and-motivation"&gt;Background and motivation&lt;/h2&gt;
</code></pre>
</div>

<p>An idealized version of a MEMS device consists of <b>two conducting plates connected to an electric circuit</b>
(see Figure 1).
The upper plate is rigid and fixed while the lower one is elastic and fixed only at the boundary.
Initially the plates are parallel and at unit distance from each other.
When a voltage (difference of potential between the two plates) is applied, the lower
plate starts to bend and, if the voltage is large enough,
the lower plate eventually touches the upper one, conducting to the so-called <b> pull-in instability</b>. In the mathematical framework, this phenomenon is known as <b>quenching</b> or <b> touchdown</b>.
Such device can be used for instance as an actuator, a microvalve (the touching-down part closes the valve),
or a fuse.</p>

<figure>
 <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/fig6.png" alt="Figure 1: MEMS device" height="200" width="300" /> 
</figure>

<center>
<strong> Figure 1: </strong> Two-membrane MEMS device
</center>

<p>We consider a well-known <b>model for micro-electromechanical systems (MEMS)
with variable dielectric permittivity</b>, based on the following parabolic equation with singular nonlinearity:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{quenching problem}
\left\lbrace \begin{array}{rrl}
u_t - \Delta u = \dfrac{f(x)}{(1-u)^2}, & x\in \Omega, & t>0, \\
u = 0, & x\in \partial \Omega, & t>0, \\
u(0,x) = 0, & x \in \Omega, &
\end{array} \right.
\end{equation} %]]></script>

<p>where $\Omega$ is a smoothly bounded domain of $\mathbb{R}^2$ and 
<script type="math/tex">f\geq 0</script> is a Hölder continuous function in <script type="math/tex">\overline{\Omega}</script>.</p>

<p>In this mathematical model, the domain $\Omega$ represents the shape of the elastic plate in the horizontal direction, the solution $u=u(t,x)$ measures its vertical deflection,
while the function $f(x)$ is proportional to the constant voltage and characterizes the varying dielectric permittivity of the elastic plate.
We can write the permittivity profile $f$ as follows:</p>

<script type="math/tex; mode=display">f(x) = \lambda\dfrac{\varepsilon_0}{\varepsilon_1(x)},</script>

<p>where $\lambda&gt;0$ is the applied voltage, $\varepsilon_0&gt;0$ is the permittivity of the vacuum and $\varepsilon_1(x)$ is the dielectric permittivity of the material. 
As a key feature, in our model the permittivity of the elastic plate may be inhomogeneous,
and this can be used to trigger the properties of the device. 
We refer to <b>[1],[4],[5] and the references therein for the full details of the model derivation</b>.</p>

<p>It is well known that problem (\ref{quenching problem}) admits a unique maximal classical solution $u$.
We denote its maximal existence time by $T=T_f\in (0,\infty]$. Moreover,
under some largeness assumption on $f$, it is known that the maximum of $u$ reaches the value $1$
at a finite time, so that $u$ ceases to exist in the classical sense. This is what we call <b> touchdown in finite time</b> $T_f&lt;\infty$.
Actually, if we consider $f(x) = \lambda\dfrac{\varepsilon_0}{\varepsilon_1(x)}$,
it is well-known that there exists a positive $\lambda^\ast$, known as <b> pull-in voltage</b>, which depends on $\Omega$ and $\varepsilon_1(x)$, such that</p>

<p>$\bullet \quad $ If $\lambda&lt;\lambda^\ast$, then $T_f=\infty$ and the global classical solution converges to the minimal positive steady state.</p>

<p>$\bullet \quad $ If $\lambda&gt;\lambda^\ast$, then $T_f&lt;\infty$, and then touchdown occurs in finite time.</p>

<p>In the actual design of a MEMS device there are several issues that must be considered.
Typically, one of the design goals is to achieve the maximum possible stable steady-state with relatively small applied voltage $\lambda$.  Another consideration may be to increase the stable operating range of the device by increasing the pull-in voltage.
For other devices, such as micropumps and microvalves, where touchdown behavior is explicitly exploited,
<b>it is of interest to be able to localize the touchdown points</b>, or similarly, to be able to avoid touchdown in certain parts of the device.
Our approach to achieve this last goal is to consider a material with varying dielectric permittivity allowing us to localize the touchdown points by a suitable choice of the permittivity profile.</p>

<h2 id="results">Results</h2>

<p>We start by the definition of touchdown point.
A point $x = x_0$ is called a <i> touchdown</i> or <i> quenching point</i> if there exists a sequence ${(x_n , t_n )} \in \Omega\times (0, T)$ such that</p>

<script type="math/tex; mode=display">x_n\to x_0,\ \ t_n\uparrow T\ \ \hbox{and}\ \ u(x_n,t_n)\to 1 \ \hbox{as}\ n\to\infty.</script>

<p>The set of all such points is called the <i> touchdown</i> or <i> quenching set</i>, denoted by $\mathcal{T}=\mathcal{T}_f\subset\overline{\Omega}$.</p>

<p>We show in [2] that <b>touchdown can actually be ruled out in subregions of $\Omega$ 
where $f$ is positive but suitably small, below a positive threshold</b>.</p>

<p><b> Theorem 1:</b>
Let $\Omega\subset \mathbb{R}^n$ a smooth bounded domain and $f$ a function satisfying</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\left\lbrace \begin{array}{rrl}
&&T_f<\infty,\quad \|f\|_\infty\le M,\quad f\ge \mu\chi_B, \\
&&\hbox{where $M,\mu , r>0$ and $B\subset\Omega$ is a ball of radius $r$.}
\end{array} \right.
\end{equation*} %]]></script>

<p>There exists $\gamma_0&gt;0$ depending only on $\Omega,M,\mu,r$ such that:</p>

<p>(i) $\quad$ For any $x_0\in \Omega$, if $f(x_0) &lt;\gamma_0 {\hskip 1pt} \text{dist}^3 (x_0,\partial\Omega)$, then $x_0$ is not a touchdown point.</p>

<p>(ii) $\quad $ For any $\omega\subset\subset \Omega$, if $\displaystyle\sup_{x\in \overline{\Omega}\setminus \omega} f(x) &lt;
\gamma_0 {\hskip 1pt} \text{dist}^3(\omega,\partial\Omega)$, then the touchdown set 
 is contained in $\omega$.</p>

<p>Roughly speaking, the statement (i) in the above theorem allows one to rule out touchdown in an interior point by choosing a permittivity profile which is sufficiently small at that point, while statement (ii) allows to design devices producing touchdown inside any given subset of $\Omega$ by choosing a permittivity profile concentrated in that subset.</p>

<h3 id="numerical-simulation-1--no-touchdown-at-the-origin-">Numerical Simulation 1: <i> no touchdown at the origin </i></h3>

<p>In our first example, we consider a circular elastic plate of radius 1, that is $\Omega = B(0,1)\subset\mathbb{R}^2$.
It is well known that if the dielectric permittivity is constant, the unique touchdown point is the center of the disk.</p>

<p>As consequence of Theorem 1 (i), we can <b>prevent touchdown to occur at the origin</b> by choosing a permittivity profile $f$ such that $f(0)$ is sufficiently small.
Let’s assume that the applied voltage $\lambda$, together with the permittivity of the vacuum $\varepsilon_0$ and the permittivity of the material $\varepsilon_1$ are such that</p>

<script type="math/tex; mode=display">\lambda\dfrac{\varepsilon_0}{\varepsilon_1} = 8.</script>

<p>In this case, we might cover the center of the disk with a material with higher permittivity so that the value of $\varepsilon_1(x)$ in $B(0,1/4)$ is (for example) twice its value in $\Omega\setminus B(0,1/4)$.
That is, we consider the following permittivity profile:</p>

<script type="math/tex; mode=display">% <![CDATA[
f(x) = \left\lbrace \begin{array}{ll}
4 &  |x|< 0.25 \\
8 &  |x|\geq 0.25.
\end{array}\right. %]]></script>

<p>The following video represents the evolution of the elastic plate from the rest position to the pull-in instability.
For the numerical simulation we have applied an implicit Crank-Nicolson scheme in polar coordinates with number of meshpoint $N=100$ in the radial interval $[0,1]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo1.mp4">
</video>
</center>

<center>
<strong> Simulation 1: </strong>  Evolution of the elastic plate until pull-in instability (touchdown). The solution reaches the value 1 in a circumference and then, <b>touchdown is avoided at the center of the plate</b>.
In the schematic video, we remove the upper plate of the MEMS device in order to see the final profile of the solution.  
</center>

<h3 id="numerical-simulation-2--touchdown-near-a-prescribed-circumference-">Numerical Simulation 2: <i> touchdown near a prescribed circumference </i></h3>

<p>Let us suppose now that we want our system to touch down in a circumference of radius near $0.7$.
This time we can use Theorem 1 (ii). We will choose a <b>permittivity profile $f$ sufficiently concentrated near a circumference of radius $0.7$</b>. Consider for example:</p>

<script type="math/tex; mode=display">% <![CDATA[
f(x) = \left\lbrace \begin{array}{ll}
2 &  |x|< 0.65 \\
8 &  0.65\geq |x|\leq 0.75 \\
2 &  0.75< |x|.
\end{array}\right. %]]></script>

<p>The following video represents the evolution of the elastic plate from the rest position to the pull-in instability. 
In Figure 2 below, we plot the radial final touchdown profile.
For the numerical simulation we have applied an implicit Crank-Nicolson scheme in polar coordinates with number of meshpoint $N=100$ in the radial interval $[0,1]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo2.mp4">
</video>
</center>

<center>
<strong> Simulation 2: </strong>  Evolution of the elastic plate until pull-in instability (touchdown). The solution reaches the value 1 in a circumference of <b>radius near</b> $0.7$.
In the schematic video, we remove the upper plate of the MEMS device in order to see the final profile of the solution.  
</center>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/Ex2PlotFinalProfile.png" height="350" width="450" /></p>

<center>
<strong> Figure 2: </strong>  Plot of the <b> radial touchdown profile</b>. Observe that, as expected, touchdown occurs on a circumference of <b>radius between $0.65$ and $0.75$</b>. 
</center>

<h2 id="nontrivial-touchdown-sets">Nontrivial touchdown sets</h2>

<p>In view of Theorem 1,
it is a natural question whether such smallness conditions are actually necessary, 
or whether touchdown could be shown to occur only at or near the maximum points of the permittivity profile $f$.
In this connection, using stability properties of the touchdown set,
in [2] we construct radial ‘‘M’‘-shaped profiles giving rise to 
single-point touchdown at the origin.</p>

<h3 id="numerical-simulation-3">Numerical simulation 3:</h3>

<p>For this example, we have considered the following radial <b>M-shaped profile</b> in a disk of radius 1:</p>

<script type="math/tex; mode=display">f(x)=8-(1/4-|x|^2)^2, \qquad \text{for} \ |x|\in B(0,1).</script>

<p>For this profile, <b>the unique touchdown point is at the origin</b>, far away from the maxima of $f$.
Therefore, if we want to prevent touchdown at the origin, we need to choose a permittivity profile $f$ such that $f(0)$ is small enough (below a certain thershold).
For the numerical simulation we have applied an implicit Crank-Nicolson scheme in polar coordinates with number of meshpoint $N=100$ in the radial interval $[0,1]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo3.mp4">
</video>
</center>

<center>
<strong> Simulation 3: </strong>  Evolution of the elastic plate until pull-in instability (touchdown). Although we consider a ''M''-shaped permittivity profile, <b>the solution touches down only at the origin, far away from the maximum of $f$</b>.
In the schematic video, we remove the upper plate of the MEMS device in order to see the final profile of the solution.  
</center>

<h3 id="numerical-simulation-4">Numerical simulation 4:</h3>

<p>Another rather surprising example is the following <b>radially increasing profile</b>:</p>

<script type="math/tex; mode=display">f(x)= 8 + \dfrac{|x|^2}{4}.</script>

<p>For this example, <b>the unique touchdown point is the origin, which is actually the global minimum of </b> $f$. In [2], we give a rigorous proof of the existence of this kind of behaviors. It is based on a stability result of the touchdown set combined with the fact that single-point touchdown occurs for constant permittivity profiles.</p>

<p>For the numerical simulation we have applied an implicit Crank-Nicolson scheme in polar coordinates with number of meshpoint $N=100$ in the radial interval $[0,1]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo4.mp4">
</video>
</center>

<center>
<strong> Simulation 4: </strong>  Evolution of the elastic plate until pull-in instability (touchdown). Although the permittivity profile is radially increasing, <b> the unique touchdown point is the origin, the minimum point of $f$</b>.
In the schematic video, we remove the upper plate of the MEMS device in order to see the final profile of the solution.  
</center>

<h2 id="quantitative-results-in-1-dimension">Quantitative results in 1 dimension</h2>

<p>Motivated by practical considerations of MEMS design, our aim in [3] is to further investigate the 
touchdown localization problem
and to show that in one space dimension, where analytic computations can be made more precise,
one can obtain quite quantitative conditions.
Namely, <b>we look for a lower estimate of the ratio $\rho$ between $f$ and its maximum,
below which no touchdown occurs</b> on a subregion of $\Omega$.
Rather surprisingly, it turns out that, under suitable assumptions on $f$,
our methods yield values of
 the <b>threshold-ratio</b> $\rho$ which are not ‘‘small’’ but can actually be up to the order</p>

<script type="math/tex; mode=display">\rho\sim 0.3,</script>

<p>which could hence be quite appropriate for robust practical use.</p>

<p>In order to give good estimates of the  ratio $\rho$, we shall consider two typical situations, which roughly correspond to a <b>one-bump</b> or a <b>two-bump</b> shape for the profile $f$. 
 The touchdown is ruled out in a subinterval respectively located between a bump and 
an endpoint of $\Omega$, or between two bumps.
The idea behind this is that the plate can be covered with two dielectric materials, 
one with a high permittivity and the other with a lower permittivity. We then seek for a ratio between the two permittivities, allowing to rule out touchdown in the low permittivity region.</p>

<h3 id="reduction-to-a-finite-dimensional-optimization-problem">Reduction to a finite-dimensional optimization problem</h3>

<p>As a consequence of our method, the <b>threshold-ratio</b> $\rho$ <b> is rigorously obtained as the solution of a suitable finite-dimensional optimization problem</b>, with either three or four parameters. 
An advantage of our results is that they apply to large classes of configurations, so that detailed numerics need not be carried out to localize the touchdown set for particular cases.</p>

<p>For the precise statements of the results, as well as for a detailed study of the optimization problem and <b>numerical estimates of the threshold ratio</b>, we refer the lector to <b>[3]</b>.
The <b>Matlab codes to compute numerical estimates of the solution of the optimization problem</b> are availabe at the beginig of the page.</p>

<p>Here we give two concrete examples in order to illustrate 
the results.
The threshold ratio is obtained by a simple numerical procedure applied to the finite-dimensional optimization problem. 
<b>The following two figures represent some typical permittivity profiles</b> $f(x)$ and the localization of the corresponding touchdown sets
 in the one-bump and two-bump cases respectively. 
The touchdown sets are localized in a neighborhood of the bumps, represented by the fat lines.</p>

<center>
<img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/OneBumpProfile.PNG" width="65%" /> 
</center>

<center>
<strong> Figure 3:</strong> An illustration of the localization of thouchdown set for a <b>one-bump permittivity profile</b>.
Here, the figure represents the permittivity profile $f$ and <b> not </b> the profile of the solution.
</center>

<center>
<img img="" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/TwoBumpProfile.PNG" width="65%" />
</center>

<center>
<strong> Figure 4:</strong> An illustration of the localization of thouchdown set for a <b>two-bump permittivity profile</b>.
Here, the figure represents the permittivity profile $f$ and <b> not </b> the profile of the solution.
</center>

<h3 id="numerical-simulation-5">Numerical simulation 5:</h3>

<p>We give an example of a one-bump permittivity profile, similar to the one in Figure 3.
Although our result applies to a large class of profiles, here we consider, for computational simplicity, the following <b>bang-bang profile</b>:</p>

<script type="math/tex; mode=display">% <![CDATA[
f(x) = \left\lbrace\begin{array}{ll}
0.42 & x<-2 \\
2 & -2\leq x\leq 0 \\
0.42 & x>0.
\end{array}\right. %]]></script>

<p>The following video represents <b> the evolution of a 1-dimensional membrane</b>
with a one-bump permittivity profile $f$. 
For the numerical simulation we have applied an implicit Crank-Nicolson scheme with number of meshpoint $N=1000$ in the interval $[-6,6]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo5.mp4">
</video>
</center>

<center>
<strong> Simulation 5: </strong>  Evolution of the elastic 1-dimensional membrane until pull-in instability (touchdown). We see that <b>touchdown is localized in the region where $f$ is big</b> (see <b>Figure 3</b>).  
</center>

<h3 id="numerical-simulation-6">Numerical simulation 6:</h3>

<p>We give an example of a two-bump permittivity profile, similar to the one in Figure 4.
Although our result applies to a large class of profiles, here we consider, for computational simplicity,
the following bang-bang profile:</p>

<script type="math/tex; mode=display">% <![CDATA[
f(x) = \left\lbrace\begin{array}{ll}
0.42 & x<-1 \\
2 & -1\leq x\leq 1 \\
0.42 & 1<x<4 \\
2 & 4\leq x \leq 6 \\
0.42 & x > 6.
\end{array}\right. %]]></script>

<p>The following video represents <b> the evolution of a 1-dimensional membrane</b>
with a two-bump permittivity profile $f$.
For the numerical simulation we have applied an implicit Crank-Nicolson scheme with number of meshpoint $N=1000$ in the interval $[-10,10]$.</p>

<center>
<video controls="" width="65%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0010/MEMSvideo6.mp4">
</video>
</center>

<center>
<strong> Simulation 6: </strong>  Evolution of the elastic 1-dimensional membrane until pull-in instability (touchdown). We see that <b>touchdown is localized in the region where $f$ is big</b> (see <b>Figure 4</b>).  
</center>

<h3 id="references">References</h3>

<p>[1] P. Esposito, N. Ghoussoub, Y. Guo, <i> Mathematical analysis of partial differential equations modeling electrostatic MEMS</i>. Courant Lecture Notes in Mathematics, 20. Courant Institute of Mathematical Sciences, New York; American Mathematical Society, Providence, RI, 2010. xiv+318 pp.</p>

<p>[2] C. Esteve, Ph. Souplet, <i> No touchdown at points of small permittivity and nontrivial touchdown sets for the MEMS problem</i>. Advances in Differential Equations, Vol 24, Number 7-8(2019), 465-500.</p>

<p>[3] C. Esteve, Ph. Souplet, <i> Quantitative touchdown localization for the MEMS problem with variable dielectric permittivity</i>. Nonlinearity} 31 4883 (2018).</p>

<p>[4] Ph. Laurençot, Ch. Walker, <i> Some singular equations modeling MEMS</i>. Bull. Amer. Math. Soc. 54 (2017), 437-479.</p>

<p>[5] J.A. Pelesko, D.H. Bernstein, <i> Modeling MEMS and NEMS</i>, Chapman Hall and CRC Press, 2002.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;The main objective of this blog is to explain numerically the difference between exponential and polynomial decay in term of energy and spectral properties. We Show also that system with polynomial decay are very  sensitive to the choice of initial data.&lt;/p&gt;
</code></pre>
</div>

<h2 id="model-problem">Model Problem</h2>

<p>We consider the numerical approximation of the following coupled thermoelastic wave models</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \label{eq1} \tag{1}  \left\{\begin{array}{llll}                       u_{tt}(x,t)- \Delta u(x,t)+\gamma\theta_x(x,t)=0\quad &in\;\Omega\times(0, \infty)\\ 		      \theta_{t}(x,t)-\Delta\theta(x,t)-\gamma u_{tx}(x,t) =0\quad &in\;\Omega\times(0, \infty)\\ 		      u(x,t)=0=\theta(x,t)\qquad &\text{on } \partial\Omega\times(0,\infty)\\ u(x,0)=u_{0}(x),\; u_{t}(x,0)=u_{1}(x),\; \theta(x,0)=\theta_{0}(x) \quad &on \;\Omega                      \end{array}                    \right. \end{equation} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \label{eq2} \tag{2}  \left\{\begin{array}{llll}                       u_{tt}(x,t)- \Delta u(x,t)+\gamma\theta(x,t)=0\quad &in\;\Omega\times(0, \infty)\\ 		      \theta_{t}(x,t)-\Delta\theta(x,t)-\gamma u_{t}(x,t) =0\quad &in\;\Omega\times(0, \infty)\\ 		      u(x,t)=0=\theta(x,t)\qquad &\text{on } \partial\Omega\times(0,\infty)\\ u(x,0)=u_{0}(x),\; u_{t}(x,0)=u_{1}(x),\; \theta(x,0)=\theta_{0}(x) \quad &on \;\Omega                      \end{array}                    \right. \end{equation} %]]></script>

<p>where $u(x,t)$ is the displacement (longitudinal or transverse, depending upon the application) at position $x$ along a bounded smooth domain $\Omega\subset\mathbb{R}$ and time $t$ , and $\theta(x,t)$ is the temperature deviation from the reference temperature at position $x$ and time $t$, $u_0(x)$, $v_0(x)$ and $\theta_0(x)$ are initial data in a suitable space. The small positive constant $\gamma$ is a thermo-mechanical coupling parameter and is generally small in comparison to 1. System (\ref{eq1}) differs from system $\eqref{eq2}$ at the coupling terms, where we have replaced the strong coupling ($\gamma\theta_x$ and $\gamma u_{tx}$) by a weak coupling ($\gamma\theta$ and $\gamma u_{t}$).</p>

<p>It is well known from literature that system (\ref{eq1}) and (\ref{eq2}) are respectively exponentially and polynomially stable, see [3,7] and [5,6,9].</p>

<p>In this post, we will show by numerical experiments, how the coupling terms affect quantitative and qualitative properties of thermoelastic systems (\ref{eq1}) and (\ref{eq2}). These results could be found in [8,10].</p>

<p>To do this, we consider a semi discretization version of both systems (\ref{eq1}) and (\ref{eq2}), obtained with finite element method, which has the following form</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq3} \tag{3}  (S_i)\left\{\begin{array}{ll}  z'_n(t)=A_{i,n} z_n(t),\quad t\geq 0,\;n\in\mathbb{N},\;i=1,2\\  z_n(0)=z_{n0},\;n\in\mathbb{N}\\ \end{array} \right. \end{equation}</script>

<p>where for all $n\in\mathbb{N}$, $z_n=(u_n,v_n,\theta_n)^T$ is the semi discrete solution, $z_{n0}$ is the discretized initial data, $A_{i,n}$ the discretized dynamic and the subscript $\cdot_i$ refers to system (\ref{eq1}) and (\ref{eq2}) with</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align} A_{i,n}=\left(\begin{matrix}                     0 & D_n & 0\\ 	       -D_n & 0 & -\gamma F_{i,n}\\ 		    0 & \gamma F_{i,n} & -D_n^2                    \end{matrix} \right),\quad i=1,2 \end{align} %]]></script>

<p>and $F_{2,n}=I_n$,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align} D_n=\left(\begin{matrix}                     1 &  & \\ 	        & \ddots &  \\ 		     &   & n                    \end{matrix} \right),\quad (F_{1,n})_{ij}=\left\{\begin{array}{ll}  -\frac{4}{\pi}\frac{ij}{i^2-j^2},\quad `i-j`=\text{odd},\\  0,\qquad\qquad\text{otherwise}. \end{array} \right. \end{align} %]]></script>

<h2 id="spectral-properties-of-thermoelastic-systems">Spectral properties of thermoelastic systems</h2>

<p>Figure 1 and Figure 2 show how the coupling terms affect the placement of eigenvalues of the dynamic $A_{n}$. In Figure 1, we see that a uniform distance between the eigenvalues and the imaginary axis is preserved, see Table 1. Another observation is that for fixed $n$, the eigenvalues of higher frequency modes, in particular, the one of the $n^{th}$ mode, are closer to the imaginary axis. Moreover, as the number of modes increases, these eigenvalues bend back towards the vertical line $\lambda=-\frac{\gamma^2}{2}$, a fact which has been already shown in [4]. Therefore, the corresponding spectral element approximation scheme preserves the property of exponential stability.</p>

<center> <strong>Table 1.</strong> Distance between $\sigma(A_{1,n})$ and the imaginary axis form the spectral element method</center>
<center>
<table align="center">
    <tr>
        <th>n</th>
        <th>$min \{ -Re(\Lambda),\Lambda \in \sigma(A_{1,n}) \}$</th>
    </tr>
    <tr>
        <th>8</th>
        <th>$8.9227x10^{-4}$</th>
    </tr>
    <tr>
        <th>16</th>
        <th>$8.9383x10^{-4}$</th>
    </tr>
    <tr>
        <th>24</th>
        <th>$8.9402x10^{-4}$</th>
    </tr>
    <tr>
        <th>32</th>
        <th>$8.9407x10^{-4}$</th>
    </tr>            
</table>
</center>
<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/fig1.png" alt="" /> Location of the complex eigenvalues of the matrix $A_{1,n}$ with the finite element method</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">error</span>
<span class="n">Nx</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">stabexpsem</span><span class="p">(</span><span class="n">Nx</span><span class="p">);</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Error using error
Not enough input arguments.

Error in tp1d0d1572_49d1_41a8_914f_f09a199a8ec3 (line 114)
error

</code></pre>
</div>

<p>In Figure 2, conversely to Figure 1 where a uniform distance between the eigenvalues and the imaginary axis is preserved, we observe that, as the number of modes increases, an asymptotic behaviour appears in the neighborhood of the imaginary axis at $\pm\infty$. This property is mainly related to systems with polynomial decay, see \cite{BEPS2006}.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/fig2.png" alt="" /> Location of the complex eigenvalues of the matrix $A_{2,n}$ with the finite</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Nx</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">stabpolysem</span><span class="p">(</span><span class="n">Nx</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="uniform-and-polynomial-decay-of-the-energy">Uniform and polynomial decay of the energy</h2>

<p>The discrete energy associated to system (\ref{eq3}) is given by</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq4} \tag{4} E_{i,n}(t)=\frac{1}{2}\sum_{j=1}^n\Big\{ \vert u_j(t)\vert^{2} + \vert v_j(t)\vert^{2}+ \vert \theta_j(t)\vert^{2}\Big\},\;i=1,2. \end{equation}</script>

<p>The discrete energy $E_{1,n}$ associated to system (ref{eq1}) decays exponentially to zero, see Figure 3, in the following sense: $\exists M,\alpha$ positive constants such that</p>

<script type="math/tex; mode=display">E_{1,n}(t)\leqslant Me^{-\alpha t}E_{1,n}(0),\;n\in\mathbb{N},\;t>0.</script>

<p>However, the introduction of the weak coupling term in system (ref{eq1}) has changed the dynamic and consequently the behavior of energy (\ref{eq4}). In this case, we say that system (\ref{eq2}) decays polynomially to zero, see Figure 4, in the following sense: $\exists M,\alpha$ positive constants such that</p>

<script type="math/tex; mode=display">E_{2,n}(t)\leqslant \frac{M}{t} \vert A_{2,n} z_{n0} \vert^2  ; n \in \mathbb{N},\;t>0.</script>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/exp.png" alt="" /> Exponential decay of $E_{1,n}(t)$</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/poly.png" alt="" /> Polynomial decay of $E_{2,n}(t)$</p>

<h2 id="effect-of-smoothness-of-the-initial-data-on-the-rate-of-decay-of-energy">Effect of smoothness of the initial data on the rate of decay of energy</h2>

<p>It has been shown theoretically, see [1,2], that the energy associated to system (\ref{eq2}) is very sensitive to the smoothness of its initial data. This fact, has been also observed numerically, see Figure 6. we use</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Nx</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">FinalTime</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="nb">mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Gamma</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">k</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre>
</div>

<p>and we consider the following initial data</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">u0</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">pi</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
<span class="n">v0</span><span class="o">=</span><span class="nb">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">/</span><span class="nb">pi</span><span class="p">)</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="n">teta0</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</code></pre>
</div>

<p>Through Figure 6, we notice that for $j = 1$, the approximate energy $E_{2,n}(t)$ decays to zero as the time $t$ increases. Moreover, we observe that the decay rate depends strongly on $j$. That is, when $j$ increases, initial data are very oscillating. We say in this case that the rate of decay of the discrete energy $E_{2,n}(t)$ is very sensitive to the choice of the initial data. However, the behavior of the energy assosiated to system (\ref{eq1}) remains indifferent to the smoothness of initial data when $n\to\infty$, see Figure 5.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/fig5.png" alt="" />  Exponential decay of $E_{1,n}(t)$</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0009/fig6.png" alt="" />  Polynomial decay of $E_{2,n}(t)$</p>

<h2 id="references">References</h2>

<p>[1] A. B' atkai, K.J. Engel, J. Pr"uss and R. Schnaubelt, Polynomial stability of operator semigroups, Math. Nachr. 279, pp.</p>

<p>[2] A. Borichev and Y. Tomilov, Optimal polynomial decay of functions and operator semigroups, Math. Ann., 347(2), pp.455-478, 2010.</p>

<p>[3] S. W. Hansen, Exponential energy decay in a linear thermoelastic rod. J. Math. Anal. Appli.,167, pp. 429-442, 1992.</p>

<p>[4] F.A. Khodja, A. Benabdallah, and D. Teniou, Stability of coupled systems, Abstr. Appl. Anal. Volume 1, Number 3, 327-340, 1996.</p>

<p>[5] F. A. Khodja, A. Benabdallah and D. Teniou, Dynamical stabilizers and coupled systems}, ESAIM Proceeding,2, pp. 253-262, 1997.</p>

<p>[6] F. A. Khodja, A. Bader and A. Benabdallah, Dynamic stabilization of systems via decoupling techniques, ESAIM: COCV,4,</p>

<p>[7] Z. Liu and S. Zheng, Exponential stability of semigroup associated with thermoelastic system, Quart. Appl. Math, 51, pp.535-545, 1993.</p>

<p>[8] Z. Y. Liu and S. Zheng, Uniform exponential stability and approximation in control of a thermoelastic system, SIAM J. Control Optim. 32, pp. 1226-1246, 1994.</p>

<p>[9] Z. Liu and B. Rao, Characterization of polynomial decay rate for the solution of linear evolution equation. Zeitschrift  angewandte Mathematik und Physik ZAMP,56, pp. 630-644, 2005.</p>

<p>[10] L. Maniar and S. Nafiri, Approximation and uniform polynomial stability of C_0-semigroups,ESAIM: COCV 22, pp. 208-235, 2016.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h2 id="asda"&gt;asda&lt;/h2&gt;


&lt;p&gt;In this tutorial, we present some aspects of the obstacle problem in the stationary (elliptic) and the evolutionary (parabolic) setting by means of numerical simulations, performed in &lt;code class="highlighter-rouge"&gt;FEniCS&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Matlab&lt;/code&gt;.&lt;/p&gt;
</code></pre>
</div>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/obstaclepb_1d.png" width="1000px" />
</center>
<center> <strong>Figure 1.</strong> The solution (blue) of the one-dimensional elliptic obstacle problem is superharmonic (concave down) and matches derivatives with the obstacle (black). 
</center>

<h2 id="1-mathematical-formulation"><em>1. Mathematical formulation</em></h2>

<h3 id="11-elliptic-problem">1.1. Elliptic problem</h3>
<p>Let $\Omega \subset \mathbb{R}^d$ be open, regular and bounded, let $\psi \in H^2(\Omega)$ (the <em>obstacle</em>) and $g \in H^1(\Omega)$ (boundary data) with $\psi \leq g$ on $\partial \Omega$ be given. We consider the functional</p>

<script type="math/tex; mode=display">\mathcal{F}_{\text{OB}}(u):= \frac12 \int_\Omega |\nabla u|^2 dx - \int_\Omega fu \, dx</script>

<p>where $f \in L^2(\Omega)$ is given, and the closed convex set</p>

<script type="math/tex; mode=display">\mathcal{K}^g_{\text{OB}} := \{ u \in H^1(\Omega): u - g \in H^1_0(\Omega), \, u \geq \psi \, \text{ in } \, \Omega  \}.</script>

<p>The <strong>classical obstacle problem</strong> can be written as</p>

<script type="math/tex; mode=display">\min_{u \in \mathcal{K}^g_{\text{OB}}} \mathcal{F}_{\text{OB}}(u)</script>

<p>and admits a unique minimizer $\phi \in \mathcal{K}^g_{\text{OB}}$, which is also a solution of the <strong>variational inequality</strong></p>

<script type="math/tex; mode=display">\nabla \mathcal{F}_{\text{OB}}(\phi) \cdot (v-\phi) \geq 0 \quad \text{ for every } \quad v \in \mathcal{K}^g_{\text{OB}}.</script>

<p>The terminology “<em>obstacle problem</em>” comes from the physical origin of the model $-$ the solution $\phi$ represents the equilibrium position of an elastic membrane, which is constrained to lie above an obstacle (given by the graph of the function $\psi$).</p>

<p><strong>Notation:</strong>  The notation</p>

<script type="math/tex; mode=display">\nabla \mathcal{F}_{\text{OB}}(\phi)\cdot\zeta</script>

<p>designates the Gateaux derivative ($L^2$-gradient) of the functional ${F}_{\text{OB}}$ at the point $\phi$ in the direction $\zeta$; in occurence,</p>

<script type="math/tex; mode=display">\nabla \mathcal{F}_{\text{OB}}(\phi)\cdot\zeta = (\nabla \phi, \nabla \zeta)_{L^2(\Omega)}-(f, \zeta)_{L^2(\Omega)}-(g,\zeta)_{L^2(\partial \Omega)}</script>

<p>Most of the regularity theory for the obstacle problem has been developed for the model case $\Delta \psi=-1$. We refer to [3,4] for a detailed presentation. 
For simplicity of the presentation, let us thus assume for a moment that $f \equiv -1$ and $\psi \equiv 0$. Choosing appropriate test functions bring us from the variational inequality for $\phi$ to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
\Delta \phi = 1 	&\text{ in }  \{\phi>0\}  \\
\phi \geq 0 &\text{ in } \Omega \\
\phi = |\nabla \phi| = 0 &\text{ on } \partial \{\phi>0\} \\
\phi = g &\text{ on } \partial \Omega.
\end{cases} %]]></script>

<p>The set ${ \phi=0 }$ is called <em>contact set</em>, while $\partial { \phi&gt;0 }$ is the <em>free boundary</em>.</p>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/esol_matlab_1.png" width="600px" />
<center> <strong>Figure 2.</strong> The solution $\phi$ to the elliptic obstacle problem just above. The <strong>obstacle</strong> is equal to 0 (<strong>gray plane</strong>), and the free boundary (boundary of the contact set between the membrane and the obstacle) is displayed in red, projected just below. </center>
</center>

<p><strong>Remark:</strong> At this point, we may see why solving the elliptic obstacle problem is different to just solving the Poisson equation for $\phi$ in a subdomain of $\Omega$ and setting $\phi=\psi$ elsewhere. Indeed, solving the latter problem does not guarantee that we would have</p>

<script type="math/tex; mode=display">|\nabla (\phi-\psi)| =0</script>

<p>along the boundary.</p>

<h3 id="12-parabolic-problem">1.2. Parabolic problem</h3>

<p>The parabolic counterpart onsists in finding $u \in H^1(]0, +\infty[; L^2(\Omega))\cap L^2(]0,+\infty[; H^2(\Omega) \cap \mathcal{K}^g_{\text{OB}})$ satisfying</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
	\big(\, u'(t), v-u(t) \big)_{L^2(\Omega)} + 
	\nabla \mathcal{F}_{\text{OB}}(u(t))\cdot (v-u(t)) \geq 0 &\text{ for every } v \in \mathcal{K}^g_{\text{OB}}, \, t>0 \\
	u(0, x) = u_0 \in \mathcal{K}^g_{\text{OB}}.
\end{cases} %]]></script>

<p>The name “<em>parabolic obstacle problem</em>” for the above system <strong>may be misleading</strong>. 
While the mathematical formulation is similar, the physical interpretation of the elliptic and parabolic problem is different. In the parabolic setting, seeing $\psi$ as a physical obstacle in space is not correct. Rather, one should interpret $\psi$ as a <em>barrier</em> for the temperature $u$. More accurately, we are dealing with a parabolic variational inequality with an obstacle-type constraint.</p>

<p>The function $\psi$ may be time-dependent, but for simplicity we omit this case.</p>

<center>
<table>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/parabolic_free_dome.gif" width="600px" /></th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/steady_dome.png" width="600px" /></th>
</tr>
</table>
</center>
<center> <strong>Figure 3.</strong> Here $\psi(x)=3*\sqrt{(1-x^2)}$ in $(-1,1)$ (black) is a barrier for the evolving solution (blue). The initial data coincides with $\psi$ on (-1.5, 1.5). We observe that the contact set $\{ u = \psi \}$ changes (gets smaller) as time grows. There is also matching of normal derivatives on the contact points (i.e. the free boundary). 
Finally, the solution of the parabolic problem (left, blue) converges to that of the elliptic problem (right, red) for large time, as seen below.   </center>

<center>
<table>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/terrain_rotate.gif" width="600px" /></th>
</tr>
</table>


</center>
<center><strong>Figure 4.</strong> The solution to the parabolic problem with Dirichlet boundary condition =1. The <strong>obstacle</strong> is given by the <strong>"three towers"</strong>. The free boundary (boundary of the contact set with the obstacle) is projected on a plane below in red. It is seen that the source term $-1$ acts as a gravity force pushing the membrane towards the obstacle. We moreover observe a convergence to the equilibrium position (see also the section below). </center>

<p>For $\psi \equiv 0$ and $f\equiv-1$ (or more generally $f + \Delta \psi = -1$), a manifestation of the parabolic variational inequality above is as a “weak form” of the one-phase Stefan problem (see [3,4]). In this setting, we may pass from the variational inequality to the equivalent problem with <strong>two boundary conditions</strong> at the free boundary</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
	u_t - \Delta u = -1 &\text{ in } \quad \{ u(t)>0\} \times ]0, +\infty[ \\
	u \geq 0 &\text{ in } \quad \Omega \times ]0, +\infty[ \\
	u = |\nabla u| = 0 &\text{ on } \quad \partial \{ u(t)>0 \} \times ]0, +\infty[\\
	u = g &\text{ on } \quad  \partial \Omega \times ]0, +\infty[ \\
	u = u_0 &\text{ on } \quad \Omega \times \{ t = 0\}
\end{cases} %]]></script>

<p>This is an overdetermined problem, which means that the <em>free boundary/the contact set ${u=0}$ has to change with time</em> to ensure that both BC hold for every time. The evolution of the contact set may be observed in the numerics of Figures 3,4,5.</p>

<p><strong>Remark:</strong> $\quad$
As for the elliptic problem, solving the above parabolic problem is different to just solving the heat equation for $u$ in a subdomain of $\Omega$ and setting $u$ elsewhere, with a Dirichlet boundary condition. Indeed, solving the latter problem does not guarantee that we would have $|\nabla u|= 0$ along the boundary.</p>

<p><strong>Remark:</strong> $\quad$
While in Figure 3 the contact set is shrinking does not disappear, it may happen that the contact set vanishes (depending on the magnitude of the boundary data $g$, the support of the initial data $u_0$, and if present, the source term $f$).</p>

<h3 id="13-relationship-between-both-problems">1.3. Relationship between both problems</h3>

<p>In the recent paper [5], it is shown that the solution $u(t)$ to the parabolic variational inequality converges to the solution $\phi$ of the elliptic probelem in $H^1(\Omega)$ norm as $t\rightarrow \infty$ with exponential rate. This is done by means of new techniques including a so-called constrained Lojaseiwicz inequality.</p>

<p>We may observe this convergence numerically in Figures 4 and 5. In both cases, we work in the ball $B_2$, with boundary data $g\equiv 0.8$, barrier $\psi\equiv 0$ and 
initial datum supported outside $B_{1.5}$.</p>

<p><strong>The one-dimensional case:</strong></p>

<table>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/parabolic_free_0.gif" width="600px" /></th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/steady_0.png" width="600px" /></th>
</tr>
</table>

<center><strong>Figure 5.</strong> The solution of the parabolic problem (left, blue) converges to that of the elliptic problem (right, red) as time increases. We again see that the contact set $\{ u = 0\}$ changes with time. </center>

<p><strong>The two-dimensional case:</strong></p>
<center>
<table>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/state.gif" width="600px" /></th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/interface.gif" width="600px" /></th>
</tr>
</table>


</center>
<center><strong>Figure 6.</strong> We see that as time increases, the contact region $\{ u = 0\}$ (white patch) gets smaller. In terms of the Stefan problem, the white patch represents the ice temperature. Ice is melting as time increases, but does not fully melt, because the support of the initial data is too small and the temperature on the boundary is not high enough.  </center>

<table>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/finger_rotate.gif" width="600px" /></th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/esol_matlab_1.png" width="600px" /></th>
</tr>
</table>

<center><strong>Figure 7.</strong> In this figure, the obstacle is set to zero, and we consider Dirichlet boundary conditions $=0.8$ on the fixed boundary. We see that even when considering initial data which are not an equilibrum membrane position (but do satisfy the obstacle condition), as time increases, the solution of the parabolic problem (<strong>left</strong>) converges to that of the elliptic problem (<strong>right</strong>)  </center>

<h2 id="2-numerical-implementation">2. <em>Numerical implementation</em></h2>

<h3 id="21-possible-strategies">2.1. Possible strategies</h3>

<p>A common approach for proving the well-posedness and $W^{2,p}$ regularity for variational inequalities is a technique called penalization, which consists of approximating by a sequence of semilinear equations [8]. For any $\epsilon&gt;0$, we will consider</p>

<script type="math/tex; mode=display">u' - \Delta u + \frac{1}{\epsilon} (u-\psi)_{-} = f \quad \text{ in } \quad \Omega \times ]0,\infty[</script>

<p>to approximate the parabolic problem, and remove $u’$ and time dependence for the elliptic one. As $\epsilon\rightarrow0$, the solution $u_\epsilon$ of the above equation converges to the variational inequality.  Here</p>

<script type="math/tex; mode=display">\beta_\epsilon(u) = \frac{1}{\epsilon}(u)_- = \frac{1}{\epsilon}\min \{u, 0 \}</script>

<p>may be replaced by another penalty function, for instance $\beta_\epsilon(u) = -\exp(-u/\epsilon)$.</p>

<p>The approximated problem is relatively simple to implement numerically. We may use finite elements (say $P1$ elements) to discretize in space, and time-stepping (Euler implicit for instance) to discretize in time.</p>

<p>There are other ways to solve the variational inequality after discretizing in space and time (using one’s favorite metood). One which is popular in the literature for the elliptic problem is the <em>primal dual active set</em> method, which we will present in a future post.</p>

<h3 id="22-code">2.2. Code</h3>

<h4 id="i-elliptic-problem">i). Elliptic problem.</h4>

<p>Let us start by solving the two-dimensional elliptic problem from Figure 4.</p>

<p>The <code class="highlighter-rouge">fenics</code> module [1] contains all of the necessary finite element tools for the space discretization of PDEs.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">obstacles</span> <span class="kn">import</span> <span class="n">dome</span>
<span class="kn">from</span> <span class="nn">mshr</span> <span class="kn">import</span> <span class="n">mesh</span>
</code></pre>
</div>
<p>It is advantageous to regularize the “kink” appearing in penalty function (the negative part of a function) in view of using a Newton method for solving the nonlinear problem</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">smoothmax</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span> 
	<span class="k">return</span> <span class="n">conditional</span><span class="p">(</span><span class="n">gt</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span> <span class="n">r</span><span class="o">-</span><span class="n">eps</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">conditional</span><span class="p">(</span><span class="n">lt</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span><span class="p">)))</span>
</code></pre>
</div>
<p>We mesh the domain $B_2$.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">mesh</span> <span class="o">=</span> <span class="n">generate_mesh</span><span class="p">(</span><span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">25</span><span class="p">)</span>
</code></pre>
</div>

<p>$P1$ elements are used for the FEM spaces (but one may easily choose higher order in the definition of V).</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">"CG"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>		
<span class="n">eps</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">))</span>
</code></pre>
</div>

<p>Using the symbolic expressions of <code class="highlighter-rouge">FEniCS</code>, we define the variational formulation of the penalized PDE, which we write in the form $F(w)=0$:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="s">"on_boundary"</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">eps</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">smoothmax</span><span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="o">+</span><span class="n">psi</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</code></pre>
</div>

<p>We solve the nonliner problem with the command <code class="highlighter-rouge">solve</code>, which makes use of a Newton method to solve the nonlinear equation $F(w)=0$.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span>
</code></pre>
</div>

<p>We visualise in <code class="highlighter-rouge">ParaView</code> by storing the solution in .vtk format using:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>vtkel = File("output/el.pvd")
vtkel &lt;&lt; w
</code></pre>
</div>

<h4 id="ii-parabolic-problem">ii). Parabolic problem.</h4>

<p>We set $T=2$, use $100$ subdivisions and set</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">dt</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="mi">100</span>
</code></pre>
</div>

<p>This part only differs by the presence of a time-loop. We define the initial datum in a separate class:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">indata</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mf">1.95</span><span class="p">:</span>
			<span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">elif</span> <span class="mf">1.95</span> <span class="o">&lt;=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mf">1.95</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mf">1.95</span><span class="p">)</span><span class="o">*</span><span class="mf">0.8</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.8</span>
</code></pre>
</div>

<p>Repeating as in the elliptic case up to defining the variational form, we now set the inital datum (interpolating the expression onto the FEM space) and time:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">un</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">indata</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre>
</div>
<p>We set up the time loop:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>vtksol = File("output/popsol.pvd")
for n in range(num_steps):
    t+=dt
    solve(F==0, u, bcs=bc)
    vtksol &lt;&lt; (u, t)
    un.assign(u) 
</code></pre>
</div>

<h2 id="optimal-control"><em>Optimal Control</em></h2>

<p>We will now briefly present the implementation of an optimal control strategy for the elliptic and parabolic problems. We will make use of the penalized problems where $\epsilon&gt;0$ is small (of the order $10^{-8}$). This strategy has been succesfully applied in [8].</p>

<h3 id="31-elliptic-problem">3.1. Elliptic problem</h3>

<p>Given a target $\phi_d$ and a regularization parameter $\delta&gt;0$ (we usually use $\delta = 10^{-2}$), we seek to minimize</p>

<script type="math/tex; mode=display">J(u) = \frac12 \|\phi-\phi_d \|_{L^2(\Omega)}^2 + \frac{\delta}{2} \| u \|^2_{L^2(\Omega)}</script>

<p>subject to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
	-\Delta \phi + \frac{1}{\epsilon} (\phi-\psi)_- = f+u &\text{ in } \Omega \\
	\phi = g &\text{ on } \partial \Omega.
\end{cases} %]]></script>

<p>For simplicity of the presentation, we will consider</p>

<script type="math/tex; mode=display">f\equiv-1</script>

<script type="math/tex; mode=display">g\equiv0\</script>

<script type="math/tex; mode=display">\psi(x) = \sqrt{(1-|x|^2)_+}</script>

<p>on the domain $\Omega = [-2,2]^2$. The target is the function $\phi_d(x) = \frac12(\cos(x_1)+\cos(x_2))$.</p>

<p>The uncontrolled solution of the elliptic obstacle problem in this case is:</p>

<table>
<tr>
	<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/elliptic_zero_dome.png" width="600px" />
	</th>
	<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/obstacle.png" width="600px" />
	</th>
</tr>
</table>

<center><strong>Figure 8.</strong> For comparison with the controlled problem, we show also the solution to the free elliptic problem with the "dome" like obstacle given on the right. </center>

<p>The <code class="highlighter-rouge">FEniCS</code> optimization code will have the effect of obtaining the following results.</p>

<table>
<tr>
	<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/opt_state.png" width="600px" />
	</th>
	<th>
	<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/obstacle.png" width="600px" />
	</th>
</tr>
<tr>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/target.png" width="600px" />
</th>
<th>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/opt_control.png" width="600px" />
</th>
</tr>
</table>

<center>


</center>
<center><strong>Figure 9.</strong> The optimal state (<strong>top left</strong>) can be seen to be above the obstacle (<strong>top right</strong>), and is very much alike the shape of the target (<strong>bottom left</strong>). Finally, the optimal control is given (<strong>bottom right</strong>). </center>

<p>Let us present the numerical implementation. After importing the <code class="highlighter-rouge">dolfin_adjoint</code> optimization module [2], we make use of the code for simulating the uncontrolled problem. A “tape” of the forward model is built. This tape is used to drive the optimization by repeatedly solving the forward model and the adjoint model for varying control inputs.</p>

<p>Defining the objective functional to be minimized:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">delta</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">)</span>
<span class="n">j</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">w</span><span class="o">-</span><span class="n">wd</span><span class="p">,</span> <span class="n">w</span><span class="o">-</span><span class="n">wd</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">delta</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>	
<span class="n">m</span> <span class="o">=</span> <span class="n">Control</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</code></pre>
</div>

<p>Writing the state $y$ as the output of the solution map corresponding to the input $m$, one sees that the objective functional depends only on the control:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">J</span> <span class="o">=</span> <span class="n">ReducedFunctional</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>									
</code></pre>
</div>

<p>We run the optimization, based on a conjugate-gradient method:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">u_opt</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">"method"</span><span class="o">=</span><span class="s">"CG"</span><span class="p">})</span>
</code></pre>
</div>

<p>The tape is modified such that the initial guess for y (to be used in the Newton solver in the forward problem) is set to y_opt.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">y_opt</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">block_variable</span><span class="o">.</span><span class="n">saved_output</span>
<span class="n">Control</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">y_opt</span><span class="p">)</span>
</code></pre>
</div>

<p>The algorithm converged after 8 iterations, and the value of the functional at the final iteration is $0.0967$.</p>

<h3 id="32-the-parabolic-problem">3.2. The parabolic problem</h3>

<p>Given a final time $T&gt;0$, a target $u_d$ and a regularization parameter $\delta&gt;0$, we seek to minimize</p>

<script type="math/tex; mode=display">J(u) = \frac12 \|u(T)-u_d \|_{L^2(\Omega)}^2 + \frac{\delta}{2} \| v \|_{L^2(\Omega)}</script>

<p>subject to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
	u'-\Delta u + \frac{1}{\epsilon} (u)_- = f+v &\text{ in } \Omega \times (0, T) \\
	u = g &\text{ on } \partial \Omega \times (0, T) \\
	u = u_0 &\text{ in } \Omega \times \{ t = 0 \}
\end{cases} %]]></script>

<p>For simplicity of the presentation, we will consider the same setting as in Figure 3, namely $f\equiv-1\,$,  $g\equiv0.8\,$, on the domain $\Omega = [-2,2]$. The target temperature is $u_d(x) = 0.8$. This would correspond to “melting”, as this target is never equal to zero, thus has no contact set. We would thus expect the action of the control $v$ to lift-up $u$ from $0$ and thus the contact set (and free boundary) to vanish.</p>

<p>We appeal to <code class="highlighter-rouge">DyCon-Toolbox</code> [9] for the numerical implementation of this problem. <code class="highlighter-rouge">DyCon-Toolbox</code> is an efficient and easy to use solver for nonlinear control problems.</p>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/ocpop.gif" width="900px" />
<center><strong>Figure 10.</strong> The optimal state (left, red), starting from an initial datum with a non-empty contact set (left, blue) and the optimal control (red, right). </center>
</center>

<p>The action and magnitude of the control ensures that the solution to the parabolic problem will lift-off from the initial contact set. 
For comparison, we recall that the uncontroled free dynamics have a very different behavior:</p>

<center>
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP03/P0004/parabolic_free_0.gif" width="600px" />
</center>

<center><strong>Figure 11.</strong> The uncontrolled free dynamics of the parabolic obstacle problem in 1 dimension, where the obstacle is zero. </center>

<p>We begin by symbolically defining the time variable:</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">syms</span> <span class="n">t</span>
</code></pre>
</div>

<p>We discretize the interval $[-2, 2]$:</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">70</span><span class="p">;</span>
<span class="n">xi</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="n">xf</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">xline</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">xf</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">xline</span> <span class="o">=</span> <span class="n">xline</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>
<p>We define symbolically (as in <code class="highlighter-rouge">FEniCS</code>) the state vector $Y$ and control vector $U$:</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">Y</span> <span class="o">=</span> <span class="n">SymsVector</span><span class="p">(</span><span class="s">'y'</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">SymsVector</span><span class="p">(</span><span class="s">'u'</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
</code></pre>
</div>
<p>We discretize by finite differences, and define the semilinear penalty term:</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">alpha</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">;</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-2</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">FDLaplacian</span><span class="p">(</span><span class="n">xline</span><span class="p">);</span>

<span class="n">F</span>  <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="n">NonLinearTerm</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">alpha</span><span class="p">);</span>
<span class="n">dF</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="n">DiffNonLinearTerm</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">alpha</span><span class="p">);</span>
</code></pre>
</div>

<p>We may define the parabolic problem to be solved.</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">dx</span> <span class="o">=</span> <span class="n">xline</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">xline</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Y_t</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">Params</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">Y</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">epsilon</span><span class="o">*</span><span class="n">F</span><span class="p">(</span><span class="o">-</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">U</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="mf">0.8</span><span class="p">;</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="mf">0.8</span><span class="p">];</span>
<span class="n">Dyn</span> <span class="o">=</span> <span class="n">pde</span><span class="p">(</span><span class="n">Y_t</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">U</span><span class="p">);</span>
</code></pre>
</div>
<p>We set the mesh, and other relevant parameters such as the final time and initial data. We consider the same data as in the free problem.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">Dyn</span><span class="o">.</span><span class="n">mesh</span>   <span class="o">=</span> <span class="n">xline</span><span class="p">;</span>
<span class="n">Dyn</span><span class="o">.</span><span class="n">Solver</span> <span class="o">=</span> <span class="nd">@ode23</span><span class="p">;</span>
<span class="n">Dyn</span><span class="o">.</span><span class="n">Nt</span>     <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>
<span class="n">Dyn</span><span class="o">.</span><span class="n">FinalTime</span>        <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
<span class="n">Dyn</span><span class="o">.</span><span class="n">InitialCondition</span> <span class="o">=</span> <span class="n">InitialConditionFcn</span><span class="p">(</span><span class="n">xline</span><span class="p">);</span>
</code></pre>
</div>

<p>We now compute the necessary Jacobian matrices.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">Dyn</span><span class="o">.</span><span class="n">Derivatives</span><span class="o">.</span><span class="n">Control</span><span class="o">.</span><span class="n">Num</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">Params</span><span class="p">)</span> <span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="n">Dyn</span><span class="o">.</span><span class="n">Derivatives</span><span class="o">.</span><span class="n">State</span><span class="o">.</span><span class="n">Num</span>   <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">Params</span><span class="p">)</span> <span class="n">A</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">epsilon</span><span class="o">*</span><span class="n">dF</span><span class="p">(</span><span class="o">-</span><span class="n">Y</span><span class="p">);</span>
</code></pre>
</div>

<p>We may solve the free problem over the given time interval. We recall that we have used finite differences to discretize in space (but finite elements can be used as well in more complicated settings), and the underlying solve command solves the system of ODEs by means of some Runge-Kutta scheme.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">tspan</span><span class="p">,</span><span class="n">Ysolution</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">Dyn</span><span class="p">);</span>
<span class="n">figure</span>
<span class="n">surf</span><span class="p">(</span><span class="n">Ysolution</span><span class="p">)</span>
</code></pre>
</div>
<p>Having solved the free dynamics, we are now in a position to solve the optimal control problem:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">YT</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="n">xline</span><span class="o">'</span><span class="p">;</span>
<span class="nb">beta</span> <span class="o">=</span> <span class="n">dx</span><span class="o">^</span><span class="mi">4</span><span class="p">;</span>
<span class="n">Psi</span>  <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="n">YT</span> <span class="o">-</span> <span class="n">Y</span><span class="p">)</span><span class="o">.'*</span><span class="p">(</span><span class="n">YT</span> <span class="o">-</span> <span class="n">Y</span><span class="p">);</span>
<span class="n">L</span>    <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">U</span><span class="p">)</span>  <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="n">YT</span> <span class="o">-</span> <span class="n">Y</span><span class="p">)</span><span class="o">.'*</span><span class="p">(</span><span class="n">YT</span> <span class="o">-</span> <span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="k">...</span>
                 <span class="nb">beta</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="nb">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">U</span><span class="o">.'*</span><span class="n">U</span><span class="p">);</span>
<span class="n">OCP</span> <span class="o">=</span> <span class="n">Pontryagin</span><span class="p">(</span><span class="n">Dyn</span><span class="p">,</span><span class="n">Psi</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
<span class="n">U0</span> <span class="o">=</span> <span class="o">-</span><span class="nb">ones</span><span class="p">(</span><span class="n">Dyn</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span><span class="n">Dyn</span><span class="o">.</span><span class="n">ControlDimension</span><span class="p">);</span>
<span class="n">U0</span> <span class="o">=</span> <span class="n">GradientMethod</span><span class="p">(</span><span class="n">OCP</span><span class="p">,</span><span class="n">U0</span><span class="p">,</span><span class="s1">'Graphs'</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span><span class="s1">'EachIter'</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">'DescentAlgorithm'</span><span class="p">,</span><span class="o">@</span><span class="n">AdaptativeDescent</span><span class="p">)</span>
</code></pre>
</div>

<h2 id="references">References:</h2>

<p>[1] The FEniCS Project Version 1.5
M. S. Alnaes, J. Blechta, J. Hake, A. Johansson, B. Kehlet, A. Logg, C. Richardson, J. Ring, M. E. Rognes and G. N. Wells
Archive of Numerical Software, vol. 3, 2015.</p>

<p>[2] Patrick E. Farrell, David A. Ham, Simon W. Funke and Marie E. Rognes (2013). Automated derivation of the adjoint of high-level transient finite element programs, SIAM Journal on Scientific Computing 35.4, pp. C369-C393. doi:10.1137/120873558. arXiv:1204.5577</p>

<p>[3] Figalli A. (2018), Free boundary regularity in obstacle problems 
Journées EDP 2018, to appear.</p>

<p>[4] Figalli, A. (2018), Regularity of interfaces in phase transitions via obstacle problems 
Proceedings ICM 2018, to appear.</p>

<p>[5] Colombo M. and Spolaor, L. and Velichkov, B. (2018), On the asymptotic behavior of the solutions to parabolic variational inequalities, ArXiV preprint.</p>

<p>[6] Borjan Geshkovski (2018). Obstacle Problems: Theory and Applications. Master Thesis.</p>

<p>[7] Hintermüller M. and Kopacka I., A smooth penalty approach and a nonlinear multigrid algorithm for elliptic MPECs. Computational Optimization and Applications, 50(1):111–145, 2011.</p>

<p>[8] D. Kinderlehrer and G. Stampacchia. An introduction to variational inequalities and their applications. Volume 31 of Classics in Applied Mathematics. SIAM, 2000.</p>

<p>[9] DyCon-Toolbox, https://deustotech.github.io/dycon-toolbox-documentation/.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;Consider a rotor rotating around a fixed axis. Because of wear and damage, the mass distribution is not homogeneous. This leads to dangerous vibrations in the rotation. A prototypical example can be a wind turbine, affected by misalignment of the blades and/or mass imbalance of the hub and blades [2].&lt;/p&gt;
</code></pre>
</div>

<p>In order to compensate the imbalance, two balancing heads are mounted at the endpoints of the axle, as in figure <a href="#1">1</a>. Each balancing head is made of two masses free to rotate.</p>

<p>Our goal is to determine the optimal movement of the balancing masses to minimize the vibrations. Control theoretical techniques are employed. For further details, see [6].
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/spindlegrinder8mod.png" alt="" /></p>
<center id="1"> Figure <a href="#1">1</a>: representation of the rotor and the balancing. The balancing heads are located at the endpoints of the spindle. The four balancing masses (two for each balancing head) are drawn in red. </center>

<p>Consider a rotor-fixed reference frame $(O;(x,y,z))$. Figures <a href="#1">1</a> and <a href="#2">2</a> show a front view of the device and a scheme of the balancing heads. 
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/rotorfront.png" alt="" /></p>
<center id="2">Figure <a href="#2">2</a>: front view of the system made of rotor and balancing device. </center>
<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/angles.png" alt="" /></p>
<center id="3">Figure <a href="#3">3</a>: scheme of one balancing head. The balancing masses $(m_i,P_{i,1})$ and $(m_i,P_{i,2})$ are drawn in red. The bisector of the angle generated by $\overset{\longrightarrow}{OP_{i,1}}$ and $\overset{\longrightarrow}{OP_{i,2}}$ is the dashed line. The *intermediate* angle $\alpha_i$ is represented in <a href="#3">3</a>(A), while the *gap* angle $\gamma_i$ is depicted in <a href="#3">3</a>(B). The angles $\alpha_i$ and $\gamma_i$ give the position of the balancing masses in each balancing head. </center>

<p>We consider two planes</p>

<script type="math/tex; mode=display">\pi_1:= \left\{z=-a\right\} \quad \text{and} \quad \pi_2 :=  \left\{z=b\right\},\quad a,b,\geq 0</script>

<p>orthogonal to the rotation axis $z$. The balancing device (see figures <a href="#1">1</a> and <a href="#2">2</a>) is made of two heads lying in each of these planes.</p>

<p>The heads are fixed to the rotor and rotate with it. In particular, $\alpha_i$ and $\gamma_i$ are defined with respect to the rotor-fixed reference frame $(O;(x,y,z))$.</p>

<p>Each head is made of a pair of balancing masses, which are free to rotate orthogonally to the rotation axis $z$.</p>

<p>Namely, we have</p>
<ul>
  <li>two mass-points $(m_1,P_{1,1})$ and $(m_1,P_{1,2})$ lying on $\pi_1$ at distance $r_1$ from the axis $z$, i.e., in the reference frame $(O;(x,y,z))$</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
P_{1,1;x}=&r_1\cos(\alpha_1-\gamma_1)\\
P_{1,1;y}=&r_1\sin(\alpha_1-\gamma_1)\\
P_{1,1;z}=&-a,\\
\end{cases}
\hspace{0.3 cm}\text{and}\hspace{0.3 cm}
\begin{cases}
P_{1,2;x}=&r_1\cos(\alpha_1+\gamma_1)\\
P_{1,2;y}=&r_1\sin(\alpha_1+\gamma_1)\\
P_{1,2;z}=&-a;\\

\end{cases} %]]></script>

<ul>
  <li>two mass-points $(m_2,P_{2,1})$ and $(m_2,P_{2,2})$ lying on $\pi_2$ at distance $r_2$ from the axis $z$, namely, in the reference frame $(O;(x,y,z))$</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
		P_{2,1;x}=&r_2\cos(\alpha_2-\gamma_2)\\
		P_{2,1;y}=&r_2\sin(\alpha_2-\gamma_2)\\
		P_{2,1;z}=&b,\\
		\end{cases}
		\hspace{0.3 cm}\text{and}\hspace{0.3 cm}
		\begin{cases}
		P_{2,2;x}=&r_2\cos(\alpha_2+\gamma_2)\\
		P_{2,2;y}=&r_2\sin(\alpha_2+\gamma_2)\\
		P_{2,2;z}=&b.\\
		
		\end{cases} %]]></script>

<p>For any $i=1,2$, let $b_i$ be the bisector of the angle generated by $\overset{\longrightarrow}{OP_{i,1}}$ and $\overset{\longrightarrow}{OP_{i,2}}$ (see figure <a href="#3">3</a>). The <em>intermediate</em> angle $\alpha_i$ is the angle between the $x$-axis and the bisector $b_i$, while the <em>gap</em> angle $\gamma_i$ is the angle between $\overset{\longrightarrow}{OP_{i,1}}$ and the bisector $b_i$.</p>

<p>The imbalance is modelled by a resulting force $F$ and a momentum $N$ orthogonal to the rotation axis. In the rotor-fixed reference frame $(O;(x,y,z))$, set $P_1 :=  (0,0,-a)$, $P_2 :=  (0,0,b)$, $F :=  (F_x,F_y,0)$ and $N :=  (N_x,N_y,0)$. By imposing the equilibrium condition on forces and momenta, the force $F$ and the momentum $N$ can be decomposed into a force $F_1$ exerted at $P_1$ contained in plane $\pi_1$ and a force $F_2$ exerted at $P_2$ contained in $\pi_2$.</p>

<p>In each plane, we generate a force to balance the system, by moving the balancing masses:</p>
<ul>
  <li>in the plane $\pi_1$, we compensate $F_1$ by the centrifugal force:</li>
</ul>

<script type="math/tex; mode=display">B_1=m_1r_1\omega^2\left(\cos(\alpha_1-\gamma_1)+\cos(\alpha_1+\gamma_1),\sin(\alpha_1-\gamma_1)+\sin(\alpha_1+\gamma_1)\right);</script>

<ul>
  <li>in the plane $\pi_2$, we compensate $F_2$ by the centrifugal force:</li>
</ul>

<script type="math/tex; mode=display">B_2=m_2r_2\omega^2\left(\cos(\alpha_2-\gamma_2)+\cos(\alpha_2+\gamma_2),\sin(\alpha_2-\gamma_2)+\sin(\alpha_2+\gamma_2)\right);</script>

<p>The overall imbalance of the system is then given by the resulting forces in $\pi_1$ and $\pi_2$,</p>

<script type="math/tex; mode=display">F_{ris,1}=B_1+F_1</script>

<p>and</p>

<script type="math/tex; mode=display">F_{ris,2}=B_2+F_2,</script>

<p>respectively.</p>

<p>The overall imbalance on the system made of rotor and balancing device is measured by the imbalance indicator</p>

<script type="math/tex; mode=display">G=\|B_1+F_1\|^2+\|B_2+F_2\|^2.</script>

<p>Our task is to find a control strategy such that</p>
<ul>
  <li>the balancing masses move from their initial configuration $\Phi_0$ to a final configuration $\overline{\Phi}$, where the imbalance is compensated;</li>
  <li>the imbalance and velocities should be kept small during the correction process.</li>
</ul>

<p>We address the minimization problem</p>

<script type="math/tex; mode=display">\min_{\Phi\in\mathscr{A}} \frac{1}{2}\int_0^{\infty} \left[\|\Phi'\|^2+{\beta}Q(\Phi)\right] dt,\hspace{0.6 cm}(M)</script>

<p>where $Q(\Phi) :=  G(\Phi)-\inf G$ and</p>

<script type="math/tex; mode=display">\mathscr{A} :=  \left\{\Phi\in H^1_{loc}((0,+\infty);\mathbb{T}^4) \hspace{0.3 cm} \big| \hspace{0.3 cm} \Phi(0)=\Phi_0,\hspace{0.3 cm}and\hspace{0.3 cm}L(\Phi,\Phi')\in L^1(0,+\infty)\right\},</script>

<p>with <script type="math/tex">H^1_{loc}((0,+\infty);\mathbb{T}^4) :=  \cap_{T>0}H^1(0,T;\mathbb{T}^4)</script>.</p>

<p>The theoretical analysis of the above problem is in [6]. The existence of the optimum is proved. The stabilization of the optimal trajectories towards steady optima is proved in any condition.</p>

<h1 id="simulation">Simulation</h1>

<p>In order to perform some numerical simulations, we firstly discretize our cost functional and then we run AMPL-IPOpt to minimize the resulting discretized functional.</p>

<p>For the purpose of the numerical simulations, it is convenient to rewrite the cost functional as</p>

<script type="math/tex; mode=display">{K}\left(\psi,\Phi\right)  :=  \int_0^{\infty}\frac12 \|\Phi'\|^2+Q\left(\Phi\right)dt,</script>

<p>subject to the state equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
\Phi'=\psi\hspace{0.6 cm} &t\in (0,+\infty)\\
\Phi(0)=\Phi_0.\\
\end{cases} %]]></script>

<h2 id="discretization">Discretization</h2>
<p>Choose $T$ sufficiently large and $Nt \in \mathbb{N} \setminus {0,1}$. Set</p>

<script type="math/tex; mode=display">\Delta t :=  \frac{T}{Nt-1}.</script>

<p>The discretized state is <script type="math/tex">(\Phi_i)_{i=0, ... ,Nt-1}</script> , whereas the discretized control (velocity) is $(\psi_{i})_{i=0, … ,Nt-2}$. The discretized functional then reads as</p>

<script type="math/tex; mode=display">\begin{equation}\label{functional}
{K_d}\left(\psi,\Phi\right)  :=  \Delta t\sum_{i=0}^{Nt-1}\left[\frac12 \|\psi_i\|^2+Q\left(\Phi_i\right)\right],
\end{equation}</script>

<p>subject to the state equation</p>

<script type="math/tex; mode=display">\frac{\Phi_i-\Phi_{i-1}}{\Delta t}=\psi_{i-1},\hspace{0.3 cm}i=1, ... ,Nt-1,\hspace{0.6 cm}\text{(D)}</script>

<h2 id="execution">Execution</h2>

<p>The discretized minimization problem is</p>

<script type="math/tex; mode=display">\text{minimize}\hspace{0.3 cm}{K_d},\hspace{0.3 cm}\text{subject to (D)}.</script>

<p>We address the above minimization problem by employing the interior-point optimization routine IPOpt (see [3,4]) coupled with AMPL [1], which serves as modelling language and performs the automatic differentiation. The interested reader is referred to [8, Chapter 9] and [7] for a survey on existing numerical methods to solve an optimal control problem.</p>

<p>In figures <a href="#4">4</a>, <a href="#5">5</a>, <a href="#6">6</a> and <a href="#7">7</a>, we plot the computed optimal trajectory for \eqref{functional}, with initial datum $\Phi_0=\left(\alpha_{0,1},\gamma_{0,1};\alpha_{0,2},\gamma_{0,2}\right) :=  \left(2.6,0.6, 2.5,1.5\right)$. We choose $F$, $N$ and $m_i$. The exponential stabilization proved in [6] emerges. 
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/optstabilalpha1.png" alt="" /></p>
<center id="4">Figure <a href="#4">4</a>: intermediate angle $\alpha_1$ versus time. </center>
<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/optstabilgamma1.png" alt="" /></p>
<center id="5">Figure <a href="#5">5</a>: gap angle $\gamma_1$ versus time. </center>
<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/optstabilalpha2.png" alt="" /></p>
<center id="6"> Figure <a href="#6">6</a>: intermediate angle $\alpha_2$ versus time. </center>
<p>In figure <a href="#8">8</a>, we depict the imbalance indicator versus time along the computed trajectories. As expected, it decays to zero exponentially.
<img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/optstabilgamma2.png" alt="" /></p>
<center id="7">Figure <a href="#7">7</a>: gap angle $\gamma_2$ versus time. </center>
<p><img src="https://deustotech.github.io//DyCon-Blog/assets/imgs/WP02/P0004/systemresponse.png" alt="" /></p>
<center id="8"> Figure <a href="#8">8</a>: system response. </center>

<p></p>
<video controls="" width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP02/P0004/rotor.mp4"></video>
<center> Figure <a href="#9">9</a>: We represent the evolution in time of the rotor vibrations.
In the uncontrolled case, the balancing device does not act. In the controlled case, our balancing strategy suppress the vibrations. </center>

<h1 id="references">References:</h1>
<p>[1] Robert Fourer, David M Gay, and Brian W Kernighan. A modeling language for mathematical programming. Management Science, 36(5):519{554, 1990.</p>

<p>[2] Mike Jeffrey, Michael Melsheimer, and Jan Liersch. Method and system for determining an imbalance of a wind turbine rotor, September 11 2012. US Patent 8,261,599.</p>

<p>[3] Andreas Waechter, Carl Laird, F Margot, and Y Kawajir. Introduction to ipopt: A tutorial for downloading, installing, and using ipopt. Revision, 2009.</p>

<p>[4] Andreas Waechter and Lorenz T Biegler. On the implementation of an interior-point lterline-search algorithm for large-scale nonlinear programming. Mathematical programming, 106(1):25{57, 2006.</p>

<p>[6] Matteo Gnuffi, Dario Pighin and Noboru Sakamoto. Rotors imbalance suppression by optimal control. Preprint.</p>

<p>[7] Noboru Sakamoto and Arjan J van der Schaft. Analytical approximation methods for the stabilizing solution of the Hamilton-Jacobi equation. IEEE Transactions on Automatic Control, 53(10):2335{2350, 2008.</p>

<p>[8] Emmanuel Trélat. Contrôle optimal : théorie et applications
Mathématiques Concrètes. Vuibert, Paris, 2005. available
online:
https://www.ljll.math.upmc.fr/trelat/chiers/livreopt2.pdf.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In [1], we discuss several aspects of wave propagation in a computational framework. In particular, we consider the following one-dimensional wave equation&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{main_eq_1d}
\begin{cases}
\partial_t^2u - \partial_x^2u = 0, & (x,t)\in (-1,1)\times (0,T)
\\
u(-1,t)=0=u(1,t), & t\in(0,T)
\\
u(x,0) = u^0(x), \quad \partial_t u(x,0) = u^1(x), & x\in(-1,1),
\end{cases}
\end{equation} %]]></script>

<p>and we discuss the propagation properties of its finite-difference solutions on uniform and non-uniform grids, by establishing comparisons with the usual behavior of the continuos waves.</p>

<p>Our approach is based on the study of the propagation of high-frequency Gaussian beam solutions (that is, solutions originated from highly concentrated and oscillating initial data), both in continuous and
discrete media.</p>

<p>Roughly speaking, the idea at the basis of this techniques is that the energy of Gaussian beam solutions propagates along bi-characteristic rays, which are obtained from the Hamiltonian system associated to the
symbol of the operator under consideration.</p>

<p>At the continuous level of equation \eqref{main_eq_1d}, these mentioned rays are straight lines and travel with a uniform velocity.</p>

<p>On the other hand, the finite difference space semi-discretization of \eqref{main_eq_1d} may introduce different dynamics, with a series of unexpected propagation properties at high frequencies. For instance, one can generate spurious solutions traveling at arbitrarily small velocities which, therefore, show lack of propagation in space.</p>

<p>In addition, the introduction of a non-uniform mesh for the discretization may generate further pathologies such as <em>internal
reflections</em>, meaning that the waves change direction without hitting the boundary.</p>

<p>In order to illustrate these mentioned pathological phenomena, we perform simulations on a uniform space-mesh of $N$ points and mesh-size $h=2/(N+1)$</p>

<script type="math/tex; mode=display">\mathcal G_h :=\Big\{x_j:= − 1 + jh, \; \; j = 0,\ldots,N + 1\Big\}</script>

<p>and on two non-uniform ones produced by applying to $\mathcal G_h$ the transformations</p>

<script type="math/tex; mode=display">g_1(x):=\tan\left(\frac \pi4 x\right) \quad \text{or} \quad g_2(x):=2\sin\left(\frac \pi6 x\right).</script>

<p>Moreover, the initial data are constructed starting from the following Gaussian profile</p>

<script type="math/tex; mode=display">G_\gamma(x):= e^{-\frac \gamma2(x-x_0)^2}e^{i\frac{\xi_0x}{h}}, \quad x_0\in(-1,1),\;\xi_0\in(0,2\pi),\;\gamma>0.</script>

<h2 id="low-frequency-simulations">Low frequency simulations</h2>

<p>We present in <strong>Figure 1</strong> our simulations for low-frequency solutions of \eqref{main_eq_1d}. In particular, we considered initial position and frequency $(x_0,\xi_0)=(0,\pi/4)$ and a time horizon $T=5s$.</p>

<p>In this case, the numerical solutions behave basically like the continuous ones: they start traveling to the left along the straight characteristic line $x+t$ and, after having hit the boundary, they reflect following the Descartes-Snell’s law and continue propagating, this time to the right along the other branch of the characteristic ($x−t$).</p>

<h2><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig1.png" alt="" /></h2>
<p><strong>Figure 1</strong>. Numerical solutions of \eqref{main_eq_1d} with $(x_0,\xi_0)=(0,\pi/4)$ on uniform and non-uniform meshes.</p>

<h2 id="high-frequency-simulations">High frequency simulations</h2>

<p>When increasing the frequency, the situation changes and we encounter several interesting phenomena and pathologies:</p>

<p>• The so-called <em>umklapp</em> or <em>U-process</em>, also known as <em>internal reflection</em>, consisting in the reflection of waves without touching only one or both the endpoints of the space interval. This phenomenon is typical for the semi-discretization of high-frequecncy solutions of \eqref{main_eq_1d} on non-uniform meshes, which may produce waves oscillating in the interior of the computational domain and reflecting without touching the boundary (see <strong>Figure 2</strong> - middle) or touching the boundary only at one of the endpoints (see <strong>Figure 2</strong> - right).</p>

<h2 id="-1"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig2.png" alt="" /></h2>
<p><strong>Figure 2</strong>. Numerical solutions of \eqref{main_eq_1d} with $(x_0,\xi_0)=(1/2,\pi)$ on uniform and non-uniform meshes.</p>

<p>• Non-propagating waves, corresponding to equilibrium (fixed) points on the phase diagram (see <strong>Figure 3</strong>).</p>

<h2 id="-2"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig2.png" alt="" /></h2>
<p><strong>Figure 3</strong>. Numerical solutions of \eqref{main_eq_1d} with $(x_0,\xi_0)=(0,\pi)$ on uniform and non-uniform meshes.</p>

<p>These phenomena are related with the particular nature of the discrete group velocity which, in the finite difference setting, is given by</p>

<script type="math/tex; mode=display">\omega(\xi) = \cos\left(\frac \xi2\right)</script>

<p>and vanishes for $\xi = (2k+1)\pi$, $k\in\mathbb{Z}$. Moreover, they can be understood by looking at the phase portrait of the hamiltonian system associated to the finite difference semi-discretization of \eqref{main_eq_1d} (see <strong>Figure 4</strong>).</p>

<h2 id="-3"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/phase_portrait.png" alt="" /></h2>
<p><strong>Figure 4</strong>. Phase portrait of the Hamiltonian system for the numerical wave equation corresponding to the and the grid transformation $g_1$ (left) and $g_2$ (right).</p>

<p>In particular, the solutions displayed in <strong>Figure 2</strong> correspond to
trajectories which remain always in the red area of these phase portraits, while <strong>Figure 3</strong> shows solutions starting from the equilibrium point $(0,\pi)$ (the green one in <strong>Figure 4</strong>)</p>

<p>Notice that, for the grid transformation $g_1$, this equilibrium point is a center (stable) while it is a saddle (unstable) for the grid transformation $g_2$. For this reason, in the first case the non-propagating wave remains concentrated along the vertical ray, while in the second case the wave presents more very dispersive features.</p>

<h2 id="two-dimensional-simulations">Two-dimensional simulations</h2>

<p>Analogous phenomena can be detected also in the case of the finite-difference semi-discretization of the two-dimensional wave equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{main_eq_2d}
\begin{cases}
\partial_t^2u - \Delta u = 0, & (x,y,t)\in (-1,1)^2\times (0,T)
\\
u(-1,y,t)=0=u(1,y,t), & (y,t)\in(-1,1)\times(0,T)
\\
u(x,-1,t)=0=u(x,1,t), & (x,t)\in(-1,1)\times(0,T)
\\
u(x,y,0) = u^0(x,y), \quad \partial_t u(x,y,0) = u^1(x,y), & (x,y)\in(-1,1)^2.
\end{cases}
\end{equation} %]]></script>

<p>Also in this case, we perform simulations on  a uniform mesh of $N$ points both in the $x$ and $y$ direction and mesh-sizes $h_x=2/(N+1)=h_y$</p>

<script type="math/tex; mode=display">\mathcal G_h :=\Big\{(x_j,y_k):= (- 1 + jh_x,-1+kh_y) \; \; j,k = 0,\ldots,N + 1\Big\}</script>

<p>and on two non-uniform ones produced by applying to $\mathcal G_h$ the transformations $g_1$ and $g_2$ above introduced.</p>

<p>Moreover, the initial data are constructed once again starting from a Gaussian profile:</p>

<script type="math/tex; mode=display">G_\gamma(x,y):= e^{-\frac \gamma2\big[(x-x_0)^2+(y-y_0)^2\big]}e^{i\big(\frac{\xi_0x}{h_x}+\frac{\eta_0y}{h_y}\big)}, \quad (x_0,y_0)\in(-1,1)^2,\;(\xi_0,\eta_0)\in(0,2\pi)^2,\;\gamma>0.</script>

<p>Then, it can be observed in <strong>Video 1</strong> that, as for the one-dimensional case, at low frequencies the solution remains concentrated and propagates along straight characteristics which reach the boundary, where there is reflection according to the Descartes-Snell’s law. This independently on whether we use a uniform or a non-uniform mesh.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig1_1.mp4" alt="" /></p>

<video controls="" width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig1_1.mp4">
</video>

<hr />

<p><strong>Video 1</strong>. Numerical solutions of \eqref{main_eq_2d} with $(x_0,y_0,\xi_0,\eta_0)=(0,0,\pi/4,\pi/4)$ on uniform and non-uniform meshes.</p>

<p>Nevertheless, increasing the frequencies similar phenomena as in the one-dimensional case show up. For instance, on the non-uniform mesh corresponding to the transformation $g_1$, we observe the so-called
<em>rodeo effect</em>, according to which, waves that should propagate along straight lines are trapped along closed circles (<strong>Video 2</strong> - middle).</p>

<video controls="" width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig2_2.mp4">
</video>
<hr />

<p><strong>Video 2</strong>. Numerical solutions of \eqref{main_eq_2d} with $(x_0,y_0,\xi_0,\eta_0)=(0,\tan(\arccos(\sqrt[4]{1/2},\pi/2,\pi)$ on uniform and non-uniform meshes.</p>

<p>Finally, waves starting from the point $(x_0,y_0,\xi_0,\eta_0)=(0,0,\pi,\pi)$, which is an equilibrium for the phase Hamiltonian system, cannot move, and remain trapped around the point $(0,0)$ in the physical plane for any time (see <strong>Video 3</strong>).</p>

<video controls="" width="100%" src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0008/fig3_3.mp4">
</video>
<hr />

<p><strong>Video 3</strong>. Numerical solutions of \eqref{main_eq_2d} with $(x_0,y_0,\xi_0,\eta_0)=(0,0,\pi,\pi)$ on uniform and non-uniform meshes.</p>

<h2 id="conclusions">Conclusions</h2>

<p>Summarizing, our analysis shows that the finite-difference semi-discretization of one and two-dimensional waves may modify the dynamics of the continuous model. In particular, as a result of the accumulation of the local effects introduced by the heterogeneity of the employed grid, numerical high-frequency solutions can bend in a singular and unexpected manner. Moreover, this phenomenon has to be added to the well known numerical dispersion effect, producing the high-frequency discrete group velocity to vanish, even in uniform grids.
Our results constitute a warning both for adaptivity and for the treating of control and inverse problems. In broad terms, the goal of adaptivity is to refine a mesh on the support of the solution, keeping it coarse where the solution has little oscillations and energy. Our analysis shows that, in this context, adaptivity has to be performed with some attention. Indeed, if one is not careful enough when refining the mesh, they can be produced spurious effects due to the fact that waves feel the fictitious numerical boundaries that are generated when the grid passes from fine to coarse. Finally, our results are also a signal that the dangers of uniform meshes in the study of numerical control and inverse problems (already observed in [2]) may be enhanced when the mesh is non-uniform. In more details, the heterogeneity of the grid may introduce added trapping effects, which need to be avoided in
order to prove convergence in the context of controllability, stabilization or inversion algorithms.</p>

<h2 id="references">References</h2>

<p>[1] U. Biccari, A. Marica and E. Zuazua, <em>Propagation of one and two-dimensional discrete waves under finite difference approximation</em>. Submitted</p>

<p>[2] E. Zuazua, <em>Propagation, observation, control and numerical approximation of waves</em>. SIAM Rev. 47, 2 (2005), 197-243.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h2 id="model-problem"&gt;Model Problem&lt;/h2&gt;
</code></pre>
</div>

<p>We consider the numerical approximation of the inverse problem for the linear advection-diffusion equation,</p>

<script type="math/tex; mode=display">\begin{equation}\label{modeleq} \begin{cases} \partial_t u - d \Delta u + v \nabla \cdot u = 0, \  \  \textbf{x}  \in \Omega, t \in [0,T],\\ u(\textbf{x},t) = 0,  \  \  \textbf{x}  \in \partial \Omega, t \in [0,T],\\ u(\textbf{x},0) = u_0(\textbf{x}), \  \  \textbf{x}  \in \Omega,\\ \end{cases} \end{equation}</script>

<p>with $d$ being the diffusivity of the material and $v$ the direction of the advection.</p>

<p>Given a final time $T&gt;0$ and a target function $u^\ast$ the aim is to identify the initial condition $u_0$ such that the solution, at time $t=T$, reaches the target $u^*$ or gets as close as possible to it. We assume that the initial condition $u_0$ is characterized as a combined set of sparse sources. This means that $u_0$ is a linear combination of unitary deltas with certain and possibly different weights, i.e:</p>

<script type="math/tex; mode=display">\begin{align} u_0 = \sum_{i=1}^{l} \alpha_i \delta(x_i). \end{align}</script>

<p>We formulate the inverse problem using optimal control techniques. In particular, we consider the minimization of the following functional:</p>

<script type="math/tex; mode=display">\begin{align} J(u_0) := J(u(\cdot,0)) = \frac{1}{2} \int_{\Omega} (u(\cdot, T) - u^*)^2 d \Omega + \tau \int_{\Omega} \vert u(\cdot,0) \vert d \Omega. \end{align}</script>

<h2 id="space-and-time-discretization">Space and time discretization</h2>

<p>Letting $\textbf{u} : [0, T] \rightarrow \mathbb{R}^s$ where $s$ is the number of grid points on $\Omega$, we can write a general finite element (FE) discretization of the diffusion–advection equation in \eqref{modeleq} in a compact form as:</p>

<script type="math/tex; mode=display">\begin{align} \textbf{M} \dot{\textbf{u}}(t) + d \textbf{A} \textbf{u}(t) + v \textbf{V} \textbf{u}(t) = 0. \end{align}</script>

<p>In order to get a time discretized version of the previous equation, we apply implicit Euler method with stepsize $\Delta t := T/N$ where $N$ is the total number of time steps. The numerical approximations to the solution are given by the vectors $\textbf{u}^n \approx \textbf{u}(t_n) \in \mathbb{R}^s$ with respect to the index $n=i\Delta t$ for $i=1,2,..,N$. Therefore, the fully discrete version of model equation is as follows,</p>

<script type="math/tex; mode=display">\begin{align} (\textbf{M} + d \Delta t \textbf{A} + v \Delta t \textbf{V}) \textbf{u}^{n+1} = \textbf{M} \textbf{u}^n. \end{align}</script>

<h2 id="adjoint-algorithm-for-sparse-source-identification">Adjoint Algorithm for sparse source identification</h2>

<p>The algorithm to be presented in this work for the sparse source identification of the linear diffusion-advection equation based on the adjoint methodology consists of two steps. Firstly, we use the adjoint methodology to identify the locations of the sources. Secondly, a least squares fitting is applied to find the corresponding intensities of the sources.</p>

<p>We have considered here a two-dimensional example with several sources to be identified in a multi-model environment. This means that the left half ($\Omega_1 = [0,1] \times [0,1]$) and the right half ($\Omega_2 = [1,2] \times [0,1]$) of the domain are modelled with different equations. In particular, the heat equation is used on $\Omega_1$ and the diffusion–advection equation is used on $\Omega_2$.</p>

<p>The initialization parameters look as follows:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span> <span class="c1">%% space discretization points in y-direction</span>
<span class="n">dx</span><span class="o">=</span><span class="mi">1</span><span class="p">/(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% mesh size</span>
<span class="n">t0</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">%% initial time</span>
<span class="n">tf</span><span class="o">=</span><span class="mf">0.1</span><span class="p">;</span> <span class="c1">%% final time</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="c1">%% time discretization points</span>
<span class="n">dt</span><span class="o">=</span><span class="p">(</span><span class="n">tf</span><span class="o">-</span><span class="n">t0</span><span class="p">)/</span><span class="n">n</span><span class="p">;</span> <span class="c1">%% stepsize</span>
<span class="n">TOL</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">;</span> <span class="c1">%% stopping tolerance</span>

<span class="n">d1</span><span class="o">=</span><span class="mf">0.05</span><span class="p">;</span> <span class="c1">%% diffusivity of the material on the left sudomain</span>
<span class="n">d2</span><span class="o">=</span><span class="mf">0.05</span><span class="p">;</span> <span class="c1">%% diffusivity of the material on the left sudomain</span>

<span class="c1">%% advection components</span>
<span class="n">vx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">vy</span><span class="o">=-</span><span class="mi">3</span><span class="p">;</span>

<span class="n">tau</span><span class="o">=</span><span class="n">dx</span><span class="o">^</span><span class="mi">4</span><span class="p">;</span> <span class="c1">%% regularization parameter</span>
<span class="n">epsilon</span><span class="o">=</span><span class="mf">0.1</span><span class="p">;</span> <span class="c1">%% stepsize of the gradient descent method</span>
</code></pre>
</div>

<p>We now compute the FE discretization matrices $M$, $A$ and $V$ that are respectively the mass matrix, the stiffness matrix and the advection matrix. For the FE discretization we assume equidistant structured meshes. In particular we use triangular elements and the classical pyramidal test functions are employed.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">M</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">V</span><span class="p">]</span> <span class="o">=</span> <span class="n">computeFEmatrices</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">,</span><span class="n">vx</span><span class="p">,</span><span class="n">vy</span><span class="p">);</span> <span class="c1">%% Compute FE discretization matrices</span>
</code></pre>
</div>

<p>A reference initial condition is chosen and we compute using the FE discretization specified above and implicit Euler in time its corresponding final state at time $T$. This final state will be considered the initial data of the inverse problem to be solved and we name it the target function $u^*$ as mentioned previously.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">U0_ref</span> <span class="o">=</span> <span class="n">initial_deltas</span><span class="p">(</span><span class="n">N</span><span class="p">);</span> <span class="c1">%% computes reference initial condition</span>

<span class="p">[</span><span class="n">U_target</span><span class="p">,</span><span class="n">u_target</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_target</span><span class="p">(</span><span class="n">U0_ref</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">V</span><span class="p">);</span> <span class="c1">%% Compute target distribution</span>
</code></pre>
</div>

<p>We now call the algorithm that estimates the initial condition $u_0$ using as a initial data the target function $u^*$. As mentioned before, this algorithm consists of two steps.</p>

<p>Firstly, the classical adjoint methodology that minimizes the functional $J(u_0)$ subject to the diffusion-advection equation is used. The iterative optimization algorithm employed is the classical gradient descent method. However, although this iterative procedure finds quite accurately the locations of the sources, it does not recover the sparse character of the initial condition. This is not suprising because the recovered initial data comes from solving the adjoint problem which is basically a diffusive process that smoothes out its state. Consequently, a second procedure is needed to project the obtained non sparse initial condition into the set of admissible sparse solutions.</p>

<p>As the initial condition $u_0$ is assumed to be a linear combination between the locations and the intensities, once we have fixed the locations using the adjoint methodology we can solve a least squares problem to get the remaining intensities. We assemble a matrix $\textbf{L} \in \mathbb{R}^{s \times l}$ where at each column we have the forward solution for a single unitary delta placed at each of the locations already identified. We then solve the following linear system of equations for the vector of unknowns $\alpha = (\alpha_1, \alpha_2, …, \alpha_l)^T$:</p>

<script type="math/tex; mode=display">\begin{align} \textbf{L}^T \textbf{L} \alpha = \textbf{L}^T u^*, \end{align}</script>

<p>to find the intensities vector $\alpha$.</p>

<p>Adjoint algorithm for sparse source identification (algorithm 4)</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">U0</span> <span class="o">=</span> <span class="n">SparseIdentification</span><span class="p">(</span><span class="n">u_target</span><span class="p">,</span><span class="n">TOL</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">epsilon</span><span class="p">,</span><span class="n">tau</span><span class="p">);</span>
</code></pre>
</div>

<p>Finally, the final state at $T$ is computed using as a initial condition the estimated sparse sources identified with our algorithm.</p>

<p>Compute final state with the recovered initial condition</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">UF</span><span class="p">,</span><span class="n">u_final</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_target</span><span class="p">(</span><span class="n">U0</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">V</span><span class="p">);</span>
</code></pre>
</div>

<p>We can see the evolution recovered</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0005/evolution.gif" alt="" /></p>

<p>We now visualize the numerical results. Plots on the left side show the reference initial solution and the given target. Similarly, plots on the right side show the recovered initial condition and the distribution at the final time $T$ produced by the recovered initial sources.</p>

<p>One can observe the difference between the two models (the heat equation on $\Omega_1$ and the diffusion-advection on $\Omega_2$) in the two figures at the bottom where the initial sources on $\Omega_2$ move downwards at the same time as they dissipate while the initial sources on $\Omega_1$ only dissipate without displacement.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">xplot</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span> <span class="c1">%% space grid w.r.t component x</span>
<span class="n">yplot</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span> <span class="c1">%% space grid w.r.t component y</span>
<span class="c1">%%</span>
<span class="nb">figure</span><span class="p">(</span><span class="s1">'unit'</span><span class="p">,</span><span class="s1">'norm'</span><span class="p">,</span><span class="s1">'pos'</span><span class="p">,[</span><span class="mf">0.25</span> <span class="mf">0.1</span> <span class="mf">0.5</span> <span class="mf">0.8</span><span class="p">])</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">U0_ref</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="n">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Reference initial state (front view)'</span><span class="p">)</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">U0</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="n">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Recovered initial state (front view)'</span><span class="p">)</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">pcolor</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">U0_ref</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="n">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Reference initial state (above view)'</span><span class="p">)</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">pcolor</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">U0</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="n">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Recovered initial state (above view)'</span><span class="p">)</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">pcolor</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">U_target</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="n">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Given target u^*'</span><span class="p">)</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="nb">pcolor</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span><span class="n">yplot</span><span class="p">,</span><span class="n">UF</span><span class="p">)</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span><span class="nb">colorbar</span><span class="p">;</span><span class="nb">colormap</span> <span class="n">jet</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Recovered final state'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0005/copiaRM_01.png" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;  Infinite dimensional dynamical systems coupling age structuring with diffusion appear naturally in  population dynamics, medicine or epidemiology. A by now classical example is the Lotka-Mckendrick system with spatial diffusion. The  aim of this blog is to study contaollability properties of such age structured models in an unified manner. 
</code></pre>
</div>
<p>&lt;/p&gt;</p>

<p>
Let $A : \mathcal{D}(A) \to X$  be the generator of a $C^0$ semigroup $\mathbb{S}$ on the Hilbert space $X$ and let $U$ be
another Hilbert space. Both $X$ and $U$ will be identified with their duals. Let $B$ be a (possibly unbounded) linear operator
from $U$ to $X$, which is supposed to be an admissible control operator for  $\mathbb{S}$.
In the examples we have in mind, the above spaces and operators describe the dynamics of a system without age structure.
In particular, $X$ is the state space and $U$ is the control space.
The corresponding age structured system is obtained by first extending these spaces to
\begin{equation} \label{input-space}
\mathcal{X} = L^{2}(0,a_{\dagger}; X), \quad \mathcal{U} = L^{2}(0,a_\dagger;U).
\end{equation} 
where $a_\dagger&gt;0$ denotes the maximal age individuals can attain. Let $p(t) \in \chi$ be the distribution density of the
individuals with respect to age $a\geqslant 0$ and at some time $t \geqslant 0.$  Then the abstract version of the Lotka-McKendrick
system to be considered in this paper writes:
 \begin{equation} \label{eq:main}
\begin{cases}
\displaystyle \frac{\partial p}{\partial t} + \frac{\partial p}{\partial a} - A p  + \mu(a) p =  \mathcal{\chi}_{(a_{1},a_{2})} B u, &amp; t \geqslant 0, a \in (0,a_\dagger), \\
\displaystyle p(t,0)  = \displaystyle \int_{0}^{a_\dagger} \beta(s) p(t,s) \; {\rm d}s, &amp; t \geqslant 0, \\
\displaystyle p(0,a) = p_{0},
\end{cases}
\end{equation} 
where $\mathcal{\chi}$ is the characteristic function of the interval $(a_{1}, a_{2})$ with
$0 \leqslant a_{1} &lt; a_{2} \leqslant a_\dagger$ and $p_{0}$ is the initial population density.
In the above system, the positive function $\mu:[0,a_\dagger] \to \mathbb{R}_{+}$ denotes the
natural mortality rate of individuals of age $a.$ We denote by $\beta: [0,a_\dagger] \to \mathbb{R}_{+}$
the positive function describing the fertility rate at age $a.$ We assume that the fertility rate $\beta$ a
nd the mortality rate $\mu$ satisfy the conditions
<ul style="list-style: none;">
<li>(H1) $\beta \in L^\infty[0, a_\dagger], \; \beta \geqslant 0$ for almost every $a \in [0,a_\dagger].$</li>
<li>(H2) $\mu \in L^1_{loc}[0, a_\dagger], \; \mu \geqslant 0$ for almost every $a \in [0,a_\dagger].$</li>
<li>(H3) $\displaystyle \int_0^{a_\dagger} \mu(a) \ {\rm d} a = \infty.$</li>
</ul>

Before we state our result, let us introduce the notion of null controllability of the pair $(A,B).$
<div class="definition">
We say that a pair $(A,B)$ is null-controllable in time $\tau,$ if for every $z_{0} \in X$ there exists a control $u \in L^{2}(0,\tau,U)$ such that, the solution of the system
\begin{equation*}
\dot z(t) = A z(t) + Bu(t) \quad t \in [0,\tau], \qquad z(0) = z_{0},
\end{equation*}
satisfies $z(\tau) = 0.$
</div>

We prove the following result
<div class="theorem">
Assume that  $\beta$ and $\mu$ satisfy the conditions (H1)-(H3) above. Moreover,
suppose that the fertility rate $\beta$ is such that
\begin{equation} \label{eq:beta}
\beta(a)= 0 \mbox{ for all } a \in (0,a_{b}),
\end{equation}
for some $a_b\in (0,a_\dagger)$ and that $a_1 &lt; a_b$.
Let us assume that the pair $(A,B)$ is null controllable in arbitrary time. 
Then for every $\tau &gt; a_{1} + a_{\dagger}-a_{2}$ and for every $p_{0} \in \chi$ there exists  a control $v \in L^{2}(0,\tau;\mathcal{U})$ such that the solution $p$ of \eqref{eq:main} satisfies
\begin{equation}
p(\tau,a) = 0 \mbox{ for all }  a \in (0,a_\dagger).
\end{equation} 
 </div>

It is well known that null controllability is equivalent to final state observability of the adjoint system
(see for instance [4, Section 11.2]). The adjoint of the above system reads as
\begin{equation} \label{eq:adj}
\begin{cases}
\displaystyle \frac{\partial q}{\partial t} - \frac{\partial p}{\partial a} - A^* p  + \mu(a) p - \beta(a) q(t,0) =  0, &amp; t \geqslant 0, a \in (0,a_\dagger), \\
\displaystyle q(t,a_\dagger)  = 0, &amp; t \geqslant 0, \\
\displaystyle q(0,a) = q_{0},
\end{cases}
\end{equation} 
where $A^*$ is the adjoint of  $A.$  In order to prove Theorem 1, it is enough to prove the following
<div class="theorem">
 Let us assume the hypothesis of Theorem 1. Then for every $\tau &gt; a_1 + a_\dagger - a_2$ there exists $k_\tau &gt; 0$ such that
 the solution $q$ of \eqref{eq:adj} satishfies
 \begin{equation} \label{eq:est-adj}
 \int_0^{a_\dagger} \|q(\tau, a)\|^2_X \ da  \leqslant k_\tau^2 \int_0^\tau \int_{a_1}^{a_2} \left\|B^*q(t,a) \right\|^2_U \ da dt, \qquad \qquad (q_0 \in \mathcal{X}).
 \end{equation}
 </div>
Let us give an idea of the proof. We combine characteristics method with final state observability of the pair $(A^*, B^*).$ For siplicity
in the presentation, let us assume that $\mu = 0,$ $a_1 = 0,$ $a_2 &lt; a_b$ and $\tau = 2a_\dagger.$
The detail proof of Theorem 1, in a slightly more general case, can be found in [3]. Integrating along the characteristic lines,
it is not very difficult to see that
\begin{equation*}
q(t,a) = \int_{t + a - a_\dagger}^{t} e^{(t-s)A^*} \beta(a+ \tau - s) q(s, 0) \ ds, \qquad t &gt; a_\dagger. 
\end{equation*}
Therefore,
\begin{equation} \label{est0}
\int_0^{a_\dagger} \|q(\tau, a)\|^2_X \ da \leqslant C \int_{a_\dagger}^\tau \left\|q(t,0) \right\|^2_X \ dt. 
\end{equation}
Thus to prove \eqref{eq:est-adj}, we need to estimate the right hand side of the above estimate. We now make use of the condition
\eqref{eq:beta}.  Note that, due to this condition, $q$ satisfies
\begin{equation} \label{eq:adj-2}
\displaystyle \frac{\partial q}{\partial t} - \frac{\partial q}{\partial a} - A^* p  + \mu(a) p =  0,  \quad  t \geqslant 0, a \in (0,a_2).
\end{equation}
For a.e. $t \in (a_\dagger, \tau),$ we define $w(s) = q(s, t- s),$ $s \in (t - a_2, t).$ Then $w$ solves
\begin{equation*}
\displaystyle \frac{\partial w}{\partial s} - A^* w = 0, \quad s \in (t - a_2, t). 
\end{equation*}
Since the pair $(A, B)$ is null controllable in any time, or equivalently the pair $(A^*, B^*)$ is final-state observable in any
time, there exists a constant
$C &gt; 0,$ depending only on $a_2, A$ and $B$  such that
\begin{equation*}
\left\| w(t) \right\|_{X}^2 \leqslant C \int_{t-a_2}^t \left\| B^* w(s) \right\|^2_U \ ds. 
\end{equation*}
Coming back to $q$ and integrating over $[a_\dagger, \tau]$ with respect to $t,$ we have that
\begin{equation}
\int_{a_\dagger}^\tau \|q(t,0)\|^2_X \ dt \leqslant \int_{0}^\tau \int_{0}^{a_2} \left\|B^* q(t,a)\right\|^2  \ da dt. 
\end{equation}
Combining the above estimate together with \eqref{est0}, we get \eqref{eq:est-adj}. In the two figures below, we ilustrate the
estimate of $q(t,0)$ and the final-state observability of $q$ in the general case.
</p>

<table>
  <tr>
   <th>
     <figure>
  <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/trace-bis.jpg" alt="trace" style="width:95%" />
  <figcaption> Fig.1 - An ilustration of the estimate of $q(t,0).$ We apply final state observability of $(A^*, B^*)$ along
  the characteristics. Since we want to estimate $q(t,0),$ we consider the trajectory $\gamma(s) = (t-s,s),$
  $s \leqslant t \leqslant \tau$ (or equivalently the backward characteristics starting from $(t,0).$) </figcaption>
</figure>
    </th>
<th>
    <figure>
  <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/finalTh2.jpg" alt="final" style="width:85%" />
  <figcaption> Fig.2 - An illustration of the final-state observability at time $\tau &gt; a_1 + a_\dagger - a_2$: For
  $ a \in (0,a_2 - \varepsilon)$ (blue region) the backward characteristics starting from $t = \tau$ enters the
  observation domain.  For $a \in (a_2 - \varepsilon, a_\dagger)$, the backward characteristics (green region)
  hits the line $a = a_\dagger$, gets renewed by the renewal condition $\beta(a)q(t,0)$ and then enters the observation
  domain (purple region).</figcaption>
</figure> 
 </th>
 </tr>
 </table>

<h2 id="Examples">Examples</h2>
<p>We consider two examples :  1) The classical Lotka-McKendrick system and 2) Lotka-Mckendrick system with diffusion.</p>
<p>
 1) <em> The classical Lotka-McKendrick system </em>: Let us choose $X = \mathbb{R},$ $A=0$ and $B=1.$ Then the system \eqref{eq:main} reduces
 to  classical Lotka-McKendrick system. By Theorem 1, this system is null controllable in time $\tau &gt; a_1 + a_\dagger - a_2.$ A
 similar result was obtained in [1]. 
</p>

<p>
 2) <em> The Lotka-McKendrick system with spatial diffusion </em> : Let $\Omega$ be a smooth bounded domain in $\mathbb{R}^3$ and
 $\omega \subseteq \Omega.$ Let us consider 
 \begin{equation*}
 X = L^2(\Omega), \quad A = \Delta , \quad \mathcal{D}(A) =
 \left\{ f \in H^2(\Omega) \mid \displaystyle \frac{\partial f}{\partial n} = 0\right\}, \quad B = \chi_{\omega}.
 \end{equation*}
 This corresponds to the Lotka-McKendrick model with spatial diffusion ([2]). It is known that, the pair $(A, B)$ or equivalently
 the heat equation with localized interior control, is null controllable in any time. Thus we can apply Theorem 1 to conclude that
 the system is null controllable in time $\tau &gt; a_1 + a_\dagger - a_2.$
 </p>
<p> Several other applications can be found in [3].</p>

<h2 id="NS">Numerical Simulations</h2>
<p> We now present some numerical siimulations of the controlled trajectory.  We shall consider the case  $A = 0$
and $B = 1,$ i.e the classical Lotka-McKendrick system. We also consider the case $a_1 = 0$ and $a_2 = a_{\dagger} =4,$ i.e., the control
acts everywhere with respect to age variable. We present numerical simulations in the following two scenarios : 1) null controllabilty,
2) controllability to a steady state.
<h4 id="NS">Null Controllability</h4>
By Theorem 1 we know that system (1) is null controllable in any time. In the following
video, we see the evolution of unctrolled trajectory and controlled trajectories to zero  with controllability time $t=2$ and $t =5.$ </p>
<video style="display:block; margin: 0 auto;;width:80%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/Video-Null.mp4" type="video/mp4" />
  </video>

<p>
 We now plot the control functions. In the following two videoes, we see the evolution of the control
 functions at controllability time $t = 2$ and $t =5$
 respectively.
</p>

<table>
  <tr>
   <th>
    <video style="display:block; margin: 0 auto;width:100%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/control-1.mp4" type="video/mp4" />
  </video>
    </th>
   &nbsp; &nbsp; 
<th>
   <video style="display:block; margin: 0 auto;width:100%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/control-2.mp4" type="video/mp4" />
  </video>
 </th>
 </tr>
 </table>
<h4 id="NS">Controllability to a steady state</h4>
<p> If we choose $\beta$ and $\mu$ such that $R = \int_0^{a_\dagger} \beta(a) e^{-\int_0^r \mu(r) \ dr } da = 1,$ then
$p_s(a) = \alpha e^{-\int_0^r \mu(r) \ dr }$ with $\alpha \in (0,\infty)$ is a steady state to the system (1) with zero steady control.
Thus we can control to these trajectories also. In the following example, we have chosen $a_{\dagger} = 4,$ $a_b = 1,$ $\alpha = 1.25$ and
\begin{equation*}
\beta(a) = \begin{cases}
0 &amp; \mbox{ if } a \in [0,1), \\
\frac{1}{3}e^{.05 a^2} &amp;  \mbox{ if } a \in [1,4],
\end{cases}
\qquad
\mu(a) = .1 a.
\end{equation*}
In this case we can verify that $R=1$ and $p_s(a) = 1.25 e^{-.05 a^2}.$ As before we take control everywhere, thus the system is
controllable to the trajectory $p_s(a)$ in any time.  In the following video,
we see the evolution of unctrolled trajectory and controlled trajectories to the steady state $p_s(a)$ with
controllability time $t=2$ and $t =5.$
</p>
<video style="display:block; margin: 0 auto;width:80%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/Video-SS.mp4" type="video/mp4" />
  </video>
<p> As before, in the following two videos we see the evolution of the control functions at time $t =2$ and $t=5$ respectively. </p>

<p>
<table>
  <tr>
   <th>
    <video style="display:block; margin: 0 auto;;width:100%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/control-3.mp4" type="video/mp4" />
  </video>
    </th>
   &nbsp; &nbsp; 
<th>
   <video style="display:block; margin: 0 auto;;width:100%" controls="">
   <source src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0010/control-4.mp4" type="video/mp4" />
  </video>
 </th>
 </tr>
 </table>

</p>

<h2 id="references">References</h2>
<p> [1] D. Maity, <em> On the Null Controllability of the Lotka-Mckendrick System,</em> Submitted. </p>
<p> [2] D. Maity, M. Tucsnak and E. Zuazua, <em> Controllability and positivity constraints in population dynamics with age
structuring and diffusion </em>, Journal de Math&eacute;matiques Pures et Appliqu&eacute;s. In press, 10.1016/j.matpur.2018.12.006.</p>

<p> [3] D. Maity, M. Tucsnak and E. Zuazua, <em> Controllability of a Class of Infinite Dimensional
Systems with Age Structure</em>. Submitted.</p>

<p> [4] M. Tucsnak and G. Weiss, <em> Observation and control for operator semigroups, </em>  
Birkh&auml;user Advanced Texts: Basler Lehrbu&uuml;cher. [Birkh&auml;user Advanced Texts: Basel Textbooks], Birkh&auml;user Verlag, Basel, 2009. </p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;We describe here a Finite Element algorithm for the approximation of the one-dimensional fractional Laplacian $(-d_x^2)^s$ on the interval $(-L,L)$, $L&amp;gt;0$ and for the numerical resolution of the following fractional Poisson equation&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{Fl_Poisson}
\begin{cases}
(-d_x^2)^s u = f, & x\in (-L,L)
\\
u = 0, & x\in(-L^L)^c=: \mathbb{R}\setminus (-L,L.)
\end{cases}
\end{equation} %]]></script>

<p>This algorithm has also been emploied in [2,3] for the numerical controllability of fractional parabolic problems (see our previous entries in the <strong>DyCon Blog</strong>, <a href="https://deustotech.github.io/DyCon-Blog//tutorial/wp03/P0001">WP3_P0001</a> and <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/WP03-P0022">WP3_P0022</a>).</p>

<p>We recall that the fractional Laplacian is defined, for all $s\in(0,1)$ and any function $u$ regular enough, as the following singular integral</p>

<script type="math/tex; mode=display">(-d_x^2)^s u(x) := c_s \,P.V.\,\int_{\mathbb{R}} \frac{u(x)-u(y)}{|x-y|^{1+2s}}\,dy,</script>

<p>with $c_s$ an explicit normalization constant given by</p>

<script type="math/tex; mode=display">c_s = \frac{s2^{2s}\Gamma\left(\frac{1+2s}{2}\right)}{\sqrt{\pi}\Gamma(1-s)},</script>

<p>$\Gamma$ being the usual Euler Gamma function.</p>

<p>The starting point of the FE method is the definition of a bilinear form associated to the fractional Laplace operator $(-d_x^2)^s$ and the introduction of the variational formulation corresponding to the elliptic problem \eqref{Fl_Poisson}.</p>

<p>This variational formulation is given as follows: find $u\in H_0^s(-L,L)$ such that the identity</p>

<script type="math/tex; mode=display">\begin{equation}\label{variational}
a(u,v) = \int_{-L}^L fv\,dx
\end{equation}</script>

<p>is satisfied for any function $v\in H_0^s(-L,L)$. In \eqref{variational}, with $H_0^s(-L,L)$ we indicate the space</p>

<script type="math/tex; mode=display">H_0^s(-L,L):=\Big\{ u\in H^s(\mathbb{R})\;:\; u=0\;in\; (-L,L)^c\Big\},</script>

<p>$H^s(\mathbb{R})$ being the usual fractional Sobolev space. Moreover, the bilinear form</p>

<script type="math/tex; mode=display">a: H_0^s(-L,L)\times H_0^s(-L,L)\to \mathbb{R}</script>

<p>is defined as</p>

<script type="math/tex; mode=display">a(u,v) = \frac{c_s}{2}\int_{\mathbb{R}}\int_{\mathbb{R}} \frac{(u(x)-u(y))(v(x)-v(y))}{|x-y|^{1+2s}}\,dxdy.</script>

<p>Let us describe how, starting from the above bilinear form, we can obtain our FE approximation. For simplicity, in what follows we will take $L=1$, although the methodology remains the same for any real $L&gt;0$.</p>

<p>Let us take a uniform partition of the interval $(-1,1)$ as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
-1 = x_0<x_1<\ldots <x_i<x_{i+1}<\ldots<x_{N+1}=1\,, %]]></script>

<p>with $x_{i+1}=x_i+h$, $i=0,\ldots N$. We call $\mathfrak{M}$ the mesh composed by the points ${x_i\,:\, i=1,\ldots,N}$, while the set of the boundary points is denoted $\partial\mathfrak{M}:={x_0,x_{N+1}}$.</p>

<p>Now, define $K_i:=[x_i,x_{i+1}]$ and consider the discrete space</p>

<script type="math/tex; mode=display">\begin{equation}\label{Vh}
V_h :=\Big\{v_h\in H_0^s(-1,1)\,\big|\, \left. v_h\,\right|_{K_i}\in \mathcal{P}^1\Big\},
\end{equation}</script>

<p>where $\mathcal{P}^1$ is the space of the continuous and piece-wise linear functions. Hence, we approximate \eqref{variational} with the following discrete problem: find $u_h\in V_h$ such that</p>

<script type="math/tex; mode=display">\frac{c_s}{2} \int_{\mathbb{R}}\int_{\mathbb{R}}\frac{(u_h(x)-u_h(y))(v_h(x)-v_h(y))}{|x-y|^{1+2s}}\,dxdy = \int_{-1}^1 fv_h\,dx,</script>

<p>for all $v_h\in V_h$. If now we indicate with</p>

<script type="math/tex; mode=display">\big\{\phi_i\big\}_{i=1}^N</script>

<p>a basis of $V_h$, it will be sufficient that the above equality is satisfied for all the functions of the basis, since any element of $V_h$ is a linear combination of them. Therefore the problem takes the following form</p>

<script type="math/tex; mode=display">\begin{equation}\label{WFD}
\frac{c_s}{2} \int_{\mathbb{R}}\int_{\mathbb{R}}\frac{(u_h(x)-u_h(y))(\phi_i(x)-\phi_i(y))}{|x-y|^{1+2s}}\,dxdy = \int_{-1}^1 fv_h\,dx,\;\;\; i=1,\ldots,N.
\end{equation}</script>

<p>Clearly, since $u_h\in V_h$, we have $u_h(x) = \sum_{j=1}^N u_j\phi_j(x)$, where the coefficients $u_j$ are, a priori, unknown. In this way, \eqref{WFD} is reduced to solve the linear system $\mathcal A_h u=F$, where the stiffness matrix $\mathcal A_h\in \mathbb{R}^{N\times N}$ has components</p>

<script type="math/tex; mode=display">\begin{equation}\label{stiffness_nc}
a_{i,j}=\frac{c_s}{2} \int_{\mathbb{R}}\int_{\mathbb{R}}\frac{(\phi_i(x)-\phi_i(y))(\phi_j(x)-\phi_j(y))}{|x-y|^{1+2s}}\,dxdy,
\end{equation}</script>

<p>while the vector $F\in\mathbb{R}^N$ is given by $F=(F_1,\ldots,F_N)$ with</p>

<script type="math/tex; mode=display">F_i = \langle f,\phi_i\rangle_{L^2(-1,1)} = \int_{-1}^1 f\phi_i\,dx,\;\;\; i=1,\ldots,N.</script>

<p>Moreover, the basis</p>

<script type="math/tex; mode=display">\big\{\phi_i\big\}_{i=1}^N</script>

<p>that we will employ is the classical one in which each $\phi_i$ is the tent function with $supp(\phi_i)=(x_{i-1},x_{i+1})$ and verifying $\phi_i(x_j)=\delta_{i,j}$. In particular, for $x\in{x_{i-1},x_i,x_{i+1}}$ the $i^{th}$ function of the basis is explicitly defined as (see <strong>Figure 1</strong>)</p>

<script type="math/tex; mode=display">\begin{equation}\label{basis_fun}
\phi_i(x)= 1-\frac{|x-x_i|}{h}.
\end{equation}</script>

<h2><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/basis_function.png" alt="" /></h2>
<p><strong>Figure 1</strong>. Basis function $\phi_i$ on its support $(x_{i-1},x_{i+1})$.</p>

<p>We now start building the stiffness matrix $\mathcal A_h$ approximating the fractional Laplacian. This will be done in three steps, since the values of the matrix can be computed differentiating among three well defined regions: the upper triangle, corresponding to $j\geq i+2$, the upper diagonal corresponding to $j=i+1$ and the diagonal, corresponding to $j=i$. In each of these regions the intersections among the support of the basis functions are different, thus generating different values of the bilinear form.</p>

<p>We present below an abridged explanation of how to compute the entries of $\mathcal{A}_h$. Complete details may be found in [2].</p>

<h2 id="step-1-jgeq-i2"><strong>Step 1</strong>: $j\geq i+2$</h2>

<p>In this case we have $supp(\phi_i)\cap supp(\phi_j) =\emptyset$ (see also <strong>Figure 2</strong>). Hence, \eqref{stiffness_nc} is reduced to computing only the integral</p>

<script type="math/tex; mode=display">\begin{equation}\label{elem_noint_app}
a_{i,j}=-2 \int_{x_{j-1}}^{x_{j+1}}\int_{x_{i-1}}^{x_{i+1}}\frac{\phi_i(x)\phi_j(y)}{|x-y|^{1+2s}}\,dxdy.
\end{equation}</script>

<h2 id="-1"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/phi1.png" alt="" /></h2>
<p><strong>Figure 2</strong>. Basis functions $\phi_i(x)$ and $\phi_j(x)$ for $j\geq i + 1$. The supports are disjoint.</p>

<p>Taking into account the definition of the basis function \eqref{basis_fun}, the integral \eqref{elem_noint_app} becomes</p>

<script type="math/tex; mode=display">a_{i,j}=-2 \int_{x_{j-1}}^{x_{j+1}}\int_{x_{i-1}}^{x_{i+1}}\frac{\left(1-\frac{|x-x_i|}{h}\right)\left(1-\frac{|y-x_j|}{h}\right)}{|x-y|^{1+2s}}\,dxdy.</script>

<p>Let us introduce the following change of variables:</p>

<script type="math/tex; mode=display">\begin{equation}\label{CV}
\frac{x-x_i}{h}=\hat{x},\;\;\; \frac{y-x_j}{h}=\hat{y}.
\end{equation}</script>

<p>Then, rewriting (with some abuse of notations since there is no possibility of confusion) $\hat{x}=x$ and $\hat{y}=y$, we get</p>

<script type="math/tex; mode=display">a_{i,j}=-2h^{1-2s} \int_{-1}^1\int_{-1}^1\frac{(1-|x\,|\,)(1-|y\,|\,)}{|x-y+i-j\,|^{1+2s}}\,dxdy.</script>

<p>This integral can be computed explicitly, and we obtain</p>

<script type="math/tex; mode=display">a_{i,j} = - h^{1-2s}\,\frac{4(k+1)^{3-2s} + 4(k-1)^{3-2s}-6k^{3-2s}-(k+2)^{3-2s}-(k-2)^{3-2s}}{2s(1-2s)(1-s)(3-2s)}.</script>

<p>Notice that, when $s=1/2$, both the numerator and the denominator of the expression above are zero. In this case, the value of $a_{i,j}$ can be obtained by taking the limit $s\to 1/2$ and we get</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{l}
a_{i,j} &= -4 (k+1)^2\log(k+1) -4(k-1)^2\log(k-1)+6k^2\log(k)
\\[10pt]
&+(k+2)^2\log(k+2) +\;(k-2)^2\log(k-2)
\end{array} %]]></script>

<p>if $k\neq 2$ and</p>

<script type="math/tex; mode=display">a_{i,i+2} = 56\ln(2)-36\ln(3).</script>

<h2 id="step-2-j-i1"><strong>Step 2</strong>: $j= i+1$</h2>
<p>This is the most cumbersome case, since it is the one with the most interactions between the basis functions (see <strong>Figure 3</strong>).</p>

<h2 id="-2"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/phi2.png" alt="" /></h2>
<p><strong>Figure 3</strong>. Basis functions $\phi_i(x)$ and $\phi_{i+1}(x)$. In this case, the intersection of the supports is the interval $[x_i,x_{i+1}]$.</p>

<p>Using the symmetry of the integral with respect to the bisector $y=x$, we have</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{ll}
a_{i,i+1} &= \displaystyle\int_{\mathbb{R}}\int_{\mathbb{R}}\frac{(\phi_i(x)-\phi_i(y))(\phi_{i+1}(x)-\phi_{i+1}(y))}{|x-y|^{1+2s}}\,dxdy
\\[15pt]
&= \displaystyle\int_{x_{i+1}}^{+\infty}\int_{x_{i+1}}^{+\infty} \ldots\,dxdy + 2\int_{x_{i+1}}^{+\infty}\int_{x_i}^{x_{i+1}} \ldots\,dxdy + 2\int_{x_{i+1}}^{+\infty}\int_{-\infty}^{x_i} \ldots\,dxdy
\\[15pt]
&\quad + \displaystyle\int_{x_i}^{x_{i+1}}\int_{x_i}^{x_{i+1}} \ldots\,dxdy + 2\int_{x_i}^{x_{i+1}}\int_{-\infty}^{x_i} \ldots\,dxdy + \int_{-\infty}^{x_i}\int_{-\infty}^{x_i} \ldots\,dxdy
\\[15pt]
&:= Q_1 + Q_2 + Q_3 + Q_4 + Q_5 + Q_6.
\end{array} %]]></script>

<p>Also in this case, the terms $Q_i$, $i=1,\ldots,6$, can be computed explicitely, by noticing also the following facts:</p>

<ol>
  <li>$Q_1=Q_6=0$ since $\phi_i = 0$ on the domain of integration.</li>
  <li>$Q_2=Q_5$ due to symmetry.</li>
</ol>

<p>Then, the elements $a_{i,i+1}$ are given by the sum $2Q_2+Q_3+Q_4$ and we have</p>

<script type="math/tex; mode=display">% <![CDATA[
a_{i,i+1} = \begin{cases}
\displaystyle h^{1-2s}\frac{3^{3-2s}-2^{5-2s}+7}{2s(1-2s)(1-s)(3-2s)}, & \displaystyle s\neq \frac{1}{2}
\\[15pt]
9\ln 3-16\ln 2, & \displaystyle s=\frac{1}{2}.
\end{cases} %]]></script>

<h2 id="step-3-j-i"><strong>Step 3</strong>: $j= i$</h2>
<p>As a last step, we fill the diagonal of the matrix $\mathcal A_h$, which collects the values corresponding to $\phi_i(x)=\phi_j(x)$ (see <strong>Figure 4</strong>).</p>

<h2 id="-3"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/phi4.png" alt="" /></h2>
<p><strong>Figure 4</strong>. Basis functions $\phi_i(x)=\phi_j(x)$.</p>

<p>In this case, we have</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{ll}
a_{i,i} &= \displaystyle\int_{\mathbb{R}}\int_{\mathbb{R}}\frac{(\phi_i(x)-\phi_i(y))^2}{|x-y|^{1+2s}}\,dxdy
\\[15pt]
& = \displaystyle\int_{x_{i+1}}^{+\infty}\int_{x_{i+1}}^{+\infty} \ldots\,dxdy + 2\int_{x_{i+1}}^{+\infty}\int_{x_{i-1}}^{x_{i+1}} \ldots\,dxdy + \int_{x_{i+1}}^{+\infty}\int_{-\infty}^{x_{i-1}} \ldots\,dxdy 
\\[15pt]
& \quad\displaystyle+ \int_{x_{i-1}}^{x_{i+1}}\int_{x_{i-1}}^{x_{i+1}} \ldots\,dxdy + 2\int_{-\infty}^{x_{i-1}}\int_{x_{i-1}}^{x_{i+1}} \ldots\,dxdy + + \int_{-\infty}^{x_{i-1}}\int_{x{i+1}}^{+\infty} \ldots\,dxdy 
\\[15pt]
& \quad\displaystyle +  \int_{-\infty}^{x_{i-1}}\int_{-\infty}^{x_{i-1}} \ldots\,dxdy := R_1 + R_2 + R_3 + R_4 + R_5 + R_6 + R_7.
\end{array} %]]></script>

<p>Once again, the terms $R_i$, $i=1,\ldots,7$ can be computed explicitely, by taking also into account that $R_1=R_3=R_6=R_7=0$ because the corresponding integration domains are all away from the support of the basis functions.</p>

<p>The result of these computations gives the values</p>

<script type="math/tex; mode=display">% <![CDATA[
a_{i,i} = \begin{cases}
\displaystyle h^{1-2s}\,\frac{2^{3-2s}-4}{s(1-2s)(1-s)(3-2s)}, & \displaystyle s\neq\frac{1}{2}
\\
\\
8\ln 2, & \displaystyle s=\frac{1}{2}.
\end{cases} %]]></script>

<h2 id="step-4-building-of-mathcal-a_h">Step 4: building of $\mathcal A_h$</h2>

<p>Summarizing, we have the following values for the elements of the stiffness matrix $\mathcal{A}_h$: for $s\neq 1/2$</p>

<script type="math/tex; mode=display">% <![CDATA[
a_{i,j} =  -h^{1-2s} \begin{cases}
\displaystyle \,\frac{4(k+1)^{3-2s} + 4(k-1)^{3-2s}-6k^{3-2s}-(k+2)^{3-2s}-(k-2)^{3-2s}}{2s(1-2s)(1-s)(3-2s)}, &  \displaystyle k=j-i,\,k\geq 2
\\
\\
\displaystyle\frac{3^{3-2s}-2^{5-2s}+7}{2s(1-2s)(1-s)(3-2s)}, & \displaystyle j=i+1
\\
\\
\displaystyle\frac{2^{3-2s}-4}{s(1-2s)(1-s)(3-2s)}, & \displaystyle j=i.
\end{cases} %]]></script>

<p>For $s=1/2$, instead, we have</p>

<script type="math/tex; mode=display">% <![CDATA[
a_{i,j} = \begin{cases}
-4(j-i+1)^2\log(j-i+1)-4(j-i-1)^2\log(j-i-1)
\\
\;\;\;+6(j-i)^2\log(j-i)+(j-i+2)^2\log(j-i+2)+(j-i-2)^2\log(j-i-2), &  \displaystyle j> i+2
\\
\\
56\ln(2)-36\ln(3), & \displaystyle j= i+2.
\\
\\
\displaystyle 9\ln 3-16\ln 2, & \displaystyle j=i+1
\\
\\
\displaystyle 8\ln 2, & \displaystyle j=i.
\end{cases} %]]></script>

<h1 id="numerical-results">Numerical results</h1>

<p>We present the numerical simulations corresponding to the algorithm previously described.</p>

<p>First of all, we test numerically the accuracy of our method for the resolution of the elliptic equation \eqref{Fl_Poisson} by applying it to the following problem</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{poisson}
\begin{cases}
(-d_x^2)^s u = 1, & x\in(-1,1)
\\
u\equiv 0, & x\in(-1,1)^c.
\end{cases}
\end{equation} %]]></script>

<p>In this particular case, the unique solution $u$ can be computed exactly and it is given by</p>

<script type="math/tex; mode=display">\begin{equation}\label{real_sol}
  u(x)=\frac{2^{-2s}\sqrt{\pi}}{\Gamma\left(\frac{1+2s}{2}\right)\Gamma(1+s)}\Big(1-x^{\,2}\Big)^s\cdot\chi_{(-1,1)},  
\end{equation}</script>

<p>where $\chi_{(-1,1)}$ indicates the characteristic function of the interval $(-1,1)$.</p>

<p>The solution of \eqref{poisson} in the case  $s=0.1$ and $N=50$ is computed with the following script which emploies the function <strong>FEFractionalLaplacian.m</strong> ginving the FE discretization of $(-d_x^2)^s$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">f</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">Phi</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">1</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">F</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">+</span><span class="n">h</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">xx</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">)</span><span class="o">+</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">B1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">.*</span><span class="p">(</span><span class="n">Phi</span><span class="p">((</span><span class="n">xx</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="nb">i</span><span class="p">))/</span><span class="n">h</span><span class="p">));</span>
    <span class="n">F</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">)/</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">B1</span><span class="p">);</span> 
<span class="k">end</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">FEFractionalLaplacian</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">A</span><span class="p">\</span><span class="n">F</span><span class="p">;</span>
</code></pre>
</div>

<p>In <strong>Figure 5</strong>, we show a comparison for different values of $s$ between the exact solution \eqref{real_sol} and the computed numerical approximation.</p>

<h2 id="-4"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/solution.png" alt="" /></h2>
<p><strong>Figure 5</strong>. Real and numerical solution.</p>

<p>One can notice that when $s=0.1$ (and also for other small values of s), the computed solution is to a certain extent different from the exact solution. Notwithstanding, it is well-known that the notion of trace is not defined for the spaces $H^s(-1,1)$ with $s\leq 1/2$. Hence, it is somehow natural that we cannot expect a point-wise convergence in this case.</p>

<p>Furthermore, the accuracy of our algorithm is validated by a simple error analysis.</p>

<p>The computation of the error in the space $H_0^s(-1,1)$ can be readily done by using the definition of the bilinear form, namely</p>

<script type="math/tex; mode=display">\|u-u_h\|_{H_0^s(-1,1)}^2 =a(u-u_h,u-u_h) =a(u,u-u_h) =\int_{-1}^1f(x)\left(u(x)-u_h(x)\right)dx</script>

<p>where have used the orthogonality condition $a(v_h,u-u_h)=0$ for all $v_h \in V_h$.</p>

<p>For this particular test, since $f\equiv 1$ in $(-1,1)$, the problem is therefore reduced to</p>

<script type="math/tex; mode=display">\|u-u_h\|_{H^s_0(-1,1)}=\left(\int_{-1}^1\left( u(x)-u_h(x) \right)\,dx\right)^{1/2}</script>

<p>where the right-hand side can be easily computed, since we have the closed formula</p>

<script type="math/tex; mode=display">\int_{-1}^1u\,dx= \frac{\pi}{2^{2s}\Gamma(s+\frac{1}{2})\Gamma(s+\frac{3}{2})}</script>

<p>and the term corresponding to $\int_{-1}^1u_h$ can be carried out numerically. Moreover, we have the following convergence result.</p>

<p><strong>Theorem</strong> [2] For the solution $u$ of \eqref{WFD} and its FE approximation $u_h$ given by \eqref{WFD}, if $h$ is sufficiently small, the following estimates hold</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{ll}
\|u-u_h\|_{H^s_0(-1,1)}\leq \mathcal{C} h^{1/2}|\!\ln h|\,\|f\|_{C^{1/2-s}(-1,1)}, &\text{if}\quad s<1/2,
\\[15pt]
\|u-u_h\|_{H^s_0(-1,1)}\leq \mathcal{C} h^{1/2} |\!\ln h|\, \|f\|_{L^\infty(-1,1)},&\text{if}\quad  s=1/2 
\\[15pt]
\displaystyle\|u-u_h\|_{H^s_0(-1,1)}\leq \tfrac{\mathcal{C}}{2s-1} h^{1/2} \sqrt{|\!\ln h|}\, \|f\|_{C^\beta(-1,1)},& \text{if} \quad s>1/2,\;\;\beta>0
\end{array} %]]></script>

<p>where $\mathcal{C}$ is a positive constant not depending on $h$.</p>

<p>In <strong>Figure 6</strong>, we present the computational errors evaluated for different values of $s$ and $h$, which can be obtained with the following function.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="p">[</span><span class="n">h</span><span class="p">,</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_fl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">f</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">Phi</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">1</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">F</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="k">for</span> <span class="nb">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span><span class="o">+</span><span class="n">h</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">xx</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">)</span><span class="o">+</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">B1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">.*</span><span class="p">(</span><span class="n">Phi</span><span class="p">((</span><span class="n">xx</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="nb">i</span><span class="p">))/</span><span class="n">h</span><span class="p">));</span>
    <span class="n">F</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">)/</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">B1</span><span class="p">);</span> 
<span class="k">end</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">FEFractionalLaplacian</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">A</span><span class="p">\</span><span class="n">F</span><span class="p">;</span>
<span class="n">val</span> <span class="o">=</span> <span class="nb">pi</span><span class="p">/(</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="nb">gamma</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="nb">gamma</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mf">1.5</span><span class="p">));</span>
<span class="n">valnum</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">sol</span><span class="p">);</span>
<span class="n">e</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">val</span><span class="o">-</span><span class="n">valnum</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="-5"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0009/error.png" alt="" /></h2>
<p><strong>Figure 6</strong>. Computational error in logarithmic scale in terms for different values of $s$.</p>

<p>The rates of convergence shown are of order (in $h$) of $1/2$, and this convergence rate is maintained also for small values of $s$. This confirms the accuracy of our approximation. In particular, the behavior shown in <strong>Figure 6</strong> is not in contrast with the known theoretical results.</p>

<h2 id="references">References</h2>

<p>[1] G. Acosta, F. Bersetche and J. P. Borthagaray, <em>A short FE implementation for a 2d homogeneous Dirichlet problem of a Fractional Laplacian</em>. Comput. Math. Appl., Vol. 74, No. 4 (2017), pp. 784-816.</p>

<p>[2] U. Biccari and V. Hernández-Santamarı́a, <em>Controllability of a one-dimensional fractional heat equation: theoretical and
numerical aspects</em>. IMA J. Math. Control. Inf, to appear, 2018.</p>

<p>[3] U. Biccari, M. Warma and E. Zuazua, <em>Controllability of the one-dimensional fractional heat equation under positivity constraints</em>. Submitted.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;The aim of this tutorial is to give a numerical method for solving an age structured virus model.&lt;/p&gt;
</code></pre>
</div>

<h2 id="introduction">Introduction</h2>

<p>The virus infection mathematical models are proposing and studying for a long time (see for example C.L. Althaus, R.J. DE Boer [1] and F. Brauer, C. Castillo-Chavez [2]. In particular case of an HIV infection model (see for P. W. Nelson and al. [6]), the corresponding model is usually divided into three classes called  uninfected cells, $T$,  infected cells, $i$ and free virus particles, $V$.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/Schema.png" alt="" /></p>

<p>schematic representation of HIV dynamic.</p>

<p>We refer the reader to [4] and [5] for more general class on nonlinear incidence rates that take into account the saturation phenomenon.</p>

<p>We consider an age-structured HIV infection model with a very general nonlinear infection function</p>

<script type="math/tex; mode=display">\begin{equation} \label{A} \left \{ \begin{array}{lll} T'(t)=A- \mu T(t)-f(T(t),V(t)) \;\;\ t \geq 0,\\ i_t(t,a)+i_a(t,a)=-\delta(a) i(t,a), \\ V'(t)=\int_0^{\infty} p(a)i(t,a)da-\mu_cV(t), \end{array} \right. \end{equation}</script>

<p>with the boundary and initial conditions</p>

<script type="math/tex; mode=display">\begin{equation} \begin{cases} i(t,0)=f(T(t),V(t)), \\ T(0)=T_0\geq 0, \quad  V(0)=V_0 , \quad i(0,.)=i_0(.)\in L_{+}^{1}(\mathbb{R}^{+}). \end{cases} \end{equation}</script>

<p>We denote by</p>

<script type="math/tex; mode=display">\Pi(a)=e^{-\int_0^a\delta(\theta)d\theta}, \qquad  N=\int_0^{\infty}p(a)\Pi(a)da.</script>

<p>The number $R_0$ represents the expected number of secondary infections produced by a single infected cell during its lifetime,</p>

<script type="math/tex; mode=display">R_0=\frac{N}{c}\dfrac{\partial f}{\partial V}(\frac{A}{d},0).</script>

<p>The complete global stability analysis for the system (\ref{A}) has been studied in [4]. The system (\ref{A}) admits at most two equilibrium, from Theorem 3.1 and Theorem 5.2 in [4], we obtain the following result:</p>

<ul>
  <li>
    <p>If $R_0 \leqslant 1$, the disease free equilibrium $E_0=(\frac{A}{\mu},0,0)$ is globally asymptotically stable.</p>
  </li>
  <li>
    <p>If $R_0&gt;1$, the positive infection equilibrium $E^{\ast}=(T^\ast,i^\ast,V^\ast)$ is globally asymptotically stable.</p>
  </li>
</ul>

<h2 id="numerical-method">Numerical method</h2>

<p>We consider the Beddington-Deangelis function $f$  defined by</p>

<script type="math/tex; mode=display">f(T, V)=  \frac{\beta T V}{1+ \alpha_1 S+ \alpha_2 V}.</script>

<p>In this case, the basic reproduction number ${\cal R}_0$  is given by</p>

<script type="math/tex; mode=display">R_0 = \displaystyle \frac{N}{\mu_c} \frac{A \beta }{\mu + \alpha_1}.</script>

<p>Where $\pi(a)=\exp^{-\int_{0}^{a} \delta (s) ds}$ and $N=\int_{0}^{\infty} p(a) \pi(a) da$.</p>

<p>The numerical method to solve this system of equation is based on the upwind method for solving hyperbolic partial differential equation, (see [3]) called also the FTBS method (Forward-Time-Backward-Space), has first-order accuracy in both space and time. The CFL condition is necessary for the stability of numerical solutions. The ODEs are solving by explicit Euler method.</p>

<p>we use a grid with points $(x_j,t_n)$ defined by</p>

<script type="math/tex; mode=display">a_j=j\Delta a, \qquad j=0,...,N,  \qquad t_n=n\Delta t, \qquad n=0,...,M.</script>

<p>with age step $\Delta a$ and time step $\Delta t$. Denoting, respectively, by $T^n$, $i^n_j$ and $V^n$  the numerical approximation of $T(t_n)$, $i(t_n,a_j)$ and $V(t_n)$, moreover,</p>

<p><script type="math/tex">\left(  \frac{\partial i}{\partial t} \right)_n \simeq \frac{i^{n+1}_j-i^n_{j}}{\Delta t}, \qquad \left(  \frac{\partial i}{\partial a} \right)_j \simeq \frac{i^n_j-u^n_{j-1}}{\Delta a}.</script> we thus obtain the difference scheme of hyperbolic PDE</p>

<script type="math/tex; mode=display">i^{n+1}_j=(1-\lambda) i^n_j +\lambda i^n_{j-1}+ \Delta t \delta(a_j) i^n_j, \quad n=0,...,M-1, \text{ and } j=0,...,N.</script>

<p>with $\lambda = \frac{\Delta t}{\Delta a}$. We fix the following values of parameters</p>

<script type="math/tex; mode=display">A_0=2, \qquad \mu=0.04\qquad \mu_c=0.5 \qquad \text{and} \qquad \delta =0.4,</script>

<p>with the initial conditions</p>

<script type="math/tex; mode=display">T_0=20, \qquad  V_0=5 \qquad \text{and} \qquad i_0(a)=4 e^{-0.3 a}.</script>

<p>The functions $p$ is given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*} p(a)=\left\{ \begin{array}{lll} 0, & \text{ if } a\leq \tau_1, \\ 0.4, & \text{ if } a> \tau_1, \end{array} \right. \end{equation*} %]]></script>

<p>We change the values of $\tau_1$ in order to have $R_0 \leq 1$ or to have $R_0 &gt; 1$.  If we choose $ \tau_1 = 3 $ then $ R_0 = 0.5417 &lt; 1 $,</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/SIV.png" alt="" /> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/Infected.png" alt="" /></p>

<p>And if we choose $ \tau_1 = 0.5 $ then $ R_0 = 1.4216 &gt; 1 $,</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/SIVend.png" alt="" /> <img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/Infectedend.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clear</span> <span class="nb">all</span><span class="p">,</span><span class="nb">close</span> <span class="nb">all</span>
<span class="n">a1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">a2</span><span class="o">=</span><span class="mi">60</span><span class="p">;</span>
<span class="n">Tf</span><span class="o">=</span><span class="mi">300</span><span class="p">;</span>
<span class="n">I0</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="mi">4</span><span class="o">*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.3</span><span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="n">T0</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span>
<span class="n">V0</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
<span class="n">A0</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.02</span><span class="p">;</span> <span class="n">muc</span><span class="o">=</span><span class="mf">0.4</span><span class="p">;</span>
<span class="nb">beta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">;</span>
<span class="n">alpha1</span><span class="o">=</span><span class="mf">0.1</span><span class="p">;</span>
<span class="n">alpha2</span><span class="o">=</span><span class="mf">0.2</span><span class="p">;</span>
<span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">;</span>
<span class="n">fct</span><span class="o">=@</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">beta</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)/(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha1</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">alpha2</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="n">N</span><span class="o">=</span><span class="mi">199</span><span class="p">;</span><span class="n">M</span><span class="o">=</span><span class="mi">1200</span><span class="p">;</span>
<span class="n">h</span><span class="o">=</span><span class="p">(</span><span class="n">a2</span><span class="o">-</span><span class="n">a1</span><span class="p">)/</span><span class="n">N</span><span class="p">;</span>
<span class="n">k</span><span class="o">=</span><span class="n">Tf</span><span class="p">/</span><span class="n">M</span><span class="p">;</span>
<span class="n">a</span><span class="o">=</span><span class="n">a1</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">h</span><span class="p">;</span>
<span class="n">ap</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">];</span>
<span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">M</span><span class="p">)</span><span class="o">*</span><span class="n">k</span><span class="p">;</span>
<span class="n">lambda</span><span class="o">=</span><span class="n">k</span><span class="p">/</span><span class="n">h</span><span class="p">;</span>
<span class="n">C</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="n">A</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">lambda</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">+</span><span class="n">lambda</span><span class="o">*</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>The reproduction number $R_0$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">R0</span><span class="o">=</span><span class="n">tauxR</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="nb">beta</span><span class="p">,</span><span class="n">muc</span><span class="p">,</span><span class="n">mu</span><span class="p">,</span><span class="n">A0</span><span class="p">,</span><span class="n">alpha1</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
R0 =

    1.4216


</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">T0</span><span class="p">;</span>
<span class="n">V</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">V0</span><span class="p">;</span>
<span class="n">U</span><span class="o">=</span> <span class="n">I0</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">))</span><span class="o">'</span><span class="p">;</span>  <span class="c1">%% initial values</span>
<span class="n">Up</span><span class="o">=</span><span class="p">[</span><span class="n">fct</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span><span class="n">V0</span><span class="p">);</span> <span class="n">U</span><span class="p">];</span> <span class="c1">%% Initial value + Boundary condition</span>
<span class="n">Uf</span><span class="o">=</span><span class="n">Up</span><span class="p">;</span>

<span class="n">F</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="n">UI</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="p">);;</span>

<span class="k">for</span> <span class="nb">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">M</span>
    <span class="n">Uold</span><span class="o">=</span><span class="n">U</span><span class="p">;</span>
      <span class="n">UI</span><span class="p">(</span><span class="nb">j</span><span class="p">)</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="n">fct</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="nb">j</span><span class="p">),</span><span class="n">V</span><span class="p">(</span><span class="nb">j</span><span class="p">));</span>
    <span class="k">for</span> <span class="n">o</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="n">UI</span><span class="p">(</span><span class="nb">j</span><span class="p">)</span><span class="o">=</span><span class="n">UI</span><span class="p">(</span><span class="nb">j</span><span class="p">)</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">Uold</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="n">B</span><span class="o">=</span><span class="p">[</span><span class="n">lambda</span><span class="o">*</span><span class="n">fct</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="nb">j</span><span class="p">),</span><span class="n">V</span><span class="p">(</span><span class="nb">j</span><span class="p">))</span> <span class="p">;</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)];</span>
    <span class="n">F</span><span class="o">=-</span> <span class="n">delta</span><span class="o">*</span><span class="n">Uold</span> <span class="p">;</span>
    <span class="n">U</span><span class="o">=</span><span class="n">A</span><span class="o">*</span><span class="n">Uold</span><span class="o">+</span><span class="n">B</span><span class="o">+</span><span class="n">k</span><span class="o">*</span><span class="n">F</span><span class="p">;</span>
    <span class="n">val</span><span class="o">=</span><span class="nb">feval</span><span class="p">(</span><span class="o">@</span><span class="n">int</span><span class="p">,</span><span class="n">Uold</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">a</span><span class="p">);</span>
    <span class="n">T</span><span class="p">(</span><span class="nb">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">T</span><span class="p">(</span><span class="nb">j</span><span class="p">)</span><span class="o">+</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">A0</span><span class="o">-</span><span class="n">mu</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="nb">j</span><span class="p">)</span><span class="o">-</span><span class="n">fct</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="nb">j</span><span class="p">),</span><span class="n">V</span><span class="p">(</span><span class="nb">j</span><span class="p">)));</span>
    <span class="n">V</span><span class="p">(</span><span class="nb">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">V</span><span class="p">(</span><span class="nb">j</span><span class="p">)</span><span class="o">+</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">muc</span> <span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="nb">j</span><span class="p">));</span>
    <span class="n">Up</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">Up</span><span class="o">=</span><span class="p">[</span><span class="n">fct</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="nb">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">V</span><span class="p">(</span><span class="nb">j</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span> <span class="n">U</span><span class="p">];</span>
    <span class="n">Uf</span><span class="o">=</span><span class="p">[</span><span class="n">Uf</span><span class="p">,</span><span class="n">Up</span><span class="p">];</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code> <span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">[</span><span class="n">X</span> <span class="p">,</span> <span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span> <span class="n">ap</span> <span class="p">,</span><span class="n">t</span><span class="p">);</span>
 <span class="nb">mesh</span> <span class="p">(</span><span class="n">X</span> <span class="p">,</span> <span class="n">Y</span> <span class="p">,</span> <span class="n">Uf</span><span class="o">'</span><span class="p">)</span>
 <span class="nb">title</span><span class="p">(</span><span class="s1">'The evolution of solution i(t,a)'</span><span class="p">)</span>
 <span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Age'</span><span class="p">)</span>
 <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">)</span>
 <span class="nb">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
 <span class="nb">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">T</span><span class="s1">','</span><span class="n">b</span><span class="s1">',t,[UI UI(N+2)],'</span><span class="n">r</span><span class="s1">',t,V'</span><span class="p">,</span><span class="s1">'g'</span><span class="p">)</span>
 <span class="nb">legend</span><span class="p">(</span><span class="s1">'S(t)'</span><span class="p">,</span><span class="s1">'I(t)=\int i(t,a)da'</span><span class="p">,</span><span class="s1">'R(t)'</span><span class="p">)</span>
 <span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/copiaRM_01.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0008/copiaRM_02.png" alt="" /></p>

<h2 id="references">References</h2>

<p>[1]  R. J. De Boer C. L. Althaus. Dynamics of immune escape during hiv/siv infection, PloS Comput. Biol, 2008.</p>

<p>[2] F. Brauer and C. Castillo-Chavez. Mathematical Models in Population Biology and Epidemiology Springer, New York, 2000.</p>

<p>[3] L. Edsberg. Introduction to Computation and Modeling for Differential Equations, 2nd Edition. Wiley, 288 Pages, 2016.</p>

<p>[4] M. N. Frioui S. E. Miri, T. M. Touaoula. Unified lyapunov functional for an age-structured virus model with very general nonlinear infection response. J. Appl. Math. Comput, pages 1–27, 2017.</p>

<p>[5]  T. Kuniya J. Wang, R. Zhang.. Mathematical analysis for an age-structured hiv infection model with saturation infection rate, Elect. J. Diff. Eq, pages 1–19, 2015.</p>

<p>[6]  A. S. Perelson P. W. Nelson. Mathematical analysis of delay differential equation models of hiv-1 infection. Math. Biosc, 179, pages 73–94, 2002.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In [2], we analyzed the controllablity properties under non-negative control and state constraints of the following heat-like equation involving the fractional Laplacian on $(-1,1)$&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{frac_heat}
    \begin{cases}
        z_t+(-d_x^2)^s z = u\chi_{\omega}, & (x,t)\in (-1,1)\times(0,T)
        \\
        z = 0, & (x,t)\in (-1,1)^c\times(0,T)
        \\
        z(\cdot,0)=z_0, & x\in (-1,1).
    \end{cases}
\end{equation} %]]></script>

<p>In \ref{frac_heat}, $\omega\subset (-1,1)$ is the control region in which the distributed control $u$ acts. Moreover, we denote by $(-d_x^2)^s$ the fractional Laplace operator defined, for all $s\in(0,1)$, as the following singular integral</p>

<script type="math/tex; mode=display">(-d_x^2)^s z(x) := c_s \,P.V.\,\int_{\mathbb{R}} \frac{z(x)-z(y)}{|x-y|^{1+2s}}\,dy,</script>

<p>with $c_s$ an explicit normalization constant given by</p>

<script type="math/tex; mode=display">c_s = \frac{s2^{2s}\Gamma\left(\frac{1+2s}{2}\right)}{\sqrt{\pi}\Gamma(1-s)},</script>

<p>Gamma being the usual Euler Gamma function.</p>

<p>The main result we established are the following results:</p>

<ol>
  <li>
    <p>For any $s&gt;1/2$, there exists $T&gt;0$ such that the fractional heat equation \ref{frac_heat} is controllable to positive trajectories by means of a non-negative control $u\in L^\infty(\omega\times(0,T))$. Moreover, if the initial datum $z_0\geq 0$ is non-negative, we also have $z(x,t)\geq 0$ for every $(x,t)\in (-1,1)\times (0,T)$.</p>
  </li>
  <li>
    <p>If we define the minimal controllability time by</p>
  </li>
</ol>

<script type="math/tex; mode=display">\begin{align}
    T_{min}(z_0,\widehat{z}):= \inf\Big\{T>0:\exists\;\; 0\leq u\in L^\infty(\omega\times(0,T)) \\ \hspace{5cm} such\;that\; z(\cdot,0)=z_0\; and\; z(\cdot,T)=\widehat{z}(\cdot,T)\Big\},
\end{align}</script>

<p>we have $T_{min}&gt;0$.</p>

<ol>
  <li>For $T = T_{min}$, there exists a non-negative control $u\in \mathcal M(\omega\times(0,T_{min}))$, the space of Radon measures
on $\omega\times(0,T_{min})$, such that the corresponding solution $z$ of \ref{frac_heat} satisfies $z(x,T) = \widehat{z}(x,T)$ a.e.
in $(-1,1)$.</li>
</ol>

<p>These results extend to the fractional case the ones previously obtained by our team in the context of the linear and semi-linear heat equation (see our previous entries in the <strong>DyCon Blog</strong>, <a href="https://deustotech.github.io/DyCon-Blog//tutorial/wp03/P0001">WP3_P0001</a> and <a href="https://deustotech.github.io/DyCon-Blog//tutorial/wp03/P0002">WP3_P0002</a>).</p>

<p>In this post, we present some numerical development in order to find the minimal controllability time for the discretized
fractional heat equation with non-negative control constraint and to confirm our theoretical results.</p>

<p>In particular, we will consider the problem of steering the initial datum</p>

<script type="math/tex; mode=display">z_0(x) = \frac 12\cos\left(\frac \pi2 x\right)</script>

<p>to the target trajectroy $\widehat{z}$ solution of \ref{frac_heat} with initial datum</p>

<script type="math/tex; mode=display">\widehat{z}_0(x) = 6\cos\left(\frac \pi2 x\right)</script>

<p>and right-hand side $\widehat{u}\equiv 1$.</p>

<p>We choose $s=0.8$ and $\omega=(-0.3,0.8)\subset (-1,1)$ as the control region. The approximation of the minimal controllability time is obtained by solving the following constrained minimization problem.</p>

<script type="math/tex; mode=display">minimize\;T</script>

<p>subject to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
T>0
\\
z_t+(-d_x^2)^s z=u\chi_\omega, & a.\,e.\;in\; (-1,1)\times(0,T)
\\
z(\cdot,0)=z_0\geq 0, & a.\,e.\;in\; (-1,1)
\\
z\geq 0, & a.\,e.\;in\; (-1,1)\times(0,T)
\\
u\geq 0, & a.\,e.\;in\; \omega\times(0,T).
\end{cases} %]]></script>

<p>To solve this problem numerically, we employ the expert interior-point optimization routine <a href="https://github.com/coin-or/Ipopt">IpOpt</a> combined with automatic differentiation and the modeling language <a href="https://ampl.com/">AMPL</a>. The interest of using <strong>AMPL</strong> together with <strong>IpOpt</strong> is that the gradient of the cost function and the constraints is automatically generated. Solving problems with <strong>IpOpt</strong> and AMPL can be made online through the <a href="https://neos-server.org/neos/">NEOS</a> solvers.</p>

<p>To perform our simulations, we apply a FE method for the space discretization of the fractional Laplacian (see [1]) on a uniform space-grid</p>

<script type="math/tex; mode=display">x_i = -1 + \frac{2i}{N_x}, \quad i = 1,\ldots,N_x,</script>

<p>with $N_x=20$ . Moreover, we use an explicit Euler scheme for the time integration on the time-grid</p>

<script type="math/tex; mode=display">t_j = \frac{Tj}{N_t}, \quad j = 0,\ldots,N_t,</script>

<p>with $N_t$ satisfying the <strong>Courant-Friedrich-Lewy</strong> condition. In particular, we choose here $N_t=100$.</p>

<p>The AMPL code for solving this minimation problem is included below. In it, the matrices defining the dynamics are computed through specific functions implemented in <strong>Matlab</strong> and are given as parameters.</p>

<p>It is important to remark that we are interested in the controllability to the trajectory $\widehat{z}(\cdot,T)$ but, at the same time, $T$ is a variable in our code since it is the cost functional we aim to minimize. In view of that, our final target changes during the minimization process. Nevertheless this issue can be bypassed by taking advance of the linear nature of our equation and solving the <em>traslated</em> constrained minimization problem consisting in finding the minimial time for steering the inital datum $z_0-\widehat{z}_0$ by employing a control $u\geq\widehat{u}$ ($\widehat{z}_0$ and $\widehat{u}$ are the same given above).</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Minimal time for the constrained controllability of the fractional heat equation.</span>

<span class="c"># 1: define the parameters</span>

<span class="n">param</span> <span class="n">Nx</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>               <span class="c"># number of spatial discretization points</span>

<span class="n">param</span> <span class="n">Nt</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>              <span class="c"># number of time discretization points</span>

<span class="n">param</span> <span class="n">y0</span> <span class="p">{</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">};</span>            <span class="c"># initial condition</span>

<span class="n">param</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                <span class="c"># target</span>

<span class="n">param</span> <span class="n">dx</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">Nx</span><span class="p">;</span>             <span class="c"># Space step</span>

<span class="n">param</span> <span class="n">C</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                 <span class="c"># Bound on the controls</span>

<span class="n">param</span> <span class="n">A</span> <span class="p">{</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">};</span>       <span class="c"># Stiffness or rigidity matrix</span>

<span class="n">param</span> <span class="n">B</span> <span class="p">{</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">};</span>       <span class="c"># Control matrix</span>

<span class="n">param</span> <span class="n">M</span> <span class="p">{</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">};</span>       <span class="c"># Mass matrix  </span>

<span class="c"># 2: define the variables</span>

<span class="n">var</span> <span class="n">y</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">};</span>       <span class="c"># State</span>
<span class="n">var</span> <span class="n">u</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}</span><span class="o">&gt;=-</span><span class="n">C</span><span class="p">;</span>   <span class="c"># Control</span>
<span class="n">var</span> <span class="n">T</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span>                            <span class="c"># Time horizon</span>
<span class="n">var</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="n">Nt</span><span class="p">;</span>                        <span class="c"># Time step</span>

<span class="c"># 3: define the data</span>

<span class="n">data</span><span class="p">;</span>

<span class="c"># Initial datum</span>

<span class="n">param</span> <span class="n">y0</span><span class="p">:</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">20</span> <span class="p">:</span><span class="o">=</span>
<span class="mi">1</span> <span class="o">-</span><span class="mf">0.000000</span> <span class="o">-</span><span class="mf">0.905270</span> <span class="o">-</span><span class="mf">1.785847</span> <span class="o">-</span><span class="mf">2.617711</span> <span class="o">-</span><span class="mf">3.378170</span> <span class="o">-</span><span class="mf">4.046482</span> <span class="o">-</span><span class="mf">4.604416</span> <span class="o">-</span><span class="mf">5.036753</span> <span class="o">-</span><span class="mf">5.331701</span> <span class="o">-</span><span class="mf">5.481215</span> <span class="o">-</span><span class="mf">5.481215</span> <span class="o">-</span><span class="mf">5.331701</span> <span class="o">-</span><span class="mf">5.036753</span> <span class="o">-</span><span class="mf">4.604416</span> <span class="o">-</span><span class="mf">4.046482</span> <span class="o">-</span><span class="mf">3.378170</span> <span class="o">-</span><span class="mf">2.617711</span> <span class="o">-</span><span class="mf">1.785847</span> <span class="o">-</span><span class="mf">0.905270</span> <span class="o">-</span><span class="mf">0.000000</span><span class="p">;</span>

<span class="c"># Stiffness or rigidity matrix A</span>

<span class="n">param</span> <span class="n">A</span><span class="p">:</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">20</span> <span class="p">:</span><span class="o">=</span>
<span class="mi">1</span> <span class="o">-</span><span class="mf">5.551728</span> <span class="mf">2.242487</span> <span class="mf">0.359689</span> <span class="mf">0.077115</span> <span class="mf">0.033148</span> <span class="mf">0.017829</span> <span class="mf">0.010871</span> <span class="mf">0.007193</span> <span class="mf">0.005044</span> <span class="mf">0.003694</span> <span class="mf">0.002798</span> <span class="mf">0.002178</span> <span class="mf">0.001733</span> <span class="mf">0.001405</span> <span class="mf">0.001158</span> <span class="mf">0.000966</span> <span class="mf">0.000816</span> <span class="mf">0.000697</span> <span class="mf">0.000600</span> <span class="mf">0.000521</span>
<span class="o">...</span>
<span class="mi">20</span> <span class="mf">0.000521</span> <span class="mf">0.000600</span> <span class="mf">0.000697</span> <span class="mf">0.000816</span> <span class="mf">0.000966</span> <span class="mf">0.001158</span> <span class="mf">0.001405</span> <span class="mf">0.001733</span> <span class="mf">0.002178</span> <span class="mf">0.002798</span> <span class="mf">0.003694</span> <span class="mf">0.005044</span> <span class="mf">0.007193</span> <span class="mf">0.010871</span> <span class="mf">0.017829</span> <span class="mf">0.033148</span> <span class="mf">0.077115</span> <span class="mf">0.359689</span> <span class="mf">2.242487</span> <span class="o">-</span><span class="mf">5.551728</span><span class="p">;</span>
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Control matrix B</span>

<span class="n">param</span> <span class="n">B</span><span class="p">:</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">20</span> <span class="p">:</span><span class="o">=</span>
<span class="mi">1</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span>
<span class="o">...</span>
<span class="mi">20</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span><span class="p">;</span>
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Mass matrix M</span>

<span class="n">param</span> <span class="n">M</span><span class="p">:</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">20</span> <span class="p">:</span><span class="o">=</span>
<span class="mi">1</span> <span class="mf">0.070175</span> <span class="mf">0.017544</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span>
<span class="o">...</span>
<span class="mi">20</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.000000</span> <span class="mf">0.017544</span> <span class="mf">0.070175</span><span class="p">;</span>
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># 4: define the cost functional to minimize</span>

<span class="n">minimize</span> <span class="n">cost</span><span class="p">:</span> <span class="n">T</span><span class="p">;</span>

<span class="c"># 5: define the constraints</span>

<span class="c"># 5.a: dynamics y' = Ay + Bu, implemented through an Explicit Euler method.</span>

<span class="n">subject</span> <span class="n">to</span> <span class="n">y_dyn</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">2.</span><span class="o">.</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">}:</span>
<span class="nb">sum</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="nb">sum</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">]);</span>

<span class="c"># 5.b: homogeneous Dirichlet boundary conditions in -1 and 1.</span>

<span class="n">subject</span> <span class="n">to</span> <span class="n">left_boundary</span>  <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}:</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">right_boundary</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}:</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c"># 5.c: initial condition.</span>

<span class="n">subject</span> <span class="n">to</span> <span class="n">y_init</span> <span class="p">{</span><span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}:</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="c"># 5.d: target.</span>

<span class="n">subject</span> <span class="n">to</span> <span class="n">y_end1</span> <span class="p">{</span><span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}:</span> <span class="n">y</span><span class="p">[</span><span class="n">Nt</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1</span><span class="p">;</span>

<span class="c"># 6: solve the problem with IpOpt</span>

<span class="n">option</span> <span class="n">solver</span> <span class="n">ipopt</span><span class="p">;</span>
<span class="n">option</span> <span class="n">ipopt_options</span> <span class="s">"max_iter=100000 linear_solver=mumps hessian_approximation=exact halt_on_ampl_error yes"</span><span class="p">;</span>
<span class="n">solve</span><span class="p">;</span>

<span class="c"># 7: print the results.</span>

<span class="n">printf</span><span class="p">:</span> <span class="s">"T  = </span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">T</span><span class="p">;</span>
<span class="n">printf</span><span class="p">:</span> <span class="s">"Nx = </span><span class="si">%</span><span class="s">d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Nx</span><span class="p">;</span>
<span class="n">printf</span><span class="p">:</span> <span class="s">"Nt = </span><span class="si">%</span><span class="s">d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Nt</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}:</span> <span class="s">" </span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">Nx</span><span class="p">}:</span> <span class="s">" </span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">];</span>

<span class="n">end</span><span class="p">;</span>
</code></pre>
</div>

<p>Once the minimization is concluded, we save the results in a file “data.txt” and we use <strong>Matlab</strong> to reshape the solution and the control so to obtain two $N_x\times(N_t+1)$ matrices for the plots.</p>

<p>This can be done through the following script:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">close</span> <span class="nb">all</span>
<span class="c1">% Read the data from the external file data.txt</span>

<span class="n">fid</span><span class="o">=</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">'data.txt'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">);</span>
<span class="n">C</span> <span class="o">=</span> <span class="nb">fscanf</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="s1">'%f'</span><span class="p">,</span><span class="n">Inf</span><span class="p">);</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Nx</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">4</span><span class="p">:(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Nx</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">C</span><span class="p">((</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Nx</span><span class="o">+</span><span class="mi">4</span><span class="p">:</span><span class="k">end</span><span class="p">);</span>
<span class="nb">fclose</span><span class="p">(</span><span class="n">fid</span><span class="p">);</span>

<span class="c1">% Reshape the state y and the control u into two Nx times Nt+1 matrices</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">u</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>From the reshaped solution and control, we can generate the plots. For instance, the m-file plot_control.m is the one generating <strong>Figure 2</strong> below.</p>

<p>The minimal time that we obtain from our minimization process is $T_{min}\simeq 0,2101$. Our simulations show that in this time horizon the fractional heat equation \ref{frac_heat} is controllable from the initial datum $z_0$ to the desired trajectory $\widehat{z}(\cdot,T)$ by maintaining the positivity of the solution (as it is expected since the initial datum is positive in $(-1,1)$, see <strong>Figure 1</strong>).</p>

<h2><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/evolution_tmin.gif" alt="GitHub Logo" /></h2>
<p><strong>Figure 1</strong>. Controllability of the fractional heat equation \ref{frac_heat}in the minimal time $T_{min}=0.2101$.</p>

<p>Moreover, as it is observed also in <strong>Figure 2</strong>, the control has an impulsional behavior.</p>

<h2 id="-1"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/deltas.png" alt="GitHub Logo" /></h2>
<p><strong>Figure 2</strong>. Minimal-time control. In the $(t,x)$ plane in blue the time $t$ varies from $t = 0$ (left) to $t = T_{min}$ (right).</p>

<p>This behavior of the control is not surprising. Indeed, as it was already observed in our previous works [3,4], the minimal-time controls are expected to be atomic measures, in particular linear combinations of Dirac deltas. Our simulations are thus consistent with the aforementioned papers.</p>

<p>The impulsional behavior of the control is then lost when extending the time horizon beyond $T_{min}$. This is shown in <strong>Figure 3</strong>, in which we display the behavior of the control steering the solution of the fractional heat equation \ref{frac_heat} from the initial datum $z_0$ to the target $\widehat{z}(\cdot,T)$ in the time horizon $T=0.4$.</p>

<h2 id="-2"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/disposition_tlarge.png" alt="GitHub Logo" /></h2>
<p><strong>Figure 3</strong>. Behavior of the control in time $T = 0.4$. The white lines delimit the control region $\omega = (-0.3, 0.8)$. The regions in which the control is active are marked in yellow. The atomic nature is lost.</p>

<p>This control has been computed by employing once again <strong>IpOpt</strong> for solving the following minimization problem:</p>

<script type="math/tex; mode=display">\min\;\|z(\cdot,T)-\widehat{z}(\cdot,T)\|_{L^2(-1,1)}</script>

<p>subject to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
z_t+(-d_x^2)^s z=u\chi_\omega, & a.\,e.\;in\; (-1,1)\times(0,T)
\\
z(x,0)=z_0\geq 0, & a.\,e.\;in\; (-1,1)
\\
z(x,t)\geq 0, & a.\,e.\;in\; (-1,1)\times(0,T)
\\
u(x,t)\geq 0, & a.\,e.\;in\; \omega\times(0,T).
\end{cases} %]]></script>

<p>As we can observe, the action of this control is now more distributed in $\omega$. Neverthelss, in accordance with our theoretical results, the equation is still controllable in the prescribed time horizon (see <strong>Figure 4</strong>)</p>

<h2 id="-3"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/evolution_tlarge.gif" alt="GitHub Logo" /></h2>
<p><strong>Figure 4</strong>. Controllability of the fractional heat equation \ref{frac_heat}in time $T = 0.4$. The atomic behavior of the control is lost.</p>

<p>Finally, we consider the case of a time horizon $T&lt;T_{min}$, in which constrained controllability is expected to fail. This time, we employ a classical conjugate gradient method implemented in the <a href="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/https://deustotech.github.io/dycon-toolbox-documentation/">DyCon Computational Toolbox</a> for solving the above optimization problem.</p>

<p>As before, we apply a FE method for the space discretization of the fractional Laplacian on a uniform space-grid with $N_x=20$ points and we use an explicit Euler scheme for the time integration on a time-grid with $N_t=100$ points. Furthermore, we choose a time horizon $T=0.15$, which is below the minimal controllability time $T_{min}$.</p>

<p>Our simulation then show that the solution of \ref{frac_heat} fails to be controlled. In fact, <strong>Figure 5</strong> shows that the state computed by employing the tools of the <a href="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/https://deustotech.github.io/dycon-toolbox-documentation/">DyCon Computational Toolbox</a> does not totally match the desired target in the time horizon prescribed.</p>

<h2 id="-4"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP03/P0003/evolution_tsmall.gif" alt="GitHub Logo" /></h2>
<p><strong>Figure 5</strong>. Evolution in the time interval $(0,0.15)$ of the solution of \ref{frac_heat} with $s = 0.8$ under the positivity control constraint $u\geq 0$. The equation is not controllable.</p>

<h2 id="references">References</h2>

<p>[1] U. Biccari and V. Hernández-Santamarı́a, <em>Controllability of a one-dimensional fractional heat equation: theoretical and
numerical aspects</em>. IMA J. Math. Control. Inf, to appear, 2018.</p>

<p>[2] U. Biccari, M. Warma and E. Zuazua, <em>Controllability of the one-dimensional fractional heat equation under positivity constraints</em>. Submitted.</p>

<p>[3] J. Loheac, E. Trélat, and E. Zuazua, <em>Minimal controllability time for the heat equation under unilateral state or control
constraints</em>. Math. Models Methods Appl. Sci., Vol. 27, No. 9 (2017), pp 1587-1644.</p>

<p>[4] D. Pighin and E. Zuazua, <em>Controllability under positivity constraints of semilinear heat equations</em>. Math. Control. Relat.
Fields, Vol. 8, No. 3,4 (2018), pp. 935-964.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3 id="a-sample-result"&gt;A sample result&lt;/h3&gt;
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0005/ds.gif" alt="Figure1" /></p>

<p>This video describes an optimal control steering red dots(evaders) to the position $(4,4)$, which is calculated by IpOpt with AMPL. See <a href="https://deustotech.github.io/DyCon-Blog/tutorial/wp03/P0002">the post explaining IpOpt and AMPL</a> for detailed description.</p>

<h3 id="the-guidance-by-repulsion-model">The guidance-by-repulsion model</h3>

<p>Let $u_{ei}$ and $u_{dj}$ be the positions of the evaders $(i=1,\ldots,N)$ and drivers $(j=1,\ldots,M)$, respectively, in ${\mathbb R}^2$. We consider the following ODE system:</p>

<script type="math/tex; mode=display">\ddot{u}_{dj} = -f_d(|u_{dj} - u_{ec}|)(u_{dj} - u_{ec}) - \nu \dot{u}_{dj} + \kappa_j(t) (u_{dj} - u_{ec})^\perp,\quad u_{ec} := \frac{1}{N}\sum_{k=1}^N u_{ek},</script>

<script type="math/tex; mode=display">\ddot{u}_{ei} =  - \frac{1}{M} \sum_{j=1}^M f_e(|u_{dj} - u_{ei}|)(u_{dj} - u_{ei}) - \nu \dot{u}_{ei}, \\</script>

<script type="math/tex; mode=display">u_{dj}(0) = u_{dj}^0,~ u_{ei}(0) = u_{ei}^0,~ \dot{u}_{dj}(0) = v_{dj}^0, ~ \dot{u}_{ei}(0) = v_{ei}^0,</script>

<p>where $\kappa_j(t)$ is the control interface and the interaction functions are given by</p>

<script type="math/tex; mode=display">f_d(r) = \frac{2}{r^2}-\frac{3}{r^4}+2,\quad f_e(r) = \frac{1}{r^2} \quad\text{and}\quad \nu = 2.</script>

<p>In the dynamics, the evaders always get forced from all of the drivers, while the drivers wants to keep a stable distance ($f_d(1)-f_e(1)=0$). By choosing proper $\kappa_j(t)$, we wants to steer the evaders into a predetermined region.</p>

<p>The objective of the control is given by the cost function with the fixed final time $t_f&gt;0$,</p>

<script type="math/tex; mode=display">J(\kappa_1(\cdot),\ldots,\kappa_M(\cdot)) = \frac{1}{N} \sum_{i=1}^N |u_{ei}(t_f) - u_f|^2 + \frac{\delta_1}{M} \sum_{k=1}^M \int_0^{t_f} |\kappa_k(t)|^2 dt,</script>

<p>where $\delta_1$ is a regularization coefficient, $0.1$ in this post.</p>

<h3 id="ampl-code-for-solving-the-optimal-control-problem">AMPL code for solving the optimal control problem</h3>

<p>Let us explain an AMPL code step by step. First, we need to set relative parameters.</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># GBR_fixedtime.mod</span>

<span class="c"># This file solves the Guidance-by-repulsion model with 2 drivers and 16 evaders to </span>

<span class="c"># the target point [4;4] in a fixed final time T=10.</span>

<span class="c"># Define the parameters of the problem</span>

<span class="n">param</span> <span class="n">pi</span>      <span class="o">=</span> <span class="mf">3.141592653589793238462643</span><span class="p">;</span> 

<span class="n">param</span> <span class="n">Nt</span>      <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>      <span class="c"># number of discretized points in time</span>

<span class="n">param</span> <span class="n">M_sqrt</span>  <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>        <span class="c"># sqrt of Number of evaders</span>

<span class="n">param</span> <span class="n">M_e</span>     <span class="o">=</span> <span class="n">M_sqrt</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span> <span class="c"># Number of evaders</span>

<span class="n">param</span> <span class="n">M_d</span>     <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>        <span class="c"># Number of drivers</span>

<span class="n">param</span> <span class="n">T</span>       <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="n">param</span> <span class="n">M_kappa</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>        <span class="c"># Bound on the control</span>

<span class="c"># Target point</span>

<span class="n">param</span> <span class="n">uf1</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">param</span> <span class="n">uf2</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</code></pre>
</div>

<p>For the initial condition, we use uniform distribution of evaders in a square $[-1,1]\times[-1,1]$, and the drivers are in a circle with radius $5$.</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Initial values</span>

<span class="n">param</span> <span class="n">ue_zero</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">};</span>
<span class="k">for</span> <span class="p">{</span><span class="n">k1</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_sqrt</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_sqrt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">{</span>
	<span class="n">let</span> <span class="n">ue_zero</span><span class="p">[</span><span class="n">M_sqrt</span><span class="o">*</span><span class="p">(</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">k2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="p">((</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">M_sqrt</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">let</span> <span class="n">ue_zero</span><span class="p">[</span><span class="n">M_sqrt</span><span class="o">*</span><span class="p">(</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">k2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="p">((</span><span class="n">k2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">M_sqrt</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">param</span> <span class="n">ud_zero</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">};</span>
<span class="k">for</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">{</span>
	<span class="n">let</span> <span class="n">ud_zero</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">M_d</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">let</span> <span class="n">ud_zero</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">M_d</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="c"># State variables</span>

<span class="n">var</span> <span class="n">ue</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">};</span>
<span class="n">var</span> <span class="n">ve</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">};</span>
<span class="n">var</span> <span class="n">ud</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">};</span>
<span class="n">var</span> <span class="n">vd</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">};</span>
<span class="n">var</span> <span class="n">uec</span> <span class="p">{</span><span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">M_e</span><span class="o">*</span><span class="p">(</span><span class="nb">sum</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">}</span> <span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]));</span>

<span class="c"># initialize</span>

<span class="n">subject</span> <span class="n">to</span> <span class="n">ue_init</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ue_zero</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">ud_init</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span> <span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ud_zero</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">vd_init</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span> <span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">ve_init</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span> <span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
<span class="n">let</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n">ue_zero</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">let</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n">ud_zero</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">let</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">let</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</code></pre>
</div>
<p>For the initial guess, we also put the initial data for the whole timeline. If we don’t specify this, then the default values are zero, which can make redundant errors or iterations.</p>

<p>Now, we define the controls and cost.</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># The control function</span>

<span class="n">var</span> <span class="n">kappa</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">},</span> <span class="n">default</span> <span class="mf">2.8</span><span class="p">;</span>  
<span class="n">subject</span> <span class="n">to</span> <span class="n">kappa_bounds</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}</span> <span class="p">:</span> <span class="o">-</span><span class="n">M_kappa</span> <span class="o">&lt;=</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">M_kappa</span><span class="p">;</span>
<span class="c"># initial guess on control</span>

<span class="n">let</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mf">2.8</span><span class="p">;</span>

<span class="c"># The cost function</span>

<span class="n">minimize</span> <span class="n">cost</span><span class="p">:</span> 
 <span class="mi">1</span><span class="o">/</span><span class="n">M_e</span><span class="o">*</span><span class="p">(</span><span class="nb">sum</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">}</span> <span class="p">((</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">uf1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">uf2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">/</span><span class="n">M_d</span><span class="o">/</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="nb">sum</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}</span> <span class="p">((</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span> <span class="p">);</span>
</code></pre>
</div>
<p>The dynamics need to be described in the form of restriction condition of states and control variables. In order to avoid divide-by-zero, we additionally put the restriction on the distance. Since our equation has unbounded interaction kernels, it is convenient to use Euler’s forward method. Backward or central method may result unexpected high velocities by closing to the infinite values.</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Restriction on distance</span>

<span class="n">subject</span> <span class="n">to</span> <span class="n">distance</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mf">0.001</span><span class="p">;</span>
<span class="c"># Dynamics</span>

<span class="n">subject</span> <span class="n">to</span> <span class="n">ue_dyn</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">Nt</span><span class="o">/</span><span class="n">T</span> <span class="o">=</span> <span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">ud_dyn</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">Nt</span><span class="o">/</span><span class="n">T</span> <span class="o">=</span> <span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">ve_dyn</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">Nt</span><span class="o">/</span><span class="n">T</span> <span class="o">=</span> <span class="nb">sum</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">}</span> <span class="p">(</span> <span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="p">((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="p">)</span>  <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">vd1_dyn</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">Nt</span><span class="o">/</span><span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">5.5</span><span class="o">/</span><span class="p">((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="o">/</span><span class="p">(((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">vd2_dyn</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="p">:</span>
		<span class="p">(</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">Nt</span><span class="o">/</span><span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">5.5</span><span class="o">/</span><span class="p">((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="o">/</span><span class="p">(((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">uec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
</code></pre>
</div>
<p>The next step is to solve and get the output. It is convenient to describe the parameters of the problem to visualize later.</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Solve with IpOpt</span>

<span class="n">option</span> <span class="n">solver</span> <span class="n">ipopt</span><span class="p">;</span>
<span class="n">option</span> <span class="n">ipopt_options</span> <span class="s">"max_iter=20000 linear_solver=mumps hessian_approximation=limited-memory halt_on_ampl_error yes"</span><span class="p">;</span>
<span class="n">solve</span><span class="p">;</span>
<span class="c"># Display solution</span>

<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">T</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%</span><span class="s">d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Nt</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%</span><span class="s">d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">M_d</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%</span><span class="s">d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">M_e</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uf1</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uf2</span><span class="p">;</span>

<span class="n">printf</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">}</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kappa</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ue</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ud</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">k</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">{</span><span class="n">l</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="n">M_d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">.</span><span class="n">Nt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">2</span><span class="p">}</span> <span class="p">:</span> <span class="s">"</span><span class="si">%24.16</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">vd</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
<span class="n">printf</span> <span class="p">:</span> <span class="s">"End. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">end</span><span class="p">;</span>

</code></pre>
</div>

<p>Finally, we used MATLAB to show the trajectories. After copying the result to a file ‘output.txt’, we read it with the following code.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">fid</span><span class="o">=</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">'output.txt'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">);</span>            <span class="c1">% Open out.txt</span>
<span class="n">temp</span> <span class="o">=</span> <span class="nb">fscanf</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="s1">'%f'</span><span class="p">);</span>
<span class="n">M_d</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">M_e</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">index1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">M_d</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">M_e</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">uf1</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">uf2</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="n">M_d</span><span class="o">*</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">kappa</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">:</span><span class="n">index2</span><span class="p">);</span> <span class="n">kappa</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span> <span class="p">[</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span> <span class="n">M_d</span><span class="p">]);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">M_e</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">ue</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">:</span><span class="n">index2</span><span class="p">);</span> <span class="n">ue</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">ue</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span> <span class="n">M_e</span><span class="p">]);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">M_d</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">ud</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">:</span><span class="n">index2</span><span class="p">);</span> <span class="n">ud</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">ud</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span> <span class="n">M_d</span><span class="p">]);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">M_e</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">ve</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">:</span><span class="n">index2</span><span class="p">);</span> <span class="n">ve</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">ve</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span> <span class="n">M_e</span><span class="p">]);</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">index2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">index1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">M_d</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">vd</span> <span class="o">=</span> <span class="n">temp</span><span class="p">(</span><span class="n">index1</span><span class="p">:</span><span class="n">index2</span><span class="p">);</span> <span class="n">vd</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">vd</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span> <span class="n">M_d</span><span class="p">]);</span> 
<span class="n">index2</span> <span class="o">==</span> <span class="nb">length</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>      <span class="c1">% Check the file is properly read.</span>
<span class="n">tline</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

<span class="nb">fclose</span><span class="p">(</span><span class="n">fid</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="c1">%% Cost calculation</span>

<span class="n">u_f</span> <span class="o">=</span> <span class="p">[</span><span class="n">uf1</span><span class="p">;</span><span class="n">uf2</span><span class="p">];</span>
<span class="n">Final_Time</span> <span class="o">=</span> <span class="n">tline</span><span class="p">(</span><span class="k">end</span><span class="p">);</span>
<span class="n">Final_Position</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">ue</span><span class="p">(:,</span><span class="k">end</span><span class="p">,:),[</span><span class="mi">2</span> <span class="n">M_e</span><span class="p">]);</span>
<span class="n">Final_cost</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">Final_Position</span><span class="p">(</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">-</span> <span class="n">u_f</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">Final_Position</span><span class="p">(</span><span class="mi">2</span><span class="p">,:)</span> <span class="o">-</span> <span class="n">u_f</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span> <span class="p">)/</span><span class="n">M_e</span><span class="p">;</span>
<span class="n">Running_cost</span> <span class="o">=</span> <span class="mf">0.001</span><span class="o">*</span><span class="nb">trapz</span><span class="p">(</span><span class="n">tline</span><span class="p">,</span><span class="nb">mean</span><span class="p">(</span><span class="n">kappa</span><span class="p">(:,</span><span class="mi">1</span><span class="p">:</span><span class="n">M_d</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))/</span><span class="n">M_d</span><span class="p">;</span>

<span class="c1">%% Visualize the trajectories</span>

<span class="n">f1</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">(</span><span class="s1">'position'</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">400</span><span class="p">]);</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">M_d</span>
	<span class="nb">plot</span><span class="p">(</span><span class="n">ud</span><span class="p">(</span><span class="mi">1</span><span class="p">,:,</span><span class="n">k</span><span class="p">),</span><span class="n">ud</span><span class="p">(</span><span class="mi">2</span><span class="p">,:,</span><span class="n">k</span><span class="p">),</span><span class="s1">'b--'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mf">1.3</span><span class="p">);</span>
<span class="k">end</span>
<span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">M_e</span>
	<span class="nb">plot</span><span class="p">(</span><span class="n">ue</span><span class="p">(</span><span class="mi">1</span><span class="p">,:,</span><span class="n">l</span><span class="p">),</span><span class="n">ue</span><span class="p">(</span><span class="mi">2</span><span class="p">,:,</span><span class="n">l</span><span class="p">),</span><span class="s1">'r-'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mf">1.5</span><span class="p">);</span>
<span class="k">end</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'abscissa'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'ordinate'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">([</span><span class="s1">'Position error = '</span><span class="p">,</span> <span class="nb">num2str</span><span class="p">(</span><span class="n">Final_cost</span><span class="p">)])</span>
<span class="nb">grid</span> <span class="n">on</span>
</code></pre>
</div>

<p>Then, one can get the following trajectories and optimal control solution.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0005/D2E16_figure.png" alt="Figure1" /></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">tline</span><span class="p">,</span><span class="n">kappa</span><span class="s1">','</span><span class="n">LineWidth</span><span class="o">'</span><span class="p">,</span><span class="mf">1.3</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Control \kappa(t)'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">([</span><span class="s1">'Total Time = '</span><span class="p">,</span><span class="nb">num2str</span><span class="p">(</span><span class="n">tline</span><span class="p">(</span><span class="k">end</span><span class="p">)),</span><span class="s1">' and running cost = '</span><span class="p">,</span><span class="nb">num2str</span><span class="p">(</span><span class="n">Running_cost</span><span class="p">)])</span>
<span class="nb">grid</span> <span class="n">on</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0005/D2E16_control.png" alt="Figure2" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3 id="a-coupled-pde-ode-model"&gt;A coupled PDE-ODE model&lt;/h3&gt;
</code></pre>
</div>
<p>We consider the following hybrid PDE-ODE model</p>

<script type="math/tex; mode=display">% <![CDATA[
\left\{
\begin{array}{ll} 
    \partial_t \rho(t,x) + \partial_x (f(\rho(t,x)))=0, & (t,x)\in R^+\times R, \quad \quad \quad \quad \text{(1a)} \\ 
    \rho(0,x)=\rho_{0}(x), & x\in R,\quad \quad \quad \quad \quad \quad \quad \quad \,\text{(1b)}\\
    \dot y_i(t)=v (\rho(t,y_i(t)+))), & t\in R^+, i=1,\cdots,M,\quad \,   \, \, \,\text{(1c)}\\
    y_i(0)=y_0^i, & i=1,\cdots,M.\quad \, \quad \quad \quad \quad \text{(1d)}\\
\end{array}
\right. %]]></script>

<p>Above, (1a) and (1b) consists  of  a  scalar  conservation proposed by Lighthill-Whitham-Richards law  modeling  the  evolution  of vehicular traffic. (1c) and (1d) represent the trajectory of autonomous vehicles. <script type="math/tex">\rho</script> stands for the density of cars and  the flux function <script type="math/tex">f</script> is defined by <script type="math/tex">f(\rho)=\rho v(\rho)</script> with the average speed <script type="math/tex">v(\rho)=1-\rho</script>.</p>

<p>We assume that <script type="math/tex">\bar \rho_0</script> is an unknown function and our goal is to find a time <script type="math/tex">T</script> at which it is possible to reconstruct the true density <script type="math/tex">\rho</script> between two autonomous vehicles based only on the measured local density of each autonomous vehicle.</p>

<p>We introduce the two following operators</p>
<ul>
  <li><script type="math/tex">S_t(\rho_0)(x)</script> is the solution of (1a) at time <script type="math/tex">t</script> and at the position <script type="math/tex">x</script> with initial density <script type="math/tex">\rho_0</script></li>
  <li><script type="math/tex">\Gamma(\rho_0)=(\rho(\cdot,y_i(\cdot)\pm))_{i\in\{1,\cdots,M\}}</script> where <script type="math/tex">(\rho,y_i)</script> is the solution of (1) with initial data <script type="math/tex">\rho_0</script>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/shocksurj11.png" alt="" /></th>
      <th style="text-align: center"> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/shocksurj22.png" alt="" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Figure 1.1 - <script type="math/tex">\rho_0(x)=0.16</script> if <script type="math/tex">% <![CDATA[
x<1.33 %]]></script> and <script type="math/tex">\rho_0(x)=0.63</script> if <script type="math/tex">x>1.33</script> with two autonomous vehicles positioned at <script type="math/tex">y_0^1=0</script> and <script type="math/tex">y_0^2=3</script>.</td>
      <td style="text-align: center"> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>Figure 1.2 - <script type="math/tex">\rho_1(x)=0.16</script> if <script type="math/tex">% <![CDATA[
x<1 %]]></script> and <script type="math/tex">\rho_0(x)=0.47</script> if <script type="math/tex">% <![CDATA[
1<x<2 %]]></script> and <script type="math/tex">\rho_0(x)=0.63</script> if <script type="math/tex">% <![CDATA[
2<2 %]]></script> with two connected vehicles positioned at <script type="math/tex">y_0^1=0</script> and <script type="math/tex">y_0^2=3</script></td>
    </tr>
  </tbody>
</table>

<p>In Figure 1.1 and Figure 1.2, we construct two initial data <script type="math/tex">\rho_0</script> and <script type="math/tex">\rho_1</script> such that <script type="math/tex">\Gamma(\rho_0)=\Gamma(\rho_1)</script> and for every <script type="math/tex">% <![CDATA[
t < 2 %]]></script> , for every <script type="math/tex">x\in[y_1(t),y_2(t)]</script> , <script type="math/tex">S_T(\rho_0)(x) \neq S_T(\rho_1))(x)</script>. Thus, there isn’t backward uniqueness from the trajectory of autonomous vehicles.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/example2_sol.png" alt="" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Figure 1.3 <script type="math/tex">\rho_0(x)=1</script> if <script type="math/tex">% <![CDATA[
x<10 %]]></script> and <script type="math/tex">\rho_0(x)=0</script> if <script type="math/tex">x>10</script> with two autonomous vehicles positioned at $x=8$ and $x=12$ respectively</td>
    </tr>
  </tbody>
</table>

<p>In Figure Figure 1.3, we cannot reconstruct the traffic state at any time using data collected by the two autonomous vehicles. Some additional conditions on the set of initial densities will be require.</p>

<p><strong>Theorem</strong> Let <script type="math/tex">\bar \rho_0 \in BV(R,[0,1])\cap L^1(R)</script> and we assume that for every <script type="math/tex">x\in R</script>, <script type="math/tex">% <![CDATA[
0<\rho_{\min}\leq  \bar \rho_0(x) \leq \rho_{\max} %]]></script>.  For every <script type="math/tex">i\in \{1,\cdots,M-1\}</script> there exists <script type="math/tex">T_i>0</script> such that for every <script type="math/tex">\rho_0 \in \Gamma^{-1}(\Gamma(\bar \rho_0))</script> and  for almost every <script type="math/tex">x\in [y_i(T_i),y_{i+1}(T_i)]</script> we have 
<script type="math/tex">S_{T_i}(\rho_0)(x)= S_{T_i}(\bar \rho_0)(x)</script></p>

<p>The reconstruction time <script type="math/tex">T_i</script> is obtained using the notion of generalized characteristics and <script type="math/tex">T_i</script> has an implicit form.</p>

<h3 id="numerical-simulations">Numerical simulations</h3>
<p>In  Figure 2.1 and  Figure 2.2, we consider the example of two shocks with a fan of rarefaction shocks between the two shocks. A total of three AVs, denoted  by <script type="math/tex">AV_0</script> , <script type="math/tex">AV_1</script> and <script type="math/tex">AV_2</script> , are used to reconstruct the traffic state resulting in two regions of reconstruction between <script type="math/tex">AV_0</script> and <script type="math/tex">AV_1</script> , and between <script type="math/tex">AV_1</script> and <script type="math/tex">AV_2</script> . Specifically, the initial density <script type="math/tex">\rho_0</script> is defined as follows : $\rho_0(x) = 0.0938 $ for $ x\in (-\infty, 8] $, $\rho_0(x) = 0.9062$ for <script type="math/tex">x\in (8, 10]</script>, <script type="math/tex">\rho_0(x) = 0.2188</script> for $x\in (10, 13]$ and $\rho_0(x) = 0.9062$ for <script type="math/tex">x\in (13, \infty)</script>. <script type="math/tex">AV_0</script> , <script type="math/tex">AV_1</script> , and <script type="math/tex">AV_2</script> start at <script type="math/tex">x=5</script> , <script type="math/tex">x=9</script> , and <script type="math/tex">x=12</script> , respectively. The resulting traffic state solved using wave front tracking over the first 20 seconds is shown in Figure 2.1, while the reconstructed state between the AVs is shown in Figure 2.2. The time at which the reconstruction becomes valid is <script type="math/tex">T_{0} = 6.87</script> between <script type="math/tex">AV_0</script> and <script type="math/tex">AV_1</script>, and <script type="math/tex">T_{1} = 3.39</script> between <script type="math/tex">AV_1</script> and <script type="math/tex">AV_2</script>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/paper_example_3_real_sol 2.png" alt="" /></th>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/paper_example_3_reconstruction 2.png" alt="" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Figure 2.1</td>
      <td style="text-align: center">Figure 2.2</td>
    </tr>
  </tbody>
</table>

<p>In  Figure 3.1 and Figure 3.2, one autonomous vehicle, denoted by <script type="math/tex">AV_0</script> , is deployed on a ring. The initial density <script type="math/tex">\rho_0</script> is a <script type="math/tex">10</script>-periodic function  defined as follows:  <script type="math/tex">\rho_0(x) = 0.8125</script> for <script type="math/tex">x\in (0,2)</script> , <script type="math/tex">\rho_0(x) = 0.3125</script> for <script type="math/tex">x\in (2, 10)</script> . Since <script type="math/tex">\rho</script> and <script type="math/tex">y_0</script> are also <script type="math/tex">10</script> periodic functions, both trajectories plotted in red in  Figure 3.2  are  the ones of <script type="math/tex">AV_0</script>. The traffic state on the whole ring can be reconstructed after <script type="math/tex">T_{\max}=15.444</script>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/example_ring_sol.png" alt="" /></th>
      <th style="text-align: center"><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0004/example_ring_reconstruction.png" alt="" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Figure 3.1</td>
      <td style="text-align: center">Figure 3.2</td>
    </tr>
  </tbody>
</table>

<h3 id="references">References</h3>
<p>[1] T.Liard, B. Piccoli, R. Stern, D. Work. <em>Traffic reconstruction using autonomous vehicles</em>; submitted (2019)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this short tutorial, we explain how to use Riccati’s theory to solve an LQ control problem with targets.&lt;/p&gt;
</code></pre>
</div>

<p>We consider the optimal control problem:</p>

<script type="math/tex; mode=display">\min_{u\in L^2(0,T;\mathbb{R}^m)}J^{T}(u)=\frac12 \left[ \int_0^T  \vert u(t)-q(t) \vert ^2 dt+\beta\int_0^T  \vert C(x(t)-z(t))\vert ^2 dt+\gamma \vert D(x(T)-z(T))\vert ^2\right],</script>

<p>where:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} \frac{d}{dt}x(t)+Ax(t)=Bu(t)\hspace{0.6 cm} & t\in (0,T)\\ x(0)=x_0. \end{cases} %]]></script>

<p>In the above control problem, $A \in M_{n \times n}$, $B \in M_{n \times m}$, $C \in M_{r\times n}$ and $D\in M_{r\times n}$. The control $u:[0,T]\longrightarrow R^m$, while the state $x:[0,T]\longrightarrow R^n$. The control target is $q\in C^1([0,T];R^m)$ and the state target is $z\in C^1([0,T];R^n)$. $\beta\geq 0$ and $\gamma\geq 0$ are positive parameters.</p>

<p>By the Direct Methods in the Calculus of Variations and strict convexity, the above problem admits an unique optimal control $u^T$. The corresponding optimal state is denoted by $x^T$.</p>

<p>We compute the optimal pair (optimal control, optimal state) by using the well-known Riccati’s theory (see, for instance, [1, Lemma 2.6] and [2, section 4.3]).</p>

<p>For further details regarding the algorithm, we refer to <a href="a">href=”https://github.com/DeustoTech/RiccatiLQ/blob/master/RiccatiAlgorithm.pdf”</a> RiccatiAlgorithm <a href="/a">/a</a></p>

<p>Take</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">A</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
<span class="n">B</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">0</span><span class="p">];</span>
<span class="n">C</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">D</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">beta</span><span class="o">=</span><span class="mi">26</span><span class="p">;</span>
<span class="nb">gamma</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="mf">1.4</span><span class="p">;</span><span class="mf">1.4</span><span class="p">];</span>
<span class="n">q</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="n">z</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="nb">sin</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="nb">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)];</span>
<span class="n">T</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="n">Nt</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span>
</code></pre>
</div>

<p>We solve an LQ problem with the above data.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span> <span class="n">uopt</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">lqtarget</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="nb">beta</span><span class="p">,</span> <span class="nb">gamma</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Nt</span> <span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP02/P0003/copiaRM_01.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP02/P0003/copiaRM_02.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP02/P0003/copiaRM_03.png" alt="" /></p>

<p>Since the parameter $\beta$ is large enough and the control acts only on the first component of first equation</p>

<ul>
  <li>
    <p>the first component of the state is close to the target;</p>
  </li>
  <li>
    <p>the second component of the state is less close to the target;</p>
  </li>
  <li>
    <p>the control is far from its target.</p>
  </li>
</ul>

<p>The algorithm described in this guide can be employed to test the fulfillment of the turnpike property (see, for instance, [1] and [3]). In agreement with the theory, the turnpike effect is evident if:</p>

<ul>
  <li>
    <p>the targets are constants;</p>
  </li>
  <li>
    <p>$(A,B)$ is controllable;</p>
  </li>
  <li>
    <p>$(A,C)$ is observable, $\beta&gt;0$ and $\gamma=0$;</p>
  </li>
  <li>
    <p>the time horizon $T$ is large enough.</p>
  </li>
</ul>

<h1 id="references">References</h1>
<p>[1] Alessio Porretta and Enrique Zuazua, <em>Long time versus steady state optimal control</em>, SIAM Journal on Control and Optimization, 51 (2013).</p>

<p>[2] Emmanuel Trelat, control optimal: theory &amp; applications , Vuibert, 2008.</p>

<p>[3] Emmanuel Trelat and Enrique Zuazua, <em>The turnpike property in finite-dimensional nonlinear optimal control</em>, Journal of Differential Equations, 258 (2015).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;The aim of this tutorial is to give a numerical method for solving a partial differential equation with a constant delay.&lt;/p&gt;
</code></pre>
</div>

<h2 id="introduction">Introduction</h2>

<p>We consider the following one-dimentional reaction-diffusion equation with logistic production and delayed term,</p>

<script type="math/tex; mode=display">\frac{\partial u}{ \partial t} = D \frac{\partial^2 u}{\partial x^2} + r u( 1-u -  f(u_{\tau})),</script>

<p>this equation was suggested in [1] as a model of viral infection spreading in tissues. For the existence of solution and Global stability of the homogeneous in space equilibrium we refer the reader to [2]. Here, $u(x,t)$ is the concentration of virus with respect to the space variable $x$ and time $t$. The parameters $D$ and $r$ are respectively the diffusion coefficient and replication rate constant. The function $f(u_{\tau})$ describes the concentration of immune cells as a function of the virus concentration at time $t-\tau, u_{\tau}(x, t) = u(x, t - \tau)$.</p>

<h2 id="numerical-method">Numerical method</h2>

<p>We rewrite the one-dimentional reaction-diffusion equation with a constant time delay described above with Neumann boundary condition:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \begin{cases} \frac{\partial u}{ \partial t} = D \frac{\partial^2 u}{\partial x^2} + r u( 1-u -  f(u_{\tau})), & (x,t) \in (0,L) \times (0,T), \\ \frac{\partial u(x,t)}{ \partial n}=0, & x \in \{0,L\}, \quad t \in (0,T), \\ u(x,t)=u_0(x,t),     & (x,t) \in [0,L] \times [- \tau,0]. \end{cases} \label{equa1} \end{equation} %]]></script>

<p>where the delay $\tau$ is a positive constant. we use an implicit finite difference approximation for the diffusion term and classical approach of the resolution of delay equations.  let N and M denote the number of space steps and time steps with the notations $\Delta x= L/N$ and $\Delta t= T/M$, respectively.</p>

<p>The discretization of space $x_i$ and time $t_n$ are given by</p>

<script type="math/tex; mode=display">x_i=i\Delta x, \qquad i=0,...,N,</script>

<script type="math/tex; mode=display">t_n=n\Delta t, \qquad n=0,...,M.</script>

<p>Let $u^n_i$  be the approximation of the function $u$ at $(x,t)=(x_i,t_n)$, moreover,</p>

<script type="math/tex; mode=display">\left( \frac{\partial u}{ \partial t} \right)^{n+1}_i= \frac{u^{n+1}_i-u^{n}_i}{\Delta t}, \qquad \left( \frac{\partial^2 u}{ \partial x^2} \right)^{n+1}_i= \frac{u^{n+1}_{i+1}-2 u^{n+1}_i+u^{n+1}_{i-1}}{\Delta x},</script>

<p>We write the scheme of the equation (\ref{equa1}) at the point $u^n_i$,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} \frac{ u^{n+1}_i- u^n_i}{  \Delta t} = D \frac{u^{n+1}_{i+1}-2 u^{n+1}_i+u^{n+1}_{i-1}}{\Delta x} + r u^n_i( 1-u^n_i -  f(u^{n-k}_i)), & i=1,..,N-1, \quad n=0,..,M-1 \\ u^{n+1}_1=u^{n+1}_0, \quad u^{n+1}_{N}=u^{n+1}_{N-1} , & n=0,..,M-1, \\ u^{n-k}_i=u_0(x_i,t_n-\tau),     & i=0,..,N, \quad n=1,..,k.\\ \end{cases} %]]></script>

<p>Where, $u^{n-k}_i \approx u(x_i,t_n-\tau)$ is the delay variable and $k$ is determined by the equality $\tau= k \Delta t$. For simplicity of notation, we denote by $F^{n-k}_i := f(u^{n-k}_i)$ and $G^{n,k}_i:=r u^n_i( 1-u^n_i -  F^{n-k}_i)$, for $i=0,..,N-1, \quad n=1,..,k$ and $n=0,..,M-1$.</p>

<p>The simplest form of this expression is given as follows</p>

<script type="math/tex; mode=display">- \lambda u^{n+1}_{i+1} + (1+2\lambda) u^{n+1}_i - \lambda u^{n+1}_{i-1} = u^n_i + G^{n,k}_i, \text{ for } i=0,..,N-1,</script>

<p>where $\lambda= D \Delta t /(\Delta x)^2$.</p>

<p>Now, we can write the following semi-linear system with Neumann boundary condition</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*} \begin{array}{lll} \left( \begin{array}{ccccc} 1+\lambda 	&-\lambda	  &             &		\dots 		& 0		\\ -\lambda 		&1+2\lambda 	  		& -\lambda 	&    & 	\vdots	\\ \vdots		&\ddots       & \ddots		&       \ddots 		&	\\ &             &  -\lambda   &       1+2\lambda	& -\lambda	 \\ 0 & 		\dots		& 	&-\lambda	& 1+\lambda \end{array} \right) \left( \begin{array}{c} U_1 \\ U_2 \\ \vdots \\ \\ U_{N-2} \\ U_{N-1}	 . \end{array} \right)^{n+1} =  \left( \begin{array}{c} U_1 \\ U_2 \\ \vdots \\  \\  U_{N-2} \\ U_{N-1}	 .  \end{array} \right)^{n} +  \left( \begin{array}{c} G_1 \\ G_2 \\ \vdots \\ \\ G_{N-2} \\ G_{N-1}	 . \end{array} \right)^{n,k}


\end{array} \end{equation*} %]]></script>

<p>First, we fix the parametrs as follows $T=10$, $\tau=1$, $L=1$, $D=1$, $r=1$,</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clear</span> <span class="p">;</span>
<span class="nb">close</span> <span class="p">;</span>
<span class="nb">clc</span><span class="p">,</span>
<span class="nb">tic</span>
<span class="n">T</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="n">M</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span>
<span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">epsilon</span><span class="o">=</span><span class="mi">10</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">);</span>
<span class="n">D</span><span class="o">=</span><span class="mf">0.01</span><span class="p">;</span>
<span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">to</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="n">N</span><span class="o">=</span><span class="mi">200</span><span class="p">;</span>
<span class="n">dx</span><span class="o">=</span><span class="n">L</span><span class="p">/(</span><span class="n">N</span><span class="p">);</span>
<span class="n">dt</span><span class="o">=</span><span class="n">T</span><span class="p">/</span><span class="n">M</span><span class="p">;</span>
<span class="n">x</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="p">;</span>
<span class="n">lambda</span><span class="o">=</span><span class="n">dt</span><span class="o">*</span><span class="n">D</span><span class="p">/(</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
<span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">M</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">;</span>
</code></pre>
</div>

<p>The tridiagonal matrix with Neumann condition</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">C</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">D</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">lambda</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">-</span><span class="n">lambda</span><span class="o">*</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">lambda</span><span class="o">*</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">B</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="n">lambda</span><span class="p">;</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span> <span class="p">[</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="p">[</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="o">-</span><span class="n">lambda</span><span class="p">]];</span>
<span class="n">A</span><span class="o">=</span><span class="n">D</span><span class="o">+</span><span class="n">B</span><span class="p">;</span>
</code></pre>
</div>

<p>The initial function $u_0$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">U</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">U</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">u0</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="nb">i</span><span class="p">),</span><span class="mi">0</span><span class="p">);</span>
<span class="k">end</span>
<span class="nb">figure</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">U</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Initial function u_0(x)'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0007/copiaRM_01.png" alt="" /></p>

<p>The delay function $f(u_{\tau})$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">f</span><span class="o">=@</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span> <span class="p">;</span>
<span class="n">Q</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span>
 <span class="n">Q</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="nb">i</span><span class="p">))</span>   <span class="p">;</span>
<span class="k">end</span>

<span class="nb">figure</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'The function f'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0007/copiaRM_02.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Ut</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Fretard</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Uf</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Uf</span><span class="o">=</span><span class="n">U</span><span class="p">;</span>
</code></pre>
</div>

<p>We introduce the following test to get $u(x, t-\tau)$,</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">fig</span> <span class="o">=</span>        <span class="nb">figure</span><span class="p">;</span>
<span class="n">ax</span>  <span class="o">=</span> <span class="nb">axes</span><span class="p">(</span><span class="s1">'Parent'</span><span class="p">,</span><span class="n">fig</span><span class="p">,</span><span class="s1">'XLim'</span><span class="p">,[</span><span class="mi">0</span> <span class="n">L</span><span class="p">],</span><span class="s1">'YLim'</span><span class="p">,[</span><span class="mi">0</span> <span class="mf">1.1</span><span class="p">]);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XLabel</span><span class="o">.</span><span class="n">String</span> <span class="o">=</span> <span class="s1">'space'</span><span class="p">;</span>

<span class="c1">%%gif('pdedelay4.gif','frame',fig,'DelayTime',1)</span>
<span class="k">for</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">M</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">to</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">to</span><span class="p">)</span><span class="o">&lt;</span><span class="n">epsilon</span><span class="p">))</span>
        <span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">Ut</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">u0</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="nb">i</span><span class="p">),</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">to</span><span class="p">);</span>
            <span class="n">Fretard</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">Ut</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
        <span class="k">end</span>
    <span class="k">else</span>
        <span class="n">s</span><span class="o">=</span><span class="nb">floor</span><span class="p">((</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">to</span><span class="p">)/</span><span class="n">dt</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">Ut</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">Uf</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
            <span class="n">Fretard</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">Ut</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">Uold</span><span class="o">=</span><span class="n">U</span><span class="p">;</span>
    <span class="n">Ur</span><span class="o">=</span><span class="n">dt</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="n">Uold</span><span class="o">.*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Uold</span><span class="o">-</span><span class="n">Fretard</span><span class="p">);</span>
    <span class="n">U</span><span class="o">=</span><span class="n">A</span><span class="p">\(</span><span class="n">Uold</span><span class="o">+</span><span class="n">Ur</span><span class="p">);</span>
    <span class="c1">%%</span>
    <span class="c1">%% We plot the evolution of solution $u(x,t)$ at</span>
    <span class="c1">%% $t= \Delta t, \tau, 2 \tau, 3\tau, ...$,</span>
    <span class="c1">%% when $\tau=0$, we plot the solution for $t=5, 10, 15, ...$</span>
    <span class="c1">%%</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">dt</span><span class="p">)</span><span class="o">||</span> <span class="p">(</span><span class="nb">mod</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">to</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">to</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(((</span><span class="nb">mod</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="mi">5</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="n">M</span><span class="p">)))))</span>

        <span class="n">ll</span> <span class="o">=</span><span class="nb">line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">Uold</span><span class="p">,</span><span class="s1">'Color'</span><span class="p">,</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">'Parent'</span><span class="p">,</span><span class="n">ax</span><span class="p">);</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">Title</span><span class="o">.</span><span class="n">String</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'t='</span><span class="p">,</span><span class="nb">num2str</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))];</span>
        <span class="nb">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">%%gif;</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">Uf</span><span class="o">=</span><span class="p">[</span><span class="n">Uf</span><span class="p">,</span><span class="n">U</span><span class="p">];</span>
<span class="k">end</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0007/pdedelay4.gif" alt="" /></p>

<p>The solution $u(x,t)$ of PDE with delay</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">[</span><span class="n">X</span> <span class="p">,</span> <span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,[</span><span class="n">t</span><span class="p">]);</span>
<span class="nb">mesh</span> <span class="p">(</span><span class="n">X</span> <span class="p">,</span> <span class="n">Y</span> <span class="p">,</span> <span class="n">Uf</span><span class="o">'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'The evolution of solution u(x,t)'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0007/copiaRM_03.png" alt="" /></p>

<h2 id="references">References</h2>

<p>[1]  G.Bocharov, A. Meyerhans, N. Bessonov, S. Trofimchuk, V. Volpert. Spatiotemporal dynamics of virus infection spreading in tissues. PlosOne, December 20, 2016.</p>

<p>[2]   T. M. Touaoula, M. N. Frioui, N. Bessonov, V. Volpert Dynamics of solutions of a reaction-diffusion equation with delayed inhibition. Manuscript submitted for publication.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3 id="a-multiscale-geometrical-basis-for-variational-problems-in-mechanics"&gt;&lt;em&gt;A Multiscale Geometrical Basis for Variational Problems in Mechanics&lt;/em&gt;&lt;/h3&gt;
</code></pre>
</div>

<p>This tutorial introduces the notion of <em>structured deformation</em> and shows an easy one-dimensional example.</p>

<p>In the continuum theories of bodies deformations, it is necessary to account for mechanisms of different nature that happen at different length scales. These include</p>

<ul>
  <li>elastic deformations during which, once the load on the body is released, the original configuration is restored;</li>
  <li>plastic deformations, which involve a permanent macroscopic deformation after releasing the external load. This permanent macroscopic deformation is explained by means of the reorganisation of atomic bonds;</li>
  <li>fractures, which involve rupture of the material both at the microscopic and at the macroscopic length scales.</li>
</ul>

<p>Structured deformations <a href="#DPO1993">[DPO1993]</a> provide a multiscale geometry that captures the contributions at the macroscopic level of both smooth and non-smooth geometrical changes at sub-macroscopic levels. The latter are called <em>disarrangements</em>. <br />
To encode information of phenomena happening at different length scales in one mathematical object, a (first-order) structured deformation is defined as a pair <script type="math/tex">(g,G)</script>, where <script type="math/tex">g</script> is the macroscopic deformation, the tensor field <script type="math/tex">G</script> is a measure of deformations without disarrangements (the smooth microscopic deformation), and <script type="math/tex">M:=\nabla g-G</script> is a measure of deformations due to disarrangements (the smooth microscopic deformation).
<br />
One can recover the standard notions of plastic deformation from <script type="math/tex">G</script> and <script type="math/tex">M</script>, as well as information on the Burgers vector field associated with closed
curves in the body and the dislocation density field used in describing geometrical changes in bodies with defects from <script type="math/tex">M</script> and <script type="math/tex">\mathrm{curl}M</script> <a href="O2017">[O2017]</a>.</p>

<p>Structured deformations have been set in an energetic formulation framework <a href="#CF1997">[CF1997]</a>, therefore rendering them apt to be studied with variational techniques. In this context, considering suitable function spaces was fundamental to give <script type="math/tex">(g,G)</script> citizenship in the realm of the calculus of variations. The functional-analytic choice of the space <script type="math/tex">SD(\Omega;\mathbb{R}^d)</script>, the set of <script type="math/tex">\mathbb{R}^d</script>-valued structured deformations on <script type="math/tex">\Omega\subset\mathbb{R}^N</script>, was dictated by the necessity of treating the non-smooth behaviours described by the disarrangement tensor <script type="math/tex">M</script>. Being able to describe the discontinuities of the deformation suggested that a good space for <script type="math/tex">g</script> be <script type="math/tex">SBV(\Omega;\mathbb{R}^d)</script>, the space of <script type="math/tex">\mathbb{R}^d</script>-valued <em>special functions of bounded variation</em>. Consequently, the matrix-valued field <script type="math/tex">G</script> is assumed to live in <script type="math/tex">L^1(\Omega;\mathbb{R}^{d\times N})</script>, so that</p>

<script type="math/tex; mode=display">SD(\Omega;\mathbb{R}^d):= SBV(\Omega;\mathbb{R}^d) \times L^1(\Omega;\mathbb{R}^{d\times N}).</script>

<h3 id="aside-on-bv-functions">Aside on <script type="math/tex">BV</script> functions</h3>
<p>Functions of bounded variation are integrable functions whose distributional derivative is a finite Radon measure, in symbols</p>

<script type="math/tex; mode=display">BV(\Omega;\mathbb{R}^d):=\big\{u\in L^1(\Omega;\mathbb{R}^d): Du\in\mathcal{M}(\Omega;\mathbb{R}^{d\times N})\big\}.</script>

<p>It is known that the distributional derivative <script type="math/tex">Du</script> admits a decomposition into three pieces, namely an absolutely continuous part with respect to the Lebesgue measure <script type="math/tex">\mathcal{L}^N</script>, whose density is given by the gradient <script type="math/tex">\nabla u</script>; a jump part, which is concentrated on an <script type="math/tex">(N-1)</script>-dimensional set <script type="math/tex">S_u</script> and whose density with respect to the Hausdorff measure <script type="math/tex">\mathcal{H}^{N-1}</script> is given by <script type="math/tex">[u]\otimes\nu_u</script> (<script type="math/tex">[u]</script> being the jump of <script type="math/tex">u</script> across the <em>singular set</em> <script type="math/tex">S_u</script>, and <script type="math/tex">\nu_u</script> being the normal vector to <script type="math/tex">S_u</script>); and a part <script type="math/tex">D^c u</script> which is singular with respect to both <script type="math/tex">\mathcal{L}^N</script> and <script type="math/tex">\mathcal{H}^{N-1}</script>, called the <em>Cantor part</em>. To summarise,</p>

<script type="math/tex; mode=display">Du=\nabla u\mathcal{L}^N+[u]\otimes\nu_u\mathcal{H}^{N-1}\lfloor S_u+D^c u.</script>

<p>Special functions of bounded variations are those whose distributional derivative has no Cantor part,</p>

<script type="math/tex; mode=display">SBV(\Omega;\mathbb{R}^d):=\big\{u\in BV(\Omega;\mathbb{R}^d): D^c u=0\big\},</script>

<p>so that, for <script type="math/tex">u\in SBV(\Omega;\mathbb{R}^d)</script> we have <script type="math/tex">Du=\nabla u\mathcal{L}^N+[u]\otimes\nu_u\mathcal{H}^{N-1}\lfloor S_u</script>.</p>

<p><br /></p>

<p>One of the fundamental results contained in the seminal paper <a href="#DPO1993">[DPO1993]</a> is the <em>Approximation Theorem</em>, stating that any structured deformation <script type="math/tex">(g,G)</script> can be approximated by a sequence of simple deformations; in the language of <a href="#CF1997">[CF1997]</a>, the approximation theorem reads
<br />
<strong>Approximation Theorem</strong>: <em>Given <script type="math/tex">(g,G)\in SD(\Omega;\mathbb{R}^d)</script>, there exists a sequence <script type="math/tex">u_n\in SBV(\Omega;\mathbb{R}^d)</script> such that</em></p>

<script type="math/tex; mode=display">u_n\to g\quad \text{in $L^1(\Omega;\mathbb{R}^d)$} \qquad \text{and} \qquad \nabla u_n\stackrel{*}{\rightharpoonup}G\quad \text{in $\mathcal{M}(\Omega;\mathbb{R}^{d\times N})$.}</script>

<p>Given the structure of the distributional derivative, it is not difficult to see that the singular part <script type="math/tex">D^s u</script> of <script type="math/tex">Du</script> behaves as below</p>

<script type="math/tex; mode=display">D^s u_n\stackrel{*}{\rightharpoonup} (\nabla g-G)\mathcal{L}^N+ D^s g,</script>

<p>stating that the discontinuities of the approximating sequence <script type="math/tex">u_n</script> converge, in the sense of measures, to a limiting measure which is both diffuse and singular. Therefore, if a structured deformation is such that its disarrangement tensor <script type="math/tex">M=\nabla g-G</script> is non-trivial, it can be approximated by functions with discontinuities which, in the limit, diffuse in the bulk. This has the effect of making the approximating sequence achieve the given structured deformation <script type="math/tex">(g,G)</script> while also achieving <script type="math/tex">M</script>. In a sense, the disarrangement tensor <script type="math/tex">M</script> is a measure of how non-classical a deformation is.</p>

<h2 id="an-example-of-a-1d-structured-deformation">An example of a <script type="math/tex">1D</script> structured deformation</h2>
<p>In this example, we consider a one-dimensional structured deformation and show how it can be approximated. Let <script type="math/tex">\Omega=(0,1)</script>, and let <script type="math/tex">g(x)=2x</script>, <script type="math/tex">G(x)=1</script>. This pair <script type="math/tex">(g,G)</script> describes the deformation of a material which is stretched macroscopically to twice its size by the <script type="math/tex">g</script>, whereas the smooth part of the microscopic deformation has a gradient <script type="math/tex">G</script> equal to the identity.</p>

<p>How is it possible, then, to approximate <script type="math/tex">(g,G)</script> with a sequence of deformations which behave microscopically like the identity, but achieve the overall effect to stretch the material? Such an approximating sequence should have jumps to allow the material to deform macroscopically, while keeping a microscopical deformation gradient of <script type="math/tex">1</script>. The sequence</p>

<script type="math/tex; mode=display">% <![CDATA[
u_n(x):=x+{k\over n},\qquad \text{for ${k\over n}\leq x<{k+1\over n}$},\qquad k\in\{0,1,\ldots, n-1\} %]]></script>

<p>behaves as desired and approximates <script type="math/tex">(g,G)</script> in the sense described in the Approximation Theorem above. As a matter of fact, <script type="math/tex">u_n\to g</script> and <script type="math/tex">u_n'\to G</script> (even) in <script type="math/tex">L^\infty(0,1)</script>. We can get more information on how the jumps of <script type="math/tex">u_n</script> diffuse in the whole interval <script type="math/tex">(0,1)</script> by looking at the distributional gradient</p>

<script type="math/tex; mode=display">Du_n=1\cdot\mathcal{L}^{N}+D^s u_n=1+\sum_{k=1}^{n-1}{1\over n}\delta_{k/n}</script>

<p>Since <script type="math/tex">D^s g=0</script>, the limit of <script type="math/tex">D^s u_n=\sum_{k=1}^{n-1} {1\over n}\delta_{k/n}</script> recovers just the difference <script type="math/tex">u_n'-G=1</script>. A stronger link between these two quantities is evident considering that <script type="math/tex">\sum_{k=1}^{n-1} {1\over n}\delta_{k/n}</script> is the Riemann sum of the function <script type="math/tex">f(x)=1</script> on <script type="math/tex">(0,1)</script>. A depiction of the first elements of the sequence <script type="math/tex">u_n</script> is provided in the picture below.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0007/p0018_50.png" alt="" /></p>

<center>approximation of the broken ramp</center>

<h1 id="references">References</h1>

<p><a name="CF1997">R. Choksi and I. Fonseca: <em>Bulk and Interfacial Energy Densities for Structured Deformations of Continua</em>. Arch. Rational Mech. Anal. <strong>138</strong> (1997), 37-103.</a></p>

<p><br />
<a name="DPO1993">G. Del Piero and D. R. Owen: <em>Structured Deformation of Continua</em>. Arch. Rational Mech. Anal. <strong>124</strong> (1993), 99-155.</a>
<br /></p>

<p><a name="O2017">D. R. Owen: <em>Elasticity with Gradient-Disarrangements: A Multiscale Perspective for Strain-Gradient Theories of Elasticity and of Plasticity</em>. J. Elast. <strong>127</strong> (2017), 115-150.</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;The time dependent transmission problem is as follows, where we consider a domain $\Omega \subset \mathbb{R}^2$ which is cut into two subdomains $\Omega_1 \cup \Omega_2 = \Omega$ with transmission conditions at the interface $\Gamma = \Omega_1 \cap \Omega_2$:&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align} \begin{split} & \alpha_m \frac{\partial u_m(\textbf{x},t)}{\partial t} - \nabla \cdot (\lambda_m  \nabla u_m(\textbf{x},t)) = 0,\  \  t \in [t_0, t_f],  \  \  \textbf{x} \in \Omega_m \subset \mathbb{R}^2, \\ & u_m(\textbf{x},t) = 0, \  \  t \in [t_0, t_f], \  \  \textbf{x} \in \partial \Omega_m \backslash \Gamma, \\ & u_1(\textbf{x},t) = u_2(\textbf{x},t), \  \  \textbf{x} \in \Gamma, \\ & \lambda_2 \frac{\partial u_2(\textbf{x},t)}{\partial \textbf{n}_2} = -\lambda_1 \frac{\partial u_1(\textbf{x},t)}{\partial \textbf{n}_1}, \  \  \textbf{x} \in \Gamma, \\ & u_m(\textbf{x},0) = u_m^0(\textbf{x}), \  \  \textbf{x} \in \Omega_m, \end{split} \end{align} %]]></script>

<p>where $\textbf{n}_m$ is the outward normal to $\Omega_m$ for $m=1,2$.</p>

<p>The constants $\lambda_1$ and $\lambda_2$ describe the thermal conductivities of the materials on $\Omega_1$ and $\Omega_2$ respectively. $D_1$ and $D_2$ represent the thermal diffusivities of the materials and they are defined by</p>

<script type="math/tex; mode=display">\begin{align} D_m = \frac{\lambda_m}{\alpha_m}, \  \  \mbox{with} \  \  \alpha_m = \rho_m c_{p_m} \end{align}</script>

<p>where $\rho_m$ represents the density and $c_{p_m}$ the heat capacity of the material placed in $\Omega_m$, $m=1,2$.</p>

<h2 id="discretization">DISCRETIZATION</h2>

<p>Let $u_I^{(1)}$ and $u_I^{(2)}$ correspond to the unknowns on $\Omega_1$ and $\Omega_2$ respectively and $u_{\Gamma}$ correspond to the unknows at the interface $\Gamma$, then the compact 2D finite difference (FD) formulation on equidistant meshes of (1) for the vector of unknowns</p>

<script type="math/tex; mode=display">\textbf{u} = (\textbf{u}_I^{(1)}, \textbf{u}_I^{(2)}, \textbf{u}_{\Gamma})^T</script>

<p>will be</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \tilde{\textbf{M}} \dot{\textbf{u}} - \tilde{\textbf{A}} \textbf{u} = 0 \  \  \mbox{where} \  \  \tilde{\textbf{M}} = \left( \begin{array}{ccc} \textbf{M}_1 & \textbf{0} & \textbf{M}_{I \Gamma}^{(1)} \\ \textbf{0} & \textbf{M}_2 & \textbf{M}_{I \Gamma}^{(2)} \\ \textbf{M}_{\Gamma I}^{(1)} & \textbf{M}_{\Gamma I}^{(2)} & \textbf{M}_{\Gamma \Gamma}^{(1)} + \textbf{M}_{\Gamma \Gamma}^{(2)} \end{array} \right), \  \  \tilde{\textbf{A}} = \left( \begin{array}{ccc} \textbf{A}_1 & \textbf{0} & \textbf{A}_{I \Gamma}^{(1)} \\ \textbf{0} & \textbf{A}_2 & \textbf{A}_{I \Gamma}^{(2)} \\ \textbf{A}_{\Gamma I}^{(1)} & \textbf{A}_{\Gamma I}^{(2)} & -\textbf{A}_{\Gamma \Gamma}^{(1)} - \textbf{A}_{\Gamma \Gamma}^{(2)} \end{array} \right), \end{equation} %]]></script>

<p>for the mass matrices $M_m$, $M_{\Gamma \Gamma}^{(m)}$, $M_{I \Gamma}^{(m)}$, $M_{\Gamma I}^{(m)}$ and the stiffness matrices</p>

<script type="math/tex; mode=display">\textbf{A}_m, \textbf{A}_{\Gamma \Gamma}^{(m)}, \textbf{A}_{I \Gamma}^{(m)}, \textbf{A}_{\Gamma I}^{(m)}</script>

<p>for $m=1,2$.</p>

<p>Applying the implicit Euler method with time step $\Delta t$ to the system (3), we get for the vector of unknowns</p>

<script type="math/tex; mode=display">u^{n+1} = (u_I^{(1),n+1}, u_I^{(2),n+1}, u_{\Gamma}^{n+1})^T</script>

<script type="math/tex; mode=display">\begin{equation} \textbf{A} \textbf{u}^{n+1} = \tilde{\textbf{M}} \textbf{u}^n \  \  \mbox{where} \  \  \textbf{A} = \tilde{\textbf{M}} - \Delta t \tilde{\textbf{A}}. \end{equation}</script>

<h2 id="dirichlet-neumann-iteration">DIRICHLET-NEUMANN ITERATION</h2>

<p>We now employ a standard Dirichlet-Neumann iteration to solve the discrete system (4), getting in the $k$-th iteration the two equation systems</p>

<script type="math/tex; mode=display">\begin{equation} (\textbf{M}_1 - \Delta t \textbf{A}_1) \textbf{u}_I^{(1),n+1,k+1} = -(\textbf{M}_{I \Gamma}^{(1)} - \Delta t \textbf{A}_{I \Gamma}^{(1)}) \textbf{u}_{\Gamma}^{n+1,k} + \textbf{M}_1 \textbf{u}_I^{(1),n} + \textbf{M}_{I \Gamma}^{(1)} \textbf{u}_{\Gamma}^n, \end{equation}</script>

<script type="math/tex; mode=display">\begin{equation} \hat{\textbf{A}} \hat{\textbf{u}}^{k+1} = \hat{\textbf{M}} \textbf{u}^n - \textbf{b}^k, \end{equation}</script>

<p>to be solved in succession. Here,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} \begin{split} \hat{\textbf{A}} = \left( \begin{array}{cc} \textbf{M}_2 - \Delta t \textbf{A}_2 & \textbf{M}_{I \Gamma}^{(2)} - \Delta t \textbf{A}_{I \Gamma}^{(2)} \\ \textbf{M}_{\Gamma I}^{(2)} - \Delta t \textbf{A}_{\Gamma I}^{(2)} & \textbf{M}_{\Gamma \Gamma}^{(2)} + \Delta t \textbf{A}_{\Gamma \Gamma}^{(2)} \end{array} \right), \  \  \hat{\textbf{M}} = \left( \begin{array}{ccc} \textbf{0} & \textbf{M}_2 & \textbf{M}_{I \Gamma}^{(2)} \\ \textbf{M}_{\Gamma I}^{(1)} & \textbf{M}_{\Gamma I}^{(2)} & \textbf{M}_{\Gamma \Gamma}^{(1)} + \textbf{M}_{\Gamma \Gamma}^{(2)} \end{array} \right) \  \  \mbox{and} \\ \textbf{b}^k = \left( \begin{array}{c} \textbf{0} \\ (\textbf{M}_{\Gamma I}^{(1)} - \Delta t \textbf{A}_{\Gamma I}^{(1)}) \textbf{u}_I^{(1),n+1,k+1} + (\textbf{M}_{\Gamma \Gamma}^{(1)} + \Delta t \textbf{A}_{\Gamma \Gamma}^{(1)}) \textbf{u}_{\Gamma}^{n+1,k} \end{array} \right),  \  \  \hat{\textbf{u}}^{k+1} = \left( \begin{array}{c} \textbf{u}_I^{(2),n+1,k+1} \\ \textbf{u}_{\Gamma}^{n+1,k+1} \end{array} \right) \nonumber \end{split} \end{equation} %]]></script>

<p>with some initial condition, here $u_{\Gamma}^{n+1,0} = u_{\Gamma}^{n}$. The iteration is terminated according to the standard criterion</p>

<script type="math/tex; mode=display">\vert \textbf{u}_{\Gamma}^{k+1} - \textbf{u}_{\Gamma}^k \vert \leq \tau</script>

<p>where $\tau$ is a user defined tolerance.</p>

<h2 id="implementation">IMPLEMENTATION</h2>

<p>We consider here the thermal interaction between two different materials which physical properties are described by their thermal conductivities and diffusivities $\lambda_1$, $\lambda_2$ and $D_1$, $D_2$ respectively. Furthermore, we consider the non overlapping identical domains $\Omega_1 = [0,1] \times [0,1]$ and $\Omega_2 = [1,2] \times [0,1]$.</p>

<p>The initialization parameters look as follows:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Ns</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>          <span class="c1">%% space discretization points in each dimension</span>
<span class="n">dx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/(</span><span class="n">Ns</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">%% mesh size</span>
<span class="n">tf</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>   <span class="n">t0</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">%% final time - initial time</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>           <span class="c1">%% time discretization points</span>
<span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-</span><span class="n">t0</span><span class="p">)/</span><span class="n">Nt</span><span class="p">;</span>  <span class="c1">%% stepsize</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">D1</span>      <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>    <span class="c1">%% thermal diffusivity of material on domain 1</span>
<span class="n">D2</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">%% thermal diffusivity of material on domain 2</span>
<span class="n">lambda1</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>    <span class="c1">%% thermal conductivity material on domain 1</span>
<span class="n">lambda2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">%% thermal conductivity material on domain 2</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">alpha1</span>  <span class="o">=</span> <span class="n">lambda1</span><span class="p">/</span><span class="n">D1</span><span class="p">;</span>
<span class="n">alpha2</span>  <span class="o">=</span> <span class="n">lambda2</span><span class="p">/</span><span class="n">D2</span><span class="p">;</span>
</code></pre>
</div>

<p>In addition to the parameters above, other objects need to be specified before starting the iterative procedure. The space grids both in $x$-direction and $y$-direction are given to later plot the numerical solution, also the initial conditions $u_m^0(x)$, $x \in \Omega_m$ and the mass and stiffness matrices coming from the space discretization:</p>

<p>space grid w.r.t component x</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">xplot</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
<span class="c1">%% space grid w.r.t component y</span>
<span class="n">yplot</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">%%</span>
<span class="c1">%% this functions gives the initial conditions w.r.t. domain 1 (U1_0), domain 2 (U2_0) and interface unknowns (UG_0).</span>
<span class="p">[</span><span class="n">U1_0</span><span class="p">,</span> <span class="n">U2_0</span><span class="p">,</span> <span class="n">UG_0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_conditions</span><span class="p">(</span><span class="n">Ns</span><span class="p">);</span>
<span class="c1">%%</span>
<span class="c1">%% this function calculates the discretization matrices using finite differences</span>
<span class="p">[</span><span class="n">A1</span><span class="p">,</span><span class="n">A2</span><span class="p">,</span><span class="n">A1g</span><span class="p">,</span><span class="n">A2g</span><span class="p">,</span><span class="n">Ag1</span><span class="p">,</span><span class="n">Ag2</span><span class="p">,</span><span class="n">Agg1</span><span class="p">,</span><span class="n">Agg2</span><span class="p">,</span><span class="n">M1</span><span class="p">,</span><span class="n">M2</span><span class="p">,</span><span class="n">M1g</span><span class="p">,</span><span class="n">M2g</span><span class="p">,</span><span class="n">Mg1</span><span class="p">,</span><span class="n">Mg2</span><span class="p">,</span><span class="n">Mgg1</span><span class="p">,</span><span class="n">Mgg2</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_matrices</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="n">lambda1</span><span class="p">,</span><span class="n">lambda2</span><span class="p">,</span><span class="n">alpha1</span><span class="p">,</span><span class="n">alpha2</span><span class="p">);</span>
</code></pre>
</div>

<p>Then, the iterative procedure takes place where the equations (4) and (5) are solved alternatively on $\Omega_1$ and $\Omega_2$ respectively until convergence is achieved at each time step. The implementation is specified below:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">UG_old</span> <span class="o">=</span> <span class="n">UG_0</span><span class="p">;</span> <span class="c1">%% UG_0 is fixed over the Dirichlet-Neumann iteration while UG_old is being updated</span>
<span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">%% gif('2D_FDM.gif','frame',figure(1))</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">Nt</span> <span class="c1">%% time recursion</span>
    <span class="c1">%% initial guess for the stopping criteria of the inner fixed point iteration</span>
    <span class="nb">error</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="c1">%% Dirichlet-Neumann iteration</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">error</span><span class="o">&gt;</span><span class="mf">1e-10</span><span class="p">)</span>
        <span class="c1">%% solve problem on domain 1 using Dirichlet BC at the interface</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">solve_dirichlet</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">U1_0</span><span class="p">,</span><span class="n">UG_0</span><span class="p">,</span><span class="n">A1</span><span class="p">,</span><span class="n">M1</span><span class="p">,</span><span class="n">A1g</span><span class="p">,</span><span class="n">M1g</span><span class="p">,</span><span class="n">UG_old</span><span class="p">);</span>
        <span class="c1">%% solve problem on domain 2 using Neumann BC at the interface</span>
        <span class="p">[</span><span class="n">U2</span><span class="p">,</span> <span class="n">UG_new</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve_neumann</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">U1_0</span><span class="p">,</span><span class="n">U2_0</span><span class="p">,</span><span class="n">UG_0</span><span class="p">,</span><span class="n">A2</span><span class="p">,</span><span class="n">M2</span><span class="p">,</span><span class="n">Ag2</span><span class="p">,</span><span class="n">Mg2</span><span class="p">,</span><span class="n">A2g</span><span class="p">,</span><span class="n">M2g</span><span class="p">,</span><span class="n">Agg1</span><span class="p">,</span><span class="n">Agg2</span><span class="p">,</span><span class="n">Mgg1</span><span class="p">,</span><span class="n">Mgg2</span><span class="p">,</span><span class="n">Ag1</span><span class="p">,</span><span class="n">Mg1</span><span class="p">,</span><span class="n">U1</span><span class="p">,</span><span class="n">UG_old</span><span class="p">);</span>
        <span class="c1">%% calculate value for the stopping criteria (difference between two consecutive iterates at the interface)</span>
        <span class="nb">error</span> <span class="o">=</span> <span class="nb">norm</span><span class="p">(</span><span class="n">UG_old</span> <span class="o">-</span> <span class="n">UG_new</span><span class="p">);</span>
        <span class="c1">%% update UG_old</span>
        <span class="n">UG_old</span> <span class="o">=</span> <span class="n">UG_new</span><span class="p">;</span>

        <span class="c1">%%put together U1,U2 and UG_old for plotting</span>
        <span class="n">Uplot</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Ns</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">Ns</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
        <span class="n">Uplot</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">Ns</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">U1</span><span class="p">;</span>
        <span class="n">Uplot</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">UG_old</span><span class="p">;</span>
        <span class="n">Uplot</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns</span><span class="o">+</span><span class="mi">3</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">U2</span><span class="p">;</span>

<span class="c1">%%         figure(1)</span>
<span class="c1">%%         mesh(xplot,yplot,Uplot);</span>
<span class="c1">%%         zlim([-80 40])</span>
<span class="c1">%%         xlabel('x')</span>
<span class="c1">%%         ylabel('y')</span>
<span class="c1">%%         zlabel('u(x,y)')</span>
<span class="c1">%%         title(['Numerical solution at time: t = ',num2str(k*dt)])</span>
<span class="c1">%%         gif</span>
<span class="c1">%%         pause(0.1)</span>
    <span class="k">end</span>
    <span class="c1">%% update the initial values U1_0, U2_0 and UG_0 to start the next time</span>
    <span class="c1">%% step</span>
    <span class="n">U1_0</span> <span class="o">=</span> <span class="n">U1</span><span class="p">;</span>
    <span class="n">U2_0</span> <span class="o">=</span> <span class="n">U2</span><span class="p">;</span>
    <span class="n">UG_0</span> <span class="o">=</span> <span class="n">UG_old</span><span class="p">;</span>
<span class="k">end</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0006/2D_FDM.gif" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;The aim of this note is to explain how one can solve an optimal control problem with the moment method. While the theory is collected in [1], we will explain how one is able to use the Globtipoly toolbox, which is a powerful toolbox able to solve many other problems. This toolbox is available in &lt;a href="http://homepages.laas.fr/henrion/software/gloptipoly3/"&gt;http://homepages.laas.fr/henrion/software/gloptipoly3/&lt;/a&gt;. A more detailed documentation is provided in this link, if you are insterested in other applications than the optimal control problem.&lt;/p&gt;
</code></pre>
</div>

<p>The use of this toolbox needs a proper installation either of Sedumi or the Mosek solvers, which are toolboxes instrumental to solve numerically SDP (Semidefinite Program) problems, i.e. optimization problems expressed with LMI (Linear Matrix Inequalities) constraints.</p>

<p>This note does not aim at explaining all the details of the toolbox Globtipoly, since there exists already the paper [2] which introduces really well the problem. It does not aim neither at introducing in details the moment framework developed by Jean Bernard Lasserre and Didier Henrion, which is much more general than the optimal control problem framework. In this note, we just give a simple example to explain how this method can be used in the context of optimal control (especially for ODEs). Thanks to the recent paper [3], we also think that this framework might also work for optimal control of PDEs.</p>

<h2 id="framework">FRAMEWORK</h2>

<p>We focus on the following ordinary differential equations:</p>

<script type="math/tex; mode=display">\begin{cases}    \dot{x} = f(x,u) \\    x(0)=x_0 \end{cases}</script>

<p>where $x$ belongs to a subset $X$ of $\mathbb{R}^n$ and $u$ to a subset $U$ of $\mathbb{R}^m$. We assume that $f$ is a polynomial of $x$ and $u$. Moreover, we assume that $X$ and $U$ can be written with finitely many polynomial inequalities. The Gloptipoly toolbox allows to solve the following kind of optimal control problem:</p>

<script type="math/tex; mode=display">\begin{cases} \rho^\star = \inf_u \int_{t_0}^T l(x(t),u(t))dt + l_T(x(T)) \\ \text{    s.t }  \dot{x} = f(x,u), x(t_0)=x_0 \\                  x(t) \in X,\: t\in  [t_0,T] \\                  u(t) \in U,\: t\in [t_0,T] \\                  x(T) \in X_T, \end{cases}</script>

<p>where $X_T$ is also a subset of $\mathbb{R}^n$ defined with finitely many polynomial inequalities and $l$ is also a polynomial in the variables $x$ and $u$.</p>

<h2 id="a-simpler-example-as-a-motivation">A SIMPLER EXAMPLE AS A MOTIVATION</h2>

<p>We focus on a specific example to make the reading of thenote easier. We have</p>

<script type="math/tex; mode=display">% <![CDATA[
x=\begin{bmatrix} x_1 & x_2\end{bmatrix}\in\mathbb{R}^2 %]]></script>

<p>$u\in\mathbb{R}$ and:</p>

<script type="math/tex; mode=display">f(x,u):=\begin{bmatrix} x_1\\ u \end{bmatrix}</script>

<p>It is a simple chain of integrators, really well-known in automatic control theory. As described in [1], the related system can be equivalently rewritten as follows:</p>

<script type="math/tex; mode=display">\int_{K_2} g(x) d\mu_2(x) -g(x_0) = \int_{K_1} \frac{d}{dx}g(x) f(x,u) d\mu_1(x),</script>

<p>where $g$ is any test function in $C^1(X)$, $\mu_1(x)$ is a measure supported on a compact set $K_1$ representing the constraints on $x$ and $u$, $\mu_2(x)=$ is supported on a given compact set $K_2$ corresponding to performance requirements. For example $K_2 = 0$ indicates that state $x$ must reach the origin.</p>

<p>The approximation provided by Gloptipoly consists in reducing the class of test function $g$ to be polynomials, with maximal degree $d$. This maximal degree $d$ is the parameter of approximation of the program. As proved in [1], the higher the degree $d$ is, the better is the result of the approximation.</p>

<p>Our aim is to find the minimal time so that the trajectories of the system go to $0$. Obviously, this result is already known, but we provide this simple example to make clear the use of the Globtipoly toolbox</p>

<h2 id="implementation">IMPLEMENTATION</h2>

<p>Before going to the optimal control problem, some (easy) technical lines of command are necessary for Gloptipoly to work.</p>

<p>First, you have to add to the path the toolbox Globtipoly</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">untar</span><span class="p">(</span><span class="s1">'http://homepages.laas.fr/henrion/software/gloptipoly3/gloptipoly3.tar.gz'</span><span class="p">)</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="s1">'gloptipoly3'</span><span class="p">))</span>
</code></pre>
</div>

<p>Second, you have also to add to the path the toolbox Sedumi.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">unzip</span><span class="p">(</span><span class="s1">'https://github.com/sqlp/sedumi/archive/master.zip'</span><span class="p">)</span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="s1">'sedumi-master'</span><span class="p">))</span>
</code></pre>
</div>

<p>Then, you are ready to define the optimization problem.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span> <span class="n">u0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">%% initial conditions</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">%% maximum degree of test function.</span>
</code></pre>
</div>

<p>We compute the analytic minimum time. We want to know whether we are able to compute the good one with the toolbox Gloptipoly.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="p">(</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">)/</span><span class="mi">2</span>
<span class="n">tmin</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">;</span>
<span class="k">elseif</span> <span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="o">*</span><span class="nb">sign</span><span class="p">(</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">tmin</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nb">sqrt</span><span class="p">(</span><span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="k">else</span>
<span class="n">tmin</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nb">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We define measures for constraints. In other words, we also define the vector field under consideration.</p>

<p>The command mpol in Globtipoly allows to define the variables under consideration. One can then define polynomials with respect to these variables.</p>

<p>The command meas allows to define a measure depending on several variables. Hence, when writing meas([x_1;u_1]), one is defining a measure depending on the variables x_1 and u_1.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">mpol</span> <span class="n">x1</span> <span class="mi">2</span>
<span class="n">mpol</span> <span class="n">u1</span>
<span class="n">m1</span> <span class="o">=</span> <span class="n">meas</span><span class="p">([</span><span class="n">x1</span><span class="p">;</span><span class="n">u1</span><span class="p">]);</span>
</code></pre>
</div>

<p>We now define a measure associated to $x_2$, which will be related to some performance requirement. Indeed, we will impose that this variable is dissipative.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">mpol</span> <span class="n">x2</span> <span class="mi">2</span>
<span class="n">m2</span> <span class="o">=</span> <span class="n">meas</span><span class="p">(</span><span class="n">x2</span><span class="p">);</span>
</code></pre>
</div>

<p>We then define the vector field.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="n">u1</span><span class="p">];</span>
</code></pre>
</div>

<p>We now define the test functions as polynomials, with maximal degree $d$. The command mmon in Globtipoly allows to define monomials up to an order $d$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">g1</span> <span class="o">=</span> <span class="n">mmon</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>
<span class="n">g2</span> <span class="o">=</span> <span class="n">mmon</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>
</code></pre>
</div>

<p>It is also necessary to assign the initial conditions, for the states as well for the control.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">assign</span><span class="p">([</span><span class="n">x1</span><span class="p">;</span><span class="n">u1</span><span class="p">],[</span><span class="n">x0</span><span class="p">;</span><span class="n">u0</span><span class="p">]);</span>
<span class="n">g0</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">g1</span><span class="p">);</span>
</code></pre>
</div>

<p>We define $K_1$ and $K_2$. The set $K_1$ is defined as: $K_1= \lbrace x_1,u_1 \in \mathbb{R}^2\mid x_1(2)\geq -1,: u_1^2\leq 1\rbrace$ and $K_2$ is defined as: $K_2 =\lbrace x_2\in\mathbb{R}\mid x_2^2\leq 0\rbrace$.</p>

<p>We have also to define the cost function of the problem under consideration. The one we are considering is quite simple and just reduces to being</p>

<script type="math/tex; mode=display">\int_{K_1} d\mu_1</script>

<p>In terms of functions, this means that you are minizing $x_1(t)$. This implies in particular that you are looking for the minimal time such that the trajectory $(x_1(t),x_2(t))$ will converge to $(0,0)$.</p>

<p>In other words, we are asking that the mass the measure $\mu_1$ is minimal.</p>

<p>Finally, we define also the differential equation with the polynomials truncated up to the order $d$. The command mom corresponds to the integral of polynomials against the suitable measure. For instance, for mom(g_2), one integrates the the polynomial g_2 against the measure $\mu_2$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">P</span> <span class="o">=</span> <span class="n">msdp</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">mass</span><span class="p">(</span><span class="n">m1</span><span class="p">)),</span><span class="k">...</span><span class="c"> %%Definition of the cost function</span>
<span class="n">u1</span><span class="o">^</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span><span class="k">...</span><span class="c"> %% Definition of $K_1$</span>
<span class="n">x1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">...</span><span class="c"> %% Definition of $K_&amp;$</span>
<span class="n">x2</span><span class="o">'*</span><span class="n">x2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span><span class="k">...</span><span class="c"> %% Definition of $K_2</span>
<span class="n">mom</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span> <span class="o">-</span> <span class="n">g0</span> <span class="o">==</span> <span class="n">mom</span><span class="p">(</span><span class="nb">diff</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">));</span> <span class="c1">%% Definition of the dynamics.</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>GloptiPoly 3.8 of 15 December 2014
Define moment SDP problem
  Valid objective function
  Number of support constraints = 3
  Number of moment constraints = 28
Measure 1
  Degree = 6
  Variables = 3
  Moments = 84
Measure 2
  Degree = 6
  Variables = 2
  Moments = 28
Relaxation order = 3
Total number of moments = 112
Generate moment and support constraints
Generate moment SDP problem

</code></pre>
</div>

<p>The command msdp allows to define the problem and all the constraints. As written in [1], this means that you are transforming the problem on functions into a SDP (Semi-definite programming) problem.</p>

<p>Once you do that, one has to solve this SDP problem. The command msol allows to do that.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">status</span><span class="p">,</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">msol</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>GloptiPoly 3.8 of 15 December 2014
Solve moment SDP problem
*****************************************************
Calling SeDuMi
SeDuMi 1.32 by AdvOL, 2005-2008 and Jos F. Sturm, 1998-2003.
Alg = 2: xz-corrector, Adaptive Step-Differentiation, theta = 0.250, beta = 0.500
Put 28 free variables in a quadratic cone
eqs m = 112, order n = 59, dim = 766, blocks = 7
nnz(A) = 597 + 0, nnz(ADA) = 10192, nnz(L) = 5152
 it :     b*y       gap    delta  rate   t/tP*  t/tD*   feas cg cg  prec
  0 :            6.97E-01 0.000
  1 :  -4.85E+00 2.61E-01 0.000 0.3749 0.9000 0.9000  -0.46  1  1  7.9E+00
  2 :  -1.58E+01 1.08E-01 0.000 0.4124 0.9000 0.9000  -0.63  1  1  5.7E+00
  3 :  -1.60E+01 4.52E-02 0.000 0.4189 0.9000 0.9000   0.74  1  1  2.0E+00
  4 :  -7.27E+00 1.65E-02 0.000 0.3663 0.9000 0.9000   1.88  1  1  4.7E-01
  5 :  -4.16E+00 5.56E-03 0.000 0.3361 0.9000 0.9000   1.60  1  1  1.3E-01
  6 :  -3.52E+00 2.17E-03 0.000 0.3912 0.9000 0.9000   1.07  1  1  5.0E-02
  7 :  -3.37E+00 1.06E-03 0.000 0.4892 0.9000 0.9000   0.88  1  1  2.6E-02
  8 :  -3.24E+00 4.94E-04 0.000 0.4642 0.9000 0.9000   0.70  1  1  1.5E-02
  9 :  -3.17E+00 2.14E-04 0.000 0.4334 0.9000 0.9000   0.58  1  1  7.8E-03
 10 :  -3.12E+00 9.06E-05 0.000 0.4235 0.9000 0.9000   0.46  1  1  4.3E-03
 11 :  -3.08E+00 4.45E-05 0.000 0.4907 0.9000 0.9000   0.48  1  1  2.6E-03
 12 :  -3.05E+00 2.39E-05 0.000 0.5378 0.9000 0.9000   0.34  1  1  1.9E-03
 13 :  -3.02E+00 1.07E-05 0.000 0.4486 0.9000 0.9000   0.46  1  1  1.1E-03
 14 :  -2.98E+00 5.94E-06 0.000 0.5540 0.9000 0.9000   0.23  1  1  8.3E-04
 15 :  -2.95E+00 2.34E-06 0.000 0.3932 0.9000 0.9000   0.35  2  1  4.4E-04
 16 :  -2.91E+00 1.06E-06 0.000 0.4528 0.9000 0.9000   0.22  2  2  3.1E-04
 17 :  -2.88E+00 2.15E-07 0.000 0.2032 0.9000 0.7324   0.34  2  2  1.8E-04
 18 :  -2.84E+00 9.48E-08 0.000 0.4410 0.7706 0.9000   0.22  2  2  1.2E-04
 19 :  -2.82E+00 4.23E-08 0.000 0.4464 0.9000 0.9000   0.34  3  2  7.3E-05
 20 :  -2.78E+00 1.96E-08 0.000 0.4627 0.9000 0.9000   0.20  5  5  5.2E-05
 21 :  -2.76E+00 8.49E-09 0.000 0.4334 0.9000 0.9000   0.34  7  7  3.0E-05
 22 :  -2.73E+00 3.76E-09 0.000 0.4427 0.9000 0.9000   0.19  8  8  2.1E-05
 23 :  -2.70E+00 1.56E-09 0.000 0.4156 0.9000 0.9000   0.33 12 12  1.2E-05
 24 :  -2.67E+00 6.45E-10 0.000 0.4129 0.9000 0.9000   0.20 14 14  7.9E-06
 25 :  -2.66E+00 2.71E-10 0.000 0.4202 0.9000 0.9000   0.35 41 41  4.5E-06
Run into numerical problems.

iter seconds digits       c*x               b*y
 25      0.4   Inf -2.6569125651e+00 -2.6557155494e+00
\vertAx-b\vert =   9.3e-06, [Ay-c]_+ =   1.9E-06, \vertx\vert=  5.2e+03, \verty\vert=  4.9e+04

Detailed timing (sec)
   Pre          IPM          Post
6.598E-03    2.390E-01    7.343E-04    
Max-norms: \vert\vertb\vert\vert=1, \vert\vertc\vert\vert = 1,
Cholesky \vertadd\vert=1, \vertskip\vert = 7, \vert\vertL.L\vert\vert = 3155.
*****************************************************
Check feasibility (eps = 1.0000e-03):
  Marginally feasible SDP: residual = -5.0513e-07
Check Euclidean norm of solution (max = 1.0000e+06):
  Norm = 4.9305e+04
Check ranks of moments matrices (rel gap svd = 1.0000e-03):
  Measure 1
    Rank shift = 1
    Moment matrix of order  1 has size  4 and rank  4
    Moment matrix of order  2 has size 10 and rank 10
    Moment matrix of order  3 has size 20 and rank 20
  Measure 2
    Rank shift = 1
    Moment matrix of order  1 has size  3 and rank  1
  Rank conditions cannot ensure global optimality
Try to extract solutions (rel tol basis detection = 1.0000e-06):
  Measure 1
    Incomplete basis - no solution extracted
    Global optimality cannot be ensured
  Measure 2
    Maximum relative error = 0.0000e+00
    1 solution extracted
Inconsistent number of solutions amongst respective measures
No globally optimal solution could be extracted
Global optimality cannot be ensured

</code></pre>
</div>

<p>You display the minimal time and the lower bound of the cost functional.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">disp</span><span class="p">([</span><span class="s1">'Minimum time = '</span> <span class="nb">num2str</span><span class="p">(</span><span class="n">tmin</span><span class="p">)]);</span>
<span class="nb">disp</span><span class="p">([</span><span class="s1">'LMI '</span> <span class="nb">int2str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="s1">' lower bound = '</span> <span class="nb">num2str</span><span class="p">(</span><span class="n">obj</span><span class="p">)])</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Minimum time = 3.5
LMI 6 lower bound = 2.6557

</code></pre>
</div>

<p>For the initial condition x0 = [1 1] the exact minimum time is equal to 3.5. In table 1 of [2], a table is provided where you can see that when increasing $d$ the minimum time becomes closer and closer to the analytic one. We copy it in the note.</p>

<h2 id="conclusion">Conclusion</h2>

<p>As noticed before, this note aimed at providing a quick course on how using the toolbox Gloptipoly toolbox to solve optimal control problem. The document [2] provides more examples, even for other kinds of optimization problem. Hence, we refer the interested reader to this document if he is interested in using this toolbox for other problems. Let us note moreover that this toolbox has been used to solve nonlinear hyperbolic PDEs, in the paper [3].</p>

<h2 id="references">References</h2>

<p>[1] J. B. Lasserre, D. Henrion, C. Prieur, and E. Trélat, Nonlinear optimal control via occupation measures and LMI-relaxations, SIAM J. Control Opt., vol. 47, 4, pp. 1643-1666, 2008.</p>

<p>[2] D. Henrion, J.B. Lasserre and J. Löfberg. GloptiPoly 3: moments, optimization and semidefinite programming. Optimization Methods &amp; Software, 24(4-5), 761-779, 2009.</p>

<p>[3] S. Marx, T. Weisser, D. Henrion and J.B. Lasserre. A moment approach for entropy solutions to nonlinear hyperbolic PDEs arXiv preprint arXiv:1807.02306</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;This tutorial aims to show how to build equations of motion, control system model and optimally stabilizing controllers for the inverted pendulum. This tutorial is a standard material in control engineering education. We first derive the equations of motion via Lagrange’s method using Symbolic Math Toolbox. Then, a linear control model is derived. The optimal controller is designed using linear quadratic regulator theory. Simulations are carried out for the inverted pendulum nonlinear model. In Appendix, finite horizon linear optimal control is shown by solving a differential Riccati equation.&lt;/p&gt;
</code></pre>
</div>

<p>A schematic of an inverted pendulum is shown below.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0003/Pendulum_pic.png" alt="" /></p>

<p>A pendulum is attached with a cart that moves horizontally due to the force $u$ without friction. The pendulum freely rotates around the pivot on the cart. It is assumed that the cart and pendulum move in the vertical plane. The masses of the pendulum and cart are $m$ and $M$, respectively, and the length of the pendulum is $2l$. The position of the cart is denoted by $x$ and the angle of the pendulum from the vertical axis is $\theta$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">syms</span> <span class="n">t</span><span class="p">;</span>
<span class="n">syms</span> <span class="n">x</span> <span class="n">dx</span> <span class="n">theta</span> <span class="n">dtheta</span><span class="p">;</span>
<span class="n">syms</span> <span class="n">M</span> <span class="n">m</span> <span class="n">l</span> <span class="n">g</span><span class="p">;</span>
<span class="n">syms</span> <span class="n">Lgr</span> <span class="n">Lgr_x</span> <span class="n">Lgr_dx</span> <span class="n">Lgr_theta</span> <span class="n">Lgr_dtheta</span><span class="p">;</span>
</code></pre>
</div>

<h2 id="derivation-of-equations-of-motion">Derivation of equations of motion</h2>

<p>The Lagrangian $L$ consists of the kinetic energy and potential energy, which is given by</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Lgr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">M</span><span class="o">*</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">/</span><span class="mi">3</span> <span class="o">*</span> <span class="n">m</span><span class="o">*</span><span class="n">l</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">dtheta</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">l</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="n">dtheta</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="k">...</span>
        <span class="o">+</span> <span class="mi">1</span><span class="p">/</span><span class="mi">2</span> <span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">l</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
</code></pre>
</div>

<p>Compute derivatives of Lagrangian</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Lgr_x</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">Lgr</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="n">Lgr_dx</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">Lgr</span><span class="p">,</span><span class="n">dx</span><span class="p">);</span>
<span class="n">Lgr_theta</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">Lgr</span><span class="p">,</span><span class="n">theta</span><span class="p">);</span>
<span class="n">Lgr_dtheta</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">Lgr</span><span class="p">,</span><span class="n">dtheta</span><span class="p">);</span>

<span class="n">syms</span> <span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">dx_f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">dtheta_f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">Lgr_x_f</span> <span class="n">Lgr_dx_f</span> <span class="n">Lgr_theta_f</span> <span class="n">Lgr_dtheta_f</span><span class="p">;</span> <span class="c1">%% _f means functionalized</span>
<span class="n">dx_f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">=</span><span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
<span class="n">dtheta_f</span><span class="o">=</span><span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>

<span class="n">Lgr_dx_f</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Lgr_dx</span><span class="p">,[</span><span class="n">x</span> <span class="n">dx</span> <span class="n">theta</span> <span class="n">dtheta</span><span class="p">],[</span><span class="n">x_f</span> <span class="n">dx_f</span> <span class="n">theta_f</span> <span class="n">dtheta_f</span><span class="p">])</span>
<span class="n">Lgr_theta_f</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Lgr_theta</span><span class="p">,[</span><span class="n">x</span> <span class="n">dx</span> <span class="n">theta</span> <span class="n">dtheta</span><span class="p">],[</span><span class="n">x_f</span> <span class="n">dx_f</span> <span class="n">theta_f</span> <span class="n">dtheta_f</span><span class="p">])</span>
<span class="n">Lgr_dtheta_f</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Lgr_dtheta</span><span class="p">,[</span><span class="n">x</span> <span class="n">dx</span> <span class="n">theta</span> <span class="n">dtheta</span><span class="p">],[</span><span class="n">x_f</span> <span class="n">dx_f</span> <span class="n">theta_f</span> <span class="n">dtheta_f</span><span class="p">])</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
Lgr_dx_f =

M*diff(x_f(t), t) + m*diff(x_f(t), t) + l*m*cos(theta_f(t))*diff(theta_f(t), t)


Lgr_theta_f =

g*l*m*sin(theta_f(t)) - l*m*sin(theta_f(t))*diff(theta_f(t), t)*diff(x_f(t), t)


Lgr_dtheta_f =

(4*m*diff(theta_f(t), t)*l^2)/3 + m*cos(theta_f(t))*diff(x_f(t), t)*l


</code></pre>
</div>

<p>Coumpute Lagrange’s equations of motion with external force $u$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Leq</span> <span class="n">Eqn</span><span class="p">;</span>
<span class="n">Leq</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">([</span><span class="n">Lgr_dx_f</span><span class="p">;</span> <span class="n">Lgr_dtheta_f</span><span class="p">],</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="p">[</span><span class="n">Lgr_x</span><span class="p">;</span> <span class="n">Lgr_theta_f</span><span class="p">];</span>
<span class="n">syms</span> <span class="n">Ddx</span> <span class="n">Ddtheta</span> <span class="n">u</span><span class="p">;</span>
<span class="n">Leq</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Leq</span><span class="p">,[</span><span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">],[</span><span class="n">Ddx</span><span class="p">,</span> <span class="n">Ddtheta</span><span class="p">])</span><span class="o">-</span><span class="p">[</span><span class="n">u</span><span class="p">;</span> <span class="mi">0</span><span class="p">];</span>
<span class="n">Eqn</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">Leq</span><span class="o">==</span><span class="mi">0</span><span class="p">,[</span><span class="n">Ddx</span><span class="p">,</span><span class="n">Ddtheta</span><span class="p">]);</span>
</code></pre>
</div>

<p>Construct state space equations of the first order equation</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">syms</span> <span class="n">x1</span> <span class="n">x2</span> <span class="n">x3</span> <span class="n">x4</span> <span class="n">X</span><span class="p">;</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">;</span><span class="n">x2</span><span class="p">;</span><span class="n">x3</span><span class="p">;</span><span class="n">x4</span><span class="p">];</span>
<span class="n">subs</span><span class="p">(</span><span class="n">Eqn</span><span class="o">.</span><span class="n">Ddx</span><span class="p">,</span> <span class="p">[</span><span class="n">x_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="n">theta_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">]);</span>
<span class="n">subs</span><span class="p">(</span><span class="n">Eqn</span><span class="o">.</span><span class="n">Ddtheta</span><span class="p">,</span> <span class="p">[</span><span class="n">x_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="n">theta_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">]);</span>

<span class="n">syms</span> <span class="n">Nsys</span>
<span class="n">Nsys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x2</span><span class="p">;</span><span class="k">...</span>
        <span class="n">subs</span><span class="p">(</span><span class="n">Eqn</span><span class="o">.</span><span class="n">Ddx</span><span class="p">,</span> <span class="p">[</span><span class="n">x_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="n">theta_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">]);</span><span class="k">...</span>
        <span class="n">x4</span><span class="p">;</span><span class="k">...</span>
        <span class="n">subs</span><span class="p">(</span><span class="n">Eqn</span><span class="o">.</span><span class="n">Ddtheta</span><span class="p">,</span> <span class="p">[</span><span class="n">x_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">x_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="n">theta_f</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">theta_f</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">])];</span>

<span class="n">syms</span> <span class="n">F</span><span class="p">;</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre>
</div>

<p>Construct linear model $\dot{x} = Ax+Bu$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Amat</span> <span class="n">Bmat</span>
<span class="n">Amat</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">jacobian</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">X</span><span class="p">),[</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x3</span><span class="p">,</span><span class="n">x4</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Bmat</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,[</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x3</span><span class="p">,</span><span class="n">x4</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">u</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
Amat =

[ 0, 1,                             0, 0]
[ 0, 0,            -(3*g*m)/(4*M + m), 0]
[ 0, 0,                             0, 1]
[ 0, 0, (3*(M*g + g*m))/(l*(4*M + m)), 0]


Bmat =

                0
      4/(4*M + m)
                0
 -3/(l*(4*M + m))


</code></pre>
</div>

<p>We will use the following physical parameters m = 0.3 [kg]; M = 0.8 [kg]; l = 0.25 [m]; g = 9.8 [m/s^2];</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Amat</span><span class="p">,[</span><span class="n">m</span> <span class="n">M</span> <span class="n">l</span> <span class="n">g</span><span class="p">],[</span><span class="mf">0.3</span> <span class="mf">0.8</span> <span class="mf">0.25</span> <span class="mf">9.8</span><span class="p">]));</span>
<span class="n">B</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Bmat</span><span class="p">,[</span><span class="n">m</span> <span class="n">M</span> <span class="n">l</span> <span class="n">g</span><span class="p">],[</span><span class="mf">0.3</span> <span class="mf">0.8</span> <span class="mf">0.25</span> <span class="mf">9.8</span><span class="p">]));</span>
</code></pre>
</div>

<h2 id="lqr-controller-design">LQR controller design</h2>

<p>We design a linear feedback controller that minimizes the cost function</p>

<script type="math/tex; mode=display">J =\int_0^{\infty} x^TQx + u^2\,dt</script>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">[</span><span class="n">ricsol</span><span class="p">,</span><span class="n">cleig</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">Q</span><span class="p">);</span>

<span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">i_linear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">%% closed loop systems</span>

<span class="n">tspan</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">];</span>
<span class="n">ini</span> <span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.91</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="c1">%%1.1894299</span>
<span class="p">[</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_linear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>
<span class="n">input_linear</span> <span class="o">=</span> <span class="n">f_ctr</span><span class="p">(</span><span class="n">state</span><span class="o">'</span><span class="p">);</span>
</code></pre>
</div>

<p>Simulations with linear and nonlinear models</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Nsys_f</span> <span class="o">=</span> <span class="n">matlabFunction</span><span class="p">(</span><span class="n">Nsys</span><span class="p">);</span> <span class="c1">%% function of M,g,l,m,u,x2,x3,x4</span>
<span class="n">i_nonlinear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">Nsys_f</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">9.8</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>

<span class="p">[</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_nonlinear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>
<span class="n">input_nonlinear</span> <span class="o">=</span> <span class="n">f_ctr</span><span class="p">(</span><span class="n">staten</span><span class="o">'</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Linear model'</span><span class="p">,</span> <span class="s1">'Nonlinear model'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Cart position [m]'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0003/copiaRM_01.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">3</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">3</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Linear model'</span><span class="p">,</span> <span class="s1">'Nonlinear model'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Pendulum angle [rad]'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0003/copiaRM_02.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">input_linear</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span><span class="nb">grid</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">input_nonlinear</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Linear model'</span><span class="p">,</span><span class="s1">'Nonlinear model'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Input response'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0003/copiaRM_03.png" alt="" /></p>

<h2 id="appendix-finite-interval-optimal-control-with-dre-">Appendix (finite interval optimal control with DRE )</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">rho</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="nb">eye</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
</code></pre>
</div>

<h2 id="solve--dxdt--xa--ax---xbr-1bx-q-xt--s-dre">Solve -dX/dt = XA + A’X - X<em>B</em>R^{-1}<em>B’</em>X +Q, X(T) = S (DRE)</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">tspan_ric</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="c1">%% change horizon!</span>
<span class="n">iniric</span> <span class="o">=</span> <span class="n">S</span><span class="p">(:);</span>
<span class="n">i_ric</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">f_dric</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">*</span> <span class="n">B</span><span class="o">.'</span><span class="p">,</span> <span class="n">Q</span><span class="p">);</span>
<span class="n">opts</span> <span class="o">=</span> <span class="nb">odeset</span><span class="p">(</span><span class="s1">'RelTol'</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="s1">'AbsTol'</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">);</span>
<span class="p">[</span><span class="n">time_ric</span><span class="p">,</span> <span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_ric</span><span class="p">,</span> <span class="n">tspan_ric</span><span class="p">,</span> <span class="n">iniric</span><span class="p">,</span> <span class="n">opts</span><span class="p">);</span>
<span class="nb">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="k">end</span><span class="p">,:),</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="n">ricsol</span> <span class="c1">%% Convergence check with sol of ARE</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
ans =

   1.0e-04 *

   -0.0103   -0.0124   -0.0358   -0.0065
   -0.0124   -0.0185   -0.0549   -0.0099
   -0.0358   -0.0549   -0.1639   -0.0295
   -0.0065   -0.0099   -0.0295   -0.0053


</code></pre>
</div>

<p>Construct feedback controller using interpolation of DRE sol</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">gain</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="nb">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="k">for</span> <span class="nb">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">gain</span><span class="p">(</span><span class="nb">i</span><span class="p">,:)</span> <span class="o">=</span> <span class="n">B</span><span class="o">'</span> <span class="o">*</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="nb">i</span><span class="p">,:),</span><span class="nb">size</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>
<span class="k">end</span>
<span class="n">gain_t</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="nb">interp1</span><span class="p">(</span><span class="n">time_ric</span><span class="p">,</span><span class="n">gain</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
<span class="n">u_dr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">gain_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>

<span class="n">tspan</span> <span class="o">=</span> <span class="nb">sort</span><span class="p">(</span><span class="n">tspan_ric</span><span class="p">,</span> <span class="s1">'ascend'</span><span class="p">);</span>
<span class="n">i_nonlinear_dre</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">Nsys_f</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">9.8</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="n">u_dr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="p">[</span><span class="n">timedn</span><span class="p">,</span> <span class="n">statedn</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_nonlinear_dre</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span><span class="c1">%%</span>
<span class="n">input_dric</span><span class="o">=</span><span class="p">[];</span>
<span class="k">for</span> <span class="nb">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">timedn</span><span class="p">)</span>
    <span class="n">input_dric</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">u_dr</span><span class="p">(</span><span class="n">timedn</span><span class="p">(</span><span class="nb">i</span><span class="p">),</span><span class="n">statedn</span><span class="p">(</span><span class="nb">i</span><span class="p">,:)</span><span class="o">'</span><span class="p">);</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timedn</span><span class="p">,</span> <span class="n">statedn</span><span class="p">(:,</span><span class="mi">3</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">3</span><span class="p">),</span><span class="s1">'ro'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'control with DRE [10,0]'</span><span class="p">,</span> <span class="s1">'control with ARE'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Pendulum responses with nonlinear model'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0003/copiaRM_04.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">plot</span><span class="p">(</span><span class="n">timedn</span><span class="p">,</span><span class="n">input_dric</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span><span class="n">input_nonlinear</span><span class="p">,</span><span class="s1">'ro'</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'input with ARE'</span><span class="p">,</span><span class="s1">'input with DRE [10,0]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'input responses with nonlinear model'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0003/copiaRM_05.png" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;This work is regarding solving 1-d wave equation using RPS semi-discretization method and analysis corresponding dispersion relation&lt;/p&gt;
</code></pre>
</div>

<p>Solving 1-d wave equation with RPS semi-discretization method Considering 1-d wave equation,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} 	\begin{cases} 	&u_{tt}- u_{xx} =0,  0\leq x\leq 1, t\in[0,T] \\ 	& u(x,T)=u_0(x),\, \, 0\leq x\leq 1, \\ 	& u_t(x,T)=u_1(x),\,\,0\leq x\leq 1,  \\ 	& u(0,t)=u(1,t)=0, \,\, t\in[0,T], 	\end{cases} 	\label{wave} 	\end{equation} %]]></script>

<p>When $(u_0,u_1) \in H_0^1(0,1)\times L^2(0,1)$, it admits a unique solution $u(x,t) \in C^0([0,T],H_0^1(0,1)) \cap C^1([0,T],L^2(0,1))$. 	The energy of solution to \eqref{wave} $E(t)$</p>

<script type="math/tex; mode=display">\begin{equation} 	E(t)=\frac{1}{2}\int_{0}^{1} \vert u_x(x,t) \vert^2+ \vert u_t(x,t)\vert^2 dx, 	\end{equation}</script>

<p>is time conserved .</p>

<p>With Hilbert Uniqueness Method, the exact controllability of \eqref{wave} is  equal to the observability of the adjoint \eqref{wave}, Observability of \eqref{wave} reads as: Given $T\geq 2$, there exist a positive constant $C(T)\geq 0$ such that</p>

<script type="math/tex; mode=display">\begin{equation}       E(0)\leq C(T) \int_{0}^{T} \vert u_x(1,t) \vert ^2 dt. \end{equation}</script>

<p>holds for every solution $u(x,t)$ to adjoint system \eqref{wave}</p>

<p>RPS semi-discretization of  weak variation formulation  of \eqref{wave} is written as</p>

<script type="math/tex; mode=display">\begin{equation} 	M \frac{d^2 \boldsymbol{u}}{dt^2}=-R\boldsymbol{u}, 	\label{fem_wave} 	\end{equation}</script>

<p>where $M_{i,j}:=\int_{-\infty}^{+\infty}\phi_i\phi_j dx$ and $R_{i,j}=\int_{-\infty}^{+\infty}\frac{d}{dx}\phi_i\frac{d}{dx}\phi_j dx $ and  the corresponding $\hat{A}(\omega)$ defined as</p>

<script type="math/tex; mode=display">\begin{equation}       \hat{A}(\omega)= \frac{R e^{i\omega x_n}}{M e^{i\omega x_n} }. 	\end{equation}</script>

<p>As for this problem, the rps basis $\phi_i(x)$ corresponding  $x_i$ is defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} 	\phi_i =\left\{ 	\begin{aligned} 	\arg &\min_{v \in H_0^2[-1,1]}  \int_{-1}^{1}(\frac{d^2}{dx^2} v)^2 dx  \\ 	&s.t.\  v(x_j) = \delta_{i,j},\ \ j = \{1,...,N\}, \\ 	\end{aligned} 	\right. 	\label{basis} 	\end{equation} %]]></script>

<p>Set up uniform fine mesh and coarse mesh</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">h</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">);</span> <span class="n">H</span><span class="o">=</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span> <span class="n">Nbasis</span><span class="o">=</span><span class="mi">2</span><span class="p">/</span><span class="n">H</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">/</span><span class="n">h</span><span class="p">;</span> <span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">/</span><span class="n">H</span><span class="p">;</span>
</code></pre>
</div>

<p>Construct the stiffness matrix and massive matrix regarding p1 finite element on fine mesh and coarse mesh respectively</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">L</span> <span class="o">=</span> <span class="nb">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">],[</span><span class="mi">2</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)]);</span>
<span class="n">LL</span><span class="o">=</span> <span class="nb">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">-</span><span class="mi">4</span><span class="p">)]);</span>
<span class="n">M</span> <span class="o">=</span> <span class="nb">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">/</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">/</span><span class="mi">6</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">4</span><span class="p">)]);</span>
<span class="n">MM</span> <span class="o">=</span> <span class="nb">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">/</span><span class="mi">3</span><span class="o">*</span><span class="n">H</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">/</span><span class="mi">6</span><span class="o">*</span><span class="n">H</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">-</span><span class="mi">4</span><span class="p">)]);</span>
<span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">/</span><span class="n">h</span><span class="o">*</span><span class="n">L</span><span class="p">;</span>
<span class="n">LL</span><span class="o">=</span><span class="mi">1</span><span class="p">/</span><span class="n">H</span><span class="o">*</span><span class="n">LL</span><span class="p">;</span>
</code></pre>
</div>

<p>Construct the discrete energy $\vert-div(a\nabla \cdot)\vert$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">temp</span> <span class="o">=</span> <span class="n">L</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">boundary</span> <span class="o">=</span> <span class="n">L</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="k">end</span><span class="p">],</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">temp</span><span class="s1">'*temp+100*(boundary'</span><span class="p">)</span><span class="o">*</span><span class="n">boundary</span><span class="p">;</span>
</code></pre>
</div>

<p>Matrix corresponding  pointwise constrains</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">B</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">H</span><span class="p">/</span><span class="n">h</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nbasis</span><span class="p">],:);</span>
</code></pre>
</div>

<p>Solve the rps basis by solving the optimization problems</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Psi</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nbasis</span><span class="p">);</span>
<span class="k">for</span> <span class="nb">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ei</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Nbasis</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">ei</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Psi</span><span class="p">(:,</span><span class="nb">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">\(</span><span class="n">B</span><span class="s1">'*((B*inv(A)*B'</span><span class="p">)\</span><span class="n">ei</span><span class="p">));</span>
<span class="k">end</span>
</code></pre>
</div>

<p>plot the basis and log scale of basis</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">h</span><span class="p">:</span><span class="n">h</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="nb">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Psi</span><span class="p">(:,</span><span class="mi">16</span><span class="p">))));</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">h</span><span class="p">:</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">;</span><span class="n">Psi</span><span class="p">(:,</span><span class="mi">16</span><span class="p">);</span><span class="mi">0</span><span class="p">],</span><span class="s1">'b'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_01.png" alt="" /></p>

<p>Set up the time interval, time step, source term $f=0$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">T</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">J</span><span class="o">=</span><span class="mi">10000</span><span class="p">;</span><span class="n">f</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>Set up the concentration parameter of inital data $\gamma$, frequency $\xi$ and generate fine grids $x$ and the initial data defined on them</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">gamma</span><span class="o">=</span><span class="n">H</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mf">1.8</span><span class="p">);</span> <span class="n">xi</span><span class="o">=</span><span class="mi">3</span><span class="p">/</span><span class="mi">4</span><span class="o">*</span><span class="nb">pi</span><span class="p">;</span> <span class="n">x</span><span class="o">=-</span><span class="mi">1</span><span class="o">+</span><span class="n">h</span><span class="p">:</span><span class="n">h</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="n">h</span><span class="p">;</span>
<span class="n">ui</span><span class="o">=</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x</span><span class="p">/</span><span class="n">H</span><span class="p">);</span>
<span class="n">uti</span><span class="o">=-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x</span><span class="p">/</span><span class="n">H</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">/</span><span class="n">H</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">sin</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x</span><span class="p">/</span><span class="n">H</span><span class="p">);</span>
</code></pre>
</div>

<p>Solve the wave equation on fine mesh as a approximation of analytical solution, which will be used then as a reference of rps solution</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">ut</span><span class="p">]</span> <span class="o">=</span>  <span class="n">ODEsolver</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">L</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">ui</span><span class="p">,</span><span class="n">uti</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">M</span><span class="p">);</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span><span class="o">=</span><span class="nb">meshgrid</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">h</span><span class="p">:</span><span class="n">h</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">T</span><span class="p">/</span><span class="n">J</span><span class="p">:</span><span class="n">T</span><span class="p">);</span>
<span class="nb">clf</span><span class="p">,</span> <span class="nb">pcolor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">u</span><span class="o">'</span><span class="p">)</span> <span class="p">;</span><span class="nb">shading</span> <span class="n">interp</span> <span class="p">;</span> <span class="nb">colorbar</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'finemesh solution'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_02.png" alt="" /></p>

<p>Solve the wave equation on coarsemesh using RPS method</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">xc</span><span class="o">=</span><span class="n">x</span><span class="p">(</span><span class="n">H</span><span class="p">/</span><span class="n">h</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nbasis</span><span class="p">]);</span>
<span class="n">Mc</span><span class="o">=</span><span class="n">Psi</span><span class="s1">'*M*Psi; Lc=Psi'</span><span class="o">*</span><span class="n">L</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Psi</span><span class="p">;</span>
<span class="n">uci</span><span class="o">=</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">xc</span><span class="p">/</span><span class="n">H</span><span class="p">);</span>
<span class="n">utci</span><span class="o">=-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">xc</span><span class="p">/</span><span class="n">H</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">/</span><span class="n">H</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">sin</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">xc</span><span class="p">/</span><span class="n">H</span><span class="p">);</span>
<span class="n">fc</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">Lc</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
<span class="p">[</span><span class="n">uc</span><span class="p">,</span><span class="n">uct</span><span class="p">]</span><span class="o">=</span><span class="n">ODEsolver</span><span class="p">(</span><span class="n">Mc</span><span class="p">,</span><span class="n">Lc</span><span class="p">,</span><span class="n">uci</span><span class="p">,</span><span class="n">utci</span><span class="p">,</span><span class="n">fc</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">Mc</span><span class="p">);</span>
<span class="nb">clf</span><span class="p">,</span> <span class="nb">pcolor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,(</span><span class="n">Psi</span><span class="o">*</span><span class="n">uc</span><span class="p">)</span><span class="o">'</span><span class="p">);</span><span class="nb">shading</span> <span class="n">interp</span> <span class="p">;</span> <span class="nb">colorbar</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'coarsemesh solution with rps basis'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_03.png" alt="" /></p>

<p>Solve the wave equation on coarsemesh using p1 fem</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">uuc</span><span class="p">,</span><span class="n">uuct</span><span class="p">]</span><span class="o">=</span><span class="n">ODEsolver</span><span class="p">(</span><span class="n">MM</span><span class="p">,</span><span class="n">LL</span><span class="p">,</span><span class="n">uci</span><span class="p">,</span><span class="n">utci</span><span class="p">,</span><span class="n">fc</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">MM</span><span class="p">);</span>
<span class="p">[</span><span class="n">XX</span><span class="p">,</span><span class="n">YY</span><span class="p">]</span><span class="o">=</span><span class="nb">meshgrid</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">H</span><span class="p">:</span><span class="n">H</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="n">H</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">T</span><span class="p">/</span><span class="n">J</span><span class="p">:</span><span class="n">T</span><span class="p">);</span>
<span class="nb">clf</span><span class="p">,</span> <span class="nb">pcolor</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span><span class="n">YY</span><span class="p">,</span><span class="n">uuc</span><span class="o">'</span><span class="p">);</span> <span class="nb">shading</span> <span class="n">interp</span> <span class="p">;</span> <span class="nb">colorbar</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'coarsemesh solution with linear basis'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_04.png" alt="" /></p>

<p><strong>Plot the disperation relation of RPS-semi descretization</strong></p>

<p>RPS semi-discretization of  weak variation formulation  of \eqref{wave} is written as</p>

<script type="math/tex; mode=display">\begin{equation}    M \frac{d^2 \boldsymbol{u}}{dt^2}=-R\boldsymbol{u} \end{equation}</script>

<p>where $M_{i,j}:=\int_{-\infty}^{+\infty}\phi_i\phi_j dx$ and $R_{i,j}=\int_{-\infty}^{+\infty}\frac{d}{dx}\phi_i\frac{d}{dx}\phi_j dx $ and the corresponding $\hat{A}(\omega)$ defined as</p>

<script type="math/tex; mode=display">\begin{equation} \hat{A}(\omega)= \frac{R e^{i\omega x_n}}{M e^{i\omega x_n} }. 	\end{equation}</script>

<p>Since there’s no explicit formulation for matrix $M$ and $R$, We can only calculate the fourier symbol of $M$ and $R$ numerically. Assuming the matrix $M$ is symmetric and toplitze and dimension $N$ of $M$ being a odd number, then fourier symbol of $M$   could be written as</p>

<script type="math/tex; mode=display">\begin{equation} \hat{M}(\omega)= M_{(N+1)/2,(N+1)/2}-2\sum_{i=1}^{(N+1)/2-1}M_{(N+1)/2,i}cos(i\omega h ),\ \omega h = 0,\frac{1}{N+1}\pi,..., 2\pi. \end{equation}</script>

<p>For example, let $M$  be mass matrix corresponding p1 finite element semi-descretization. the fourier symbol of $M$ is</p>

<script type="math/tex; mode=display">\begin{equation} \hat{M}(\omega)=2/3+1/3cos(\omega h)  \end{equation}</script>

<p>Construct the discrete $cos(i\omega h)$ with $\omega h$ sampled at 1000 points at interval $[0,2\pi]$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="nb">cell</span><span class="p">(</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="n">f</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="nb">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">f</span><span class="p">{</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="mi">2</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="nb">i</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="k">end</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">flip</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

<span class="n">Matrix_cos</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span>
    <span class="n">xx</span><span class="o">=</span><span class="nb">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
    <span class="n">Matrix_cos</span><span class="p">(</span><span class="nb">i</span><span class="p">,:)</span><span class="o">=</span><span class="nb">arrayfun</span><span class="p">(</span><span class="n">f</span><span class="p">{</span><span class="nb">i</span><span class="p">},</span><span class="n">xx</span><span class="p">);</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Calculate the fourier symbol of $M$ and $R$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">M_symbol</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/</span><span class="n">H</span><span class="o">*</span><span class="n">Mc</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">H</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Matrix_cos</span><span class="p">;</span>
<span class="n">R_symbol</span> <span class="o">=</span> <span class="n">H</span><span class="o">*</span><span class="n">Lc</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">H</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Matrix_cos</span><span class="o">.</span><span class="p">/</span><span class="n">xx</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
</code></pre>
</div>

<p>Plot the numerical phase velocity for sinusoidal solution and compare it with the ones for FDM and FEM</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">hold</span> <span class="n">on</span>
<span class="n">phaseVelocity</span> <span class="o">=</span> <span class="n">R_symbol</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="p">/</span><span class="n">M_symbol</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">clf</span><span class="p">,</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">phaseVelocity</span><span class="p">)</span>
<span class="c1">%% for p1 FEM</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">p1PhaseV</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="n">xx</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="p">/</span><span class="n">xx</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">/</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">/</span><span class="mi">3</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span><span class="o">.^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">p1PhaseV</span><span class="p">)</span>
<span class="c1">%% for FDM</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">fdmPhaseV</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="n">xx</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="p">/</span><span class="n">xx</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">fdmPhaseV</span><span class="p">)</span>
<span class="c1">%%</span>
<span class="n">ax</span><span class="o">=</span><span class="nb">gca</span><span class="p">;</span> <span class="n">ax</span><span class="o">.</span><span class="n">XTick</span> <span class="o">=</span> <span class="p">([</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span> <span class="mi">5</span><span class="p">/</span><span class="mi">6</span><span class="o">*</span><span class="nb">pi</span> <span class="nb">pi</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">]);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XTickLabel</span> <span class="o">=</span><span class="p">({</span><span class="s1">'0'</span><span class="p">,</span><span class="s1">'1/2\pi'</span><span class="p">,</span><span class="s1">'5/6*\pi'</span><span class="p">,</span><span class="s1">'\pi'</span><span class="p">,</span><span class="s1">'2\pi'</span><span class="p">});</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'\omega*H'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'RPS'</span><span class="p">,</span><span class="s1">'P1 FEM'</span><span class="p">,</span><span class="s1">'FDM'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_05.png" alt="" /></p>

<p>Plot the numerical group velocity for sinusoidal solution and compare it with the ones for FDM and FEM</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">groupVelocity</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">phaseVelocity</span><span class="p">)/((</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">-</span><span class="mf">0.1</span><span class="p">)/</span><span class="mi">999</span><span class="p">)</span><span class="o">.*</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">phaseVelocity</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">clf</span><span class="p">,</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">groupVelocity</span><span class="p">)),</span><span class="n">groupVelocity</span><span class="p">)</span>
<span class="c1">%% for p1 FEM</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">p1GroupV</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">p1PhaseV</span><span class="p">)/((</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">-</span><span class="mf">0.1</span><span class="p">)/</span><span class="mi">999</span><span class="p">)</span><span class="o">.*</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">p1PhaseV</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">p1GroupV</span><span class="p">)</span>
<span class="c1">%% for FDM</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="n">fdmGroupV</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">fdmPhaseV</span><span class="p">)/((</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">-</span><span class="mf">0.1</span><span class="p">)/</span><span class="mi">999</span><span class="p">)</span><span class="o">.*</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">groupVelocity</span><span class="p">))</span><span class="o">+</span><span class="n">fdmPhaseV</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">groupVelocity</span><span class="p">));</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">groupVelocity</span><span class="p">)),</span><span class="n">fdmGroupV</span><span class="p">)</span>
<span class="c1">%% for ecact group velocity</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">xx</span><span class="p">)),</span><span class="s1">'LineStyle'</span><span class="p">,</span><span class="s1">'--'</span><span class="p">)</span>
<span class="c1">%%</span>
<span class="n">ax</span><span class="o">=</span><span class="nb">gca</span><span class="p">;</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XTick</span><span class="o">=</span><span class="p">([</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span> <span class="mi">5</span><span class="p">/</span><span class="mi">6</span><span class="o">*</span><span class="nb">pi</span> <span class="nb">pi</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">]);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XTickLabel</span> <span class="o">=</span><span class="p">({</span><span class="s1">'0'</span><span class="p">,</span><span class="s1">'1/2\pi'</span><span class="p">,</span><span class="s1">'5/6*\pi'</span><span class="p">,</span><span class="s1">'\pi'</span><span class="p">,</span><span class="s1">'2\pi'</span><span class="p">});</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XLim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="nb">pi</span><span class="p">];</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'\omega*H'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'RPS'</span><span class="p">,</span><span class="s1">'P1 FEM'</span><span class="p">,</span><span class="s1">'FDM'</span><span class="p">,</span><span class="s1">'exact'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_06.png" alt="" /></p>

<p>Plot the numerical disperation relation Disperation relation for RPS semi-discretizaton</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">diperss</span> <span class="o">=</span> <span class="n">phaseVelocity</span><span class="o">.*</span><span class="n">xx</span><span class="p">;</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">diperss</span><span class="p">)</span>
<span class="c1">%% for P1 FEM</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">,</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">xx</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="p">(</span><span class="mi">2</span><span class="p">/</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">/</span><span class="mi">3</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span><span class="o">.^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">));</span>
<span class="c1">%% for FDM</span>
<span class="nb">hold</span> <span class="n">on</span> <span class="p">,</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="p">/</span><span class="mi">2</span><span class="p">))</span>
<span class="c1">%% for exact one</span>
<span class="nb">hold</span> <span class="n">on</span> <span class="p">,</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">xx</span><span class="p">,</span><span class="s1">'LineStyle'</span><span class="p">,</span><span class="s1">'--'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">=</span><span class="nb">gca</span><span class="p">;</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XTick</span><span class="o">=</span><span class="p">([</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span> <span class="mi">5</span><span class="p">/</span><span class="mi">6</span><span class="o">*</span><span class="nb">pi</span> <span class="nb">pi</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">]);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XTickLabel</span> <span class="o">=</span><span class="p">({</span><span class="s1">'0'</span><span class="p">,</span><span class="s1">'1/2\pi'</span><span class="p">,</span><span class="s1">'5/6*\pi'</span><span class="p">,</span><span class="s1">'\pi'</span><span class="p">,</span><span class="s1">'2\pi'</span><span class="p">});</span>
<span class="n">ax</span><span class="o">.</span><span class="n">XLim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="nb">pi</span><span class="p">];</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'\omega*H'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'RPS'</span><span class="p">,</span><span class="s1">'P1 FEM'</span><span class="p">,</span><span class="s1">'FDM'</span><span class="p">,</span><span class="s1">'exact'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP04/P0002-Numerical homogenizaton/copiaRM_07.png" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;We analyze the stability of a simplified system modeling two converters in parallel connected to an ideal grid (modelled by a voltage source) via line impedances.&lt;/p&gt;
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0007/converters.png" alt="" /></p>

<p>Each of the converters is fed by a DC source and includes an $LC$ circuit at its output to filter the ripple introduced by the converter switching. Similarly, an $LR$ impedance is included after the $LC$ filter to model the characteristics of the line until the point of common connection (PCC). The grid in this case is modelled with an ideal voltage source $v_g$ with a series $LR$ impedance. In this context, $f$ subscript denotes filter and $o$ subscript denotes output of the inverter. The subscript %%g%% denotes that this variable is from the side of the grid.</p>

<p>The dynamics inside the system (e.g. how does the current in an inductor or the voltage in a capacitor evolve over time) is described by several differential equations describing the evolution of the state input vector. The model is then completed with the introduction of algebraic relations which link the previous equations by applying classical laws such as Kirchoff.</p>

<p>All these equations depend on some parameters characteristic of the physical model:</p>

<ul>
  <li>
    <p>$Rf_{1}$ and $Rf_{2}$: the filter resistors;</p>
  </li>
  <li>
    <p>$Lf_{1}$ and $Lf_{2}$: the inductances of the filter;</p>
  </li>
  <li>
    <p>$Cf_{1}$ and $Cf_{2}$: the capacitances;</p>
  </li>
  <li>
    <p>$Ro_{1}$ and $Ro_{2}$: the output resistors;</p>
  </li>
  <li>
    <p>$Lo_{1}$ and $Lo_{2}$: the output inductances;</p>
  </li>
  <li>
    <p>$Rg$: the grid resistor;</p>
  </li>
  <li>
    <p>$Lg$: the grid inductance.</p>
  </li>
</ul>

<p>The model is then written in the form $\dot{x} = Ax + Bu$, with</p>

<script type="math/tex; mode=display">% <![CDATA[
A = \left(\begin{array}{ccccccc} -\frac{\mathrm{Rf}_{1}}{\mathrm{Lf}_{1}} & -\frac{1}{\mathrm{Lf}_{1}} & 0 & 0 & 0 & 0 & 0\\ \frac{1}{\mathrm{Cf}_{1}} & 0 & -\frac{1}{\mathrm{Cf}_{1}} & 0 & 0 & 0 & 0\\ 0 & -\frac{\frac{1}{L\,\mathrm{Lo}_{1}}-1}{\mathrm{Lo}_{1}} & \frac{\mathrm{Ro}_{1}\,\left(\frac{1}{L\,\mathrm{Lo}_{1}}-1\right)}{\mathrm{Lo}_{1}} & 0 & -\frac{1}{L\,\mathrm{Lo}_{1}\,\mathrm{Lo}_{2}} & \frac{\mathrm{Ro}_{2}}{L\,\mathrm{Lo}_{1}\,\mathrm{Lo}_{2}} & \frac{\mathrm{Ro}_{2}}{L\,\mathrm{Lg}\,\mathrm{Lo}_{1}}\\ 0 & 0 & 0 & -\frac{\mathrm{Rf}_{2}}{\mathrm{Lf}_{2}} & -\frac{1}{\mathrm{Lf}_{2}} & 0 & 0\\ 0 & 0 & 0 & \frac{1}{\mathrm{Cf}_{2}} & 0 & -\frac{1}{\mathrm{Cf}_{2}} & 0\\ 0 & -\frac{1}{L\,\mathrm{Lo}_{1}\,\mathrm{Lo}_{2}} & \frac{\mathrm{Ro}_{1}}{L\,\mathrm{Lo}_{1}\,\mathrm{Lo}_{2}} & 0 & -\frac{\frac{1}{L\,\mathrm{Lo}_{2}}-1}{\mathrm{Lo}_{2}} & \frac{\mathrm{Ro}_{2}\,\left(\frac{1}{L\,\mathrm{Lo}_{2}}-1\right)}{\mathrm{Lo}_{2}} & -\frac{\mathrm{Rg}}{L\,\mathrm{Lg}}\\ 0 & \frac{1}{L\,\mathrm{Lg}\,\mathrm{Lo}_{1}} & -\frac{\mathrm{Ro}_{1}}{L\,\mathrm{Lg}\,\mathrm{Lo}_{1}} & 0 & \frac{\mathrm{Ro}_{1}}{L\,\mathrm{Lg}\,\mathrm{Lo}_{2}} & -\frac{\mathrm{Ro}_{2}}{L\,\mathrm{Lg}\,\mathrm{Lo}_{2}} & \frac{\mathrm{Rg}\,\left(\frac{1}{L\,\mathrm{Lg}}-1\right)}{\mathrm{Lg}} \end{array}\right) %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
B =   \left(\begin{array}{ccc} \frac{m_{1}}{\mathrm{Lf}_{1}} & 0 & 0\\ 0 & 0 & 0\\ 0 & 0 & -\frac{1}{L\,\mathrm{Lg}\,\mathrm{Lo}_{1}}\\ 0 & \frac{m_{2}}{\mathrm{Lf}_{2}} & 0\\ 0 & 0 & 0\\ 0 & 0 & 0\\ 0 & 0 & 0 \end{array}\right) %]]></script>

<p>and $u = [Vdc_{1} Vdc_{2} V_{g}]$. here we defined</p>

<script type="math/tex; mode=display">L=\left(Lo_{1}^{-1}+Lo_{2}^{-1}+Lg^{-1}\right)</script>

<p>The stability of the system is discussed by studying the evolution of the eigenvalues of $A$ in dependence of the aforementioned parameters. Due to the size of the system and to the large number of parameters involved, this stability analysis needs to be addressed by means of fine computational tools.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clear</span>
</code></pre>
</div>

<h2 id="variables-composing-the-state-vector">Variables composing the state vector</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Ii1</span> <span class="n">Vo1</span> <span class="n">Io1</span> <span class="n">Ii2</span> <span class="n">Vo2</span> <span class="n">Io2</span> <span class="n">Ig</span>
</code></pre>
</div>

<h2 id="parameters-entering-in-the-model">Parameters entering in the model</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Ro1</span> <span class="n">Rf1</span> <span class="n">Lf1</span> <span class="n">Cf1</span> <span class="n">Lo1</span>
<span class="n">syms</span> <span class="n">Ro2</span> <span class="n">Rf2</span> <span class="n">Lf2</span> <span class="n">Cf2</span> <span class="n">Lo2</span>
<span class="n">syms</span> <span class="n">Rg</span> <span class="n">Lg</span> <span class="n">L</span>
<span class="c1">%% sustituimos numericamente excepto nRo1 syms m1 m2</span>
</code></pre>
</div>

<p>Out of these parameters, we build the matrices $A$ and $B$ in symbolic form.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="n">Amatrix</span><span class="p">();</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">Bmatrix</span><span class="p">();</span>
</code></pre>
</div>

<p>We now want to study the evolution of the eigenvalues with respect to $\mathrm{Ro}_{1}$. Thus, we assign some fix value to all the others parameters</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">nRf1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nLf1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nCf1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nLo1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">nRo2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nRf2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nLf2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nCf2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">nLo2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nRg</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nLg</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/</span><span class="n">nLo1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">/</span><span class="n">nLo2</span> <span class="p">;</span>
</code></pre>
</div>

<p>and we build the corresponding matrix $A$, which will depend only on $Ro_{1}$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">symbolic</span>  <span class="o">=</span> <span class="p">[</span><span class="n">Rf1</span><span class="p">,</span> <span class="n">Lf1</span><span class="p">,</span> <span class="n">Cf1</span><span class="p">,</span> <span class="n">Lo1</span><span class="p">,</span> <span class="k">...</span>
             <span class="n">Ro2</span><span class="p">,</span>  <span class="n">Rf2</span><span class="p">,</span> <span class="n">Lf2</span><span class="p">,</span> <span class="n">Cf2</span><span class="p">,</span> <span class="n">Lo2</span><span class="p">,</span> <span class="k">...</span>
             <span class="n">Rg</span><span class="p">,</span>   <span class="n">Lg</span><span class="p">,</span>  <span class="n">L</span><span class="p">];</span>

<span class="n">numerical</span> <span class="o">=</span> <span class="p">[</span><span class="n">nRf1</span><span class="p">,</span> <span class="n">nLf1</span><span class="p">,</span> <span class="n">nCf1</span><span class="p">,</span> <span class="n">nLo1</span><span class="p">,</span> <span class="k">...</span>
             <span class="n">nRo2</span><span class="p">,</span>  <span class="n">nRf2</span><span class="p">,</span> <span class="n">nLf2</span><span class="p">,</span> <span class="n">nCf2</span><span class="p">,</span> <span class="n">nLo2</span><span class="p">,</span> <span class="k">...</span>
             <span class="n">nRg</span><span class="p">,</span>   <span class="n">nLg</span><span class="p">,</span>  <span class="n">nL</span><span class="p">];</span>
<span class="n">nA</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">symbolic</span><span class="p">,</span><span class="n">numerical</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code> 
nA =
 
[ -1,   -1,      0,  0,     0,    0,    0]
[  1,    0,     -1,  0,     0,    0,    0]
[  0,  1/2, -Ro1/2,  0,  -1/2,  1/2,  1/2]
[  0,    0,      0, -1,    -1,    0,    0]
[  0,    0,      0,  1,     0,   -1,    0]
[  0, -1/2,  Ro1/2,  0,   1/2, -1/2, -1/2]
[  0,  1/2, -Ro1/2,  0, Ro1/2, -1/2, -1/2]
 

</code></pre>
</div>

<p>Then, we convert it from symbolic to function_handle</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">funRo1</span> <span class="o">=</span> <span class="n">matlabFunction</span><span class="p">(</span><span class="nb">eig</span><span class="p">(</span><span class="n">nA</span><span class="p">));</span>
</code></pre>
</div>

<p>Finally, we compute and plot the eigenvalues of this matrix $A$ and we analyze their evolution while varying $Ro_{1}$ in a given range.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">nRo1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="mf">0.05</span><span class="p">:</span><span class="mi">5</span><span class="p">;</span>
<span class="n">eigenvalues</span> <span class="o">=</span> <span class="nb">cell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">length</span><span class="p">(</span><span class="n">nRo1</span><span class="p">));</span>
<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">inRo1</span> <span class="o">=</span> <span class="n">nRo1</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">%% in each iteration we replace in funRo1 a different value of the parameter</span>
    <span class="n">eigenvalues</span><span class="p">{</span><span class="n">index</span><span class="p">}</span> <span class="o">=</span> <span class="n">funRo1</span><span class="p">(</span><span class="n">inRo1</span><span class="p">);</span>
<span class="k">end</span>
</code></pre>
</div>

<p>For each value of $Ro_{1}$, the eigenvalues are stored in a cell. For instance, these are the eigenvalues corresponding to $Ro_{1}=-3$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">eigenvalues</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
ans =

  -1.0000 + 0.0000i
   0.0000 + 0.0000i
  -0.5000 - 0.8660i
  -0.5000 + 0.8660i
   0.0000 + 0.0000i
   0.2500 - 0.6614i
   0.2500 + 0.6614i


</code></pre>
</div>

<p>We then use use the Matlab program “EingEvolution” that we specifically degsigned, in order to see the evolution of these eigenvalues. This is done through the command <code class="highlighter-rouge">EingEvolution(autovalues,nRo1,'R_{o1}','Gif_evo_eig.gif')</code>.</p>

<p>Finally, we can plot the evolution of the eigenvalues as a function of $R_{o_1}$.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP01/P0007/Gif_evo_eig.gif" alt="" /></p>

<p>This procedure may be repeated for all the others parameters, thus obtaining a complete stability analysis of our model.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;Define vector fields of ODE : Kuramoto control problem whose dynamics is&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">\dot \theta_i = \omega_i + \frac{1}{N}\sum_{j=1}^N K_{ij} \sin(\theta_j-\theta_i),\quad i \neq 1,</script>

<p>where we control the first oscillator,</p>

<script type="math/tex; mode=display">\dot \theta_1 = u + \omega_1 + \frac{1}{N}\sum_{j=1}^N K_{1j} \sin(\theta_j-\theta_1),</script>

<p>in order to <strong>change the limit phase value to be 0</strong>.</p>

<p>We first define the system of ODEs in terms of symbolic variables.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clear</span> <span class="nb">all</span>
<span class="nb">clc</span>

<span class="n">m</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">%% [m]: number of oscillators, which we may change later.</span>

<span class="n">th</span> <span class="o">=</span> <span class="n">sym</span><span class="p">(</span><span class="s1">'th'</span><span class="p">,</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">%% [th_i]: phases of oscillators, $\theta_i$</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">sym</span><span class="p">(</span><span class="s1">'om'</span><span class="p">,</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">%% [om_i]: natural frequencies of osc., $\omega_i$</span>
<span class="n">KK</span> <span class="o">=</span> <span class="n">sym</span><span class="p">(</span><span class="s1">'K'</span><span class="p">,[</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">]);</span> <span class="c1">%% [Ki_j]: the coupling network matrix, $K_{i,j}$</span>

<span class="n">syms</span> <span class="n">Nsys</span><span class="p">;</span>   <span class="c1">%% [Nsys]: the vector fields of ODEs</span>
<span class="n">thth</span> <span class="o">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">th</span><span class="p">,[</span><span class="mi">1</span> <span class="n">m</span><span class="p">]);</span>
<span class="n">Nsys</span> <span class="o">=</span> <span class="n">om</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span><span class="p">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">KK</span><span class="o">.*</span><span class="nb">sin</span><span class="p">(</span><span class="n">thth</span><span class="o">.'</span> <span class="o">-</span> <span class="n">thth</span><span class="p">),</span><span class="mi">2</span><span class="p">);</span>   <span class="c1">%% Kuramoto interaction terms</span>
<span class="n">syms</span> <span class="n">u</span><span class="p">;</span> <span class="c1">%% [u]: One-dimensional control term</span>
<span class="n">Nsys</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Nsys</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>    <span class="c1">%% For the first particle, we put the control term</span>


<span class="c1">%% latex(Nsys)</span>
</code></pre>
</div>

<p>The system is as follows:</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/Nsys.png" alt="Variable 'Nsys' with $m=3$" /></p>

<h2 id="linearized-model-and-numerical-data-setting">Linearized model and numerical data setting</h2>

<p>We now construct the linearized system using Jacobian:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">syms</span> <span class="n">F</span><span class="p">;</span> <span class="c1">%% [F]: The system without control</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

<span class="n">syms</span> <span class="n">Amat</span> <span class="n">Bmat</span><span class="p">;</span> <span class="c1">%% [Amat, Bmat]: Symbolic versions of the matrix A and B</span>
<span class="n">th_eq</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">%% Evaluation of Jacobian is at equilibrium, [0;0;0;0].</span>
<span class="n">Amat</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">jacobian</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">th</span><span class="p">),</span><span class="n">th</span><span class="p">,</span><span class="n">th_eq</span><span class="p">);</span>
<span class="n">Bmat</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">th_eq</span><span class="p">),</span><span class="n">u</span><span class="p">);</span>
</code></pre>
</div>

<p>Construction of numerical matrices $A$ and $B$:</p>

<p>We next set the physical parameters. Natural frequencies, however, we put them zero to apply linear-quadratic control model.</p>

<p>The coupling network matrix is set to be random near ones(m,m):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  KK_init = ones(m,m)+0.2*(2*(rand(m,m)-0.5));
</code></pre>
</div>

<p>and save it in the folder ‘functions/coupling.mat’.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">om_init</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">load</span><span class="p">(</span><span class="s1">'functions/coupling.mat'</span><span class="p">,</span><span class="s1">'KK_init'</span><span class="p">);</span>

<span class="n">A</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Amat</span><span class="p">,[</span><span class="n">om</span><span class="p">,</span><span class="n">KK</span><span class="p">],[</span><span class="n">om_init</span><span class="p">,</span><span class="n">KK_init</span><span class="p">]));</span>
<span class="n">B</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">subs</span><span class="p">(</span><span class="n">Bmat</span><span class="p">,[</span><span class="n">om</span><span class="p">,</span><span class="n">KK</span><span class="p">],[</span><span class="n">om_init</span><span class="p">,</span><span class="n">KK_init</span><span class="p">]));</span>
</code></pre>
</div>

<h2 id="construction-of-the-lqr-controller-and-its-evaluation">Construction of the LQR controller and its evaluation</h2>

<p>We design the LQR controller and solve it with linearized model.</p>

<p>The cost is only for the symmetric quadrature at $[0,0,0]$ <strong>since we want all of them to be 0</strong>.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="p">[</span><span class="n">ricsol</span><span class="p">,</span><span class="n">cleig</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">Q</span><span class="p">);</span>
<span class="n">K</span> <span class="c1">%% Present the feedback matrix</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
K =

  Columns 1 through 7

    0.6358    0.2930    0.2924    0.2829    0.2604    0.3013    0.2775

  Columns 8 through 10

    0.2777    0.2701    0.2713


</code></pre>
</div>

<p>Practically, any $K$ with positive elements can make the limit point to be 0, e.g., K=[1,1,1].</p>

<p>The initial condition is chosen on $[-0.55\pi,0.55\pi]$ by</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ini = 0.55*pi()*(2*(rand(m,1)-0.5));
</code></pre>
</div>

<p>which is stored in the functions folder, ‘functions/ini.mat’.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">load</span><span class="p">(</span><span class="s1">'functions/ini.mat'</span><span class="p">,</span><span class="s1">'ini'</span><span class="p">);</span> <span class="c1">%% Safe data</span>

<span class="n">tspan</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">];</span>
</code></pre>
</div>

<p>1) Simulate the nonlinear dynamics without any control: $u = 0$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Isys_ori</span><span class="p">;</span>
<span class="n">Isys_ori</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">F</span><span class="p">,[</span><span class="n">om</span><span class="p">,</span><span class="n">KK</span><span class="p">],[</span><span class="n">om_init</span><span class="p">,</span><span class="n">KK_init</span><span class="p">]);</span>
<span class="n">Isys_ori_ftn_temp</span> <span class="o">=</span> <span class="n">matlabFunction</span><span class="p">(</span><span class="n">Isys_ori</span><span class="p">,</span><span class="s1">'Vars'</span><span class="p">,{</span><span class="n">th</span><span class="p">});</span>
<span class="n">Isys_ori_ftn</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">Isys_ori_ftn_temp</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="p">[</span><span class="n">timenc</span><span class="p">,</span> <span class="n">statenc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">Isys_ori_ftn</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span> <span class="c1">%% Solve ODE with 'ode45'</span>
</code></pre>
</div>

<p>2) Simulate the linear dynamics with CARE function</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>

<span class="n">i_linear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="p">[</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_linear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>
</code></pre>
</div>

<p>3) Simulate the nonlinear dynamics with the same control</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">syms</span> <span class="n">Isys</span><span class="p">;</span>
<span class="n">Isys</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,[</span><span class="n">om</span><span class="p">,</span><span class="n">KK</span><span class="p">,</span><span class="n">u</span><span class="p">],[</span><span class="n">om_init</span><span class="p">,</span><span class="n">KK_init</span><span class="p">,(</span><span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">th</span><span class="p">)]);</span>
<span class="n">Isys_ftn_temp</span> <span class="o">=</span> <span class="n">matlabFunction</span><span class="p">(</span><span class="n">Isys</span><span class="p">,</span><span class="s1">'Vars'</span><span class="p">,{</span><span class="n">th</span><span class="p">});</span>
<span class="n">Isys_ftn</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">Isys_ftn_temp</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="p">[</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">Isys_ftn</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="visualization">Visualization</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">plot</span><span class="p">(</span><span class="n">timenc</span><span class="p">,</span> <span class="n">statenc</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'-k'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">%% The first oscillator is black-colored.</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timenc</span><span class="p">,</span> <span class="n">statenc</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [\pi]'</span><span class="p">)</span> <span class="c1">%% The unit is $\pi$.</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Figure 1: Phases of the model without control'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/copiaRM_01.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'-k'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [\pi]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Figure 2: Phases of the linearized model'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/copiaRM_02.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'-k'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [\pi]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Figure 3: Phases of the Kuramoto model'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/copiaRM_03.png" alt="" /></p>

<p>In Figure 1, the limit point is not zero since the mean value of initial phases is nonzero.</p>

<p>Figure 2 shows that the first oscillator keeps it phase above zero to make the final phases zero.</p>

<p>The nonlinear model has less decay then the linearized model, but goes to zero in Figure 3.</p>

<h2 id="failure-of-lqr-control-for-large-initial-data">Failure of LQR control for large initial data</h2>

<p>The initial data is from</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">ini2</span> <span class="o">=</span> <span class="nb">pi</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="nb">rand</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="p">));</span>
</code></pre>
</div>

<p>which is uniformly distributed on $[-\pi,\pi]$. We expect the limit point to be separated in the real line with differences $2\pi$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">load</span><span class="p">(</span><span class="s1">'functions/ini2.mat'</span><span class="p">,</span><span class="s1">'ini2'</span><span class="p">);</span> <span class="c1">%% Separated data</span>

<span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>

<span class="n">i_linear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">tspan</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">];</span>
<span class="p">[</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_linear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini2</span><span class="p">);</span>

<span class="n">syms</span> <span class="n">Isys</span><span class="p">;</span>
<span class="n">Isys</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">Nsys</span><span class="p">,[</span><span class="n">om</span><span class="p">,</span><span class="n">KK</span><span class="p">,</span><span class="n">u</span><span class="p">],[</span><span class="n">om_init</span><span class="p">,</span><span class="n">KK_init</span><span class="p">,(</span><span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">th</span><span class="p">)]);</span>
<span class="n">Isys_ftn_temp</span> <span class="o">=</span> <span class="n">matlabFunction</span><span class="p">(</span><span class="n">Isys</span><span class="p">,</span><span class="s1">'Vars'</span><span class="p">,{</span><span class="n">th</span><span class="p">});</span>
<span class="n">Isys_ftn</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">Isys_ftn_temp</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">[</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">Isys_ftn</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini2</span><span class="p">);</span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'-k'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [\pi]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Figure 4: Phases of the linearized model'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'-k'</span><span class="p">,</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="p">)/</span><span class="nb">pi</span><span class="p">(),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Phases [\pi]'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Figure 5: Phases of the Kuramoto model'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/copiaRM_04.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0004/copiaRM_05.png" alt="" /></p>

<p>We can see that $\theta_1$ does not tend to zero in Figure 5 since $K\times\Theta$ is near zero already. Linear feedback control is not enough, or too weak, for this setting.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this tutorial, we will demonstrate how to design a LQR controller in order to stabilize the linear population dynamics model dependent on age and space&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">\begin{cases} y_t=y_{xx}-y_a+(\lambda-\mu(a))y+ U\chi_{Q_{\omega}} \text{ in } (0,1)\times (0,A)\times (0,T)\\ y(x,a,0)=y_0(x,a) \text { in } (0,1)\times (0,A)\\ y(0,a,t)=y(1,a,t)=0\text{ in } (0,A)\times(0,T)\\ y(x,0,t)=\int_{0}^{A}\beta(a)y(x,a,t)da,\\ \end{cases}</script>

<p>where $\beta$ and $\mu$ are respectively the fertility and mortality rate. The parameter $\lambda&gt;0$ is an immigration term (or unstable term), $Q_{\omega}=(a,b)\times (a_1,a_2)\times (0,T)$ is the control domain with $(a,b)\subset (0,1)$ and $(a_1,a_2)\subset (0,A).$ Here $(a,b)=(0,1)$ and $(a_1,a_2)=(0,A)$ and we take $A=1$.</p>

<p>We need to reduce the PDE to the finite dimensional system of the form <script type="math/tex">\dot{Z}=AZ+BU</script> where $A$ and $B$ are matrices, and</p>

<script type="math/tex; mode=display">\begin{pmatrix} Z(t) \\ U(t) \\ \end{pmatrix}</script>

<p>is the finite dimensional state vector.</p>

<h2 id="implementation">Implementation</h2>

<p>Construction of the matrix A. We suppose that $\lambda=\frac{1}{2}.$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clc</span><span class="p">;</span> <span class="nb">clear</span><span class="p">;</span>
<span class="n">m</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
<span class="n">n</span><span class="o">=</span><span class="mi">9</span><span class="o">*</span><span class="n">m</span><span class="p">;</span>
</code></pre>
</div>

<p>Matrix of birth Here we suppose that fertility rate $\beta$ equal to:</p>

<script type="math/tex; mode=display">% <![CDATA[
\beta(a) = \begin{cases} 0 & \text { if } a<1/9 \\ 25\frac{\alpha(a-1/9)^{\gamma-1}e^{-(a-1/9)/v}}{v^{\gamma}\Gamma(\gamma)} &\text{ if } 2/9<a<7/9\\ 0 &\text{ if } a\geq 7/9. \end{cases} %]]></script>

<p>Here $\alpha=7$, $\gamma=5$, $v=3$, $a_1=\frac{A}{9}$</p>

<p>The density of new born individuals will be approximated by:</p>

<script type="math/tex; mode=display">y(x,0,t)=\int_{0}^{1}\beta(a)y(x,a,t)da=(1/n)\sum_{1}^{n}\beta(a_i)y(x,a_i,t)</script>

<p>where $a_i$ is the age discretization.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">A1</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="n">A2</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="k">for</span> <span class="nb">j</span><span class="o">=</span><span class="n">m</span><span class="p">:</span><span class="mi">7</span><span class="o">*</span><span class="n">m</span>
    <span class="n">bj</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="p">(</span><span class="nb">j</span><span class="p">/</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="mi">9</span><span class="p">)</span><span class="o">^</span><span class="mi">4</span><span class="o">*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="nb">j</span><span class="p">/</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="mi">9</span><span class="p">)/</span><span class="mi">3</span><span class="p">)/(</span><span class="mi">3</span><span class="o">^</span><span class="mi">5</span><span class="o">*</span><span class="nb">gamma</span><span class="p">(</span><span class="mi">5</span><span class="p">)));</span>
    <span class="n">A2</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,(</span><span class="nb">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="nb">j</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">=</span><span class="n">bj</span><span class="o">*</span><span class="n">A1</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">P</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">/</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">A2</span><span class="p">;</span>
</code></pre>
</div>

<p>Discrerization of the second derivative in space and the derivative in age.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">A3</span><span class="o">=</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="n">n</span><span class="p">);</span>
<span class="n">B1</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">A3</span><span class="p">;</span>
<span class="n">A4</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">/(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="n">A5</span><span class="o">=</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
<span class="n">A6</span><span class="o">=</span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">B2</span><span class="o">=</span><span class="n">A4</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">/(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">A5</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">/(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">A6</span><span class="p">;</span>
<span class="n">B3</span><span class="o">=</span><span class="nb">kron</span><span class="p">(</span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">B2</span><span class="p">);</span>
</code></pre>
</div>

<p>Mortality matrix. The mortality rate $\beta(a)=\dfrac{1}{9(A-a)}$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">S</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="k">for</span> <span class="nb">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
    <span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
        <span class="n">S</span><span class="p">((</span><span class="nb">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="nb">i</span><span class="p">,(</span><span class="nb">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="nb">i</span><span class="p">)</span><span class="o">=-</span><span class="mi">1</span><span class="p">/(</span><span class="mi">16</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">((</span><span class="nb">j</span><span class="o">*</span><span class="n">n</span><span class="p">)/(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))));</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="n">A</span><span class="o">=</span><span class="n">P</span><span class="o">+</span><span class="n">B1</span><span class="o">+</span><span class="n">B3</span><span class="o">+</span><span class="n">S</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="initial-condition">Initial condition</h2>

<p>We suppose that $y(x,a,0)=e^{-((a-3/10)^2/\sqrt{2}+100(x-4/10))}$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">T</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="n">Z0</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
    <span class="k">for</span> <span class="nb">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
        <span class="n">Z0</span><span class="p">((</span><span class="nb">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="nb">j</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="nb">i</span><span class="p">/</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">/</span><span class="mi">10</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)/</span><span class="nb">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="nb">j</span><span class="p">/</span><span class="n">n</span><span class="o">-</span><span class="mi">4</span><span class="p">/</span><span class="mi">10</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Numerical solution without control and visualisation</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">f</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">Z</span><span class="p">;</span>
<span class="p">[</span><span class="n">t1</span><span class="p">,</span><span class="n">Z</span><span class="p">]</span><span class="o">=</span><span class="nb">ode45</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">],</span><span class="n">Z0</span><span class="p">);</span>
<span class="n">L</span><span class="o">=</span><span class="n">Z</span><span class="p">(</span><span class="mi">256</span><span class="p">,:);</span>
<span class="n">U</span><span class="o">=</span><span class="n">Z</span><span class="p">(</span><span class="mi">512</span><span class="p">,:);</span>
<span class="n">W</span><span class="o">=</span><span class="n">Z</span><span class="p">(</span><span class="mi">1025</span><span class="p">,:);</span>
<span class="n">J</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">X</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">Y</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">F1</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">Z0</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">V1</span><span class="o">=</span><span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">V2</span><span class="o">=</span><span class="n">V1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">[</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">]</span><span class="o">=</span><span class="nb">meshgrid</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span><span class="n">V2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">F1</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'initial condition'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_01.png" alt="" /></p>

<p>Here is the state y of the unstable system at time t=2,5.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">J</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'state y of the unstable system at timte t=2,5'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_02.png" alt="" /></p>

<p>Here is the state y of the unstable system at time t=5.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">X</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'state y of the unstable system at time t=10'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_03.png" alt="" /></p>

<p>Here is the state y of the unstable system at time t=10.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">Y</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'state y of the unstable system at time t=10'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_04.png" alt="" /></p>

<p>The control matrix B is constructed as follows:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">B</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
</code></pre>
</div>

<p>We may now proceed with the optimal control strategy. For a continuous time linear system generated by the matrices $(A,B)$ and an infinite time horizon cost functional defined as</p>

<script type="math/tex; mode=display">J = \int_0^\infty \langle Q z(t), z(t) \rangle + \langle R u(t), u(t)   \rangle dt,</script>

<p>the feedback control law that minimizes the value of the cost is $u = -Kz$, where $K = R^{-1}B*P$ and $P$ is found by solving the continuous time algebraic Ricatti equation</p>

<script type="math/tex; mode=display">A*P+PA-(PB)R^1(B*P)+Q=0.</script>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="n">H</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="o">'</span><span class="p">);</span>
</code></pre>
</div>

<p>LQR feedback control-Algebric Ricatti equation</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">ricsol</span><span class="p">,</span> <span class="n">cleig</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
<span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">z</span><span class="p">;</span>
</code></pre>
</div>

<p>Numerical solution with LQR feedback control and visualisation</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">f_2</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">Z</span><span class="o">+</span><span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">Z</span><span class="p">);</span>
<span class="p">[</span><span class="n">t2</span><span class="p">,</span><span class="n">Z_ctr</span><span class="p">]</span><span class="o">=</span><span class="nb">ode45</span><span class="p">(</span><span class="n">f_2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">],</span><span class="n">Z0</span><span class="p">);</span>
<span class="n">E</span><span class="o">=</span><span class="n">Z_ctr</span><span class="p">(</span><span class="mi">256</span><span class="p">,:);</span>
<span class="n">O</span><span class="o">=</span><span class="n">Z_ctr</span><span class="p">(</span><span class="mi">512</span><span class="p">,:);</span>
<span class="n">G</span><span class="o">=</span><span class="n">Z_ctr</span><span class="p">(</span><span class="mi">1025</span><span class="p">,:);</span>
<span class="n">G1</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">N</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">M</span><span class="o">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">O</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</code></pre>
</div>

<p>Here is the stabilized state y of the system at the time t=2,5.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'stabilized state of the system at time t=2,5'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_05.png" alt="" /></p>

<p>Here is the stabilized state y of the system at time t=5.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">M</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'stabilized state of the system at time t=5'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_06.png" alt="" /></p>

<p>Here is the stabilized state y of the system at time t=10.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">V3</span><span class="p">,</span><span class="n">V4</span><span class="p">,</span><span class="n">G1</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'age'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'stabilized state of the system at time t=10'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0005/copiaRM_07.png" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;We consider the semilinear hyperbolic system&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} \partial_t y + \lambda \partial_x y = c_1 v + yv \quad & (x,t)\in (0,L)\times (0,T) \\ \partial_t v + \lambda \partial_x v = c_2 y + yv  & (x,t)\in (0,L)\times (0,T) \\ y(0,t) = v(0,t) & t \in (0,T) \\ v(L,t) = u(t) & t \in (0,T) \\ y(x,0) = y^0(x) & x \in (0,L) \\ v(x,0) = v^0(x) & x \in (0,L), \end{cases} %]]></script>

<p>where $\lambda &gt; 0$ and $u$ is the control. The stability and boundary stabilization of such 1D hyperbolic systems is studied in [1]. The aim of this tutorial is to semi-discretize in space this system of equations and design a stabilizing control by using the LQR method.</p>

<p>The above system linearized around $(y,v) = (0,0)$ has the form</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} \partial_t y + \lambda \partial_x y = c_1 v  \quad & (x,t)\in (0,L)\times (0,T) \\ \partial_t v + \lambda \partial_x v = c_2 y  & (x,t)\in (0,L)\times (0,T) \\ y(0,t) = v(0,t) & t \in (0,T) \\ v(L,t) = u(t) & t \in (0,T) \\ y(x,0) = y^0(x) & x \in (0,L) \\ v(x,0) = v^0(x) & x \in (0,L). \end{cases} %]]></script>

<p>We will first use the LQR method to design a stabilizing control for the semi-discretized linear system, and then this control will be applied to the semi-discretized semilinear system.</p>

<h2 id="space-discretization">Space discretization</h2>

<p>The intervall $(0,L)$ is divided in $n+1$ subintervals, of size $h_x := \frac{L}{n+1}$, by $n+2$ evenly spaced points $x_k = kh_x$. Hence, $x_0 = 0$ and $x_{n+1} = L$. We set $y_k(t) = y(x_k,t), \quad v_k(t) := v(x_k,t)$ and similarly for the inital conditions $y_k^0(t) = y^0(x_k)$ and $v_k^0(t) := v(x_k)$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clear</span><span class="p">;</span> <span class="nb">clc</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">hx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>The points where y and v are unknown are contained in x1 and x2 respectively, where x1 and x2 are defined below.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">x1</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>Finite differences for the space derivative give</p>

<script type="math/tex; mode=display">% <![CDATA[
\partial_x y(x_k,t) \approx \begin{cases} \frac{y_1(t)}{h_x} - \frac{v_0(t)}{h_x} \quad & k=1\\ \frac{y_k(t)-y_{k-1}(t)}{h_x} \quad  &\forall k \in \{2, \ldots, n+1 \} \end{cases} %]]></script>

<p>and</p>

<script type="math/tex; mode=display">% <![CDATA[
\partial_x v(x_k,t) \approx \begin{cases} \frac{v_{k+1}(t)-v_{k}(t)}{h_x} &\forall k \in \{0, \ldots, n-1 \} \\ \frac{-v_n(t)}{h_x} + \frac{u(t)}{h_x} \quad &k=n. \end{cases} %]]></script>

<p>The sign of $\lambda$ in each equation must be taken into account to choose the approximation of $\partial_x y$ and $\partial_x v$.</p>

<p>Let $d = 2(n+1)$ represent the dimension of the state space for the semi-discretized systems. Defining the state variable $z \colon (0,T) \mapsto \mathbb{R}^d$ by</p>

<script type="math/tex; mode=display">z = \big(y_1, y_2, \ldots, y_{n+1}, v_0, v_1, \ldots, v_n \big)^\mathrm{T},</script>

<p>the semilinear system writes as</p>

<script type="math/tex; mode=display">\begin{cases} \dot{z} = Az+ Bu + f(z,u) \qquad t \in (0,T)\\ z(0) = z_0, \end{cases}</script>

<p>and the linearized system writes as</p>

<script type="math/tex; mode=display">\begin{cases} \dot{z} = Az+ Bu \qquad t \in (0,T)\\ z(0) = z^0. \end{cases}</script>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">d</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>We pick the initial condition</p>

<script type="math/tex; mode=display">z^0 := \big(y^0_1, y^0_2, \ldots, y^0_{n+1}, v^0_0, v^0_1, \ldots, v^0_n \big)^\mathrm{T}.</script>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">y0</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">x1</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
<span class="n">v0</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">x2</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
<span class="n">z0</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="n">z0</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">y0</span><span class="p">;</span> <span class="n">z0</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">v0</span><span class="p">;</span>
</code></pre>
</div>

<p>We set values for $\lambda$, $c_1$ and $c_2$:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">lambda</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre>
</div>

<p>We consider the time parameters</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">T</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">nT</span> <span class="o">=</span> <span class="mi">70</span><span class="p">;</span>
<span class="n">time</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">nT</span><span class="p">);</span>
</code></pre>
</div>

<p>The matrix $A$ of size $d \times d$ is given by</p>

<script type="math/tex; mode=display">% <![CDATA[
A = \begin{pmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \end{pmatrix}, %]]></script>

<p>where $A_{11}, A_{12}, A_{21}, A_{22}$, of size $(n+1)\times(n+1)$, are defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
A_{11} = \begin{pmatrix} \frac{-\lambda}{h_x} & & & \\ \frac{\lambda}{h_x} & \ddots & & & \\  & \ddots & \ddots &  \\  & & \frac{\lambda}{h_x} & \frac{-\lambda}{h_x} \end{pmatrix}, \quad A_{12} = \begin{pmatrix} \frac{\lambda}{h_x} & c_1 & & \\  & 0 & \ddots & \\  & & \ddots & c_1 \\  & & & 0 \\ \end{pmatrix} %]]></script>

<p>and</p>

<script type="math/tex; mode=display">% <![CDATA[
A_{21} = \begin{pmatrix} 0 & & & \\ c_2 & \ddots & & \\  & \ddots & \ddots & \\  & & c_2 & 0 \end{pmatrix}, \quad A_{22}= \begin{pmatrix}  \big(\frac{-\lambda}{h_x}+c_2\big) & \frac{\lambda}{h_x} & & \\  & \frac{-\lambda}{h_x} & \ddots & \\  & & \ddots & \frac{\lambda}{h_x} \\  & & & \frac{-\lambda}{h_x} \end{pmatrix}. %]]></script>

<p>They are constructed as follows.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="c1">%% Lower and upper extradiagonals:</span>
<span class="n">ext_down_1</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="n">ext_down_1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">/</span><span class="n">hx</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">ext_down_2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">ext_up_1</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="n">ext_up_1</span><span class="p">(</span><span class="mi">1</span><span class="p">,(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">):(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">/</span><span class="n">hx</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">ext_up_2</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="n">ext_up_2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">/</span><span class="n">hx</span><span class="p">;</span>
<span class="n">ext_up_3</span> <span class="o">=</span> <span class="n">c1</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="c1">%% We assemple:</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">lambda</span><span class="p">/</span><span class="n">hx</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="n">A</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">c2</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="n">ext_up_1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="n">ext_up_2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="n">ext_up_3</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="n">ext_down_1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="n">ext_down_2</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</code></pre>
</div>

<p>The matrix $B$ is of size $d \times 1$ and is given by</p>

<script type="math/tex; mode=display">B = \begin{pmatrix} B_1 \\ B_2 \end{pmatrix},</script>

<p>where $B_1, B_2$, of size $(n+1)\times 1$, are defined by</p>

<script type="math/tex; mode=display">B_1 = \begin{pmatrix} 0 \\ \vdots \\ 0 \\ c_1 \end{pmatrix}, \quad B_2 = \begin{pmatrix} 0 \\ \vdots \\ 0 \\ \frac{\lambda}{h_x} \end{pmatrix}.</script>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">B</span><span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">B</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">c1</span><span class="p">;</span> <span class="n">B</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">/</span><span class="n">hx</span><span class="p">;</span>
</code></pre>
</div>

<h2 id="the-lqr-method">The LQR method</h2>

<p>We check that a LQR control can be computed for the semi-descretize linear system. To begin, we verify that $ (A,BB^\ast) $ is stabilizable (where $B^\ast$ denotes the transpose of $B$), meaning that $\text{rank}((sI-A) BB^\ast) = d$ for any eigenvalue $s$ of $A$ with a nonnegative real part.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">disp</span><span class="p">(</span><span class="s1">'Stabilizability of (A, BB*):'</span><span class="p">);</span>
<span class="n">eA</span><span class="o">=</span><span class="nb">eig</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">not_stabilizable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">cpt</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
    <span class="k">if</span> <span class="nb">real</span><span class="p">(</span><span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">))</span><span class="o">&gt;=</span><span class="mi">0</span>
        <span class="nb">disp</span><span class="p">(</span><span class="n">cpt</span><span class="p">);</span> <span class="nb">disp</span><span class="p">(</span><span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">));</span>

        <span class="n">M</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">);</span>
        <span class="n">M</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="n">A</span><span class="p">;</span>
        <span class="n">M</span><span class="p">(:,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="p">(</span><span class="n">B</span><span class="o">'</span><span class="p">);</span>

        <span class="n">r</span> <span class="o">=</span> <span class="nb">rank</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">~=</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">not_stabilizable</span> <span class="o">=</span> <span class="n">not_stabilizable</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="k">if</span> <span class="n">not_stabilizable</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="nb">disp</span><span class="p">(</span><span class="s1">'stabilizable.'</span><span class="p">);</span>
<span class="k">else</span>
    <span class="nb">disp</span><span class="p">(</span><span class="s1">'not stabilizable.'</span><span class="p">);</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Stabilizability of (A, BB*):
    18

    0.3047

stabilizable.

</code></pre>
</div>

<p>Then, we verify that the eigenvalues of the Hamiltonian matrix</p>

<script type="math/tex; mode=display">% <![CDATA[
H = \begin{pmatrix} A & -BB^* \\ -Q & -A^* \end{pmatrix} %]]></script>

<p>are not purely imzginary. Here, $Q$ is a matrix of size $d \times d$ to be chosen.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="n">H</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="o">'</span><span class="p">);</span>
<span class="n">H</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">Q</span><span class="p">;</span>
<span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">(</span><span class="n">B</span><span class="o">'</span><span class="p">);</span>
<span class="n">eH</span> <span class="o">=</span> <span class="nb">eig</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
<span class="n">nb_imaginary_eig_val_hamiltonian</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">real</span><span class="p">(</span><span class="n">eH</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="nb">disp</span><span class="p">(</span><span class="s1">'Number of eigenvalues of H on the imaginary axis:'</span><span class="p">)</span>
<span class="nb">disp</span><span class="p">(</span><span class="n">nb_imaginary_eig_val_hamiltonian</span><span class="p">);</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Number of eigenvalues of H on the imaginary axis:
     0


</code></pre>
</div>

<p>To finish, we verify that $(Q, A)$ is stabilizable, meaning that the rank of</p>

<script type="math/tex; mode=display">\begin{pmatrix} Q \\ sI-A \end{pmatrix}</script>

<p>is equal to $d$, for any eigenvalue $s$ of $A$ with a nonnegative real part.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">disp</span><span class="p">(</span><span class="s1">'Detectability of (Q, A):'</span><span class="p">);</span>
<span class="n">not_detectable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">cpt</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
    <span class="k">if</span> <span class="nb">real</span><span class="p">(</span><span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">))</span><span class="o">&gt;=</span><span class="mi">0</span>
        <span class="nb">disp</span><span class="p">(</span><span class="n">cpt</span><span class="p">);</span> <span class="nb">disp</span><span class="p">(</span><span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">));</span>

        <span class="n">J</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">J</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="p">,</span> <span class="p">:)</span> <span class="o">=</span> <span class="n">Q</span><span class="p">;</span>
        <span class="n">J</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">:)</span> <span class="o">=</span> <span class="n">eA</span><span class="p">(</span><span class="n">cpt</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="n">A</span><span class="p">;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="nb">rank</span><span class="p">(</span><span class="n">J</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">~=</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">not_detectable</span> <span class="o">=</span> <span class="n">not_detectable</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="k">if</span> <span class="n">not_detectable</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="nb">disp</span><span class="p">(</span><span class="s1">'detectable.'</span><span class="p">);</span>
<span class="k">else</span>
    <span class="nb">disp</span><span class="p">(</span><span class="s1">'not detectable.'</span><span class="p">);</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Detectability of (Q, A):
    18

    0.3047

detectable.

</code></pre>
</div>

<p>The LQR control is given by the matlab routine care(), as the application $t \mapsto -Kz(t)$. The matrix $K$, of size $m \times d$ is an output of care(), where $m$ is the dimention of the input space and is equal to one.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">ricsol</span><span class="p">,</span> <span class="n">cleig</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
<span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">z</span><span class="p">;</span>
</code></pre>
</div>

<h2 id="unstable-and-stabilized-systems-solutions">Unstable and stabilized system’s solutions</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre>
</div>

<p>We compute the solution to the linear system with a control equal to zero:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">F1</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">u</span><span class="p">;</span>
<span class="p">[</span><span class="n">t1</span><span class="p">,</span> <span class="n">Z1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">z0</span><span class="p">);</span>
</code></pre>
</div>

<p>The corresponding solutions $y$ and $v$ are displayed:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z1</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution y for unstable linear system'</span><span class="p">);</span>

<span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z1</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution v for unstable linear system'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_01.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_02.png" alt="" /></p>

<p>We compute the solution to the linear system with the feedback control:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">F2</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="p">[</span><span class="n">t2</span><span class="p">,</span> <span class="n">Z2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">F2</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">z0</span><span class="p">);</span>
</code></pre>
</div>

<p>The corresponding solutions $y$ and $v$ are displayed:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z2</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution y for stabilized linear system'</span><span class="p">);</span>

<span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z2</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution v for stabilized linear system'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_03.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_04.png" alt="" /></p>

<p>We compute the solution to the semilinear system with the same feedback control as the one found for the linear system:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">F3</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.*</span><span class="n">z</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span><span class="p">:</span><span class="n">d</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="n">z</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">z</span><span class="p">);</span><span class="n">z</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="p">;</span> <span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.*</span><span class="n">z</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span><span class="p">:</span><span class="n">d</span><span class="p">,</span><span class="mi">1</span><span class="p">)];</span>
<span class="p">[</span><span class="n">t3</span><span class="p">,</span> <span class="n">Z3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">F3</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">z0</span><span class="p">);</span>
</code></pre>
</div>

<p>The corresponding solutions $y$ and $v$ are displayed:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z3</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution y for stabilized semilinear system'</span><span class="p">);</span>

<span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span> <span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z3</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'space'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Solution v for stabilized semilinear system'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_05.png" alt="" /></p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_06.png" alt="" /></p>

<p>We compare the euclidean norm of the preceding solutions:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">y1_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z1</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">y2_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z2</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">v1_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z1</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">v2_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z2</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">y3_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z3</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">v3_norm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Z3</span><span class="p">(:,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">norm1</span> <span class="o">=</span> <span class="p">(</span><span class="n">y1_norm</span> <span class="o">+</span> <span class="n">v1_norm</span><span class="p">)</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="n">norm2</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2_norm</span> <span class="o">+</span> <span class="n">v2_norm</span><span class="p">)</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="n">norm3</span> <span class="o">=</span> <span class="p">(</span><span class="n">y3_norm</span> <span class="o">+</span> <span class="n">v3_norm</span><span class="p">)</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="mi">2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">norm1</span><span class="p">,</span> <span class="s1">'lineWidth'</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">norm2</span><span class="p">,</span> <span class="s1">'lineWidth'</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="n">norm3</span><span class="p">,</span> <span class="s1">'lineWidth'</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'zero control, linear syst.'</span><span class="p">,</span> <span class="s1">'feedback control, linear syst.'</span><span class="p">,</span> <span class="s1">'feedback control, semilin. syst.'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'time'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'euclidean norm of z'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Euclidean norm of solutions across time'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0004/copiaRM_07.png" alt="" /></p>

<h2 id="references">References</h2>

<p>[1] Bastin G., J.-M. Coron, Stability and boundary stabilization of 1-D Hyperbolic systems. 2016.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;div class="language-matlab highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="nb"&gt;clc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;
</code></pre>
</div>
<p>&lt;/div&gt;</p>

<p>Summary of example objective The goal of this tutorial is to use LQR theory applied to a model of collective behavior. The model choosen shares a formal structure with the semidiscretization of the semilinear 1d heat equation.</p>

<p>Consider $N$  agents $y_i$ for $i=1,…,N$, and let $y=(y_1,…,y_N)\in \mathbb{R}^N$.</p>

<p>The model considered is the following:</p>

<p><script type="math/tex">\dot{y}=Ay+\vec{G}(y)=:F(y)</script> where $A$ is a matrix of the form:</p>

<script type="math/tex; mode=display">% <![CDATA[
A:=\begin{pmatrix}  -1 & 1& 0& & &\cdots & & & 0\\  1 & -2& 1& 0& &\cdots & & & 0\\  0 & 1& -2& 1& 0 &\cdots & & & 0\\  \\  \vdots\\  \\  0 & 0& 0& &\cdots & 0& 1& -2& 1\\  0 & 0& 0& &\cdots & & 0& 1& -1 \end{pmatrix}_{N\times N} %]]></script>

<p>and $\vec{G}:\mathbb{R}^N\to\mathbb{R}^N$ is a non linear function of the form</p>

<script type="math/tex; mode=display">\begin{equation} \vec{G}(x)=\begin{pmatrix}  G(x_1)\\  G(x_2)\\  \vdots\\  G(x_N) \end{pmatrix}, \end{equation}</script>

<p>where $G$ is a non-linear function, matrix $A$ models the interaction between agents. Agent $i$ changes its state according to the state of agent $i+1$ and $i-1$ in a linear way plus a non-linear effect that depends only on his state.</p>

<p>Note that the manifold</p>

<script type="math/tex; mode=display">% <![CDATA[
\mathcal{M}_N=\{x\in\mathbb{R}^N\text{ such that }x=\alpha \begin{pmatrix}&1\\&1\\&\vdots\\&1\end{pmatrix}\quad\alpha\in\mathbb{R}\} %]]></script>

<p>is invariant under $F$. Indeed, taking $x\in\mathcal{M}_N$ we have that</p>

<script type="math/tex; mode=display">Ax=0.</script>

<p>Therefore, the mean will follow the following 1-d dynamical system</p>

<script type="math/tex; mode=display">\dot{\alpha}=G(\alpha)</script>

<p>Here we will consider that $G(0)=0$ and that $DG(0)&gt;0$, we have an unstable critical point at 0. Let N=20,</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="n">A</span><span class="o">=</span><span class="nb">full</span><span class="p">(</span><span class="nb">gallery</span><span class="p">(</span><span class="s1">'tridiag'</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">A</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
</code></pre>
</div>

<p>and that</p>

<script type="math/tex; mode=display">\vec{G}(x)\in \mathcal{M}_N</script>

<p>here $G$ is taken in the following form (and we compute also its derivative).</p>

<p>The non-linearity choosen is:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
<span class="n">c</span><span class="o">=</span><span class="mf">0.20</span><span class="p">;</span>
<span class="n">syms</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">syms</span> <span class="n">DG</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">piecewise</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;=-</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&lt;</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">a</span><span class="p">));</span>
<span class="n">DG</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="n">G</span><span class="o">=@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nb">double</span><span class="p">(</span><span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="n">DG</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nb">double</span><span class="p">(</span><span class="n">DG</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>

<span class="nb">close</span> <span class="nb">all</span>
<span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">fplot</span><span class="p">(</span><span class="n">G</span><span class="p">,[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Plot of the non-linearity'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
<span class="nb">grid</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0003/copiaRM_01.png" alt="" /></p>

<p>The function field assigns an $N$ dimensional vector corresponding to the field for every point in $\mathbb{R}^N$, matrix $A$ and the nonlinear function $G$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">F</span><span class="o">=@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="n">field</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
F =

  function_handle with value:

    @(t,y)field(A,G,y)


</code></pre>
</div>

<p>Now its the turn to define our cost functional. Our goal will be to stabilize the system in a critical point inside the manifold $\mathcal{M}_N$. Notice that, in particular $0$ is a critical point.</p>

<p>We will choose the matrix $Q$ in a way that the vector that defines $\mathcal{M}_N$ is an eigenvector of the matrix $Q$, we have seen that the manifold $\mathcal{M}_N$ is invariant under the flow. Our cost functional will take into account if we are not in this manifold.</p>

<script type="math/tex; mode=display">% <![CDATA[
Q=\begin{pmatrix}1-\frac{1}{N}&-\frac{1}{N}&-\frac{1}{N}&\cdots&-\frac{1}{N}\\-\frac{1}{N}&1-\frac{1}{N}&-\frac{1}{N}&\cdots&-\frac{1}{N}\\ \vdots&\vdots&\vdots& &\vdots\\ -\frac{1}{N}&-\frac{1}{N}&-\frac{1}{N}&\cdots&1-\frac{1}{N}\end{pmatrix} %]]></script>

<p>We check that its eigenvalues are non-negative</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Q</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="nb">ones</span><span class="p">([</span><span class="n">N</span> <span class="n">N</span><span class="p">])/</span><span class="n">N</span><span class="p">;</span>
<span class="n">EigQ</span><span class="o">=</span><span class="nb">eig</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
EigQ =

     0
     1


</code></pre>
</div>

<p>And we define $R$ being just the identity</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">R</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</code></pre>
</div>

<p>Linearize arround the unstable equilibrium 0 and obtain the linearized system $\dot{y}=Ly$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">L</span><span class="o">=</span><span class="n">A</span><span class="o">+</span><span class="n">DG</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</code></pre>
</div>

<p>we set our control matrix B</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">B</span><span class="o">=</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</code></pre>
</div>

<p>One has to check the rank of the controllability matrix to see if we satisfy the Kalman rank condition</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Co</span><span class="o">=</span><span class="n">ctrb</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
<span class="nb">rank</span><span class="o">=</span><span class="nb">rank</span><span class="p">(</span><span class="n">Co</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
rank =

     2


</code></pre>
</div>

<p>Once it is done, we are in the position of solving the algebraic Riccati equation</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">ricsol</span><span class="p">,</span><span class="n">cleig</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">Q</span><span class="p">);</span>
</code></pre>
</div>

<p>Consider a time span and an initial datum</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">radius</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">ini</span>    <span class="o">=</span> <span class="n">radius</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">+</span><span class="nb">rand</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
radius =

     6


ini =

   -1.3855
    1.4941


</code></pre>
</div>

<p>the free dynamics would result</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">tspan</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span> <span class="n">F</span><span class="p">,</span> <span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>
    <span class="nb">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">(:,</span><span class="nb">i</span><span class="p">));</span>
    <span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="k">end</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">(:,</span><span class="n">N</span><span class="p">))</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Free dynamics'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
<span class="nb">grid</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0003/copiaRM_02.png" alt="" /></p>

<p>Now the LQ controller with the linear and the non-linear dynamics</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">u_lq</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>


<span class="n">i_linear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">L</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">u_lq</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="p">[</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_linear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>

<span class="n">i_nonlinear</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)[</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="o">*</span><span class="n">u_lq</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)];</span>
<span class="p">[</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_nonlinear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>
    <span class="nb">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="nb">i</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="k">end</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">state</span><span class="p">(:,</span><span class="n">N</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'LQR regulator on the linearized system'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0003/copiaRM_03.png" alt="" /></p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">i_nonlinear</span><span class="p">,</span><span class="n">tspan</span><span class="p">,</span> <span class="n">ini</span><span class="p">);</span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">for</span> <span class="nb">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>
    <span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="nb">i</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="k">end</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">timen</span><span class="p">,</span> <span class="n">staten</span><span class="p">(:,</span><span class="n">N</span><span class="p">),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">grid</span> <span class="n">on</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'LQR regulator on the non-linear dynamics'</span><span class="p">)</span>
<span class="nb">hold</span> <span class="n">off</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP06/P0003/copiaRM_04.png" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this tutorial, we will demonstrate how to design a LQR controller in order to stabilize the following linear coupled (hybrid) PDE-ODE system:&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}       y_t = \alpha y_{xx} + \beta y & (x, t) \in (0, 1) \times (0, T) \\       \dot{s}(t) = -y_x(0,t) & t \in (0, T) \\       y(0, t) = u(t), y(1, t) = 0 & t \in (0, T) \\       y(x, 0) = y_0(x), s(0) = s_0 & x \in (0, 1).   \end{cases} %]]></script>

<p>Similar systems may appear in the modelling of a variety physical phenomena, such as the melting of ice in a body of water [1] or fluid-structure interaction [2]. This particular system may be seen as a simplification of the well known one-phase Stefan problem. The stabilization and control of the former has been investigated in recent works by Krstic et al. (see [1] for example). The relationship between the considered system and the Stefan problem, as well as the control of the latter will be considered in a future tutorial.</p>

<p>When no forces are applied, a feature of the governing parabolic PDE is its possibility of generating unstable dynamics as $t \rightarrow \infty$. This phenomenon is due to the fact that the sign of the eigenvalues of the governing elliptic differential operator depends on the magnitude of the constant $\beta$. More precisely, as the differential operator has eigenvalues of the form $\mu_k = \beta - \lambda_k$, where $\lambda_k$ are the eigenvalues of the Dirichlet laplacian, taking $\beta &gt; \lambda_1$ (the biggest among the $\lambda_k$) would yield such a result. We will thence implement a LQR optimal control strategy in order to stabilize the system.</p>

<p>We first need to reduce the PDE-ODE system  to a finite dimensional system of the form</p>

<script type="math/tex; mode=display">\dot{z} = Az + Bu,</script>

<p>where $A$ and $B$ are matrices, and</p>

<script type="math/tex; mode=display">z(t) = \begin{pmatrix} y(t) \\ s(t) \end{pmatrix}</script>

<p>is the finite dimensional state vector.</p>

<p>We fix the parameters as follows: $T=1$, $\alpha=1$ and $\beta = 10$:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clc</span><span class="p">;</span> <span class="nb">clear</span><span class="p">;</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">nT</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">nX</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span><span class="p">/</span><span class="n">nT</span><span class="p">;</span> <span class="n">dx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">nX</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Dir0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Dir1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nb">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nb">beta</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre>
</div>

<p>We begin the code by discretizing in space the parabolic PDE; this is done by finite differences:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Id</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">nX</span><span class="p">);</span>
<span class="n">Lapl</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">Id</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">nX</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="n">nX</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
<span class="n">A0</span> <span class="o">=</span> <span class="nb">alpha</span><span class="o">*</span><span class="mi">1</span><span class="p">/</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">Lapl</span> <span class="o">+</span> <span class="nb">beta</span><span class="o">*</span><span class="n">Id</span><span class="p">;</span>
</code></pre>
</div>

<p>In fact, the finite difference discretization of the Dirichlet laplacian may also be done using the MATLAB routine <code class="highlighter-rouge">delsq</code>. We proceed similarly for the term $y_x(1,t)$ in the ODE, and assemble the complete matrix $A$:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">A0</span><span class="p">;</span> <span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">=-</span><span class="mi">1</span><span class="p">/</span><span class="n">dx</span><span class="p">;</span>
</code></pre>
</div>

<p>The control matrix B is constructed as follows:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nX</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">alpha</span><span class="o">*</span><span class="n">Dir0</span><span class="p">/</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span> <span class="n">b</span><span class="p">(</span><span class="n">nX</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">alpha</span><span class="o">*</span><span class="n">Dir1</span><span class="p">/</span><span class="n">dx</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>
<span class="n">B</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Dir0</span><span class="p">/</span><span class="n">dx</span><span class="p">;</span>
<span class="n">B</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</code></pre>
</div>

<p>We may now proceed with the optimal control strategy. For a continuous time linear system generated by the matrices $(A,B)$ and an infinite time horizon cost functional defined as</p>

<script type="math/tex; mode=display">J = \int_0^\infty \langle Q z(t), z(t) \rangle + \langle R u(t), u(t)   \rangle dt,</script>

<p>the feedback control law that minimizes the value of the cost is $u = -Kz$, where $K = R^{-1}B*P$ and $P$ is found by solving the continuous time algebraic Ricatti equation</p>

<script type="math/tex; mode=display">A*P+PA-(PB)R^1(B*P)+Q=0.</script>

<p>We check whether the constructed matrices fit in the framework of LQR. Namely, we first verify that the couple $(A, BB*)$ is stabilizable. This is done by checking if $\text{rank}[\lambda I - A, B] = d$ for any $\lambda \in \sigma(A)\cap \mathbb{R}_+$, where $d$ is the dimension of the state space.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">eigs</span> <span class="o">=</span> <span class="nb">eig</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="k">for</span> <span class="n">iter</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nb">real</span><span class="p">(</span><span class="nb">eigs</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span><span class="o">&gt;=</span><span class="mi">0</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">M</span><span class="p">(:,</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">eigs</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">A</span><span class="p">;</span> <span class="n">M</span><span class="p">(:,</span><span class="n">nX</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="p">(</span><span class="n">B</span><span class="o">'</span><span class="p">);</span>
        <span class="n">r_</span> <span class="o">=</span> <span class="nb">rank</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="n">stabilizable</span> <span class="o">=</span> <span class="p">(</span><span class="n">r_</span> <span class="o">==</span> <span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Secondly, we check that the eigenvalues of the associated Hamiltonian matrix do not lie on the imaginary axis.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">H</span> <span class="o">=</span> <span class="nb">blkdiag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="o">'</span><span class="p">);</span>
<span class="n">H</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">Q</span><span class="p">;</span> <span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nX</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">(</span><span class="n">B</span><span class="o">'</span><span class="p">);</span>
<span class="n">eigH</span> <span class="o">=</span> <span class="nb">real</span><span class="p">(</span><span class="nb">eig</span><span class="p">(</span><span class="n">H</span><span class="p">));</span>
<span class="n">nb_im_eig</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">eigH</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</code></pre>
</div>

<p>Finally, we check if the pair $(Q, A)$ is detectable; the variable <code class="highlighter-rouge">not_det</code> should equal $0$ after the loop.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">not_det</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">iter_</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nb">real</span><span class="p">(</span><span class="nb">eigs</span><span class="p">(</span><span class="n">iter_</span><span class="p">))</span><span class="o">&gt;=</span><span class="mi">0</span>
        <span class="n">M_</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">M_</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:)</span> <span class="o">=</span> <span class="n">Q</span><span class="p">;</span> <span class="n">M_</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">2</span><span class="p">:(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">:)</span> <span class="o">=</span> <span class="nb">eigs</span><span class="p">(</span><span class="n">iter_</span><span class="p">)</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">A</span><span class="p">;</span>
        <span class="n">r_</span> <span class="o">=</span> <span class="nb">rank</span><span class="p">(</span><span class="n">M_</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r_</span> <span class="o">~=</span> <span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">not_det</span> <span class="o">=</span> <span class="n">not_det</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We are now in a position to construct the LQR feedback control by solving the algebraic Ricatti equation. This is done by using the MATLAB Control Toolbox routine <code class="highlighter-rouge">care</code>:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">ricsol</span><span class="p">,</span> <span class="n">cleig</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
<span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">z</span><span class="p">;</span>
</code></pre>
</div>

<p>We now compare the uncontrolled (thence unstable) dynamics with the dynamics stabilized by the LQR feedback control. As initial datum for both systems, we pick $u_0(x) = \cos(\pi*x)$ and $s_0 = 0.1$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">x_int</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">nX</span><span class="p">);</span>
<span class="n">y0</span> <span class="o">=</span> <span class="nb">cos</span><span class="p">(</span><span class="n">x_int</span><span class="o">*</span><span class="nb">pi</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
<span class="n">z0</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">z0</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">z0</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">y0</span><span class="p">;</span>
</code></pre>
</div>

<p>The free system is solved with the Dirichlet boundary condition $u(0,t) = 0.15$:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">f1</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="mf">0.15</span><span class="p">;</span>
<span class="p">[</span><span class="n">t1</span><span class="p">,</span> <span class="n">z_free</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">nT</span><span class="p">),</span> <span class="n">z0</span><span class="p">);</span>
<span class="p">[</span><span class="n">X1</span><span class="p">,</span><span class="n">Y1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">x_int</span><span class="p">);</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">Y1</span><span class="p">,</span> <span class="n">z_free</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Unstable state y_{un} = y_{un}(t,x)'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0003/copiaRM_01.png" alt="" /></p>

<p>Now we solve and visualize the controlled problem:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">f2</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="p">[</span><span class="n">t2</span><span class="p">,</span> <span class="n">z_ctr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">nT</span><span class="p">),</span> <span class="n">z0</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="p">[</span><span class="n">X2</span><span class="p">,</span><span class="n">Y2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="n">x_int</span><span class="p">);</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">Y2</span><span class="p">,</span> <span class="n">z_ctr</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="n">nX</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Space'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Stablilized state y_{st} = y_{st}(t,x)'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0003/copiaRM_02.png" alt="" /></p>

<p>We also plot the corresponding solutions to the ODE:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">z_free</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">'Color'</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.8500</span><span class="p">,</span> <span class="mf">0.3250</span><span class="p">,</span> <span class="mf">0.0980</span><span class="p">],</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">z_ctr</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">'Color'</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4470</span><span class="p">,</span> <span class="mf">0.7410</span><span class="p">],</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Unstable'</span><span class="p">,</span> <span class="s1">'Stabilized'</span><span class="p">,</span> <span class="s1">'Location'</span><span class="p">,</span> <span class="s1">'SouthWest'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'The state s'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0003/copiaRM_03.png" alt="" /></p>

<p>As a final test of our results, we compare the $L^2(0,1)$-norms of both the controlled and uncontrolled state with respect to time.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">norm_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/</span><span class="n">nX</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">z_free</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.^</span><span class="mf">0.5</span><span class="p">;</span>
<span class="n">norm_ctr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/</span><span class="n">nX</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">z_ctr</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.^</span><span class="mf">0.5</span><span class="p">;</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">norm_free</span><span class="p">,</span> <span class="s1">'Color'</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.8500</span><span class="p">,</span> <span class="mf">0.3250</span><span class="p">,</span> <span class="mf">0.0980</span><span class="p">],</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">norm_ctr</span><span class="p">,</span> <span class="s1">'Color'</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4470</span><span class="p">,</span> <span class="mf">0.7410</span><span class="p">],</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Unstable state'</span><span class="p">,</span> <span class="s1">'Stabilized state'</span><span class="p">,</span> <span class="s1">'Location'</span><span class="p">,</span> <span class="s1">'NorthWest'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'L^2 Norm'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP05/P0003/copiaRM_04.png" alt="" /></p>

<h2 id="references">References:</h2>

<p>[1] Koga, Shumon and Diagne, Mamadou and Krstic, Miroslav. Output feedback control of the one-phase Stefan problem. 2016 IEEE 55th Conference on Decision and Control (CDC) (2016).</p>

<p>[2] Vazquez, Juan Luis and Zuazua, Enrique. Large time behavior for a simplified 1D model of fluid-solid interaction. Comm. Partial Differential Equations 28 (2003), no. 9-10, 1705-1738.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this tutorial we are going to show how to use MATLAB to control a discrete-time dynamical system that models the interactions between the nodes of a graph. The control policy will minimize a discrete linear quadratic regulator.&lt;/p&gt;
</code></pre>
</div>

<p>Let us consider a graph G that consists on $N$ nodes $x_i\in\mathbb{R}$, $i={1,2,…,N}$ that evolve in discrete time steps according to the following equation:</p>

<script type="math/tex; mode=display">x_i[k+1] = x_i[k] + \gamma\sum_{j\neq i}(x_j[k]-x_i[k]),\ k\in\mathbb{N}\cup \{0\},\ \forall i=1,2,...N \\ x_i[0] = x_{i,0},\ \forall i=1,2,...N</script>

<p>where $\gamma &gt; 0$ is a coupling parameter.</p>

<p>We can simplify this equation by using the Perron matrix $P$ of the graph, this matrix is defined as $P = I - \gamma L$, where $L$ is the Laplacian of the graph and $I$ is the identity matrix. Let $x$ be $[x_1,…,x_N]^T$, the vector of states of the nodes. Moreover, we may add a control</p>

<script type="math/tex; mode=display">\{u[k]\}_{k=0,1,...}, u\in\mathbb{R}^M, 1\leq M \leq N</script>

<p>to drive the states of the nodes to a desired state.</p>

<script type="math/tex; mode=display">x[k+1]=Px[k]+Bu[k] \\    y[k] = Cx[k]        \\    x[0] = x_0 = [x_{1,0},...,x_{N,0}]^T</script>

<p>were $B$ and $C$ are two fixed matrices and $y\in\mathbb{R}^S$ are the observed states of $1\leq S\leq N$ nodes.</p>

<p>We aim to design a control policy ${u[k]}_{k=0,1,…}$ such that minimizes the following functional $J(x,u)$ while stabilizing the system.</p>

<script type="math/tex; mode=display">J(x,u) = \sum_{k=0}^\infty\left(x[k]^TQx[k]+u[k]^TRu[k]\right)</script>

<p>where $Q$ and $R$ are semidefinite positive and definite positive matrices respectively. We can choose these two matrices in order to penalize aggressive or slow controls. To do so, we will use MATLAB’s control system toolbox.</p>

<p>Finally, we will add a reference term in the control so that we can drive the system into a desired state.</p>

<p>For instance, let us consider the coupling parameter</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">gamma</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
</code></pre>
</div>

<p>We define now a connected and bidirected graph G. Let E be the edges of the graph. We will define this set as a 2-column matrix and then we create the graph G.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">E</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">];</span>
<span class="n">E</span> <span class="o">=</span> <span class="nb">table</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="s1">'VariableNames'</span><span class="p">,{</span><span class="s1">'EndNodes'</span><span class="p">});</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">graph</span><span class="p">(</span><span class="n">E</span><span class="p">);</span>
</code></pre>
</div>

<p>This is our graph</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">plot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'EdgeColor'</span><span class="p">,</span> <span class="s1">'r'</span><span class="p">,</span> <span class="s1">'MarkerSize'</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Graph representation'</span><span class="p">,</span> <span class="s1">'FontSize'</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0002/copiaRM_01.png" alt="" /></p>

<p>N is the size of the graph, that is to say, the number of nodes.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="n">numnodes</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</code></pre>
</div>

<p>We compute the number of neighbours of each node</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">connectivities</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</code></pre>
</div>

<p>We check whether the graph is connected or not, if not, we must choose a different graph.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">conncomp</span><span class="p">(</span><span class="n">G</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Generate a new graph'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>In this example the considered graph is connected.</p>

<p>We compute the Perron matrix of $G$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">P</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="nb">gamma</span> <span class="o">*</span> <span class="n">laplacian</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</code></pre>
</div>

<p>We can see that the system tends to reach a consensus, that is to say, if no control is applied to the system, it evolves to a steady state in which all the nodes have the same state.</p>

<p>We define the initial state $x_0$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">x_0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">'</span><span class="p">;</span>
</code></pre>
</div>

<p>The mean of $x_0$ is 3</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">mean</span><span class="p">(</span><span class="n">x_0</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
ans =

     3


</code></pre>
</div>

<p>The states of the nodes will evolve to the mean of the states at the initial time. We let the system evolve for 150 iterations.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">itmax</span> <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">itmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">x</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">x_0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">itmax</span>
    <span class="n">x</span><span class="p">(:,</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="n">x</span><span class="p">(:,</span><span class="n">k</span><span class="p">);</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="nb">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">itmax</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">,:),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Node 1'</span><span class="p">,</span><span class="s1">'Node 2'</span><span class="p">,</span><span class="s1">'Node 3'</span><span class="p">,</span><span class="s1">'Node 4'</span><span class="p">,</span><span class="s1">'Node 5'</span><span class="p">,</span><span class="s1">'Node 6'</span><span class="p">,</span><span class="s1">'Node 7'</span><span class="p">,</span><span class="s1">'Node 8'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Graph evolution without control'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Iterations'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'States of the nodes'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0002/copiaRM_02.png" alt="" /></p>

<p>As stated before, we can see in this figure that the system naturally reaches consensus.</p>

<p>Recall that the system dynamics can be written as</p>

<script type="math/tex; mode=display">x[k+1] = Px[k]+Bu[k] \\    y[k] = Cx[k]</script>

<p>for any $k =0,1,…$.</p>

<p>We want to find a control $u$ such that the system stabilizes to the zero state.</p>

<p>We proceed to define matrices B and C:</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">B</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="n">C</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="c1">%% We can check whether the system is controllable</span>
<span class="k">if</span> <span class="nb">rank</span><span class="p">(</span><span class="n">ctrb</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">B</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">N</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'it is not controllable!'</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1">%% In this case, it is controllable.</span>
</code></pre>
</div>

<p>We choose the matrices $Q$ and $R$ by using Bryson and Ho’s criterium.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Q_diag</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_0</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
<span class="n">R_diag</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">/</span> <span class="mi">5</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
<span class="n">Q</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="n">Q_diag</span><span class="p">);</span>
<span class="n">R</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="n">R_diag</span><span class="p">);</span>
</code></pre>
</div>

<p>We can use now the function dlqr (discrete linear quadratic regulator) to find the feedback control $u = -K_{f} x[k]$ that minimizes the functional $J(x,u)$.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">Kf</span><span class="p">,</span> <span class="o">~</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlqr</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
</code></pre>
</div>

<p>Now we can stabilize the system by using the feedback control that we have just computed</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">itmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">itmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">x</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">x_0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">itmax</span>
    <span class="n">x</span><span class="p">(:,</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kf</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">(:,</span><span class="n">k</span><span class="p">);</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>

<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="nb">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">itmax</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">,:),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Node 1'</span><span class="p">,</span><span class="s1">'Node 2'</span><span class="p">,</span><span class="s1">'Node 3'</span><span class="p">,</span><span class="s1">'Node 4'</span><span class="p">,</span><span class="s1">'Node 5'</span><span class="p">,</span><span class="s1">'Node 6'</span><span class="p">,</span><span class="s1">'Node 7'</span><span class="p">,</span><span class="s1">'Node 8'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Graph stabilization'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Iterations'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'States of the nodes'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0002/copiaRM_03.png" alt="" /></p>

<p>We can see that the system is stabilized fast. One can tune the stabilization speed by choosing matrices $Q$ and $R$ in a smart way.</p>

<p>Now, we are about to add a reference term to the control to drive the system to a desired state. For instance, we can drive the system into the reference state</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
</code></pre>
</div>

<p>We add a reference term to the control that is proportional to the reference r, $u[k] = -K_{f}x[k] + K_{r}r$. We can use linear algebra to compute the matrix $K_{r}$ in terms of the system matrices.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Kr</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kf</span> <span class="o">-</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>We drive the system to the reference state.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">itmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">itmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">x</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">x_0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">itmax</span>
    <span class="n">x</span><span class="p">(:,</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kf</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kr</span> <span class="o">*</span> <span class="n">r</span><span class="p">;</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="nb">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">itmax</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">,:),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Node 1'</span><span class="p">,</span><span class="s1">'Node 2'</span><span class="p">,</span><span class="s1">'Node 3'</span><span class="p">,</span><span class="s1">'Node 4'</span><span class="p">,</span><span class="s1">'Node 5'</span><span class="p">,</span><span class="s1">'Node 6'</span><span class="p">,</span><span class="s1">'Node 7'</span><span class="p">,</span><span class="s1">'Node 8'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Controlled graph'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Iterations'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'States of the nodes'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0002/copiaRM_04.png" alt="" /></p>

<p>Assume now that we can control only the node 1 and we want to drive the node 8 to the reference state r = 1. Can we do it? Let’s see.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">B</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">C</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
<span class="n">C</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="nb">rank</span><span class="p">(</span><span class="n">ctrb</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">B</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">N</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'it is not controllable!'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>It is controllable.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">Q_diag</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_0</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
<span class="n">R_diag</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">/</span> <span class="mi">5</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>
<span class="n">Q</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="n">Q_diag</span><span class="p">);</span>
<span class="n">R</span> <span class="o">=</span> <span class="nb">diag</span><span class="p">(</span><span class="n">R_diag</span><span class="p">);</span>
<span class="p">[</span><span class="n">Kf</span><span class="p">,</span> <span class="o">~</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlqr</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
<span class="n">Kr</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kf</span> <span class="o">-</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">itmax</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">itmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">x</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">x_0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">itmax</span>
    <span class="n">x</span><span class="p">(:,</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kf</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">(:,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="n">Kr</span> <span class="o">*</span> <span class="n">r</span><span class="p">;</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clf</span>
<span class="nb">hold</span> <span class="n">on</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
    <span class="nb">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">itmax</span><span class="p">,</span><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">,:),</span><span class="s1">'LineWidth'</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Node 1'</span><span class="p">,</span><span class="s1">'Node 2'</span><span class="p">,</span><span class="s1">'Node 3'</span><span class="p">,</span><span class="s1">'Node 4'</span><span class="p">,</span><span class="s1">'Node 5'</span><span class="p">,</span><span class="s1">'Node 6'</span><span class="p">,</span><span class="s1">'Node 7'</span><span class="p">,</span><span class="s1">'Node 8'</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Driving node 8 to the state 1'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Iterations'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'States of the nodes'</span><span class="p">,</span><span class="s1">'FontSize'</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0002/copiaRM_05.png" alt="" /></p>

<p>As we can see, the node 8 is driven to the state 1 by achieving consensus in all the states of the graph.</p>

<h2 id="references">References</h2>

<p>[1]: R. Olfati-Saber, J. A. Fax, and R. M. Murray, "Consensus and cooperation in networked multi-agent systems". Proc. IEEE. vol. 95, pp. 215&#150;233, Jan. 2007.</p>
<p>[2]: K. J. &Aring;str&ouml;m, and R. M. Murray, "Feedback Systems: An Introduction for Scientists and Engineers". Princeton University Press, 2008, Princeton, NJ.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;We study the shape design problem through the minimization of the cost functional&lt;/p&gt;
</code></pre>
</div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%20%5Cleft%28%20%5Ctheta%2C%20y%20%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cint_%7B%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%20%5E2%20%5C%2C%20%5Cmathrm%7Bd%7D%20%5COmega%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?y%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" /> is the state variable, <img src="https://latex.codecogs.com/gif.latex?y_d%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" /> is a target function, and <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29" /> the normal displacement to a reference boundary,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%3D%20%5Cleft%5C%7B%20%5Cmathbf%7Bx%7D%20&plus;%20%5Ctheta%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cmathbf%7Bn%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3A%20%5Cmathbf%7Bx%7D%20%5Cin%20%5CGamma_%7B0%7D%20%5Cright%5C%7D." />
</p>

<p>The problem is subject to the following elliptic PDE in the domain <img src="https://latex.codecogs.com/gif.latex?%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Csubset%20%5Cmathbb%7BR%7D%5Ed" /> with Dirichlet boundary conditions on <img src="https://latex.codecogs.com/gif.latex?%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3D%20%5CGamma_w%20%5Ccup%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29" />,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y%20%3D%20f%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%5C%5C%20y%20%3D%20y_%7Bw%7D%20%26%20%5Ctext%7Bin%20%7D%20%5CGamma_w%2C%5C%5C%20y%20%3D%20y_%7Bs%7D%20%26%20%5Ctext%7Bin%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5Cend%7Bcases%7D" />
</p>

<p>and <img src="https://latex.codecogs.com/gif.latex?f%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" />.</p>

<p>We consider the set of admissible domains whose measure is fixed,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BU%7D_%7Bad%7D%20%3D%20%5Cleft%5C%7B%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3A%20%5Clvert%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Crvert%20%3D%20%5COmega_0%20%5Cright%5C%7D%2C" />
</p>

<p>and aim at finding the optimal shape that minimizes the cost function. In order to do so, we use the steepest descent method with descent direction given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cdelta%20%5Ctheta%20%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%3D%20-%20%5Cleft%5B%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20y%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20y_d%20%5Cright%29%20%5E2%20&plus;%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cfrac%7B%5Cpartial%20y%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20&plus;%20q%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%5D%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?v" /> is solution of the adjoint problem</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%20%5CDelta%20v%20%3D%20y%20-%20y_d%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20v%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3D%20%5CGamma_w%20%5Ccup%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<p>The normal displacement field is updated at every iteration,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B%5Cleft%28%20n%20&plus;%201%20%5Cright%29%7D%20%3D%20%5Ctheta%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20&plus;%20%5Cepsilon%20%5Cdelta%7B%5Ctheta%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%7D%2C" />
</p>

<p>with <img src="https://latex.codecogs.com/gif.latex?\epsilon" /> sufficiently small. The Lagrange multiplier is computed in order to ensure that the volume contraint is fulfilled, thus</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?q%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%3D%20-%20%5Cfrac%7B1%7D%7B%5Cleft%7C%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%5Cright%7C%7D%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20%5Cleft%5B%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20y%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20y_d%20%5Cright%29%20%5E2%20&plus;%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cfrac%7B%5Cpartial%20y%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%5D%20%5Cmathrm%7Bd%7D%20%5CGamma." />
</p>

<h2 id="mesh-motion-solver">Mesh Motion Solver</h2>

<p>The solutions to the primal and adjoint problems are commonly approximated by means of numerical methods, such as the finite element method (FEM) or the finite volume method (FVM). In order to apply these techniques, the domain under study must be tessellated with a mesh. Nevertheless, applying the displacement directly to the controlled boundary will deteriorate the surrounding elements after a few iterations and the computation will crash if the interior nodes of the domain are not reallocated. In order to avoid this, the domain can be re-meshed after a number of iterations. However, this can be very expensive as a completely new mesh must be generated. A commonly used alternative is to move the interior nodes of the mesh according to the displacements prescribed on the boundary.  By doing this the number of elements and the nodes connectivities remain the same, only the mesh nodes positions are updated. The Solid Body Rotation Stress method and the Laplacian smoothing included in the OpenFOAM library have been used.</p>

<h3 id="linear-elasticity">Linear Elasticity</h3>

<p>Mesh motion can be achieved by treating the mesh as an elastic body and solving the equations of Linear Elasticity for solids with prescribed displacements on the domain boundary,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20%5Cpartial_j%20%5Cleft%28%20G%20%5Cpartial_j%20u_i%20%5Cright%29%20&plus;%20%5Cpartial_j%20%5Cleft%28%20G%20%5Cpartial_i%20u_j%20%5Cright%29%20&plus;%20%5Cpartial_i%20%5Cleft%28%20%5Clambda%20%5Cpartial_j%20u_j%20%5Cright%29%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<h3 id="solid-body-rotation-sbr-stress">Solid Body Rotation (SBR) Stress</h3>

<p>The Linear Elasticity model fails when dealing with rotating meshes. This can be mitigated by selecting the material properties in a proper manner,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%202%20%5Cpartial_j%20%5Cleft%28%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cpartial_j%20u_i%20%5Cright%29%20&plus;%20%5Cpartial_j%20%5Cleft%5B%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cleft%28%20%5Cpartial_i%20u_j%20-%20%5Cpartial_j%20u_i%20-%20%5Cdelta_%7Bij%7D%20%5Cpartial_k%20u_k%20%5Cright%29%20%5Cright%5D%20%3D%200%2C%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<h3 id="laplacian-smoothing">Laplacian Smoothing</h3>

<p>A simple and widely used practice is to solve a Laplace equation with the prescribed displacements as boundary conditions,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20%5CDelta%20u_i%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<p>The behavior of the Laplacian smoothing can be improved by adding a non-uniform diffusivity term,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cpartial_k%20%5Cleft%28%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cpartial_k%20u_i%20%5Cright%29%20%3D%200%20%5Cquad%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29." />
</p>

<p>The diffusion field <img src="https://latex.codecogs.com/gif.latex?%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%3A%20%5Cmathbb%7BR%7D%5Ed%20%5Crightarrow%20%5Cmathbb%7BR%7D" /> decreases with the distance to the controlled boundary. A common choice is to make it depend on the inverse of the distance as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7Bd%5Em%7D%2C" />
</p>

<p>so that the nodes next to the deforming boundaries move with similar displacements as those on the boundary.</p>

<h2 id="getting-started">Getting Started</h2>

<p>The solver must be compiled in the terminal. It is advisable to first clean previous compilations with</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wclean
</code></pre>
</div>

<p>and then use</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wmake
</code></pre>
</div>

<h3 id="dynamic-mesh">Dynamic Mesh</h3>

<p>The mesh motion solver is specified in the dictionary <em>constant/dynamicMeshDict</em>.</p>

<ul>
  <li>For the Laplacian solver:</li>
</ul>

<pre><code class="language-C++">dynamicFvMesh   dynamicMotionSolverFvMesh;

motionSolverLibs ( "libfvMotionSolvers.so" );

solver          displacementLaplacian;

displacementLaplacianCoeffs
{
    //diffusivity  	uniform;
    //diffusivity     	inversePointDistance (deformedWall);
    diffusivity     	quadratic inversePointDistance (deformedWall);
}
</code></pre>

<ul>
  <li>For SBR Stress method:</li>
</ul>

<pre><code class="language-C++">motionSolver 	displacementSBRStress;

displacementSBRStressCoeffs
{
    // diffusivity  	uniform;
    // diffusivity  	directional (1 200 0);
    // diffusivity  	motionDirectional (1 1000 0);
    // diffusivity  	file motionDiffusivity;
    // diffusivity  	quadratic inverseFaceDistance (deformedWall);
    // diffusivity  	quadratic inverseDistance (deformedWall);
    diffusivity  	quadratic inversePointDistance (deformedWall);
    // diffusivity	inversePointDistance (deformedWall);
}
</code></pre>

<h3 id="prerequisites">Prerequisites</h3>

<p>OpenFOAM C++ library must be installed in order to compile the code.</p>

<p>The OpenFOAM distribution provided by the <a href="https://openfoam.org/">OpenFOAM Foundation</a> was used.</p>

<h2 id="running-a-case">Running a Case</h2>

<p>In order to run the solver move to the case folder <em>poissonOptShapeFoamCase</em> and type in the command line</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./Allprepare

poissonOptShapeFoam
</code></pre>
</div>

<p>The shape optimization method described in the previous section has been tested with a simple example. The Poisson equation is posed in a two-dimensional circular domain with boundary</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma_w%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%3A%20%5Csqrt%7Bx%5E2%20&plus;%20y%5E2%7D%20%3D%20R_w%20%5Cright%5C%7D." />
</p>

<p>The reference geometry to be optimized is an inner hole with boundary given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma_s%20%5Cleft%28%200%5Cright%29%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%20%3A%20%5Csqrt%7B%5Cleft%28%20x%20-%20c_x%20%5Cright%29%5E2%20&plus;%20%5Cleft%28%20y%20-%20c_y%20%5Cright%29%5E2%7D%20%3D%20R_s%20%5Cright%5C%7D." />
</p>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/poissonOptShapeFoam/master/poissonOptShapeFoamCase/figs/fig1.png" style="height: 400px; width: 490px;" />
</p>

<p>The target function <img src="https://latex.codecogs.com/gif.latex?u_d" /> will be the analytical solution of the Poisson equation with the inner hole centered in the origin,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u_%7Banalytic%7D%5Cleft%28%20r%20%5Cright%29%20%3D%20-%5Cfrac%7Bf%7D%7B4%7Dr%5E2%20&plus;%20c_1%20%5Clog%20r%20&plus;%20c_2%2C" />
</p>

<p>where the integration constants are obtained from the boundary conditions,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20c_1%20%3D%20%26%20%5Cfrac%7Bu_w%20-%20u_s%20&plus;%20%5Cdisplaystyle%20%5Cfrac%7Bf%7D%7B4%7D%20%5Cleft%28%20R_w%5E2%20-%20R_s%5E2%20%5Cright%29%7D%7B%5Clog%5Cleft%28%20%5Cdisplaystyle%20%5Cfrac%7BR_w%7D%7BR_s%7D%20%5Cright%29%7D%2C%20%5C%5C%20c_2%20%3D%20%26%20%5Cfrac%7Bu_w%20&plus;%20u_s%7D%7B2%7D%20&plus;%20%5Cfrac%7Bf%7D%7B8%7D%5Cleft%28%20R_w%5E2%20&plus;%20R_s%5E2%20%5Cright%29%20-%20%5Cfrac%7Bc_1%7D%7B2%7D%20%5Clog%5Cleft%28%20R_w%20R_s%20%5Cright%29.%20%5Cend%7Balign*%7D" />
</p>

<p>When the hole center is displaced from the origin, the target state must be extended in the region <img src="https://latex.codecogs.com/gif.latex?r%20%5Cleq%20R_1" />, thus</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u_d%5Cleft%28%20r%20%5Cright%29%3D%20%5Cbegin%7Bcases%7D%20u_s%2C%20%5Cquad%20%26%20r%20%5Cleq%20R_s%2C%20%5C%5C%20u_%7Banalytic%7D%2C%20%5Cquad%20%26%20R_s%20%3C%20r%20%5Cleq%20R_w.%20%5Cend%7Bcases%7D" />
</p>

<p>It is clear that for</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma%5E%7B*%7D_s%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%20%3A%20%5Csqrt%7Bx%5E2%20&plus;%20y%5E2%7D%20%3D%20R_s%20%5Cright%5C%7D" />
</p>

<p>the cost function equals zero, thus it is an optimal solution. The steepest descent algorithm has been coded in the OpenFOAM solver <em>poissonOptShapeFoam</em> with <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon%20%3D%2010%5E%7B-3%7D" />.</p>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/poissonOptShapeFoam/master/poissonOptShapeFoamCase/figs/fig2.png" style="width: 400px; height:300px;" />
</p>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/poissonOptShapeFoam/master/poissonOptShapeFoamCase/figs/fig3.png" style="width: 400px; height:300px;" />
</p>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/poissonOptShapeFoam/master/poissonOptShapeFoamCase/figs/laplace_uniform.gif" style="width: 600px; height:350px;" />
</p>

<h3 id="warning">Warning</h3>

<p>It might be needed to use</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sed -i -e 's/\r$//' filename
</code></pre>
</div>

<p>and</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod +x filename
</code></pre>
</div>

<p>in order to be able to execute</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./filename
</code></pre>
</div>

<h2 id="references">References</h2>

<ul>
  <li>O. Pironneau. <em>Optimal shape design for elliptic systems</em>. Springer Science &amp; Business Media, 2012.</li>
  <li>J Simon. <em>Diferenciación de problemas de contorno respecto del dominio</em>. Technical report, Universidad de Sevilla, Facultad de Matemáticas, Departamento de Análisis Matemático, 1989.</li>
  <li><a href="http://openfoam.org">The OpenFOAM Foundation</a>.</li>
  <li>Moving boundary problem based on calculated data, <a href="http://www.cfd-online.com/Forums/openfoam-programming-development/122557-moving-boundary-problem-based-calculated-data.html">CFDonline</a>, 2013.</li>
</ul>

<p>Linear Elasticity mesh motion method:</p>
<ul>
  <li>Andrew A. Johnson and Tayfun E. Tezduyar. Mesh update strategies in parallel finite element computations of flow problems with moving boundaries and interfaces. <em>Computer methods in applied mechanics and engineering</em>, 119(1-2):73–94, 1994.</li>
  <li>Thomas D. Economon, Francisco Palacios, and Juan J. Alonso. Unsteady continuous adjoint approach for aerodynamic design on dynamic meshes. <em>AIAA Journal</em>, 53(9):2437–2453, 2015.</li>
  <li>George S. Eleftheriou and Guillaume Pierrot. Rigid motion mesh morpher: A novel approach for mesh deformation. In <em>OPT-i, An International Conference on Engineering and Applied Sciences Optimization</em>, Kos, Greece, pages 4–6, 2014.</li>
</ul>

<p>Solid Body Rotation (SBR) Stress method:</p>
<ul>
  <li>Richard P. Dwight. Robust mesh deformation using the linear elasticity equations. In <em>Computational fluid dynamics 2006</em>, pages 401–406. Springer, 2009.</li>
</ul>

<p>Laplacian Smoothing:</p>
<ul>
  <li>Peter Hansbo. Generalized laplacian smoothing of unstructured grids. <em>International Journal for Numerical Methods in Biomedical Engineering</em>, 11(5):455–464, 1995.</li>
  <li>Rainald Löhner and Chi Yang. Improved ale mesh velocities for moving bodies. <em>Communications in numerical methods in engineering</em>, 12(10):599–608, 1996.</li>
  <li>Hrvoje Jasak and Zeljko Tukovic. Automatic mesh motion for the unstructured finite volume method. <em>Transactions of FAMENA</em>, 30(2):1–20, 2006.</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;Shows the propagation of the solution of a fractional Schrodinger equation with concentrated and highly oscillatory initial datum. The solution remains concentrated along the rays of geometric optics&lt;/p&gt;
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">hx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)/(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>Definition of the initial datum u0 as a function_handle. u0 is chosen as a Gaussian profile multiplied by a higly oscillatory function</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">x0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">%% Center of the Gaussian profile</span>
<span class="nb">gamma</span> <span class="o">=</span> <span class="n">hx</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mf">0.9</span><span class="p">);</span> <span class="c1">%% Amplitude of the Gaussian profile</span>
<span class="n">fr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">/</span><span class="n">hx</span><span class="p">)</span><span class="o">*</span><span class="nb">pi</span><span class="o">^</span><span class="mi">2</span><span class="p">/</span><span class="mi">16</span><span class="p">;</span> <span class="c1">%% Frequency of the oscillations</span>
</code></pre>
</div>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">u0</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="nb">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span><span class="o">.*</span><span class="nb">exp</span><span class="p">(</span><span class="mi">1</span><span class="nb">i</span><span class="o">*</span><span class="n">fr</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
</code></pre>
</div>

<p>Plot of the initial datum</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">fig</span> <span class="o">=</span> <span class="nb">gcf</span><span class="p">;</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gcf</span><span class="p">,</span><span class="s1">'Units'</span><span class="p">,</span><span class="s1">'pixels'</span><span class="p">,</span><span class="s1">'Position'</span><span class="p">,[</span><span class="mi">427</span> <span class="mi">306</span> <span class="mi">712</span> <span class="mi">284</span><span class="p">])</span>

<span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">:</span><span class="n">hx</span><span class="p">:</span><span class="n">L</span><span class="p">;</span>

<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">%% Modulus</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">abs</span><span class="p">(</span><span class="n">u0</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'\vertu_0(x)\vert'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'u(x)'</span><span class="p">);</span>

<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">%% Real part</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">real</span><span class="p">(</span><span class="n">u0</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'real(u_0(x))'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'u(x)'</span><span class="p">);</span>

<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1">%% Imaginary part</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">imag</span><span class="p">(</span><span class="n">u0</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'img(u_0(x))'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'u(x)'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0004/copiaRM_01.png" alt="" /></p>

<h2 id="solution-for-s--12">Solution for s = 1/2</h2>

<p>Define the characteristic parameters of the problem</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1">%% Order of the fractional Laplacian</span>
<span class="n">L</span>        <span class="c1">%% Extrema of the space interval</span>
<span class="n">N</span>        <span class="c1">%% Number of points in the space mesh</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>    <span class="c1">%% Length of the time interval</span>
<span class="n">u0</span>       <span class="c1">%% The function_handle that we have showed before.</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>
s =

    0.5000


L =

     1


N =

   250


T =

     5


u0 =

  function_handle with value:

    @(x)exp(-0.5*gamma*(x-x0).^2).*exp(1i*fr*x)


</code></pre>
</div>

<p>To solve the equation, we call the function fractional_schr. The solution of the equation is stored in the u variable.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">fractional_schr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">u0</span><span class="p">);</span>
</code></pre>
</div>

<p>Now we can see a graphical interpretation</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
<span class="c1">%%</span>
<span class="nb">clf</span>
<span class="nb">mesh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">u</span><span class="o">'</span><span class="p">);</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'t'</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'Ray Evolution'</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0004/copiaRM_02.png" alt="" /></p>

<p>By typing “animation(x,t,u)” in the MATLAB console you can see the evolution in time of this wave.</p>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/WP99/P0004/wave.gif" alt="$$u(t)$$ function" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this work we solve the optimal control problem&lt;/p&gt;
</code></pre>
</div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?%5Cmin%20_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29%7D%20%5Cmathcal%7BJ%7D%5Cleft%28%20u%5Cright%29%20%3D%20%5Cmin%20_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29%7D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cint_%7B%5COmega%7D%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%20%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%20&plus;%20%5Cfrac%7B%5Cbeta%7D%7B2%7D%20%5Cint_%7B%5COmega%7D%20u%20%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?u" /> is the control variable, <img src="https://latex.codecogs.com/gif.latex?y" /> the state variable and <img src="https://latex.codecogs.com/gif.latex?y_d" /> a target function. The minimization problem is subject to the elliptic partial differential equation</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y%20%3D%20f%20&plus;%20u%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20y%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma.%20%5Cend%7Bcases%7D" />
</p>

<p>In order to use the conjugate gradient method, the state variable is separated in two terms as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?y%20%3D%20y_u%20&plus;%20y_%7Bf%7D%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?y_u" /> solves the state equation with zero Dirichlet boundary conditions,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y_u%20%3D%20u%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20y_u%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma%2C%20%5Cend%7Bcases%7D" />
</p>

<p>and <img src="https://latex.codecogs.com/gif.latex?y_f" /> is the control-free solution to the state equation,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y_%7Bf%7D%20%3D%20f%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20y_%7Bf%7D%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma.%20%5Cend%7Bcases%7D" />
</p>

<p>With the above separation of the state variable, the cost functional can be expressed as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%20%5Cleft%28%20u%20%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20y_u%20&plus;%20y_f%20-%20y_d%2C%20y_u%20&plus;%20y_f%20-%20y_d%20%5Cright%29_%7BL%5E2%5Cleft%28%20%5COmega%20%5Cright%29%7D%20&plus;%20%5Cfrac%7B%5Cbeta%7D%7B2%7D%20%5Cleft%28%20u%20%2C%20u%20%5Cright%29%20_%7BL%5E2%5Cleft%28%20%5COmega%20%5Cright%29%7D." />
</p>

<p>We define a linear operator</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20%5CLambda%3A%20L%5E2%5Cleft%28%20%5COmega%20%5Cright%29%20%26%20%5Crightarrow%20L%5E2%5Cleft%28%20%5COmega%20%5Cright%29%20%5C%5C%20u%20%26%20%5Crightarrow%20y_u%20%5Cend%7Balign*%7D2" />
</p>

<p>and its adjoint</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20%5CLambda%3A%20L%5E2%5Cleft%28%20%5COmega%20%5Cright%29%20%26%20%5Crightarrow%20L%5E2%5Cleft%28%20%5COmega%20%5Cright%29%20%5C%5C%20%5Cphi%20%26%20%5Crightarrow%20%5Clambda%20%5Cend%7Balign*%7D" />
</p>

<p>with <img src="https://latex.codecogs.com/gif.latex?\lambda" /> solution to</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%20%5CDelta%20%5Clambda%20%3D%20%5Cphi%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20%5Clambda%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma.%20%5Cend%7Bcases%7D" />
</p>

<p>The directional derivative of the cost function then reads as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BD%7D_%7B%5Cdelta%20u%7D%20%5Cmathcal%7BJ%7D%5Cleft%28%20u%20%5Cright%29%20%3D%20%5Cleft%28%20%5Cunderbrace%7B%20%5Cleft%28%20%5CLambda%5E*%20%5CLambda%20&plus;%20%5Cbeta%20I%20%5Cright%29%7D_%7BA_%7Bcg%7D%7D%20u%20-%20%5Cunderbrace%7B%20%5CLambda%5E*%20%5Cleft%28%20y_d%20-%20y_f%20%5Cright%29%7D_%7Bb_%7Bcg%7D%7D%2C%20%5Cdelta%20u%20%5Cright%29%20_%7BL%5E2%5Cleft%28%20%5COmega%20%5Cright%29%7D." />
</p>

<p>After having identified <img src="https://latex.codecogs.com/gif.latex?A_%7Bcg%7D" /> and <img src="https://latex.codecogs.com/gif.latex?b_%7Bcg%7D" /> we can use the conjugate gradient method to reach the optimal control faster.</p>

<h2 id="getting-started">Getting Started</h2>

<p>The solver must be compiled in the terminal. It is advisable to first clean previous compilations with</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wclean
</code></pre>
</div>

<p>and then use</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wmake
</code></pre>
</div>

<h3 id="prerequisites">Prerequisites</h3>

<p>OpenFOAM C++ library must be installed in order to compile the code.</p>

<p>The OpenFOAM distribution provided by the <a href="https://openfoam.org/">OpenFOAM Foundation</a> was used.</p>

<h2 id="running-a-case">Running a Case</h2>

<p>In order to run the solver move to the case folder <em>poissonCGAdjoinFoamCase</em> and type in the command line</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./Allprepare

poissonCGAdjointFoam
</code></pre>
</div>

<p>The <em>poissonCGAdjointFoam</em> solver has been tested in a square domain <img src="https://latex.codecogs.com/gif.latex?%5B0%2C%201%5D%20%5Ctimes%20%5B0%2C%201%5D" /> with zero Dirichlet boundary conditions and <img src="https://latex.codecogs.com/gif.latex?%5Cbeta%20%3D%2010%5E%7B-3%7D%2C10%5E%7B-4%7D%2C10%5E%7B-5%7D%2C10%5E%7B-6%7D" />. The target function is <img src="https://latex.codecogs.com/gif.latex?y_d%20%3D%20xy%20%5Csin%20%5Cleft%28%20%5Cpi%20x%20%5Cright%29%20%5Csin%20%5Cleft%28%20%5Cpi%20y%20%5Cright%29" />.</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/poissonCGAdjointFoam/blob/master/poissonCGAdjointFoamCase/cg_J.png?raw=true" />
</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/poissonCGAdjointFoam/blob/master/poissonCGAdjointFoamCase/cg_Jy.png?raw=true" />
</p>

<h3 id="warning">Warning</h3>

<p>It might be needed to use</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sed -i -e 's/\r$//' filename
</code></pre>
</div>

<p>and</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod +x filename
</code></pre>
</div>

<p>in order to be able to execute</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./filename
</code></pre>
</div>

<h2 id="references">References</h2>

<ul>
  <li>F. Tröltzsch. <em>Optimal control of partial differential equations: theory, methods, and applications</em>. American Mathematical Soc., 2010.</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;A natural application in the framework of shape optimization is the aerodynamic design of an airfoil. An object defined by a domain &lt;img src="https://latex.codecogs.com/gif.latex?%5COmega_s%20%5Cin%20%5Cmathbb%7BR%7D%5Ed" /&gt; with boundary &lt;img src="https://latex.codecogs.com/gif.latex?%5CGamma_s" /&gt; immersed in a fluid will experience a net force given by&lt;/p&gt;
</code></pre>
</div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?F_i%20%3D%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20-%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cbm%7Bu%7D%5Cright%29%20%5C%2C%20n_j%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cbm%7Bu%7D%5Cright%29%20%3D%20-p%20%5Cdelta_%7Bij%7D%20&plus;%202%5Cnu%20S_%7Bij%7D%5Cleft%28%5Cbm%7Bu%7D%5Cright%29" /> is the stress tensor, <img src="https://latex.codecogs.com/gif.latex?p" /> is the fluid pressure, <img src="https://latex.codecogs.com/gif.latex?%5Cnu" /> is the kinematic viscosity, <img src="https://latex.codecogs.com/gif.latex?S_%7Bij%7D%5Cleft%28%5Cmathbf%7Bu%7D%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20%5Cpartial_j%20u_i%20&plus;%20%5Cpartial_i%20u_j%20%5Cright%29" /> is the strain rate tensor, and <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bu%7D%20%5Cin%20%5Cmathbb%7BR%7D%5Ed" /> is the fluid velocity vector field.</p>

<p align="center">
  <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/shapeOptimizationFoam/master/figs/fig1.png" width="400" height="320" />
</p>

<p>The force exerted by the fluid on the airfoil parallel to the fluid velocity at infinity is referred to as the drag force, whereas the force in perpendicular direction is often named the lift.</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?D%20%3D%20d%5ED_i%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20-%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cbm%7Bu%7D%5Cright%29%20%5C%2C%20n_j%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma%2C" />
</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?L%20%3D%20d%5EL_i%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20-%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cbm%7Bu%7D%5Cright%29%20%5C%2C%20n_j%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma." />
</p>

<p>We look for the optimal shape in order to minimize the drag, as this force produces energy losses, and at the same time maximize the lift for a fixed airfoil volume. This can be expressed by means of the functional</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%3D%20w%5ED%20D%20-%20w%5EL%20L%20%3D%20d_i%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%29%7D%20-%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cmathbf%7Bu%7D%5Cright%29n_j%20%5Cmathrm%7Bd%7D%20%5CGamma%2C" />
</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?d_i%20%3D%20w%5ED%20d%5ED_i%20-%20w%5EL%20d%5EL_i%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?w%5ED" /> and <img src="https://latex.codecogs.com/gif.latex?w%5EL" /> are weighting factors for drag and lift forces, respectively, and with <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%20%5Cin%20L%5E2%5Cleft%28%20%5CGamma_s%20%5Cright%29" />. The state variables are subject to a set of constraints in the fluid domain <img src="https://latex.codecogs.com/gif.latex?%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29" /> with boundary <img src="https://latex.codecogs.com/gif.latex?%5CGamma_f%20%3D%20%5CGamma_%7Bin%7D%20%5Ccup%20%5CGamma_%7Bout%7D%20%5Ccup%20%5CGamma_s%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Ccup%20%5CGamma_w" />, namely the steady Navier-Stokes equations,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20u_j%20%5Cpartial_j%20u_i%20-%20%5Cpartial_j%20%5Cleft%5B%20%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cmathbf%7Bu%7D%20%5Cright%29%20%5Cright%5D%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20%5Cpartial_j%20u_j%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%20u%5E%5Cinfty_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7Bin%7D%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Ccup%20%5CGamma_w%2C%20%5C%5C%20%5Csigma_%7Bij%7D%20%5Cleft%28p%2C%20%5Cmathbf%7Bu%7D%20%5Cright%29%20n_j%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7Bout%7D%2C%20%5Cend%7Bcases%7D" />
</p>

<p>and to the volume constraint</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cleft%7C%20%5COmega_%7Bs%7D%20%5Cright%7C%20%3D%20%5COmega_0." />
</p>

<p>The adjoint problem reads as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20v_j%20%5Cpartial_i%20u_j%20-%20%5Cpartial_j%20%5Cleft%28%20u_j%20v_i%20%5Cright%29%20-%20%5Cpartial_j%20%5Cleft%5B%20%5Csigma_%7Bij%7D%20%5Cleft%28q%2C%20%5Cmathbf%7Bv%7D%20%5Cright%29%20%5Cright%5D%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20%5Cpartial_j%20v_j%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20v_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7Bin%7D%20%5Ccup%20%5CGamma_w%2C%20%5C%5C%20v_i%20%3D%20-d_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20%5Csigma_%7Bij%7D%20%5Cleft%28q%2C%20%5Cmathbf%7Bv%7D%20%5Cright%29%20n_j%20&plus;%20v_i%20u_j%20n_j%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7Bout%7D.%20%5Cend%7Bcases%7D" />
</p>

<p>The directional derivative of the functional is given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BD%7D_%7B%5Cdelta%20%5Ctheta%7D%20%5Cmathcal%7BJ%7D%20%3D%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20%5Cleft%5B%20r%20-%202%20%5Cnu%20S_%7Bij%7D%20%5Cleft%28%20%5Cmathbf%7Bv%7D%20%5Cright%29%20%5C%2C%20n_j%20%5C%2C%20n_k%20%5C%2C%20%5Cpartial_k%20u_i%20%5Cright%5D%20%5C%2C%20%5Cdelta%20%5Ctheta%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma%2C" />
</p>

<p>and the cost function descreases by choosing the normal displacement to the controlled boundary as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cdelta%20%5Ctheta%20%5E%7B%5Cleft%28n%5Cright%29%7D%20%3D%20-%20%5Cleft%5B%20r%5E%7B%5Cleft%28n%5Cright%29%7D%20-%202%20%5Cnu%20S_%7Bij%7D%20%5Cleft%28%20%5Cmathbf%7Bv%7D%5E%7B%5Cleft%28n%5Cright%29%7D%20%5Cright%29%20%5C%2C%20n_j%5E%7B%5Cleft%28n%5Cright%29%7D%20%5C%20n_k%5E%7B%5Cleft%28n%5Cright%29%7D%20%5C%2C%20%5Cpartial_k%20u_i%5E%7B%5Cleft%28n%5Cright%29%7D%20%5Cright%5D." />
</p>

<p>Hence,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%20%5E%7B%5Cleft%28n&plus;1%5Cright%29%7D%20%3D%20%5Ctheta%20%5E%7B%5Cleft%28n%5Cright%29%7D%20&plus;%20%5Cepsilon%20%5Cdelta%20%5Ctheta%20%5E%7B%5Cleft%28n%5Cright%29%7D%2C" />
</p>

<p>for a sufficiently small value of <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon" />.</p>

<p>The remaining Lagrange multiplier associated to the volume constraint is computed in order to ensure the volume conservation,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?r%5E%7B%5Cleft%28n%5Cright%29%7D%20%3D%20%5Cfrac%7B1%7D%7B%5Cleft%7C%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Cright%7C%7D%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%202%20%5Cnu%20S_%7Bij%7D%20%5Cleft%28%20%5Cmathbf%7Bv%7D%5E%7B%5Cleft%28n%5Cright%29%7D%20%5Cright%29%20n_j%5E%7B%5Cleft%28n%5Cright%29%7D%20n_k%5E%7B%5Cleft%28n%5Cright%29%7D%20%5Cpartial_k%20u_i%5E%7B%5Cleft%28n%5Cright%29%7D%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma." />
</p>

<p>In summary, the shape optimization iteration is as follows:</p>
<ul>
  <li>Solve the primal problem.</li>
  <li>Solve the adjoint problem with the previously computed state variables.</li>
  <li>Compute the Lagrange multiplier for the volume constraint.</li>
  <li>Compute the displacement field.</li>
  <li>Update the displacement field of the previous iteration.</li>
  <li>Perform the mesh motion.</li>
</ul>

<h2 id="getting-started">Getting Started</h2>

<p>The solver must be compiled in the terminal. It is advisable to first clean previous compilations with</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wclean
</code></pre>
</div>

<p>and then use</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wmake
</code></pre>
</div>

<h3 id="prerequisites">Prerequisites</h3>

<p>OpenFOAM C++ library must be installed in order to compile the code.</p>

<p>The OpenFOAM distribution provided by the <a href="https://openfoam.org/">OpenFOAM Foundation</a> was used.</p>

<h2 id="running-a-case">Running a Case</h2>

<p>The above shape optimization process has been implemented in the open-source C++ library OpenFOAM. The already existing solver <em>adjointShapeOptimizationFoam</em> is a topological optimization routine that relies on a porosity variable and on the calculation of volume sensitivities to determine which regions of the domain must be blocked to the fluid passage in order to minimize a known functional. We have coded a new solver <em>shapeOptimizationFoam</em> that takes some ideas from the aforementioned one, but which performs a shape optimization iteration instead by computing shape sensitivities.</p>

<p align="center">
    <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/shapeOptimizationFoam/master/shapeOptimizationFoamCase/figs/fig1.png" width="400" height="320" />
</p>

<p>The solver has been tested in the minimization of the the cost function</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%3D%20%5Cleft%28%20w%5ED%20d%5ED_i%20-%20w%5EL%20d%5EL_i%20%5Cright%29%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%29%7D%20-%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cmathbf%7Bu%7D%5Cright%29n_j%20%5C%20%5Cmathrm%7Bd%7D%20%5CGamma%2C" />
</p>

<p>subject to</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20u_j%20%5Cpartial_j%20u_i%20-%20%5Cpartial_j%20%5Cleft%5B%20%5Csigma_%7Bij%7D%5Cleft%28p%2C%20%5Cmathbf%7Bu%7D%20%5Cright%29%20%5Cright%5D%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%5Cright%20%29%2C%20%5C%5C%20%5Cpartial_j%20u_j%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%20u%5E%5Cinfty_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7B%5Cinfty%7D%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%5Cright%20%29.%20%5C%5C%20%5Cend%7Bcases%7D" />
</p>

<p>The adjoint problem reads as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20v_j%20%5Cpartial_i%20u_j%20-%20%5Cpartial_j%20%5Cleft%28%20u_j%20v_i%20%5Cright%29%20-%20%5Cpartial_j%20%5Cleft%5B%20%5Csigma_%7Bij%7D%20%5Cleft%28q%2C%20%5Cmathbf%7Bv%7D%20%5Cright%29%20%5Cright%5D%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20%5Cpartial_j%20v_j%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega_f%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20v_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_%7B%5Cinfty%7D%2C%20%5C%5C%20v_i%20%3D%20-d_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5C%5C%20%5Cend%7Bcases%7D" />
</p>

<p>In order to run the solver move to the case folder <em>shapeOptimizationFoamCase</em> and type in the command line</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./Allprepare

shapeOptimizationFoam
</code></pre>
</div>

<p>The solver has been run for three different Reynolds numbers and the cost functional value has been normalized with</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B2%7D%20%5Crho%20U_%7B%5Cinfty%7D%5E2%20D%20e" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?D" /> and <img src="https://latex.codecogs.com/gif.latex?e" /> are the cylinder diameter and thickness, respectively.</p>

<p align="center">
    <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/shapeOptimizationFoam/master/shapeOptimizationFoamCase/figs/fig2.png" />
</p>

<h3 id="warning">Warning</h3>

<p>It might be needed to use</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sed -i -e 's/\r$//' filename
</code></pre>
</div>

<p>and</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod +x filename
</code></pre>
</div>

<p>in order to be able to execute</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./filename
</code></pre>
</div>

<h2 id="references">References</h2>

<ul>
  <li>Antony Jameson. Aerodynamic design via control theory. <em>Journal of scientific computing</em>, 3(3):233–260, 1988.</li>
  <li>Antony Jameson and Luigi Martinelli. Aerodynamic shape optimization techniques based on control theory. In <em>Computational Mathematics Driven by Industrial Problems</em>, pages 151–221. Springer, 2000.</li>
  <li>Antony Jameson and James Reuther. Control theory based airfoil design using the euler equations. In <em>5th Symposium on Multidisciplinary Analysis and Optimization</em>, page 4272, 1994.</li>
  <li>Bijan Mohammadi and Olivier Pironneau. Mesh adaption and automatic differentiation in a cad-free framework for optimal shape design. <em>International Journal for Numerical Methods in Fluids</em>, 30(2):127–136, 1999.</li>
  <li>Bijan Mohammadi and Olivier Pironneau. <em>Applied shape optimization for fluids</em>. Oxford University Press, 2010.</li>
  <li>C. Othmer. A continuous adjoint formulation for the computation of topological and surface sensitivities of ducted flows. <em>International Journal for Numerical Methods in Fluids</em>, 58(8):861–877, 2008.</li>
  <li>C. Othmer, E. Papoutsis-Kiachagias, and K. Haliskos. CFD optimization via sensitivity-based shape morphing. In <em>Proceedings of the 4th ANSA &amp; μETA Internat. Conf., Thessaloniki, Greece, BETA CAE Systems SA</em>, 2011.</li>
  <li>Carsten Othmer. Adjoint methods for car aerodynamics. <em>Journal of Mathematics in Industry</em>, 4(1):6, 2014.</li>
  <li>Carsten Othmer, Eugene de Villiers, and Henry Weller. Implementation of a continuous adjoint for topology optimization of ducted flows. In <em>18th AIAA Computational Fluid Dynamics Conference</em>, page 3947, 2007.</li>
  <li>Carsten Othmer and Thorsten Grahs. Approaches to fluid dynamic optimization in the car development process. In <em>International Conference on Evolutionary and Deterministic Methods for Design, Optimization and Control With Applications to Industrial and Societal Problems</em>, 2005.</li>
  <li>Carsten Othmer, Thomas Kaminski, and Ralf Giering. Computation of topological sensitivities in fluid dynamics: cost function versatility. In <em>ECCOMAS CFD 2006: Proceedings of the European Conference on Computational Fluid Dynamics, Egmond aan Zee, The Netherlands, September 5-8, 2006</em>. Citeseer, 2006.</li>
  <li>Olivier Pironneau. <em>Optimal shape design for elliptic systems</em>. Springer Science &amp; Business Media, 2012.</li>
  <li>James Reuther and Antony Jameson. Aerodynamic shape optimization of wing and wing-body configurations using control theory. In <em>33rd Aerospace Sciences Meeting and Exhibit</em>, page 123, 1995.</li>
  <li>James Reuther, Antony Jameson, James Farmer, Luigi Martinelli, and David Saunders. Aerodynamic shape optimization of complex aircraft configurations via an adjoint formulation. In <em>34th Aerospace Sciences Meeting and Exhibit</em>, page 94, 1996.</li>
  <li>James J Reuther, Antony Jameson, Juan J Alonso, Mark J Rimlinger, and David Saunders. Constrained multipoint aerodynamic shape optimization using an adjoint formulation and parallel computers, part 1. <em>Journal of aircraft</em>, 36(1):51–60, 1999.</li>
  <li>J. Simon. Diferenciación de problemas de contorno respecto del dominio. Technical report, Universidad de Sevilla, Facultad de Matemáticas, Departamento de Análisis Matemático, 1989.</li>
  <li>Orlando Soto and Rainald Löhner. On the computation of flow sensitivities from boundary integrals. <em>AIAA paper</em>, 112:2004, 2004.</li>
  <li>Orlando Soto, Rainald Löhner, and Chi Yang. An adjoint-based design methodology for CFD problems. <em>International Journal of Numerical Methods for Heat &amp; Fluid Flow</em>, 14(6):734–759, 2004.</li>
  <li>Schumacher Thomas, Othmer Carsten, et al. Adjoint optimization for vehicle external aerodynamics. <em>International Journal of Automotive Engineering</em>, 7(1):1–7, 2016.</li>
  <li>Henk Kaarle Versteeg and Weeratunge Malalasekera. <em>An introduction to computational fluid dynamics: the finite volume method</em>. Pearson Education, 2007.</li>
  <li>F. Feppon, G. Allaire, F. Bordeu, J. Cortial, and C. Dapogny. Shape optimization of a coupled thermal fluid-structure problem in a level set mesh evolution framework, 2018.</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;We study the shape design problem through the minimization of the cost functional&lt;/p&gt;
</code></pre>
</div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%20%5Cleft%28%20%5Ctheta%2C%20y%20%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cint_%7B%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%20%5E2%20%5C%2C%20%5Cmathrm%7Bd%7D%20%5COmega%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?y%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" /> is the state variable, <img src="https://latex.codecogs.com/gif.latex?y_d%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" /> is a target function, and <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29" /> the normal displacement to a reference boundary,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%29%20%3D%20%5Cleft%5C%7B%20%5Cmathbf%7Bx%7D%20&plus;%20%5Ctheta%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cmathbf%7Bn%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3A%20%5Cmathbf%7Bx%7D%20%5Cin%20%5CGamma_%7B0%7D%20%5Cright%5C%7D." />
</p>

<p>The problem is subject to the following elliptic PDE in the domain <img src="https://latex.codecogs.com/gif.latex?%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Csubset%20%5Cmathbb%7BR%7D%5Ed" /> with Dirichlet boundary conditions on <img src="https://latex.codecogs.com/gif.latex?%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3D%20%5CGamma_w%20%5Ccup%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29" />,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y%20%3D%20f%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%5C%5C%20y%20%3D%20y_%7Bw%7D%20%26%20%5Ctext%7Bin%20%7D%20%5CGamma_w%2C%5C%5C%20y%20%3D%20y_%7Bs%7D%20%26%20%5Ctext%7Bin%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5Cend%7Bcases%7D" />
</p>

<p>and <img src="https://latex.codecogs.com/gif.latex?f%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29" />.</p>

<p>We consider the set of admissible domains whose measure is fixed,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BU%7D_%7Bad%7D%20%3D%20%5Cleft%5C%7B%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3A%20%5Clvert%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%5Crvert%20%3D%20%5COmega_0%20%5Cright%5C%7D%2C" />
</p>

<p>and aim at finding the optimal shape that minimizes the cost function. In order to do so, we use the steepest descent method with descent direction given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cdelta%20%5Ctheta%20%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%3D%20-%20%5Cleft%5B%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20y%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20y_d%20%5Cright%29%20%5E2%20&plus;%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cfrac%7B%5Cpartial%20y%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20&plus;%20q%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%5D%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?v" /> is solution of the adjoint problem</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%20%5CDelta%20v%20%3D%20y%20-%20y_d%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20v%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%20%3D%20%5CGamma_w%20%5Ccup%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<p>The normal displacement field is updated at every iteration,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B%5Cleft%28%20n%20&plus;%201%20%5Cright%29%7D%20%3D%20%5Ctheta%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20&plus;%20%5Cepsilon%20%5Cdelta%7B%5Ctheta%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%7D%2C" />
</p>

<p>with <img src="https://latex.codecogs.com/gif.latex?\epsilon" /> sufficiently small. The Lagrange multiplier is computed in order to ensure that the volume contraint is fulfilled, thus</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?q%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%3D%20-%20%5Cfrac%7B1%7D%7B%5Cleft%7C%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%5Cright%7C%7D%20%5Cint_%7B%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%7D%20%5Cleft%5B%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20y%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20y_d%20%5Cright%29%20%5E2%20&plus;%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cfrac%7B%5Cpartial%20y%7D%7B%5Cpartial%20n%7D%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%5D%20%5Cmathrm%7Bd%7D%20%5CGamma." />
</p>

<h2 id="mesh-motion-solver">Mesh Motion Solver</h2>

<p>The solutions to the primal and adjoint problems are commonly approximated by means of numerical methods, such as the finite element method (FEM) or the finite volume method (FVM). In order to apply these techniques, the domain under study must be tessellated with a mesh. Nevertheless, applying the displacement directly to the controlled boundary will deteriorate the surrounding elements after a few iterations and the computation will crash if the interior nodes of the domain are not reallocated. In order to avoid this, the domain can be re-meshed after a number of iterations. However, this can be very expensive as a completely new mesh must be generated. A commonly used alternative is to move the interior nodes of the mesh according to the displacements prescribed on the boundary.  By doing this the number of elements and the nodes connectivities remain the same, only the mesh nodes positions are updated.</p>

<h3 id="linear-elasticity">Linear Elasticity</h3>

<p>Mesh motion can be achieved by treating the mesh as an elastic body and solving the equations of Linear Elasticity for solids with prescribed displacements on the domain boundary,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20%5Cpartial_j%20%5Cleft%28%20G%20%5Cpartial_j%20u_i%20%5Cright%29%20&plus;%20%5Cpartial_j%20%5Cleft%28%20G%20%5Cpartial_i%20u_j%20%5Cright%29%20&plus;%20%5Cpartial_i%20%5Cleft%28%20%5Clambda%20%5Cpartial_j%20u_j%20%5Cright%29%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<h3 id="solid-body-rotation-sbr-stress">Solid Body Rotation (SBR) Stress</h3>

<p>The Linear Elasticity model fails when dealing with rotating meshes. This can be mitigated by selecting the material properties in a proper manner, which yields</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%202%20%5Cpartial_j%20%5Cleft%28%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cpartial_j%20u_i%20%5Cright%29%20&plus;%20%5Cpartial_j%20%5Cleft%5B%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cleft%28%20%5Cpartial_i%20u_j%20-%20%5Cpartial_j%20u_i%20-%20%5Cdelta_%7Bij%7D%20%5Cpartial_k%20u_k%20%5Cright%29%20%5Cright%5D%20%3D%200%2C%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<h3 id="laplacian-smoothing">Laplacian Smoothing</h3>

<p>A simple and widely used practice is to solve a Laplace equation with the prescribed displacements as boundary conditions,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20%5CDelta%20u_i%20%3D%200%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%5C%20u_i%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_w%2C%20%5C%5C%20u_i%20%3D%20%5Cdelta%20%5Ctheta%20n_i%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29.%20%5Cend%7Bcases%7D" />
</p>

<p>The behavior of the Laplacian smoothing can be improved by adding a non-uniform diffusivity term,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cpartial_k%20%5Cleft%28%20%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%5Cpartial_k%20u_i%20%5Cright%29%20%3D%200%20%5Cquad%20%5Ctext%7Bin%20%7D%20%5COmega%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29." />
</p>

<p>The diffusion field <img src="https://latex.codecogs.com/gif.latex?%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%3A%20%5Cmathbb%7BR%7D%5Ed%20%5Crightarrow%20%5Cmathbb%7BR%7D" /> decreases with the distance to the controlled boundary. A common choice is to make it depend on the inverse of the distance as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cgamma%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3D%20%5Cfrac%7B1%7D%7Bd%5Em%7D%2C" />
</p>

<p>so that the nodes next to the deforming boundaries move with similar displacements as those on the boundary.</p>

<h3 id="spring-analogy">Spring Analogy</h3>

<p>A more intuitive approach is reached by thinking of the N mesh nodes as a mechanical system consisting of a finite set of masses that are linked with springs along the mesh edges. We can consider the existence of additional external forces acting on every mesh node, so that for every equilibrium configuration the following must hold,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7BF%7D_i%20-%20%5Csum_%7Bj%3D1%7D%5EN%20k_%7Bij%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D_i%20-%20%5Cmathbf%7Bx%7D_j%20%5Cright%29%20%3D%200%2C%20%5Cquad%201%20%5Cleq%20i%20%5Cleq%20N." />
</p>

<p>The equilibrium equations can be expressed in terms of the nodes displacements,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%5CDelta%20F%7D_i%20-%20%5Csum_%7Bj%3D1%7D%5EN%20k_%7Bij%7D%20%5Cleft%28%20%5Cmathbf%7Bu%7D_i%20-%20%5Cmathbf%7Bu%7D_j%20%5Cright%29%20%3D%200%2C%20%5Cquad%201%20%5Cleq%20i%20%5Cleq%20N." />
</p>

<p>At the M nodes that belong to the domain boundary the displacements are prescribed with unknown forces acting on them. On the other hand, on the interior nodes of the mesh whose displacements are unknown, there are no other forces than the elastic ones. Let us denote with D the indices of the nodes with prescribed displacement, and with S the set of nodes with unknown displacements. The equilibrium can be expressed in matrix form as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20%5Cmathbf%7BK%7D_%7BDD%7D%20%5Cmathbf%7Bu%7D_D%20&plus;%20%5Cmathbf%7BK%7D_%7BDS%7D%20%5Cmathbf%7Bu%7D_%7BS%7D%20%26%20%3D%20%5Cmathbf%7B%5CDelta%20F%7D_%7BD%7D%2C%20%5C%5C%20%5Cmathbf%7BK%7D_%7BSD%7D%20%5Cmathbf%7Bu%7D_D%20&plus;%20%5Cmathbf%7BK%7D_%7BSS%7D%20%5Cmathbf%7Bu%7D_%7BS%7D%20%26%20%3D%20%5Cmathbf%7B%5CDelta%20F%7D_%7BS%7D%20%3D%20%5Cmathbf%7B0%7D.%20%5Cend%7Balign*%7D" />
</p>

<p>One can get the displacements of the interior mesh nodes as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bu%7D_S%20%3D%20-%5Cmathbf%7BK%7D_%7BSS%7D%5E%7B-1%7D%20%5Cmathbf%7BK%7D_%7BSD%7D%20%5Cmathbf%7Bu%7D_D." />
</p>

<h3 id="radial-basis-functions-rbf">Radial Basis Functions (RBF)</h3>

<p>The RBF mesh morphing technique uses the known displacements at the domain boundaries to construct an interpolation expression as a weighted sum of radial functions <img src="https://latex.codecogs.com/gif.latex?%5Cvarphi%3A%20%5Cmathbb%7BR%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D" />,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?s%5E%7B%5Calpha%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3D%20%5Csum_%7Bj%3D1%7D%5EN%20%5Cgamma%5E%7B%5Calpha%7D_j%20%5Cvarphi%20%5Cleft%28%20%5C%7C%20%5Cmathbf%7Bx%7D%20-%20%5Cmathbf%7Bx%7D_%7Bs%2C%20j%7D%20%5C%7C_%7B%5Cmathbb%7BR%7D%5Ed%7D%20%5Cright%29%20&plus;%20p%5E%7B%5Calpha%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%2C%20%5Cquad%201%20%5Cleq%20%5Calpha%20%5Cleq%20d." />
</p>

<p>The weighting coefficients and the polynomials are obtained by imposing the known displacements at the boundaries,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?s%5E%7B%5Calpha%7D%20%5Cleft%28%20%5Cmathbf%7Bx%7D_%7Bs%2C%20i%7D%20%5Cright%29%20%3D%20g%5E%7B%5Calpha%7D_%7Bs%2C%20i%7D%20%3D%20%5Cdelta%20%5Ctheta%20n%5E%7B%5Calpha%7D%2C" />
</p>

<p>and the orthogonality conditions for every polynomial with degree less or equal than that of <img src="https://latex.codecogs.com/gif.latex?p%5E%7B%5Calpha%7D" />,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Csum_%7Bj%3D1%7D%5EN%20%5Cgamma%5E%7B%5Calpha%7D_j%20q%20%5Cleft%28%20%5Cmathbf%7Bx%7D_%7Bs%2Cj%7D%20%5Cright%29%20%3D%200%2C%20%5Cquad%201%20%5Cleq%20%5Calpha%20%5Cleq%20d." />
</p>

<p>At the end, a linear system of the form</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7BM%7D_s%20%26%20%5Cmathbf%7BP%7D_s%20%5C%5C%20%5Cmathbf%7BP%7D_s%5ET%20%26%20%5Cmathbf%7B0%7D%20%5Cend%7Bpmatrix%7D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7B%5Cgamma%7D%5E%7B%5Calpha%7D%20%5C%5C%20%5Cmathbf%7B%5Cbeta%7D%5E%7B%5Calpha%7D%20%5Cend%7Bpmatrix%7D%20%3D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7Bg%7D_s%5E%7B%5Calpha%7D%20%5C%5C%20%5Cmathbf%7B0%7D%20%5Cend%7Bpmatrix%7D" />
</p>

<p>must be solved, and the mesh nodes are updated as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?x%5E%7B%5Cmathrm%7Bnew%7D%2C%20%5Calpha%7D%20%3D%20x%5E%7B%5Cmathrm%7Bold%7D%2C%20%5Calpha%7D%20&plus;%20s%5E%7B%5Calpha%7D%5Cleft%28%20%5Cmathbf%7Bx%7D%5E%7B%5Cmathrm%7Bold%7D%7D%20%5Cright%29." />
</p>

<h3 id="free-form-deformation-ffd">Free Form Deformation (FFD)</h3>

<p>An alternative is to use some parametrization technique for the boundary <img src="https://latex.codecogs.com/gif.latex?%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29" /> and extend it to be able to handle the motion of the interior nodes of the mesh as well. This can be done with the Free Form Deformation method, that is based upon the positions of a set of control points inside a parallelepiped.</p>

<p>If we consider the 2-dimensional reference control domain <img src="https://latex.codecogs.com/gif.latex?%5COmega_%7Bst%7D%3D%5Cleft%5B%200%2C%201%20%5Cright%5D%20%5Ctimes%20%5Cleft%5B%200%20%2C%201%20%5Cright%5D" />, we can define a set of <img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%20N%20&plus;%201%20%5Cright%29%20%5Ctimes%20%5Cleft%28%20M%20&plus;%201%20%5Cright%29" /> evenly spaced control points,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7BP%7D_%7Bij%7D%20%3D%20%5Cleft%28%20%5Cfrac%7Bi%7D%7BM%7D%2C%20%5Cfrac%7Bj%7D%7BN%7D%20%5Cright%29%2C%20%5Cquad%200%20%5Cleq%20i%20%5Cleq%20M%2C%20%5Cquad%200%20%5Cleq%20j%20%5Cleq%20N%2C" />
</p>

<p>and introduce the tensorial product of Bernstein polynomials <img src="https://latex.codecogs.com/gif.latex?B_%7Bij%7D%5E%7BMN%7D%5Cleft%5B%5Cmathbf%7BS%7D%20%3D%20%5Cleft%28s%2C%20t%20%5Cright%29%20%5Cright%5D%20%3D%20b_i%20%5EM%20%5Cleft%28%20s%20%5Cright%29%20b_j%20%5EN%20%5Cleft%28%20t%20%5Cright%29" />, with</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20b_i%5EM%20%5Cleft%28%20s%20%5Cright%29%20%26%3D%20%5Cbinom%7BM%7D%7Bi%7D%20s%5Ei%20%5Cleft%281-s%5Cright%29%20%5E%7BM-i%7D%2C%20%5C%5C%20b_j%5EN%20%5Cleft%28%20t%20%5Cright%29%20%26%3D%20%5Cbinom%7BN%7D%7Bj%7D%20t%5Ej%20%5Cleft%281-t%5Cright%29%20%5E%7BN-j%7D.%20%5Cend%7Balign*%7D" />
</p>

<p>The transformation</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%5CPsi%7D%20%5Cleft%28%20%5Cmathbf%7BS%7D%20%5Cright%29%20%3D%20%5Csum_%7Bi%3D0%7D%5EM%20%5Csum_%7Bj%3D0%7D%5EN%20B_%7Bij%7D%5E%7BMN%7D%20%5Cleft%28%20%5Cmathbf%7BS%7D%20%5Cright%29%20%5Cmathbf%7BP%7D_%7Bij%7D" />
</p>

<p>is the identity transformation, i.e., <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%5CPsi%7D%5Cleft%28%20%5Cmathbf%7BS%7D%20%5Cright%29%20%3D%20%5Cmathbf%7BS%7D" />.</p>

<p>We consider a set of control points defined as displacements from the reference positions, <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7BP%7D_%7Bij%7D%20&plus;%20%5Cmathbf%7B%5CDelta%20P%7D_%7Bij%7D" />. In this case it is easy to see that the following holds</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%20%5CDelta%20S%20%7D%20%3D%20%5Cmathbf%7B%20%5CPsi%20%7D%20%5Cleft%28%20%5Cmathbf%7BS%7D%20%5Cright%29%20-%20%5Cmathbf%7BS%7D%20%3D%20%5Csum_%7Bi%3D0%7D%5EM%20%5Csum_%7Bj%3D0%7D%5EN%20B_%7Bij%7D%5E%7BMN%7D%20%5Cleft%28%20%5Cmathbf%7BS%7D%20%5Cright%29%20%5Cmathbf%7B%20%5CDelta%20P%20%7D_%7Bij%7D." />
</p>

<p>We must find the control points displacements <img src="https://latex.codecogs.com/gif.latex?%24%5Cmathbf%7B%5CDelta%20P%7D_%7Bij%7D%20%5Cin%20%5COmega_%7Bst%7D%24" /> that parametrize the controlled boundary and for which, for every boundary node <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7BX%7D_%7Bs%2Ck%7D%20%5Cin%20%5CGamma_s%20%5Cleft%28%20%5Ctheta%20%5Cright%20%29%2C%20%5C%201%20%5Cleq%20k%20%5Cleq%20Z" />,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%5CPhi%7D%20%5Cleft%28%20%5Cmathbf%7BX%7D_%7Bs%2Ck%7D%20&plus;%20%5Cvar%7B%5Ctheta%7D%20%5Cmathbf%7Bn%7D%20%5Cright%29%20-%20%5Cmathbf%7B%5CPhi%7D%20%5Cleft%28%20%5Cmathbf%7BX%7D_%7Bs%2Ck%7D%20%5Cright%29%20%3D%20%5Csum_%7Bi%3D0%7D%5EM%20%5Csum_%7Bj%3D0%7D%5EN%20B_%7Bij%7D%5E%7BMN%7D%20%5Cleft%5B%20%5Cmathbf%7B%5CPhi%7D%20%5Cleft%28%20%5Cmathbf%7BX%7D_%7Bs%2Ck%7D%20%5Cright%29%20%5Cright%5D%20%5Cmathbf%7B%20%5CDelta%20P%7D_%7Bij%7D%2C%20%5Cquad%201%20%5Cleq%20k%20%5Cleq%20M." />
</p>

<h2 id="getting-started">Getting Started</h2>

<p>The file <em>main.m</em> needs to be run from the Matlab command line,</p>

<pre><code class="language-Matlab">main.m
</code></pre>

<h3 id="dynamic-mesh">Dynamic Mesh</h3>

<p>The different mesh motion methods can be selected in the heading of <em>main.m</em></p>

<pre><code class="language-Matlab">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARAMETERS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Minimum element size
Hmin = 1e-3;
% Maximum elements size
Hmax = 0.05;
% Step theta^{n+1} = theta^{n} - d * Dtheta^{n}
d = 1e-3;
% Maximum number of iterations
maxIter = 2000000;
% Dirichlet boundary condition on the outer boundary
ue = 1;
% Dirichlet boundary condition on the inner boundary
uc = 0;
% Smoothing of sensitivity field
smoothing = true;
% Reshaping of elements whose edges are lying on the controlled boundary
reshaping = true;
% Mesh motion solver method:
% - Laplace Equation ('laplace')
% - Spring Analogy ('spring')
% - Free Form Deformation ('FFD')
% - Radial Basis Functions ('RBF')
meshMotionSolver = 'laplace';
% Parameters for Laplace method
% Diffusivity (diff)
% - Inverse distance ('invdist')
invdist = true;
m = 6;
% Parameters for FFD method:
% Mi - number of control points along X axis
% Nj - number of control points along Y axis
% Xmin, Xmax - coordinates defining the control rectangle
Mi = 9;
Nj = 9;
Xmin = [-0.7, -0.6];
Xmax = -Xmin;
% Parameters for RBF method
% h - Dimensionless radial distance (r/h)
% RBFtype - Radial Basis Functions
% - Spline type, n odd ('Rn')
% - Thin Plate Spline, n even ('TPSn')
% - Multiquadratic ('MQ')
% - Inverse multiquadratic ('IMQ')
% - Inverse quadratic ('IQ')
% - Gaussian ('GS')
% n - Exponent
h = 2.5*0.3;
RBFtype = 'R';
n = 1;
</code></pre>

<h2 id="running-a-case">Running a Case</h2>

<p>The shape optimization method described in the previous section has been tested with a simple example. The Poisson equation is posed in a two-dimensional circular domain with boundary</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma_w%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%3A%20%5Csqrt%7Bx%5E2%20&plus;%20y%5E2%7D%20%3D%20R_w%20%5Cright%5C%7D." />
</p>

<p>The reference geometry to be optimized is an inner hole with boundary given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma_s%20%5Cleft%28%200%5Cright%29%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%20%3A%20%5Csqrt%7B%5Cleft%28%20x%20-%20c_x%20%5Cright%29%5E2%20&plus;%20%5Cleft%28%20y%20-%20c_y%20%5Cright%29%5E2%7D%20%3D%20R_s%20%5Cright%5C%7D." />
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig1.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig1.png?raw=true" width="400" height="340" /></a>
</p>

<p>The target function <img src="https://latex.codecogs.com/gif.latex?u_d" /> will be the analytical solution of the Poisson equation with the inner hole centered in the origin,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u_%7Banalytic%7D%5Cleft%28%20r%20%5Cright%29%20%3D%20-%5Cfrac%7Bf%7D%7B4%7Dr%5E2%20&plus;%20c_1%20%5Clog%20r%20&plus;%20c_2%2C" />
</p>

<p>where the integration constants are obtained from the boundary conditions,</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20c_1%20%3D%20%26%20%5Cfrac%7Bu_w%20-%20u_s%20&plus;%20%5Cdisplaystyle%20%5Cfrac%7Bf%7D%7B4%7D%20%5Cleft%28%20R_w%5E2%20-%20R_s%5E2%20%5Cright%29%7D%7B%5Clog%5Cleft%28%20%5Cdisplaystyle%20%5Cfrac%7BR_w%7D%7BR_s%7D%20%5Cright%29%7D%2C%20%5C%5C%20c_2%20%3D%20%26%20%5Cfrac%7Bu_w%20&plus;%20u_s%7D%7B2%7D%20&plus;%20%5Cfrac%7Bf%7D%7B8%7D%5Cleft%28%20R_w%5E2%20&plus;%20R_s%5E2%20%5Cright%29%20-%20%5Cfrac%7Bc_1%7D%7B2%7D%20%5Clog%5Cleft%28%20R_w%20R_s%20%5Cright%29.%20%5Cend%7Balign*%7D" />
</p>

<p>When the hole center is displaced from the origin, the target state must be extended in the region <img src="https://latex.codecogs.com/gif.latex?r%20%5Cleq%20R_1" />, thus</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u_d%5Cleft%28%20r%20%5Cright%29%3D%20%5Cbegin%7Bcases%7D%20u_s%2C%20%5Cquad%20%26%20r%20%5Cleq%20R_s%2C%20%5C%5C%20u_%7Banalytic%7D%2C%20%5Cquad%20%26%20R_s%20%3C%20r%20%5Cleq%20R_w.%20%5Cend%7Bcases%7D" />
</p>

<p>It is clear that for</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5CGamma%5E%7B*%7D_s%20%3D%20%5Cleft%5C%7B%20%5Cleft%28%20x%2C%20y%20%5Cright%29%20%5Cin%20%5Cmathbb%7BR%7D%5E2%20%3A%20%5Csqrt%7Bx%5E2%20&plus;%20y%5E2%7D%20%3D%20R_s%20%5Cright%5C%7D" />
</p>

<p>the cost function equals zero, thus it is an optimal solution. The steepest descent algorithm has been coded in Matlab with <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon%20%3D%2010%5E%7B-3%7D" />.</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig2.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig2.png?raw=true" width="400" height="300" /></a>
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig3.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig3.png?raw=true" width="400" height="300" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c1_NS_NR_invdist2.gif" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c1_NS_NR_invdist2.gif?raw=true" width="400" height="300" /></a>
</p>

<p align="center">
  <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c1_NS_NR_invdist2.gif?raw=true" target="_blank"></a>
</p>

<p>Other geometry configurations have been tried. For instance, the inner hole can be initially located farther from its optimal position,</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig4.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig4.png?raw=true" width="400" height="340" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig5.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig5.png?raw=true" width="400" height="300" /></a>
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig6.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig6.png?raw=true" width="400" height="300" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c3_S_R_invdist2.gif" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c1_NS_NR_invdist2.gif?raw=true" width="400" height="300" /></a>
</p>

<p>Different starting shapes can be tested as well,</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig7.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig7.png?raw=true" width="400" height="340" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig8.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig8.png?raw=true" width="400" height="300" /></a>
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig9.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/fig9.png?raw=true" width="400" height="300" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/laplace_c3_S_R_invdist2.gif" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonOptimalShapeControl/blob/master/figs/RBF_s2_S_R_R1.gif?raw=true" width="400" height="300" /></a>
</p>

<h2 id="references">References</h2>

<ul>
  <li>O. Pironneau. <em>Optimal shape design for elliptic systems</em>. Springer Science &amp; Business Media, 2012.</li>
  <li>J Simon. <em>Diferenciación de problemas de contorno respecto del dominio</em>. Technical report, Universidad de Sevilla, Facultad de Matemáticas, Departamento de Análisis Matemático, 1989.</li>
</ul>

<p>Linear Elasticity mesh motion method:</p>
<ul>
  <li>Andrew A. Johnson and Tayfun E. Tezduyar. Mesh update strategies in parallel finite element computations of flow problems with moving boundaries and interfaces. <em>Computer methods in applied mechanics and engineering</em>, 119(1-2):73–94, 1994.</li>
  <li>Thomas D. Economon, Francisco Palacios, and Juan J. Alonso. Unsteady continuous adjoint approach for aerodynamic design on dynamic meshes. <em>AIAA Journal</em>, 53(9):2437–2453, 2015.</li>
  <li>George S. Eleftheriou and Guillaume Pierrot. Rigid motion mesh morpher: A novel approach for mesh deformation. In <em>OPT-i, An International Conference on Engineering and Applied Sciences Optimization</em>, Kos, Greece, pages 4–6, 2014.</li>
</ul>

<p>Solid Body Rotation (SBR) Stress method:</p>
<ul>
  <li>Richard P. Dwight. Robust mesh deformation using the linear elasticity equations. In <em>Computational fluid dynamics 2006</em>, pages 401–406. Springer, 2009.</li>
</ul>

<p>Laplacian Smoothing:</p>
<ul>
  <li>Peter Hansbo. Generalized laplacian smoothing of unstructured grids. <em>International Journal for Numerical Methods in Biomedical Engineering</em>, 11(5):455–464, 1995.</li>
  <li>Rainald Löhner and Chi Yang. Improved ale mesh velocities for moving bodies. <em>Communications in numerical methods in engineering</em>, 12(10):599–608, 1996.</li>
  <li>Hrvoje Jasak and Zeljko Tukovic. Automatic mesh motion for the unstructured finite volume method. <em>Transactions of FAMENA</em>, 30(2):1–20, 2006.</li>
</ul>

<p>Spring Analogy:</p>
<ul>
  <li>Ch. Farhat, C. Degand, B. Koobus, and M. Lesoinne. Torsional springs for two-dimensional dynamic unstructured fluid meshes. <em>Computer methods in applied mechanics and engineering</em>, 163(1-4):231–245, 1998.</li>
  <li>Christoph Degand and Charbel Farhat. A three-dimensional torsional spring analogy method for unstructured dynamic meshes. <em>Computers &amp; structures</em>, 80(3-4):305–316, 2002.</li>
  <li>Carlo L Bottasso, Davide Detomi, and Roberto Serra. The ball-vertex method: a new simple spring analogy method for unstructured dynamic meshes. <em>Computer Methods in Applied Mechanics and Engineering</em>, 194(39-41):4244–4264, 2005.</li>
</ul>

<p>Radial Basis Functions mesh morphing:</p>
<ul>
  <li>Stefan Jakobsson and Olivier Amoignon. Mesh deformation using radial basis functions for gradient-based aerodynamic shape optimization. <em>Computers &amp; Fluids</em>, 36(6):1119–1136, 2007.</li>
  <li>AM Morris, CB Allen, and TCS Rendall. Cfd-based optimization of aerofoils using radial basis functions for domain element parameterization and mesh deformation. <em>International Journal for Numerical Methods in Fluids</em>, 58(8):827–860, 2008.</li>
  <li>Daniel Sieger, Stefan Menzel, and Mario Botsch. High quality mesh morphing using triharmonic radial basis functions. In <em>Proceedings of the 21st International Meshing Roundtable</em>, pages 1–15. Springer, 2013.</li>
  <li>Marco Evangelos Biancolini. <em>Fast Radial Basis Functions for Engineering Applications</em>. Springer, 2018.</li>
  <li>Fank Martijn Bos. <em>Numerical simulations of flapping foil and wing aerodynamics: Mesh deformation using radial basis functions</em>. PhD thesis, Technische Universiteit Delf, 2010.</li>
  <li>Armin Beckert and Holger Wendland. Multivariate interpolation for fluid-structure-interaction problems using radial basis functions. <em>Aerospace Science and Technology</em>,
5(2):125–134, 2001.</li>
  <li>A De Boer, MS Van der Schoot, and Hester Bijl. Mesh deformation based on radial basis function interpolation. <em>Computers &amp; structures</em>, 85(11-14):784–795, 2007.</li>
  <li>Holger Wendland. <em>Konstruktion und Untersuchung radialer Basisfunktionen mit kompaktem Träger</em>. PhD thesis, Göttingen, Georg-August-Universität zu Göttingen, Diss, 1996.</li>
</ul>

<p>Free Form Deformation technique:</p>
<ul>
  <li>Matteo Lombardi, Nicola Parolini, Alfio Quarteroni, and Gianluigi Rozza. Numerical
simulation of sailing boats: Dynamics, fsi, and shape optimization. In <em>Variational Analysis and Aerospace Engineering: Mathematical Challenges for Aerospace Design</em>, pages 339–377. Springer, 2012.</li>
  <li>Thomas W Sederberg and Scott R Parry. Free-form deformation of solid geometric models. <em>ACM SIGGRAPH computer graphics</em>, 20(4):151–160, 1986.</li>
  <li>Michele Andreoli, Janka Ales, and Jean-Antoine Désidéri. <em>Free-form-deformation parameterization for multilevel 3D shape optimization in aerodynamics</em>. PhD thesis, INRIA, 2003.</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;This is an OpenFOAM solver for the distributed control of the heat equation through the minimization problem&lt;/p&gt;
</code></pre>
</div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20%5Cmin_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Ctimes%20%5Cleft%28%200%20%2C%20T%20%5Cright%29%20%5Cright%29%7D%20%5Cmathcal%7BJ%7D%20%5Cleft%28%20u%20%2C%20y%20%5Cleft%28%20u%20%5Cright%29%20%5Cright%29%20%3D%20%26%20%5Cmin_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Ctimes%20%5Cleft%28%200%20%2C%20T%20%5Cright%29%20%5Cright%29%7D%20%5Cfrac%7B%5Cbeta_1%7D%7B2%7D%20%5Cint_0%5ET%20%5Cint_%7B%5COmega%7D%20u%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%20%5C%2C%20%5Cmathrm%7Bd%7Dt%20&plus;%20%5Cfrac%7B%5Cbeta_2%7D%7B2%7D%5Cint_0%5ET%20%5Cint_%7B%5COmega%7D%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%20%5C%2C%20%5Cmathrm%7Bd%7Dt%20&plus;%20%5Cfrac%7B%5Cbeta_3%7D%7B2%7D%20%5Cint_%7B%5COmega%7D%20%5Cleft%28%20y%5Cleft%28%20%5Ccdot%2C%20T%20%5Cright%29%20-%20Y_d%20%5Cright%29%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%2C%20%5Cquad%20%5Cbeta_1%2C%20%5C%20%5Cbeta_2%2C%20%5C%20%5Cbeta_3%20%5Cin%20%5Cmathbb%7BR%7D%5E&plus;%2C%20%5Cend%7Balign*%7D" />
</p>

<p>subject to the state equation</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20%5Cpartial_t%20y%20-%20%5CDelta%20y%20%3D%20f%20&plus;%20u%20%26%20%5Ctext%7Bin%20%7D%20Q%20%3D%20%5COmega%20%5Ctimes%20%5Cleft%28%200%2C%20T%20%5Cright%29%2C%5C%5C%20y%20%3D%20y_D%20%26%20%5Ctext%7Bon%20%7D%20%5CSigma_D%20%3D%20%5CGamma_D%20%5Ctimes%20%5Cleft%28%200%2C%20T%20%5Cright%29%2C%5C%5C%20%5Cdisplaystyle%20%5Cfrac%7B%5Cpartial%20y%7D%7B%5Cpartial%20n%7D%20%3D%20y_N%20%26%20%5Ctext%7Bon%20%7D%20%5CSigma_N%20%3D%20%5CGamma_N%20%5Ctimes%20%5Cleft%28%200%2C%20T%20%5Cright%29%2C%5C%5C%20y%20%5Cleft%28%20%5Ccdot%2C%200%20%5Cright%29%20%3D%20y_0%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5Cend%7Bcases%7D" />
</p>

<p>with <img src="https://latex.codecogs.com/gif.latex?%5CGamma%20%3D%20%5CGamma_D%20%5Ccup%20%5CGamma_N" /> and <img src="https://latex.codecogs.com/gif.latex?%5CGamma_D%20%5Ccap%20%5CGamma_N%3D%20%5Cemptyset" />.</p>

<p>The cost functional gradient is</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BJ%7D%5E%5Cprime%20%5Cleft%28%20u%20%5Cright%29%20%3D%20%5Cvarphi%20&plus;%20%5Cbeta_1%20u%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?%5Cvarphi" /> solves the adjoint problem</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5Cpartial_t%20%5Cvarphi%20-%20%5CDelta%20%5Cvarphi%20%3D%20%5Cbeta_2%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%2C%20%26%20%5Ctext%7Bin%20%7D%20Q%2C%20%5C%5C%20%5Cvarphi%5Cleft%28%20%5Ccdot%2C%20T%20%5Cright%29%20%3D%20%5Cbeta_3%20%5Cleft%28%20y%20%5Cleft%28%20%5Ccdot%2C%20T%20%5Cright%29%20-%20Y_d%20%5Cright%29%2C%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20%5Cvarphi%20%3D%200%2C%20%26%20%5Ctext%7Bon%20%7D%20%5CSigma_D%2C%20%5C%5C%20%5Cdisplaystyle%20%5Cfrac%7B%5Cpartial%20%5Cvarphi%7D%7B%5Cpartial%20n%7D%20%3D%200%2C%20%26%20%5Ctext%7Bon%20%7D%20%5CSigma_N.%20%5Cend%7Bcases%7D" />
</p>

<p>In the steepest descent method the cost gradient is used to update the control as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u%5E%7B%5Cleft%28%20n%20&plus;%201%20%5Cright%29%7D%20%3D%20u%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20%5Cepsilon%20%5Cmathcal%7BJ%7D%5E%5Cprime%20%5Cleft%28%20u%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%29%2C%20%5Cquad%20%5Cepsilon%20%5Cin%20%5Cmathbb%7BR%7D%5E&plus;%2C" />
</p>

<p>with <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon" /> sufficiently small.</p>

<h2 id="getting-started">Getting Started</h2>

<p>The solver must be compiled in the terminal. It is advisable to first clean previous compilations with</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wclean
</code></pre>
</div>

<p>and then use</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wmake
</code></pre>
</div>

<h3 id="prerequisites">Prerequisites</h3>

<p>OpenFOAM C++ library must be installed in order to compile the code.</p>

<p>The OpenFOAM distribution provided by the <a href="https://openfoam.org/">OpenFOAM Foundation</a> was used.</p>

<h2 id="running-a-case">Running a Case</h2>

<p>In order to run the solver move to the case folder <em>heatAdjoinFoamCase</em> and type in the command line</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./Allprepare

heatAdjointFoam
</code></pre>
</div>

<ul>
  <li>The <em>heatAdjointFoam</em> solver has been tested in a square domain <img src="https://latex.codecogs.com/gif.latex?%5B0%2C%201%5D%20%5Ctimes%20%5B0%2C%201%5D" /> with zero Dirichlet boundary conditions, <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon%3D100" />, and <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_1%20%3D%2010%5E%7B-3%7D%2C10%5E%7B-4%7D%2C10%5E%7B-5%7D%2C10%5E%7B-6%7D" />, <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_2%20%3D%201" />, <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_3%20%3D%200" />. The target function is <img src="https://latex.codecogs.com/gif.latex?y_d%20%3D%20xy%20%5Csin%20%5Cleft%28%20%5Cpi%20x%20%5Cright%29%20%5Csin%20%5Cleft%28%20%5Cpi%20y%20%5Cright%29" />.</li>
</ul>

<p align="center">
  <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/J_b2_1_b3_0.png?raw=true" />
</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/Jy_b2_1_b3_0.png?raw=true" />
</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/anim_y_b6.gif?raw=true" width="500" height="300" />
</p>

<ul>
  <li>The <em>heatAdjointFoam</em> solver has been tested in a square domain <img src="https://latex.codecogs.com/gif.latex?%5B0%2C%201%5D%20%5Ctimes%20%5B0%2C%201%5D" /> with zero Dirichlet boundary conditions, <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon%3D10" />, and <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_1%20%3D%2010%5E%7B-3%7D%2C10%5E%7B-4%7D%2C10%5E%7B-5%7D%2C10%5E%7B-6%7D" />, <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_2%20%3D%200" />, <img src="https://latex.codecogs.com/gif.latex?%5Cbeta_3%20%3D%201" />. The target function is <img src="https://latex.codecogs.com/gif.latex?Y_d%20%3D%20xy%20%5Csin%20%5Cleft%28%20%5Cpi%20x%20%5Cright%29%20%5Csin%20%5Cleft%28%20%5Cpi%20y%20%5Cright%29" />.</li>
</ul>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/J_b2_0_b3_1.png?raw=true" />
</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/Jy_b2_0_b3_1.png?raw=true" />
</p>

<p align="center">
   <img src="https://github.com/ChairOfComputationalMathematics/heatAdjointFoam/blob/master/heatAdjointFoamCase/anim_Y_b6.gif?raw=true" width="500" height="300" />
</p>

<h3 id="warning">Warning</h3>

<p>It might be needed to use</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sed -i -e 's/\r$//' filename
</code></pre>
</div>

<p>and</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod +x filename
</code></pre>
</div>

<p>in order to be able to execute</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./filename
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this work we solve the optimal control problem&lt;/p&gt;
</code></pre>
</div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?%5Cmin%20_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29%7D%20%5Cmathcal%7BJ%7D%5Cleft%28%20u%5Cright%29%20%3D%20%5Cmin%20_%7Bu%20%5Cin%20L%5E2%20%5Cleft%28%20%5COmega%20%5Cright%29%7D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cint_%7B%5COmega%7D%20%5Cleft%28%20y%20-%20y_d%20%5Cright%29%20%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%20&plus;%20%5Cfrac%7B%5Cbeta%7D%7B2%7D%20%5Cint_%7B%5COmega%7D%20u%20%5E2%20%5Cmathrm%7Bd%7D%20%5COmega%2C" />
</p>

<p>where <img src="https://latex.codecogs.com/gif.latex?u" /> is the control variable, <img src="https://latex.codecogs.com/gif.latex?y" /> the state variable and <img src="https://latex.codecogs.com/gif.latex?y_d" /> a target function. The minimization problem is subject to the elliptic partial differential equation</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%5CDelta%20y%20%3D%20f%20&plus;%20u%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20y%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma.%20%5Cend%7Bcases%7D" />
</p>

<p>We use the steepest descent method based on the adjoint methodology. The corresponding adjoint system writes as</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7D%20-%20%5CDelta%20%5Clambda%20%3D%20y%20-%20y_d%20%26%20%5Ctext%7Bin%20%7D%20%5COmega%2C%20%5C%5C%20%5Clambda%20%3D%200%20%26%20%5Ctext%7Bon%20%7D%20%5CGamma.%20%5Cend%7Bcases%7D" />
</p>

<p>The directional derivative of the cost function is given by</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathcal%7BD%7D_%7B%20%5Cdelta%20u%7D%20%5Cmathcal%7BJ%7D%20%5Cleft%28%20u%20%5Cright%29%20%3D%20%5Cint_%7B%5COmega%7D%20%5Cleft%28%20%5Clambda%20&plus;%20%5Cbeta%20u%20%5Cright%29%20%5Cdelta%20u%20%5C%2C%20%5Cmathrm%7Bd%7D%20%5COmega%2C" />
</p>

<p>and the control variable is updated according to</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?u%5E%7B%5Cleft%28%20n%20&plus;%201%20%5Cright%29%7D%20%3D%20u%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20-%20%5Cepsilon%20%5Cleft%28%20%5Clambda%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20&plus;%20%5Cbeta%20u%5E%7B%5Cleft%28%20n%20%5Cright%29%7D%20%5Cright%29%2C" />
</p>

<p>for some value of <img src="https://latex.codecogs.com/gif.latex?%5Cepsilon" />.</p>

<h2 id="getting-started">Getting Started</h2>

<p>The solver must be compiled in the terminal. It is advisable to first clean previous compilations with</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wclean
</code></pre>
</div>

<p>and then use</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wmake
</code></pre>
</div>

<h3 id="prerequisites">Prerequisites</h3>

<p>OpenFOAM C++ library must be installed in order to compile the code.</p>

<p>The OpenFOAM distribution provided by the <a href="https://openfoam.org/">OpenFOAM Foundation</a> was used.</p>

<h2 id="running-a-case">Running a Case</h2>

<p>In order to run the solver move to the case folder <em>poissonAdjoinFoamCase</em> and type in the command line</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./Allprepare

poissonAdjointFoam
</code></pre>
</div>

<p>The <em>poissonAdjointFoam</em> solver has been tested in a square domain <img src="https://latex.codecogs.com/gif.latex?%5B0%2C%201%5D%20%5Ctimes%20%5B0%2C%201%5D" /> with zero Dirichlet boundary conditions and <img src="https://latex.codecogs.com/gif.latex?%5Cbeta%20%3D%2010%5E%7B-3%7D%2C10%5E%7B-4%7D%2C10%5E%7B-5%7D%2C10%5E%7B-6%7D" />. The target function is <img src="https://latex.codecogs.com/gif.latex?y_d%20%3D%20xy%20%5Csin%20%5Cleft%28%20%5Cpi%20x%20%5Cright%29%20%5Csin%20%5Cleft%28%20%5Cpi%20y%20%5Cright%29" />.</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonAdjointFoam/blob/master/poissonAdjointFoamCase/sd_J.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonAdjointFoam/blob/master/poissonAdjointFoamCase/sd_J.png?raw=true" /></a>
</p>

<p align="center">
   <a href="https://github.com/ChairOfComputationalMathematics/poissonAdjointFoam/blob/master/poissonAdjointFoamCase/sd_Jy.png" target="_blank"><img src="https://github.com/ChairOfComputationalMathematics/poissonAdjointFoam/blob/master/poissonAdjointFoamCase/sd_Jy.png?raw=true" /></a>
</p>

<h3 id="warning">Warning</h3>

<p>It might be needed to use</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sed -i -e 's/\r$//' filename
</code></pre>
</div>

<p>and</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod +x filename
</code></pre>
</div>

<p>in order to be able to execute</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./filename
</code></pre>
</div>

<h2 id="references">References</h2>

<ul>
  <li>F. Tröltzsch. <em>Optimal control of partial differential equations: theory, methods, and applications</em>. American Mathematical Soc., 2010.</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this work we sol&lt;/p&gt;


&lt;p&gt;In this tutorial, we show how to use the C++ library OpenFOAM (Open Field Operation and Manipulation) in order to solve control problems for partial differential equations (PDE).&lt;/p&gt;
</code></pre>
</div>

<p>OpenFOAM is a free open source toolbox that allows the user to code customized solvers for Continuum Mechanics, with special attention to the field of Computational Fluid Dynamics. One can either use one of the multiple solvers already programmed for steady-state, transient or multiphase problems in fluid mechanics, or code his own solver depending on particular needs.</p>

<p>In this work, we will solve the optimal control problem</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:CostFunctional}
\min _{u \in L^2 \left( \Omega \right)} \mathcal{J}\left( u\right) = \min _{u \in L^2 \left( \Omega \right)} \frac{1}{2} \int_{\Omega} \left( y - y_d \right) ^2 \mathrm{d} \Omega + \frac{\beta}{2} \int_{\Omega} u ^2 \mathrm{d} \Omega,
\end{equation}</script>

<p>where $u$ is the control variable, $y$ the state variable and $y_d$ a target function. The minimization problem is subject to the elliptic partial differential equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
-\Delta y &  = f + u && \mathrm{in} \enspace \Omega \label{eq:PoissonEq}, \\
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
y & = 0 && \mathrm{on} \enspace \Gamma \label{eq:PoissonBC}.
\end{align} %]]></script>

<p>We use some classical gradient descent methods based on the adjoint methodology, namely the steepest descent and conjugate gradient methods. The corresponding adjoint system for \ref{eq:PoissonEq} writes as,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
- \Delta \lambda & = y - y_d && \mathrm{in} \enspace \Omega, \label{eq:PoissonAdjointEq} \\
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\lambda & = 0 \ && \mathrm{on} \enspace \Gamma. \label{eq:PoissonAdjointBC}
\end{align} %]]></script>

<p>In the steepest descent gradient method, we compute the directional derivative of the cost function in \ref{eq:CostFunctional},</p>

<script type="math/tex; mode=display">\begin{equation}
J^\prime \left( u \right) \delta u = \int_{\Omega} \left( \lambda + \beta u \right) \delta u \mathrm{d} \Omega,
\end{equation}</script>

<p>where $\lambda$ is solution to the elliptic problem in \ref{eq:PoissonAdjointEq}, and use the gradient to update the control variable as</p>

<script type="math/tex; mode=display">\begin{equation}
u^{\left( n + 1 \right)} = u^{\left( n \right)} - \gamma \left( \lambda^{\left( n \right)} + \beta u^{\left( n \right)} \right),
\end{equation}</script>

<p>for some value of $\gamma$.</p>

<p>One of the main advantages of OpenFOAM is its friendly syntax to describe PDE, as can be seen in the lines 10 and 13 in the code below.</p>

<pre class="cpp" style="font-family:monospace;"><span style="color: #666666;">// Initialize L2 norm of control update</span>
scalar pL2 <span style="color: #000080;">=</span> <span style="color: #0000dd;">10</span><span style="color: #000040;">*</span>tol<span style="color: #008080;">;</span>
&nbsp;
<span style="color: #666666;">// Get the volume of mesh cells</span>
scalarField volField <span style="color: #000080;">=</span> mesh.<span style="color: #007788;">V</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
<span style="color: #0000ff;">while</span> <span style="color: #008000;">&#40;</span>runTime.<span style="color: #007788;">loop</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">&amp;&amp;</span> <span style="color: #008080;">::</span><span style="color: #0000dd;">sqrt</span><span style="color: #008000;">&#40;</span>pL2<span style="color: #008000;">&#41;</span> <span style="color: #000080;">&gt;</span> tol<span style="color: #008000;">&#41;</span>
<span style="color: #008000;">&#123;</span>
    <span style="color: #666666;">// Solve primal equation</span>
    solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, y<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> u<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Solve ajoint equation</span>
    solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, lambda<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> y <span style="color: #000040;">-</span> yd<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Update control</span>
    p <span style="color: #000080;">=</span> lambda <span style="color: #000040;">+</span> beta<span style="color: #000040;">*</span>u<span style="color: #008080;">;</span>
    u <span style="color: #000080;">=</span> u <span style="color: #000040;">-</span> gamma<span style="color: #000040;">*</span>p<span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Control update norm</span>
    pL2 <span style="color: #000080;">=</span> <span style="color: #008080;">::</span><span style="color: #0000dd;">sqrt</span><span style="color: #008000;">&#40;</span>gSum<span style="color: #008000;">&#40;</span>volField<span style="color: #000040;">*</span>p.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #000040;">*</span>p.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Compute cost function</span>
    J <span style="color: #000080;">=</span> <span style="color:#800080;">0.5</span><span style="color: #000040;">*</span>gSum<span style="color: #008000;">&#40;</span>volField<span style="color: #000040;">*</span><span style="color: #008000;">&#40;</span>Foam<span style="color: #008080;">::</span><span style="color: #0000dd;">pow</span><span style="color: #008000;">&#40;</span>y.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #000040;">-</span>yd.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>,<span style="color: #0000dd;">2</span><span style="color: #008000;">&#41;</span> \
	    <span style="color: #000040;">+</span> beta<span style="color: #000040;">*</span>Foam<span style="color: #008080;">::</span><span style="color: #0000dd;">pow</span><span style="color: #008000;">&#40;</span>u.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>,<span style="color: #0000dd;">2</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Display information</span>
    Info <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Iteration &quot;</span> <span style="color: #000080;">&lt;&lt;</span> runTime.<span style="color: #007788;">timeName</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot; - &quot;</span> \
	    <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Cost value &quot;</span> <span style="color: #000080;">&lt;&lt;</span> J <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot; - &quot;</span> \
	    <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Control variation L2 norm &quot;</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #008080;">::</span><span style="color: #0000dd;">sqrt</span><span style="color: #008000;">&#40;</span> pL2 <span style="color: #008000;">&#41;</span> <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Save current iteration results</span>
    runTime.<span style="color: #007788;">write</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
<span style="color: #008000;">&#125;</span></pre>
<!--h4 align="center">steepestdescent.cpp</h4-->

<p>In order to improve the convergence to the optimal control, the conjugate gradient method is applied also to the problem. First, the state variable must be separated in two terms as</p>

<script type="math/tex; mode=display">\begin{equation}
y = y_u + y_{f},
\end{equation}</script>

<p>where $y_u$ solves the state equation with zero Dirichlet boundary conditions,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
-\Delta y_u &  = u && \mathrm{in} \enspace \Omega \label{eq:PoissonEqu}, \\
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
y_u & = 0 && \mathrm{on} \enspace \Gamma \label{eq:PoissonBCu},
\end{align} %]]></script>

<p>and $y_{f}$ is the control-free solution to the state equation,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
-\Delta y_{f} &  = f && \mathrm{in} \enspace \Omega \label{eq:PoissonEq0}, \\
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
y_{f} & = 0 && \mathrm{on} \enspace \Gamma \label{eq:PoissonBC0}.
\end{align} %]]></script>

<p>Now, using the above separation of the state variable, one part depending on the control and the other part on a known source term, the cost functional in \ref{eq:CostFunctional} can be expressed as</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:CostFunctionalcg}
J \left( u \right) = \frac{1}{2} \left( y_u + y_f - y_d, y_u + y_f - y_d \right)_{L^2\left( \Omega \right)} + \frac{\beta}{2} \left( u , u \right) _{L^2\left( \Omega \right)}.
\end{equation}</script>

<p>We define a linear operator $\Lambda: L^2\left( \Omega \right) \rightarrow L^2\left( \Omega \right)$ that takes a control $u$ and returns the solution to problem \ref{eq:PoissonEqu}-\ref{eq:PoissonBCu}, so that $y_u = \Lambda u$. We introduce as well its adjoint operator $\Lambda^<em>: L^2\left( \Omega \right) \rightarrow L^2\left( \Omega \right)$ that takes the source term in \ref{eq:PoissonAdjointEq} and solves the Poisson equation, so that $\lambda = \Lambda^</em> \left( y - y_d \right)$.</p>

<p>The directional derivative of the functional \ref{eq:CostFunctionalcg} then reads as</p>

<script type="math/tex; mode=display">\begin{equation}
J^\prime\left( u \right) \delta u = \left( \underbrace{ \left(  \Lambda^* \Lambda + \beta I  \right)}_{A_{cg}} u - \underbrace{ \Lambda^* \left( y_d - y_f \right)}_{b_{cg}}, \delta u \right) _{L^2\left( \Omega \right)}.
\end{equation}</script>

<p>After having identified $A_{cg}$ and $b_{cg}$ we can use the conjugate gradient method to reach the optimal control faster.</p>

<h6><b>Algorithm 1</b> Optimal control with Conjugate Gradient Method</h6>
<p><b>Require:</b> $y_D$, $u^{\left(0\right)}$, $\beta$, $y_d$, $tol$</p>
<ol>
<li> $n \gets 0 $</li>
<li> compute the control-free solution, $y_f$</li>
<li> $b \gets \Lambda^*\left( y_d - y_f \right)$</li>
<li> $z \gets \Lambda u$</li>
<li> $g \gets \Lambda^*z + \beta u - b$</li>
<li> $h \gets ||g||^2_{L^2\left(\left[0,T\right]\right)}$</li>
<li> $h_a \gets h$</li>
<li> $r \gets -g$</li>
<li><b>While</b> $||r||_{L^2\left(\left[0,T\right]\right)} &gt; tol $ <b>do</b></li>
<li>   &emsp; &emsp;    $z \gets \Lambda r$</li>
<li>   &emsp; &emsp;    $w \gets \Lambda^*z + \beta r$</li>
<li>   &emsp; &emsp;    $\alpha \gets \frac{h}{\left(r,w\right)_{L^2\left(\left[0,T\right]\right)}}$</li>
<li>   &emsp; &emsp;    $u \gets u + \alpha r$</li>
<li>   &emsp; &emsp;    $g \gets g + \alpha w$</li>
<li>   &emsp; &emsp;    $h_a \gets h$</li>
<li>   &emsp; &emsp;    $h \gets ||g||^2_{L^2\left(\left[0,T\right]\right)}$</li>
<li>   &emsp; &emsp;    $\gamma \gets \frac{h}{h_a}$</li>
<li>   &emsp; &emsp;    $r \gets -g + \gamma r$</li>
<li>   &emsp; &emsp;    $n \gets n + 1$</li>
</ol>

<pre class="cpp" style="font-family:monospace;"><span style="color: #666666;">// Compute b: right-hand side of Ax = b</span>
solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, y<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, lambda<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> yd <span style="color: #000040;">-</span> y<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
volScalarField b <span style="color: #000080;">=</span> lambda<span style="color: #008080;">;</span>
&nbsp;
<span style="color: #666666;">// Compute A*f0</span>
<span style="color: #666666;">// Primal equation</span>
solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, y0<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> u<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
<span style="color: #666666;">// Adjoint equation</span>
solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, lambda<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> y0<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
<span style="color: #666666;">// Compute g0: initial gradient</span>
volScalarField g <span style="color: #000080;">=</span> lambda <span style="color: #000040;">+</span> beta<span style="color: #000040;">*</span>u <span style="color: #000040;">-</span> b<span style="color: #008080;">;</span>
scalar gL2 <span style="color: #000080;">=</span> gSum<span style="color: #008000;">&#40;</span> volField <span style="color: #000040;">*</span> g.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">*</span> g.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
scalar gL2a <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span><span style="color: #008080;">;</span>
&nbsp;
<span style="color: #666666;">// Compute initial residual and its norm</span>
volScalarField r <span style="color: #000080;">=</span> <span style="color: #000040;">-</span>g<span style="color: #008080;">;</span>
scalar rL2 <span style="color: #000080;">=</span> gL2<span style="color: #008080;">;</span>
&nbsp;
volScalarField w <span style="color: #000080;">=</span> g<span style="color: #008080;">;</span>
&nbsp;
scalar alpha <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span><span style="color: #008080;">;</span>
scalar gamma <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span><span style="color: #008080;">;</span>
&nbsp;
<span style="color: #0000ff;">while</span> <span style="color: #008000;">&#40;</span>runTime.<span style="color: #007788;">loop</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">&amp;&amp;</span> <span style="color: #008080;">::</span><span style="color: #0000dd;">sqrt</span><span style="color: #008000;">&#40;</span> rL2 <span style="color: #008000;">&#41;</span> <span style="color: #000080;">&gt;</span> tol<span style="color: #008000;">&#41;</span>
<span style="color: #008000;">&#123;</span>
    r.<span style="color: #007788;">dimensions</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>.<span style="color: #007788;">reset</span><span style="color: #008000;">&#40;</span> u.<span style="color: #007788;">dimensions</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Compute w = A*r</span>
    solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, y0<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> r<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, lambda<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> y0<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    w <span style="color: #000080;">=</span> lambda <span style="color: #000040;">+</span> beta<span style="color: #000040;">*</span>r<span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Update alpha</span>
    alpha <span style="color: #000080;">=</span> gL2 <span style="color: #000040;">/</span> gSum<span style="color: #008000;">&#40;</span> volField <span style="color: #000040;">*</span> r.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">*</span> w.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Update control</span>
    u <span style="color: #000080;">=</span> u <span style="color: #000040;">+</span> alpha<span style="color: #000040;">*</span>r<span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Update cost gradient and its norm</span>
    g <span style="color: #000080;">=</span> g <span style="color: #000040;">+</span> alpha<span style="color: #000040;">*</span>w<span style="color: #008080;">;</span>
    gL2a <span style="color: #000080;">=</span> gL2<span style="color: #008080;">;</span>
    gL2 <span style="color: #000080;">=</span> gSum<span style="color: #008000;">&#40;</span> volField <span style="color: #000040;">*</span> g.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">*</span> g.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    gamma <span style="color: #000080;">=</span> gL2<span style="color: #000040;">/</span>gL2a<span style="color: #008080;">;</span>
&nbsp;
    <span style="color: #666666;">// Update residual and its norm</span>
    r.<span style="color: #007788;">dimensions</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>.<span style="color: #007788;">reset</span><span style="color: #008000;">&#40;</span> g.<span style="color: #007788;">dimensions</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
    r <span style="color: #000080;">=</span> <span style="color: #000040;">-</span>g <span style="color: #000040;">+</span> gamma<span style="color: #000040;">*</span>r<span style="color: #008080;">;</span>
    rL2 <span style="color: #000080;">=</span> gSum<span style="color: #008000;">&#40;</span> volField <span style="color: #000040;">*</span> r.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000040;">*</span> r.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    solve<span style="color: #008000;">&#40;</span>fvm<span style="color: #008080;">::</span><span style="color: #007788;">laplacian</span><span style="color: #008000;">&#40;</span>k, y<span style="color: #008000;">&#41;</span> <span style="color: #000040;">+</span> u<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    J <span style="color: #000080;">=</span> <span style="color:#800080;">0.5</span><span style="color: #000040;">*</span>gSum<span style="color: #008000;">&#40;</span>volField<span style="color: #000040;">*</span><span style="color: #008000;">&#40;</span>Foam<span style="color: #008080;">::</span><span style="color: #0000dd;">pow</span><span style="color: #008000;">&#40;</span>y.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #000040;">-</span>yd.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>,<span style="color: #0000dd;">2</span><span style="color: #008000;">&#41;</span> \
     <span style="color: #000040;">+</span> beta<span style="color: #000040;">*</span>Foam<span style="color: #008080;">::</span><span style="color: #0000dd;">pow</span><span style="color: #008000;">&#40;</span>u.<span style="color: #007788;">internalField</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>,<span style="color: #0000dd;">2</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
    Info <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Iteration no. &quot;</span> <span style="color: #000080;">&lt;&lt;</span> runTime.<span style="color: #007788;">timeName</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot; - &quot;</span> \
	    <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Cost value &quot;</span> <span style="color: #000080;">&lt;&lt;</span> J <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot; - &quot;</span> \
	    <span style="color: #000080;">&lt;&lt;</span> <span style="color: #FF0000;">&quot;Residual &quot;</span> <span style="color: #000080;">&lt;&lt;</span> <span style="color: #008080;">::</span><span style="color: #0000dd;">sqrt</span><span style="color: #008000;">&#40;</span> rL2 <span style="color: #008000;">&#41;</span> <span style="color: #000080;">&lt;&lt;</span> endl<span style="color: #008080;">;</span>
&nbsp;
    runTime.<span style="color: #007788;">write</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
<span style="color: #008000;">&#125;</span>
&nbsp;</pre>
<!--h5 align="center">conjugategradient.cpp</h5-->

<p>Both solvers, <i>laplaceAdjointFoam</i> for the steepest descent method with $\gamma = 10$ and <i>laplaceCGAdjointFoam</i> for the conjugate gradient method, have been tested in a square domain $[0, 1] \times [0, 1]$ with zero Dirichlet boundary conditions and $\beta = 10^{-3},10^{-4},10^{-5},10^{-6}$. The target function is $y_d = xy \sin \left( \pi x \right) \sin \left( \pi y \right)$.</p>

<p>The problem setup is called <i>case</i> in OpenFOAM and it is independent from the solver itself. A typical case in OpenFOAM has three folders: <i>0</i>, where the problem fields are stored along with their boundary conditions; <i>constant</i>, that includes the mesh data and the physical properties; and <i>system</i>, with parameters regarding the numerical solution and problem output such as tolerances, linear solvers or write interval. In this example, the case folder is called <i>laplaceAdjointFoamCase</i>.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/sd_J.png" alt="Figure 1.a: Functional value against the number of iterations of the gradient method. Steepest descent method. Steepest descent method" width="560" height="420" class="size-full wp-image-8677" />
Figure 1.a: Functional value against the number of iterations of the gradient method. Steepest descent method. Steepest descent method</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/cg_J.png" alt="Figure 1.b: Functional value against the number of iterations of the gradient method. Steepest descent method. Conjugate gradient method." width="560" height="420" class="size-full wp-image-8675" />
Figure 1.b: Functional value against the number of iterations of the gradient method. Steepest descent method. Conjugate gradient method.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/sd_Jy.png" alt="Figure 2.a" width="560" height="420" class="size-full wp-image-8678" />
Figure 2.a: $|| y - y_d ||_{L^2 \left( \Omega \right)}$ against the number of iterations of the gradient method. Steepest descent method.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/cg_Jy.png" alt="Figure 2.b" width="560" height="420" class="size-full wp-image-8676" />
Figure 2.b: $|| y - y_d ||_{L^2 \left( \Omega \right)}$ against the number of iterations of the gradient method. Conjugate gradient method.</p>

<h6>Bibliography</h6>

<p><strong>[1]</strong> The OpenFOAM Foundation, <a href="http://openfoam.org" target="_blank"><em>http://openfoam.org</em></a>.</p>
<p><strong>[2]</strong> F. Tröltzsch. <a href="https://bookstore.ams.org/gsm-112/" target="_blank"><em>Optimal control of partial differential equations: theory, methods, and applications</em></a>. American Mathematical Soc., 2010.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In &lt;a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref3"&gt;[3]&lt;/a&gt;, we develop a WKB analysis for the propagation of the solutions to the following one-dimensional nonlocal Schrödinger equation&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}\label{main_eq}
	\mathcal{P}_s u:= \left[i\partial_t + \ffl{s}{}\right]u = 0, &\;\;  (x,t)\in\RR\times(0,+\infty),
\end{align} %]]></script>

<p>with highly oscillatory initial datum</p>

<script type="math/tex; mode=display">\begin{align}\label{in_dat}
	u(x,0) = u_{\textrm{\small in}}(x) e^{i\frac{\xi_0}{\varepsilon} x}:=u_0(x),\;\;\; \xi_0\in\RR.
\end{align}</script>

<p>In (\ref{main_eq}), $\ffl{s}{}$ is the fractional Laplacian, defined for all $s\in(0,1)$ and for any function $f$ sufficiently smooth as the following singular integral</p>

<script type="math/tex; mode=display">\begin{align*}
\ffl{s}{f}(x):=\ccs\; P.V. \int_{\RR}\frac{f(x)-f(y)}{\kernel{1+2s}}\,dy,
\end{align*}</script>

<p>with $\ccs$ a normalization constant given by</p>

<script type="math/tex; mode=display">\begin{align*}%\label{ccs}
\ccs:= \left(\int_{\RR} \frac{1-\cos(z)}{|z|^{1+2s}}\,dz\right)^{-1} = \frac{s2^{2s}\Gamma\left(s+\frac 12\right)}{\sqrt{\pi}\Gamma(1-s)},
\end{align*}</script>

<p>where $\Gamma$ is the usual Gamma function. The parameter $\varepsilon$ in (\ref{main_eq}) and in (\ref{in_dat}) represents the fast space and time scale introduced in the equation, as well as the typical wavelength of oscillations of the initial data. Moreover, we will assume the initial phase $u_{\textrm{\small in}}$ to be an $L^2(\RR)$ function, so that we have $u_0\in L^2(\RR)$.</p>

<p>Our study is motivated by control problems. Indeed, the well-known boundary controllability and identifiability properties of solutions of wave-like equations hold because of the fact that the energy of solutions is driven by characteristics that reach the boundary where the controllers or observers are placed. This, in particular, allows the so-called <i>observability</i> of the solutions (namely, the possibility to obtain estimates of the total energy in terms of the energy concentrated on the support of the control along time), which is by now known to be equivalent to control properties. In the framework of wave-like processes, observability is possible if and only if the geometric control condition (GCC), requiring all rays of geometric optics to enter the control region during the control time, holds (<a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref1">[1]</a>).</p>

<p>In the particular case under analysis, the construction that we obtain is then applied to the study of controllability properties for the one dimensional fractional Schrödinger equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}\label{schr_control}
     \begin{cases}
		iu_t+\ffl{s}{u} = g\chi_{\omega\times(0,T)}, & (x,t)\in (-1,1)\times(0,T)
		\\
		u\equiv 0, & (x,t)\in(-1,1)^c\times(0,T)
		\\
		u(x,0)=u_0(x), & x\in(-1,1),
	\end{cases}
\end{align} %]]></script>

<p>where $\omega$ is a neighborhood of the boundary of the space domain $(-1,1)$. In particular, it is possible to find confirmation to the following facts, proved in <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref2">[2]</a>:</p>
<ul>
	<li> For $s&gt; 1/2$, null controllability holds in any finite time $T&gt;0$. In other words, given any $u_0\in L^2(-1,1)$ there exists a control function $g\in L^2(\omega\times(0,T))$ such that the solution to (\ref{schr_control}) satisfies $u(x,T)=0$.</li>
	<li> For $s=1/2$, the same result holds if we assume the controllability time $T$ to be large enough, i.e $T\geq T_0&gt;0$.</li>
	<li> For $ s&lt; 1/2 $, the equation (\ref{schr_control}) is not null controllable.	</li>
</ul>

<p>The above facts are related to the well-known property that the solutions to wave-like equations propagate along the so-called rays of geometric optics. These rays are nothing more than the projection to the physical time-space of the null bicharacteristic, solutions to the Hamiltonian system associated to the equation.</p>

<p>In our case, since $\mathcal{P}_s=i\partial_t+\ffl{s}{}$ is a pseudo-differential operator with symbol
$ p_s(x,t,\xi,\tau) = \tau - |\xi|^{2s} $ , the Hamiltonian system is given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}\label{char_syst}
     \begin{cases}
		\dot{x}(\sigma) = \partial_\xi p_s = \pm 2s|\xi(\sigma)|^{2s-1}, & x(0)=x_0
		\\
		\dot{t}(\sigma) = \partial_\tau p_s = 1, & t(0)=t_0
		\\
		\dot{\xi}(\sigma) = -\partial_x p_s = 0, & \xi(0)=\xi_0
		\\
		\dot{\tau}(\sigma) = -\partial_t p_s =0, & \tau(0)=|\xi_0|^{2s}.
	\end{cases}
\end{align} %]]></script>

<p>Moreover, without losing generality we may assume $t_0=0$. Then, (\ref{char_syst}) can be solved explicitly, and we obtain the following expressions for the bicharacteristics</p>

<script type="math/tex; mode=display">\begin{align*}

\begin{cases}
x(\sigma) = x_0 \pm 2s|\xi_0|^{2s-1}\sigma
\\
t(\sigma) = \sigma
\\
\xi(\sigma) = \xi_0
\\
\tau(\sigma) = |\xi_0|^{2s}.
\end{cases}
\end{align*}</script>

<p>In particular, the rays of $ \mathcal{P}_s $ are given by the curves</p>

<script type="math/tex; mode=display">(t,x_0\pm 2s|\xi_0|^{2s-1}t)\in(0,+\infty)\times\RR</script>

<p>Notice that, as one expects since the operator has constant coefficients, these rays are straight lines.</p>

<p>The approach that we use for building localized solutions is quite standard. In particular, we look for quasi-solutions to (\ref{main_eq}) introducing the ansatz</p>

<script type="math/tex; mode=display">\begin{align}\label{ansatz}
	\ue{u}(x,t) = \varepsilon^s e^{i\left[\xi_0\varepsilon^{-1}x\,+\,|\xi_0|^{2s}\varepsilon^{-2s}t\right]}\sum_{j\geq 0}\varepsilon^{\frac{s}{2}j}a_j\left(x,\varepsilon^{\frac{3}{2}s}t\right),
\end{align}</script>

<p>where the normalization constant $\varepsilon^s$ is chosen asking that the function $\ue{u}$ has $H^s(\RR)$-norm of the order $\mathcal O(1)$. The identification of the $a_j$-s is then carried out imposing</p>

<script type="math/tex; mode=display">\begin{align*}
	\mathcal{P}_s\ue{u} = O(\varepsilon^{\infty}),
\end{align*}</script>

<p>thus obtaining a series of PDEs in which it is possible to clearly separate the leading order terms, with respect to $\varepsilon$, from several remainders which will vanish as $\varepsilon\to 0$. This generates a cascade system for the functions $a_j$, which can then be determined as the solution of certain given Partial Differential Equations. In our case, the cascade system is the following one</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}\label{cascade_system}


     \begin{cases}
		i\partial_\tau a_0 + \mathcal{C}_{\frac s2} \mathcal{D}^{\frac{s}{2}} a_0 = 0  
		\\
		i\partial_\tau a_1 + \mathcal{C}_{\frac s2} \mathcal{D}^{\frac{s}{2}} a_1 + \mathcal{C}_{s} \mathcal{D}^{s} a_0 = 0  
		\\
		i\partial_\tau a_2 + \mathcal{C}_{\frac s2} \mathcal{D}^{\frac{s}{2}} a_2 + \mathcal{C}_{s} \mathcal{D}^{s} a_1 + \mathcal{C}_{\frac{3s}{2}} \mathcal{D}^{\frac{3s}{2}} a_0(\theta,\tau) = 0, & \displaystyle x\leq\theta\leq x+\frac{\varepsilon}{\xi_0}q
		\\
		i\partial_\tau a_j + \mathcal{C}_{\frac s2}\mathcal{D}^{\frac{s}{2}}a_j + \mathcal{C}_{s} \mathcal{D}^{s}a_{j-1} + \mathcal{C}_{\frac{3s}{2}} \mathcal{D}^{\frac{3s}{2}}a_{j-2}(\theta,\tau) + \ffl{s}{a_{j-3}}, & j\geq 3
		\\
		&\displaystyle x\leq\theta\leq x+\frac{\varepsilon}{\xi_0}q.  
	\end{cases}
\end{align} %]]></script>

<p>with $\tau:=\varepsilon^{\frac 32 s}t$ and where $\mathcal{D}^{\,\beta}$ denotes the following fractional derivative of order $\beta$</p>

<script type="math/tex; mode=display">\begin{align*}
	\mathcal{D}^{\beta} f(x):= \frac{1}{\Gamma(1-\beta)}\int_{-\infty}^x \frac{f'(y)}{(x-y)^{\beta}}\,dy.
\end{align*}</script>

<p>Moreover, (\ref{cascade_system}) is uniquely solvable with initial conditions imposed at $\tau = 0$ and this, of course, allows to identify the expressions of the functions $a_j$. See <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref3">[3]</a> for more details.</p>

<p>Now, it is possible to show that the quasi-solutions that can be computed by using the ansatz (\ref{ansatz}) are in fact localized along rays. In more detail, we have the following result</p>

<p><strong>Theorem 1.</strong> Let $u_{\textrm{\small in}}\in L^2(\RR)$ and let $\ue{u}$ be constructed employing the expansion (\ref{ansatz}). Then, for any $\varepsilon&gt;0$ we have:</p>
<ol>
<li> The functions $\ue{u}$ are approximate solutions to (\ref{main_eq}):

$$
\begin{align*}
     \norm{u_0(x)-\ue{u}(x,0)}{L^2(\RR)} = \mathcal{O}(\varepsilon^{\frac{1}{2}}),
\end{align*}
$$


$$
\begin{align*}
     \norm{u(x,t)-\ue{u}(x,t)}{L^2(\RR)} = \mathcal{O}(\varepsilon^{\frac 12}).
\end{align*}
$$
</li>
<li> The initial energy of $\ue{u}$ remains bounded as $\varepsilon\to 0$, i.e.

$$
\begin{align*}
     \norm{\ue{u}(x,0)}{H^s(\RR)}^2 \approx 1.
\end{align*}
$$
</li>
<li> The energy of $\ue{u}$ is exponentially small off the ray $(t,x(t))$:

$$
\begin{align*}
     \int_{|x-x(t)|&gt;\varepsilon^{\frac 14}} \left|\ffl{\frac s2}{\ue{u}}(x,t)\right|^2\,dx = \mathcal O(\varepsilon^{\frac 14}).
\end{align*}
$$
</li>
</ol>
<p>Since the quasi-solution $\ue{u}$ to our original system are concentrated along the rays, they propagate with the group velocity of the plane wave solutions, which can be computed as follows. First of all, rewrite</p>

<script type="math/tex; mode=display">\begin{align*}
	e^{i\left[\xi_0\varepsilon^{-1}x\,+\,|\xi_0|^{2s}\varepsilon^{-2s}t\,\right]} = e^{it\left[\xi_0\varepsilon^{-1}\left(\frac xt\right) + \,|\xi_0|^{2s}\varepsilon^{-2s}\,\right]} = e^{it\phi(x,t,\xi_0,\varepsilon)}.
\end{align*}</script>

<p>Hence, $ v:= \vert x/t \vert $ is obtained solving the equation</p>

<script type="math/tex; mode=display">\begin{align*}
	\frac{\partial\phi}{\partial \xi_0} = \varepsilon^{-1}\frac xt + 2s\varepsilon^{-2s}|\xi_0|^{2s-1}\textrm{sgn}(\xi_0) = 0,
\end{align*}</script>

<p>from which we immediately find that</p>

<script type="math/tex; mode=display">\begin{align*}
	v=\left|\frac xt\right| = 2s\varepsilon^{1-2s}|\xi_0|^{2s-1}.
\end{align*}</script>

<p>Moreover, this group velocity can be analyzed in terms of $s$ and of the frequency $\xi_0$. Firstly, we immediately see that for $s=1/2$ we have</p>

<script type="math/tex; mode=display">\begin{align*}
v=1,
\end{align*}</script>

<p>i.e. the velocity is constant and independent of the frequency $\xi_0$. For $s\in(0,1/2)$, instead, we have that $1-2s&gt;0$. Hence, taking $\varepsilon&lt;1$, we easily get</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
v<|\xi_0|^{2s-1}.
\end{align*} %]]></script>

<p>Finally, for $s\in(1/2,1)$ the situation is the opposite. We have $1-2s&lt;0$ and, for $\varepsilon&lt;1$,</p>

<script type="math/tex; mode=display">\begin{align*}
v>|\xi_0|^{2s-1}.
\end{align*}</script>

<p>In view of these behaviors, we can conclude that:</p>
<ul>
<li> For $s&gt; 1/2$, the group velocity increases with the frequency.	</li>

<li> For $s=1/2$, the group velocity remains constant.	</li>

<li> For $s&lt;1/2$, the group velocity decreases with the frequency.	</li>
</ul>

<p>Therefore, the high-frequency solutions are travelling faster and faster, for $s&gt;1/2$, and slower and slower, for $s&lt;1/2$. This behavior has then consequences from the point of view of observation properties for the solutions. In more detail,</p>
<ul>
	<li> For $s&gt;1/2$, the velocity of propagation of the rays allow them to be observable in any finite time $T&gt;0$.	</li>
	<li> For $s=1/2$, the velocity of propagation being constant, a minimum observation time $T_0$ is needed.	</li>
	<li> for $s&lt;1/2$ the high frequency rays may not reach the control region, thus implying the failing of controllability properties. 	</li>
</ul>
<p>This, in particular, confirms the already known results presented in <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref2">[2]</a>.</p>

<p>In what follows, we present some simulations which show the propagation of solutions to the fractional Schrödinger equation (\ref{main_eq}) corresponding to initial data in the form (\ref{in_dat}).</p>

<p>For the numerical resolution of the equation, we employed a uniform mesh in the space variable and a FE discretization of the fractional Laplacian, obtained following the methodology presented in <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#ref4">[4]</a>. Moreover, we used a Crank-Nicholson scheme in time, which is known to be stable for the Schrödinger equation. The initial data $u_0$ has been chosen as</p>

<script type="math/tex; mode=display">\begin{align*}
	u_0(x) = e^{-\frac \gamma2 (x-x_0)^2}e^{i\frac {\xi_0}{\varepsilon} x},
\end{align*}</script>

<p>where the profile $u_{\textrm{in}}(x)$ is given by a Gaussian with standard deviation measured in terms of the parameter $\gamma$, which is related to the mesh size $h$. In particular we chose $\gamma = h^{0.9}$. Finally, for the oscillations we considered frequencies $\xi_0=\pi^2/16$ and $\xi_0=2\pi^2$.</p>

<p>In <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#video1">Video 1</a>, we show the plots for $\xi_0=2\pi^2$ and different values of $s\in(0,1)$. The space domain has been chosen to be the interval $(-1,1)$, while we considered a time interval of $5$ seconds.</p>

<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_19.7392_1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_19.7392_1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>

<p>Video 1. Propagation of the solution for $\xi_0 = 2\pi^2$ and different values of $s$.</p>

<!--
[video width="570" height="450" mp4="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_0.61685_1.mp4"][/video]

<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger1_01_1.png" alt="plot_frac_schrodinger1_01_1" width="300" height="235" class="size-medium wp-image-8515" /> Figure 1.a Propagation of the solution for $\xi_0 = 2\pi^2$ and different values of $s$.

<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger1_05_1.png" alt="plot_frac_schrodinger1_05_1" width="300" height="235" class="size-medium wp-image-8516" /> Figure 1.b Propagation of the solution for $\xi_0 = 2\pi^2$ and different values of $s$.

<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger1_09_1.png" alt="plot_frac_schrodinger1_09_1" width="300" height="235" class="size-medium wp-image-8518" /> Figure 1.c Propagation of the solution for $\xi_0 = 2\pi^2$ and different values of $s$.
-->

<p>It is seen there that, for small values of $s$, say $s=0.1$, the solution remains concentrated along rays which propagate only in the vertical direction. In other words, there is no propagation in space and, as we mentioned before, this implies that it will not be possible to control these solutions, no matter how one places the controls. For $s=0.5$, instead, the plots show that the solutions propagate along rays which reach the boundary of the space domain in finite time and are reflected according to the laws of optics. This translate in the fact that, provided that the time is large enough, it will be possible to control these solutions, acting with a control distributed in a neighbourhood $\omega$ of the boundary. The case of high values of the power $s$ of the fractional Laplacian is the most puzzling one. For instance, for $s=0.9$ our plots seem to show a lost of concentration of the solution along the ray, while our theoretical results would suggest that this concentration is preserved. On the other hand, we believe that what the simulations are showing is not in contradiction with the theory. In our opinion, it is only a numerical effect, which has two possible interpretations.</p>

<p>First of all, for $s&gt;1/2$, the velocity of propagation of the solutions is increasing. As a consequence, in the time framework that we are considering the waves reach the boundary and are reflected many more times than in the case $s=1/2$. This large number of reflections is quite hard to clearly distinguish a the discrete level, even when working with very fine meshes (for our simulations, for instance, we are considering a mesh of $500$ points, corresponding to a step $h$ of the order of $10^{-3}$).</p>

<p>A second possible interpretation is that this strange phenomenon appearing in the plot can be explained with the accumulation of higher order terms in the asymptotic expansion of $\ue{z}$ which, combined with the small size of the space interval considered, enhance a chaotic behavior. This interpretation is supported by the fact that, as it is shown in <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#video3">Video 3</a>, enlarging the space domain up to $(-6,6)$ it is possible to appreciate again the localization of the solution along the rays.</p>

<p>In <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#video2">Video 2</a>, the simulations have been run with an initial datum with frequency $\xi_0=\pi^2/16$. The plots obtained show a behavior which is totally analogous with what observed in <a href="/wkb-expansion-for-a-fractional-schrodinger-equation-with-applications-to-controllability#video1">Video 1</a>:</p>
<ul>
<li> For $s=0.1$, the solutions are once again concentrated along vertical rays, without propagation in time and, therefore, without possibility of being controlled.	</li>

<li> For $s=0.5$, we have propagation with constant velocity, and the ray reaches the boundary in finite time.	</li>

<li> For $s=0.9$ the chaotic comportment is still present.	</li>
</ul>

<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_0.61685_1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_0.61685_1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
<p>Video 2. Propagation of the solution for $\xi_0 = \pi^2/16$ and different values of $s$.</p>

<!--
[video width="560" height="420" mp4="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_19.7392_1.mp4"][/video]

[caption id="attachment_8519" align="aligncenter" width="300"]<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger2_01_1.png" alt="plot_frac_schrodinger2_01_1" width="300" height="235" class="size-full wp-image-8519" /> Figure 2.a Propagation of the solution for $\xi_0 = \pi^2/16$ and different values of $s$.

[caption id="attachment_8520" align="aligncenter" width="300"]<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger2_05_1.png" alt="plot_frac_schrodinger2_05_1" width="300" height="235" class="size-full wp-image-8520" /> Figure 2.b Propagation of the solution for $\xi_0 = \pi^2/16$ and different values of $s$.

[caption id="attachment_8521" align="aligncenter" width="300"]<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger2_09_1.png" alt="plot_frac_schrodinger2_09_1" width="300" height="235" class="size-full wp-image-8521" /> Figure 2.c Propagation of the solution for $\xi_0 = \pi^2/16$ and different values of $s$.
-->

<p>Once again, the most surprising case is the last one, for $s&gt;0.5$, in which the simulations seem to display dispersive features. Nevertheless, as we mentioned before, we retain that this does not contradict the theoretical results, and we think that this chaotic behavior is purely a numerical effect generated by the small size of the space interval $(-1,1)$, by the high velocity of propagation of the solutions, and by the accumulation of high order terms in the asymptotic expansion. In fact, we can observe that the enlargement of the space domain up to $(-6,6)$ seems to fix the problem, and the localization of the solution along the rays appears once again (see Video 3). This, in our opinion, justifies our interpretation of the phenomenon.</p>

<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_6.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_6.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
<p>Video 3. Propagation of the solution for $s=0.9$ on the space interval $(-6,6)$.</p>

<!--
[video width="570" height="450" mp4="https://cmc.deusto.eus/wp-content/uploads/2018/04/rays_frac_schrodinger_6.mp4"][/video]

[caption id="attachment_8518" align="aligncenter" width="300"]<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger1_09_6.png" alt="plot_frac_schrodinger1_09_6" width="300" height="235" class="size-full wp-image-8518" /> Figure 3.a Propagation of the solution for $s=0.9$ on the space interval $(-6,6)$.

[caption id="attachment_8522" align="aligncenter" width="300"]<img src="https://cmc.deusto.eus/wp-content/uploads/2018/04/plot_frac_schrodinger2_09_6.png" alt="plot_frac_schrodinger2_09_6" width="300" height="235" class="size-full wp-image-8522" /> Figure 3.b Propagation of the solution for $s=0.9$ on the space interval $(-6,6)$.
-->

<h3>Bibliography</h3>

<p><strong><a name="ref1">[1]</a></strong> Bardos, C., Lebeau, G., and Rauch, J. <a name="cite1" target="_blank"></a>Sharp sufficient conditions for the observation, control, and stabilization of waves from the boundary. <em>SIAM J. Control Optim. 30, 5 (1992), 1024–1065.</em></p>

<p><strong><a name="ref2">[2]</a></strong> Biccari, U. <a href="https://cmc.deusto.eus/internal-control-for-non-local/" target="_blank">Internal control for non-local Schrödinger and wave equations involving the fractional Laplace operator.</a> <em>ESAIM: COCV: to appear. (2018).</em></p>

<p><strong><a name="ref3">[3]</a></strong> Biccari, U., and Aceves, A. B. <a href="https://cmc.deusto.eus/wkb-expansion-for-a-fractional-schr%c2%a8odinger-equation-with-applications-to-controllability/" target="_blank">WKB expansion for a fractional Schröodinger equation with applications to controllability.</a> <em>Submitted. (2018).</em></p>

<p><strong><a name="ref4">[4]</a></strong> Biccari,U., and Hernández-Santamaría, V. <a href="https://cmc.deusto.eus/controllability-of-a-one-dimensional-fractional-heat-equation-theoretical-and-numerical-aspects/" target="_blank">Controllability of a one-dimensional fractional heat equation: theoretical and numerical aspects.</a> <em>HAL Preprint - hal-01562358. (2017).</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;In this work, we address the optimal control of parameter-dependent systems. We introduce the notion of averaged control in which the quantity of interest is the average of the states with respect to the parameter family&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">\mathcal{K}= \left\{ \nu_i \in \mathbb{R}, \enspace 1\leq i \leq K \right\}</script>

<p>More precisely, we are interested in solving the next minimization problem:</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:costFunctional}
\min _{u \in L^2(0,T)} \mathcal{J}\left( u\right) = 
\min _{u \in L^2(0,T)} \frac{1}{2} \left[ \frac{1}{K} \sum_{\nu \in \mathcal{K}} x \left( T, \nu \right) - \bar{x} \right]^2  + 
\frac{\beta}{2} \int_0^T u^2 \mathrm{d}t \quad \beta \in \mathbb{R}^+
\end{equation}</script>

<p>Where $\mathcal{U}_{ad}$ is the space of admissible controls and $\bar{x}$ the average state target. The optimization problem (\ref{eq:costFunctional}) is subject to the finite dimensional linear control system</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align} \label{eq:primalODE}
\left\{
\begin{array}{ll}
x^\prime \left( t \right) = A \left( \nu \right) x \left( t \right) + B \left( \nu \right) u \left( t \right), \quad 0 < t <T, \\
x\left( 0 \right) = x^0.
\end{array}
\right.
\end{align} %]]></script>

<p>In (\ref{eq:primalODE}), the vector valued function $ x \left( t, \nu \right) \in \mathbb{R}^N$ is the state of the system, $A \left( \nu \right)$ is a $N \times N$-matrix governing its free dynamics and $u=u\left( t \right) \in \mathbb{R}^M $ is a $M$-component control, with $M \leq N$, entering and acting on the system through the control operator $B\left( \nu \right)$, a $N \times M$ parameter-dependent matrix. Moreover, the initial datum $x^0 \in \mathbb{R}^N$ to be controlled is independent of the parameter $\nu$, but the state of the system itself $x \left( t, \nu \right)$ depends on $\nu$. The effective value of the parameter $\nu$ being unknown, we aim at choosing a control that would perform optimally in an averaged sense, this is, rather than controlling specific realizations of the state, the average with respect to $\nu$ is controlled. This allows building a control independent of the parameter and making a robust compromise of all the possible realizations of the system for the various possible values of the unknown parameter $\nu$</p>

<p>We use the classical gradient descent method based on the adjoint methodology, and obtain the corresponding adjoint system for (\ref{eq:primalODE}),</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\left\{
\begin{array}{ll}
p^\prime \left( t \right) = -A \left( \nu \right) p \left( t \right), \quad 0 < t <T, \\
\displaystyle p\left( T \right) = - \left[ \frac{1}{K} \sum_{\nu \in \mathcal{K}} x \left( T, \nu \right) - \bar{x} \right].
\end{array}
\right.
\end{align} %]]></script>

<p>To minimize the functional in (\ref{eq:costFunctional}), we take the steepest descent direction given by</p>

<script type="math/tex; mode=display">\begin{equation}
J^\prime \left[ u^{\left( k \right)} \right] = \beta u^{\left( k \right)}\left( t \right) - \frac{1}{K} \sum_{\nu \in \mathcal{K}} B^t \left( \nu \right) p^{\left( k \right)} \left( t, \nu \right)
\end{equation}</script>

<p>Hence, the new control reads as</p>

<script type="math/tex; mode=display">\begin{equation}
u^{\left( k+1 \right)} = u^{\left( k \right)} - \gamma J^\prime \left[ u^{\left( k \right)} \right]
\end{equation}</script>

<p>for some $\gamma$ small enough.</p>

<p>We have also used the conjugate gradient method in order to reach faster the optimal control. In order to be able to apply this method the state vector has been split as</p>

<script type="math/tex; mode=display">\begin{equation}
x\left( t \right) = z_u \left( t \right) + y\left( t \right),
\end{equation}</script>

<p>where $z_u$ is the solution to the controlled system with zero initial condition,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\left\{
\begin{array}{ll}
z^\prime_u \left( t \right) = A \left( \nu \right) z_u \left( t \right) + B \left( \nu \right) u \left( t \right), \quad 0 < t <T, \\
z_u{\left( 0 \right)} = 0,
\end{array}
\right.
\end{align} %]]></script>

<p>and $y$ solves the free dynamics problem,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\left\{
\begin{array}{ll}
y^\prime \left( t \right) = A \left( \nu \right) y \left( t \right), \quad 0 < t <T, \\
y{\left( 0 \right)} = x^0.
\end{array}
\right.
\end{align} %]]></script>

<p>The functional in \ref{eq:costFunctional} can be expressed as</p>

<script type="math/tex; mode=display">\begin{equation}
J\left( u \right) = \frac{1}{2}\left( \bar{z}_u\left(T\right) + \bar{y} \left( T \right) - \bar{x}, \bar{z}_u\left(T\right) + \bar{y} \left( T \right) - \bar{x} \right)_{\displaystyle \mathbb{R}^n} + \frac{\beta}{2} \left(u, u\right)_{L^2\left(\left[0,T\right]\right)}
\end{equation}</script>

<p>We introduce the linear operator</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}
\begin{split}
\Lambda: L^2 \left( [0, T] \right) & \rightarrow \mathbb{R}^n \\
u & \rightarrow \bar{z}_u \left( T \right) = \frac{1}{K} \sum_{\nu \in \mathcal{K}} z_u \left( T, \nu \right)
\end{split}
\end{equation} %]]></script>

<p>and its dual counterpart,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}
\begin{split}
\Lambda^*: \mathbb{R}^n & \rightarrow L^2 \left( [0, T] \right) \\
p_T & \rightarrow  - \frac{1}{K} \sum_{\nu \in \mathcal{K}} B^t \left( \nu \right) p \left( t, \nu \right)
\end{split}
\end{equation} %]]></script>

<p>where $p\left(t, \nu\right)$ is solution to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\left\{
\begin{array}{ll}
{p}' \left( t \right) = -A \left( \nu \right) p \left( t \right), \quad 0 < t <T, \\
p{\left( T \right)} = - p_T.
\end{array}
\right.
\end{align} %]]></script>

<p>By doing this we can write the functional gradient as</p>

<script type="math/tex; mode=display">\begin{equation}
J^\prime\left( u \right) \delta u = \left( \underbrace{\left( \Lambda^* \Lambda + \beta I \right)}_{=A_{cg}} u - \underbrace{\Lambda^*\left( \bar{x} - \bar{y} \left( T \right) \right)}_{=b_{cg}}, \delta u \right)_{L^2\left(\left[0,T\right]\right)}.
\end{equation}</script>

<p>After having defined $A_{cg}$ and $b_{cg}$ we can apply the conjugate gradient method to solve the control problem.</p>

<h6><b>Algorithm 1</b> Optimal control with Conjugate Gradient Method</h6>
<p><b>Require:</b> $A\left( \nu \right)$, $B\left( \nu \right)$, $x^0$, $u^{\left(0\right)}$, $\beta$, $T$, $\bar{x}$, $tol$</p>
<ol>
<li>$n \gets 0 $</li>
<li> compute $\bar{y} \left( T \right)$</li>
<li> $b \gets \Lambda^*\left( \bar{x} - \bar{y} \left( T \right) \right)$</li>
<li> $z \gets \Lambda u$</li>
<li> $g \gets \Lambda^*z + \beta u - b$</li>
<li> $h \gets ||g||^2_{L^2\left(\left[0,T\right]\right)}$</li>
<li> $h_a \gets h$</li>
<li> $r \gets -g$</li>
<li><b>While</b> $||r||_{L^2\left(\left[0,T\right]\right)} &gt; tol $ <b>do</b></li>
<li>  &emsp; &emsp;    $z \gets \Lambda r$</li>
<li>  &emsp; &emsp;    $w \gets \Lambda^*z + \beta r$</li>
<li>  &emsp; &emsp;    $\alpha \gets \frac{h}{\left(r,w\right)_{L^2\left(\left[0,T\right]\right)}}$</li>
<li>  &emsp; &emsp;    $u \gets u + \alpha r$</li>
<li>  &emsp; &emsp;    $g \gets g + \alpha w$</li>
<li>  &emsp; &emsp;    $h_a \gets h$</li>
<li>  &emsp; &emsp;    $h \gets ||g||^2_{L^2\left(\left[0,T\right]\right)}$</li>
<li>  &emsp; &emsp;    $\gamma \gets \frac{h}{h_a}$</li>
<li>  &emsp; &emsp;    $r \gets -g + \gamma r$</li>
<li>  &emsp; &emsp;    $n \gets n + 1$</li>
</ol>
<p><img src="http://cmc.deusto.eus/wp-content/uploads/2018/03/xav.png" alt="figure1a" width="560" height="420" class="aligncenter size-full wp-image-8114" /><i align="aligncenter">Figure 1.a: Control system with $N=3$, $M=1$ and target average state $\bar{x}=[0,0,0]^t$. Average state vector components.</i></p>

<p><img src="http://cmc.deusto.eus/wp-content/uploads/2018/03/u.png" alt="figure1b" width="560" height="420" class="aligncenter size-full wp-image-8114" /><i align="aligncenter">Figure 1.b: Control system with $N=3$, $M=1$ and target average state $\bar{x}=[0,0,0]^t$. Control.</i></p>

<p><img src="http://cmc.deusto.eus/wp-content/uploads/2018/03/xi-1024x548.png" alt="figure1b" width="648" height="347" class="aligncenter size-large wp-image-8118" /><i align="aligncenter">Figure 2: State vector components for every parameter $\nu_i$. One can observe that the final state $x\left(T, \nu_i \right)$ is not close to $\bar{x}=[0,0,0]^t$ in general.</i></p>

<h2>Bibliography</h2>

<p><strong>[1]</strong> E. Zuazua (2014) <a href="http://verso.mat.uam.es/web/ezuazua/documentos_public/archivos/publicaciones/averaged-zuazua7.pdf" target="_blank"><em>Averaged Control.</em></a> Automatica, 50 (12), p. 3077-3087.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h4&gt;1 Introduction&lt;/h4&gt;
</code></pre>
</div>

<p>In the post <a href="https://cmc.deusto.eus/how-to-use-ipopt-and-ampl-to-solve-time-optimal-control-problems" target="_blank">IpOpt and AMPL use to solve time optimal control problems</a>, we explain how to use <a href="https://projects.coin-or.org/Ipopt" target="_blank"><i>IpOpt</i></a> and <a href="https://ampl.com/products/ampl/" target="_blank"><i>AMPL</i></a> in order to solve control problems with control constraints and possibly some state constraints.</p>

<p>In the present post, we are going to present a numerical development in order to find the minimal controllability time for the discretized heat equation with unilateral (non-negative) control constraint. More precisely, we consider the controllability of a discretized version of the 1D heat equation under nonnegative Dirichlet control constraint. The infinite dimensional system, we consider is</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}
	\dot{\psi}(t,x) = \partial_x^2 \psi(t,x)              &&              ( t>0,\, x\in(0,1)),\\
	\partial_x\psi(t,0) = 0            &&          (t>0),\\
	\psi(t,1) = u(t)            &&          (t>0),\\
	\psi(0,x) = \psi^0(x)            &&          (x\in(0,1)),\\
	\end{array} %]]></script>

<p>where $\psi$ is the state to control $\psi^0$ the initial state and $u$ the Dirichlet control.
The continuous version of this problem has been analysed in <a href="https://cmc.deusto.eus/control-of-the-semi-discrete-1d-heat-equation-under-nonnegative-control-constraint#ref2">[2]</a> and it has been shown that for every initial state $\psi^0\in L^2(0,1)$ and every positive constant target $\psi^1$, the controllability of this system under the control constraint
\begin{equation}\label{eq:ContConst}
	u(t)\geqslant0 (t\geqslant 0),
\end{equation}
requires a positive waiting time as soon as the target state $\psi^1$ is different from the initial state $\psi^0$.</p>

<p>In this post, we consider a spatially discretized version with has the form</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:SysGen}
	\dot{y}(t)=Ay(t)+B u(t) (t>0),
\end{equation}</script>

<p>where the matrices $A$ and $B$ are</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{eq:ABheat}
	A=(n+1)^2\begin{pmatrix}
		-2		& 2			& 0			& \hdots& \hdots& 0\\
		1			& -2		& 1			& 0			& \hdots& 0\\
		0			& \ddots& \ddots& \ddots&	\ddots& \vdots\\
		\vdots& \ddots& \ddots& \ddots& \ddots& 0\\
		\vdots&				& \ddots& \ddots& \ddots& 1\\
		0			&	\hdots&	\hdots&	0			& 1			& -2
	\end{pmatrix}\in M_{n}(\mathbb{R})\quad\text{and}\quad B=(n+1)^2\begin{pmatrix}
		0\\
		\vdots\\
		\vdots\\
		\vdots\\
		0\\
		1
	\end{pmatrix}\in M_{n,1}(\mathbb{R}).
\end{equation} %]]></script>

<p>where $n+1&gt;2$ is the number of discretization points and $[y]_i(t)$ (the $i^\text{th}$ component of $y(t)\in\mathbb{R}^n$) stands for $\psi(t,(i-1)/n)$.
To obtain the above finite dimensional system, we have used centred finite differences.</p>

<p>The aim is then to minimize the time $T$ such that there exist a control $u:[0,T]\to\mathbb{R}_+$ steering the solution of (\ref{eq:SysGen}) from $y^0\in\mathbb{R}^n$ to $y^1\in\mathbb{R}^n$ in time $T$. For the sake of simplicity, we assume that $y^0$ and $y^1$ are constant vectors of $\mathbb{R}^n$, that is to say that</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:y0y1}
	y^0=u^0\begin{pmatrix}1\\\vdots\\1\end{pmatrix}\in\mathbb{R}^n\quad\text{ and }\quad y^1=u^1\begin{pmatrix}1\\\vdots\\1\end{pmatrix}\in\mathbb{R}^n,
\end{equation}</script>

<p>for some $u^0\in\mathbb{R}$ and $u^1\in\mathbb{R}$ Since the control $u$ shall satisfy the constraint (\ref{eq:ContConst}), it is easy to see, using a discrete version of the comparison principle, that in order to have the existence of a solution, then we need $u^1&gt;0$.
Note that, using again the comparison principle, we can also show that if $u^0\geqslant 0$ then, whatever the control $u\geqslant 0$ is, the solution of (\ref{eq:SysGen}) always satisfies $y(t)\geqslant 0$.</p>

<p>To conclude, the optimization problem we aim to solve is</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{eq:optim0}
	\begin{array}{cl}
		\inf & T\\
		 & \begin{array}{l}
			T\geqslant 0,\\
			y(T;u;y^0)=y^1,\\
			u\in L^\infty(0,T),\quad u(t)\geqslant 0\quad (t\in[0,T]\text{ a.e.}),
		\end{array}
	\end{array}
\end{equation} %]]></script>

<p>where $y^0$ and $y^1$ are given by (\ref{eq:y0y1}) for some $u^0\in\mathbb{R}$ and $u^1\in\mathbb{R}_+^*$, and where $y(t;u;y^0)$ stands for the solution of (\ref{eq:SysGen}) at time $t$, with control $u$ and initial condition $y^0$.</p>

<p>In this post, in order to find numerically the minimal controllability time and a time-optimal control, we are going to use the abstract result presented in the next paragraph. Another way could be to introduce, in addition to the control constraint $u(t)\geqslant 0$, the additional control constraint $u(t)\leqslant M$, and let $M$ increase to $+\infty$. Such an approach has been introduced in the previous post <a href="https://cmc.deusto.eus/how-to-use-ipopt-and-ampl-to-solve-time-optimal-control-problems/" target="_blank">IpOpt and AMPL use to solve time optimal control problems</a>.</p>

<h4>2 Abstract result</h4>

<p>It is shown in <a href="https://cmc.deusto.eus/control-of-the-semi-discrete-1d-heat-equation-under-nonnegative-control-constraint/#ref1">[1]</a> that at the minimal time $\underline{T}(y^0,y^1)$, defined by (\ref{eq:optim0}), there exists a non-negative control $u$ in the class of Radon measure.
Furthermore, it is proved in this article that at the minimal controllability time, there exists one and only one non-negative Radon measure and this time optimal control is a convex sum of at most $\lfloor (n+1)/2 \rfloor$ Dirac masses.
In other words, the non-negative time optimal control takes the form:</p>

<script type="math/tex; mode=display">u=\sum_{k=1}^N\alpha_k\delta_{t_k},</script>

<p>with $N=\lfloor (n+1)/2 \rfloor$, $0\leqslant \alpha_k$ and $0\leqslant t_1\leqslant\dots\leqslant t_N\leqslant T$.
For a control of this form, the solution of (\ref{eq:SysGen}) at time $T$, with initial condition $y^0$, is:</p>

<script type="math/tex; mode=display">y(T)=e^{TA}y^0+\sum_{k=1}^N \alpha_i e^{(T-t_k)A}B.</script>

<p>Consequently, the minimal time $\underline{T}(y^0,y^1)$ given by (\ref{eq:optim0}) is a minimizer of:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{eq:optim1}
	\begin{array}{cl}
		\inf & T \\
		 & \begin{array}{l}
			0\leqslant t_1\leqslant\dots\leqslant t_N\leqslant T, \\
			\alpha_1,\dots,\alpha_N\geqslant 0, \\
			\displaystyle{y^1-e^{TA}y^0=\sum_{k=1}^N \alpha_k e^{(T-t_k)A}B}.
		\end{array}
	\end{array}
\end{equation} %]]></script>

<h4>3 Numerical implementation</h4>

<p>The optimization problem (\ref{eq:optim1}) is not easy to solve directly, mainly because of the presence of a matrix exponential.
Thus, instead we will solve the discretized heat equation on each time interval $(t_k,t_{k+1})$, with $t_0=0$ and $t_{N+1}=T$.
Let us then set $\tau_k=t_{k+1}-t_k$ for every $k\in{0,\dots,N}$.
We have $T=\sum_{k=0}^N\tau_k$ and the optimization problem (\ref{eq:optim1}) also writes</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{cl}
		\inf & \displaystyle{\sum_{k=0}^N\tau_k} \\
		 & \begin{array}{l}
			0\leqslant \tau_k (k\in\{0,\dots,N\}),\\
			0\leqslant \alpha_k (k\in\{1,\dots,N\}),\\
			y_0(0)=y^0,\\
			y_{k+1}(0)=y_k(\tau_k)+\alpha_{k+1}B(k\in\{0,\dots,N-1\}),\\
			y_{N}(\tau_N)=y^1,\\
			\text{~ where $y_k(t)=e^{tA}y_k(0)$, i.e.~$y_k$ is solution of (2) with null control.}
		\end{array}
	\end{array} %]]></script>

<p>In the above constraints, $y_k(\tau)=y(\tau+t_k)$ for every $\tau\in(0,\tau_k)$, where $y$ is the solution of (\ref{eq:SysGen}), with control $u=\sum_{k=1}^N\alpha_k\delta_{t_k}$ and initial condition $y(0)=y^0$. Notice that since $\alpha_k$ is only constrained to be non-negative, and since the vector $B$ (given by (\ref{eq:ABheat})) is of the form $(0,\dots,0,b_n)^\top$, with $b_n\geqslant 0$, the constraint $y_{k+1}(0)=y_k(\tau_k)+\alpha_{k+1}B$ can be expressed as</p>

<script type="math/tex; mode=display">\begin{equation*}
	[y_{k+1}]_n(0)\geqslant [y_k]_n(\tau_k)
	\text{and}
	[y_{k+1}]_i(0)=[y_k]_i(\tau_k) (i\in\{1,\dots,n-1\}).
\end{equation*}</script>

<p>Consequently, the parameters $\alpha_1,\dots,\alpha_N$ can be forgotten.</p>

<p>In order to numerically compute $y_k(t)=e^{tA}y_k(0)$ for $t\in[0,\tau_k]$, we are going to use the Crank-Nicholson method.
More precisely, given $N_t\in\mathbb{N}^*$, we approximate $y_k(j\tau_k/N_t)$ by $y_k^j$, with $y_k^j$ solution of</p>

<script type="math/tex; mode=display">y_k^0=y_k(0), \left( \mathrm{I}_n-\frac{\tau_k}{2N_t}A \right)y_k^{j+1}=\left( \mathrm{I}_n+\frac{\tau_k}{2N_t}A \right)y_k^j (j\in\{0,\dots,N_t-1\})</script>

<p>All in all, the fully discretized optimization problem, is</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:optD1}
		\min\ \sum_{k=0}^N \tau_k,
	\end{equation}</script>

<p>subject to the constraints</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
		\label{eq:optD2}
		& 0\leqslant \tau_k (k\in\{0,\dots,N\}),\\
	\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
		\label{eq:optD3}
		& [y_0^0]_i=u^0 (i\in\{1,\dots,n\}),\\
	\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
		\label{eq:optD4}
		& [y_{k+1}^0]_j=[y_k^{N_t}]_j(k\in\{0,\dots,N-1\},\ j\in\{1,\dots,n\}),\\
	\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
		\label{eq:optD5}
		& [y_{k+1}^0]_n\geqslant [y_k^{N_t}]_n(k\in\{0,\dots,N-1\}),\\
	\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
		\label{eq:optD6}
		& \max_{i\in\{1,\dots,n\}}\left|[y_{N}^{N_t}]_i-u^1\right|\leqslant \varepsilon,\\
	\end{align} %]]></script>

<script type="math/tex; mode=display">\begin{align}
		\label{eq:optD7}
		 \left( \mathrm{I}_n-\frac{\tau_k}{2N_t}A \right)y_k^{j+1}=\left( \mathrm{I}_n+\frac{\tau_k}{2N_t}A \right)y_k^j (k\in\{0,\dots,N\},\ j\in\{0,\dots,N_t-1\}).
	\end{align}</script>

<p>Note that instead of imposing $[y_{N}^{N_t}]_i=u^1$, we chose to relax this condition in the constraint (\ref{eq:optD6}).
This choice has been a maid since we do not expect that the numerical solution exactly reaches the target $y^1$. In practice, we will take, $\varepsilon=1/(n\, N_t)$.</p>

<p>In term of <i>AMPL</i> language, the above constrained optimization problem is</p>

<pre>
<span style="color: green;"># define parameters</span>
<b>param</b> n  = 20;             <span style="color: green;"># number of spatial discretization points</span>
<b>param</b> Nt = 400;            <span style="color: green;"># number of time discretization points</span>
<b>param</b> N  = floor((n+1)/2); <span style="color: green;"># maximal number of control impulses</span>
<b>param</b> eps= 1/(n*Nt);       <span style="color: green;"># relaxation parameter $\varepsilon}$ in (\ref{eq:optD6})</span>
<b>param</b> u0 = 1;              <span style="color: green;"># parameters $u^0\text{ and }u^1}$, see (\ref{eq:y0y1})</span>
<b>param</b> u1 = 5;

<span style="color: green;"># define variables</span>
<b>var</b> y	  {k in 0..N, j in 0..Nt, i in 1..n};	<span style="color: green;"># unknowns $[y_k^j]_i$</span>
<b>var</b> tau {k in 0..N} &gt;=0;   <span style="color: green;"># unknown impulse times $\tau_k}$ subject to (\ref{eq:optD2})</span>

<span style="color: green;"># objective function, see (\ref{eq:optD1})</span>
<b>minimize</b> T:
	sum {k in 0..N} tau[k];

<span style="color: green;"># define the constraints</span>
<span style="color: green;"># constraint (\ref{eq:optD7}) for interior points</span>
<b>subject to</b> y_dyn {k in 0..N, j in 1..Nt, i in 2..n-1}:
	y[k,j,i]-y[k,j-1,i] =
		(n+1)^2*(y[k,j,i-1]-2*y[k,j,i]+y[k,j,i+1]
                +y[k,j-1,i-1]-2*y[k,j-1,i]+y[k,j-1,i+1])/2*tau[k]/Nt;
<span style="color: green;"># constraint (\ref{eq:optD7}) for i=n</span>
<b>subject to</b> y_dyn_Dirichlet {k in 0..N, j in 1..Nt}:
	y[k,j,n]-y[k,j-1,n] =
		(n+1)^2*(y[k,j,n-1]-2*y[k,j,n]+y[k,j-1,n-1]-2*y[k,j-1,n])/2*tau[k]/Nt;
<span style="color: green;"># constraint (\ref{eq:optD7}) for i=1</span>
<b>subject to</b> y_dyn_Neuman {k in 0..N, j in 1..Nt}:
	y[k,j,1]-y[k,j-1,1] =
		(n+1)^2*(y[k,j,2]-y[k,j,1]+y[k,j-1,2]-y[k,j-1,1])/2*tau[k]/Nt;
<span style="color: green;"># initial condition, constraint (\ref{eq:optD3})</span>
<b>subject to</b> y_init {i in 1..n}:
	y[0,0,i] = u0;
<span style="color: green;"># terminal condition, constraint (\ref{eq:optD6})</span>
<b>subject to</b> y_end1 {i in 1..n}:
	y[N,Nt,i] &gt;= u1-eps;
<b>subject to</b> y_end2 {i in 1..n}:
	y[N,Nt,i] &lt;= u1+eps;
<span style="color: green;"># constraint (\ref{eq:optD4})</span>
<b>subject to</b> continuity {k in 0..N-1, i in 1..n-1}:
	y[k+1,0,i]=y[k,Nt,i];
<span style="color: green;"># constraint (\ref{eq:optD5})</span>
<b>subject to</b> jump {k in 0..N-1}:
	y[k+1,0,n]&gt;=y[k,Nt,n];

<span style="color: green;"># solve the problem with IpOpt</span>
<b>option</b> solver ipopt;
<b>option</b> ipopt_options <span style="color: brown;">"max_iter=100000 linear_solver=mumps halt_on_ampl_error yes"</span>;
<b>solve</b>;

<span style="color: green;"># display parameters and solution</span>
<b>printf</b>: <span style="color: brown;">"u0 = %24.16e\n"</span>, u0;
<b>printf</b>: <span style="color: brown;">"u1 = %24.16e\n"</span>, u1;
<b>printf</b>: <span style="color: brown;">"T  = %24.16e\n"</span>, T;
<b>printf</b>: <span style="color: brown;">"n  = %d\n"</span>, n;
<b>printf</b>: <span style="color: brown;">"Nt = %d\n"</span>, Nt;
<b>printf</b>: <span style="color: brown;">"N  = %d\n"</span>, N;
<b>printf</b>: "Data\n";
<b>printf</b>: <span style="color: brown;">"t_k ="</span>;
<b>printf</b> {k in 0..N}:  <span style="color: brown;">" %24.16e\t"</span>, tau[k];
<b>printf</b>: <span style="color: brown;">"\n"</span>;
<b>printf</b>: <span style="color: brown;">"y =\n"</span>;
for {k in 0..N} {
	<b>printf</b> <span style="color: brown;">"k = %d\n"</span>, k;
	<b>printf</b> {j in 0..Nt, i in 1..n}: <span style="color: brown;">" %24.16e\n"</span>, y[k,j,i];
}
<b>end</b>;
<span style="color: green;"># quit AMPL</span>										
</pre>

<p>In the following simulations, we take n=20 and N_t=400. By post-treatment of the results (see the <a href="https://cmc.deusto.eus/how-to-use-ipopt-and-ampl-to-solve-time-optimal-control-problems/#scilab" target="_blank"><i>Scilab</i></a> file in the post <a href="https://cmc.deusto.eus/how-to-use-ipopt-and-ampl-to-solve-time-optimal-control-problems/" target="_blank">IpOpt and AMPL use to solve time optimal control problems</a> for an example), we obtain the following results:</p>
<ul>
<a name="D15"></a>
	<li>for $u^0=1$ and $u^1=5$: The minimal time obtained is $\mathtt{0.1689856}$.
<!--The control and state trajectories are displayed on Figures 1, 2 and 3.
		https://mycore.core-cloud.net/index.php/s/HzcsSlb4BZnZmpX-->
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/03/D15.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/03/D15.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
</li>
<a name="D51"></a>
	<li>for $u^0=5$ and $u^1=1$: The minimal time obtained is $\mathtt{0.7267605}$.
<!--The control and state trajectories are displayed on Figures 4, 5 and 6.
		https://mycore.core-cloud.net/index.php/s/luuWR99kvVIILQZ-->
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/03/D51.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2018/03/D51.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
</li>
</ul>

<p>In the above videos, red arrows correspond to Dirac masses in the control.</p>

<h4>References</h4>
<p><strong><a name="ref1">[1]</a></strong> J. Lohéac, E. Trélat, and E. Zuazua. <a name="cite1" target="_blank"></a><em>Control of the semi-discrete 1D heat equation under nonnegative control constraint.</em> In preparation.</p>

<p><strong><a name="ref2">[2]</a></strong> J. Lohéac, E. Trélat, and E. Zuazua. <a name="cite2" target="_blank"></a><em>Minimal controllability time for the heat equation under state constraints.</em> Mathematical Models and Methods in Applied Sciences, Volume 27, Issue 09, August 2017</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h5&gt;A Matlab guide for the numerical approximation of the exact control and stabilization of the wave equation&lt;/h5&gt;
</code></pre>
</div>

<p>This webpage contains a free software to compute the control of the wave equation with Matlab.</p>

<h5>Features</h5>

<p>With wave control you can explore the following:</p>

<ul>
<li>Exact control of the 1-d wave equation with finite differences and mixed finite elements when the control acts in one extreme.</li>
<li>Exact control of the 2-d wave equation with finite differences and mixed finite elements when the control acts in the boundary.</li>
<li>The stabilization of the 1-D wave equation in an interval with a damping acting on an internal subset, discretized with finite differences and numerical viscosity.</li>
<li>The stabilization of the 2-D wave equation in a square with a damping acting on an internal set, discretized with finite differences and numerical viscosity.</li>
</ul>

<p>Some views are given below,</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol1.jpg" alt="figure1" class="post-photo-graphic" /><br /><i>Figure 1</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol2.jpg" alt="figure2" class="post-photo-graphic" /><br /><i>Figure 2</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol3.jpg" alt="figure3" class="post-photo-graphic" /><br /><i>Figure 3</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol4.jpg" alt="figure4" class="post-photo-graphic" /><br /><i class="aligncenter">Figure 4</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol5.jpg" alt="figure5" class="post-photo-graphic" /><br /><i>Figure 5</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2018/01/wavecontrol6.jpg" alt="figure6" class="post-photo-graphic" /><br /><i>Figure 6</i></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3&gt;The problems considered&lt;/h3&gt;
</code></pre>
</div>

<p>We obtain a finite element (FE) scheme for the numerical approximation of the solution to the following non-local Poisson equation</p>

<script type="math/tex; mode=display">\begin{align}
\begin{cases}
\ffl{s}{u} = f, \quad  x\in(-L,L)
\\
u\equiv 0,  x\in\RR\setminus(-L,L).
\end{cases}
\end{align}</script>

<p>In (1), $f$ is a given function and, for all $s\in(0,1)$, $\ffl{s}{}$ denotes the one-dimensional fractional Laplace operator, which is defined as the following singular integral</p>

<script type="math/tex; mode=display">\begin{align}\label{fl}
\ffl{s}{u}(x) = \ccs\,P.V.\,\int_{\RR}\frac{u(x)-u(y)}{|x-y|^{1+2s} }\,dy.
\end{align}</script>

<p>Here, $\ccs$ is an explicit normalization constant.</p>

<p>The main novelty of this work relies on the fact that, since we are dealing with a one-dimensional problem, each entry of the stiffness matrix can be computed explicitly, without requiring numerical integration, which is instead needed for the multidimensional case (see <a href="#acosta2017short">[1]</a>). This has the great advantage of reducing the computational cost and allows to be used on more general applications.</p>

<p>A natural example is given by the numerical resolution of the following control problem: given any $T&gt;0$, find a control function $g\in L^2((-1,1)\times(0,T))$ such that the corresponding solution to the parabolic problem</p>

<script type="math/tex; mode=display">\begin{align}
\begin{cases}
z_t + \ffl{s}{z} = g\mathbf{1}_{\omega},\quad  (x,t)\in (-1,1)\times(0,T)
\\
z=0,  (x,t)\in[\,\RR\setminus (-1,1)\,]\times(0,T)
\\
z(x,0)=z_0(x),  x\in (-1,1)
\end{cases}
\end{align}</script>

<p>satisfies $z(x,T)=0$.</p>

<p>The approach emploied for solving this control problem is based on the penalized Hilbert Uniqueness Method (<a href="#boyer2013penalised">[2]</a>).</p>
<h3>Preliminary results</h3>
<h4>Variational formulation of the elliptic problem</h4>
<p>Find $u\in H^s_0(-L,L)$ such that</p>

<script type="math/tex; mode=display">\begin{align*}
\frac{\ccs}{2} \int_{\RR}\int_{\RR}\frac{(u(x)-u(y))(v(x)-v(y))}{|x-y|^{1+2s} }\,dxdy = \int_{-L}^L fv\,dx,
\end{align*}</script>

<p>for all $v\in H_0^s(-L,L)$. Here, $H^s_0(-L,L)$ denotes the space</p>

<script type="math/tex; mode=display">\begin{align*}
H^s_0(-L,L) :=\Big\{\, u\in H^s(\RR)\,:\,u=0 \textrm{ in } \RR\setminus(-L,L)\,\Big\},
\end{align*}</script>

<p>while $H^s(\RR)$ is the classical fractional Sobolev space of order <em>s</em>. Since the bilinear form <em>a</em> is continuous and coercive, Lax-Milgram Theorem immediately implies that, if $f\in H^{-s}(-L,L)$, the dual space of $H^s_0(-L,L)$, then (1) admits a unique weak solution $u\in H_0^s(-L,L)$.</p>
<h4>Parabolic problem</h4>
<p><strong>Definition 1.</strong> <em>System (3) is said to be <u>null-controllable</u> at time $T$ if, for any $z_0\in L^2(-1,1)$, there exists $g\in L^2((-1,1)\times(0,T))$ such that the corresponding solution $z$ satisfies</em></p>

<script type="math/tex; mode=display">\begin{align*}
z(x,T)=0.
\end{align*}</script>

<p><strong>Definition 2.</strong> <em>System (3) is said to be <u>approximately controllable</u> at time $T$ if, for any $z_0,z_T\in L^2(-1,1)$ and any $\delta&gt;0$, there exists $g\in L^2((-1,1)\times(0,T))$ such that the corresponding solution $z$ satisfies </em></p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}

\renewcommand{\norm}[2]{ {\left\|#1\right\|}_{#2} }

\norm{z(x,T)-z_T}{L^2(-1,1)}<\delta.
\end{align*} %]]></script>

<p>There are few results in the literature on the null-controllability of the fractional heat equation, and they all deal with the <em>spectral</em> definition of the fractional Laplace operator, which is introduced, e.g., in <a href="#micu2006controllability">[3]</a>,<a href="#miller2006controllability">[4]</a>. In this framework, it is known that the fractional heat equation is null-controllable, provided that $s&gt;1/2$. For $s\leq 1/2$, instead, null controllability does not hold, not even for $T$ large.</p>

<p>However, also for the parabolic equation involving the integral fractional Laplacian (2), at least in the one space dimension, these properties are easily achievable. In more detail, we prove the following.</p>

<p><strong>Proposition 1.</strong> <em>For all $z_0\in L^2(-1,1)$ the parabolic problem (3) is null-controllable with a control function $g\in L^2(\omega\times(0,T))$ if and only if $s&gt;1/2$.
</em></p>

<p>Even if for $s\leq 1/2$ null controllability for (3) fails, we still have the following result of approximate controllability.</p>

<p><strong>Proposition 2.</strong> <em>Let $s\in(0,1)$. For all $z_0\in L^2(-1,1)$, there exists a control function $g\in L^2(\omega\times(0,T))$ such that the unique solution $z$ to the parabolic problem (3) is approximately controllable.
</em></p>
<h3>Development of the numerical scheme</h3>
<h4>Finite element approximation of the elliptic problem</h4>
<p>Let us introduce a partition of the interval $(-L,L)$ as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
-L = x_0<x_1<\ldots <x_i<x_{i+1}<\ldots<x_{N+1}=L\,, 
\end{align*} %]]></script>

<p>with $x_{i+1}=x_i+h$, $i=0,\ldots N$, $h&gt;0$. Having defined $K_i:=[x_i,x_{i+1}]$ we consider the discrete space</p>

<script type="math/tex; mode=display">\begin{align*}
V_h :=\Big\{v\in H_0^s(-L,L)\,\big|\, \left. v\,\right|_{K_i}\in \mathcal{P}^1\Big\},
\end{align*}</script>

<p>where $\mathcal{P}^1$ is the space of the continuous and piece-wise linear functions. If we indicate with</p>

<script type="math/tex; mode=display">\big\{\phi_i\big\}_{i=1}^N</script>

<p>the classical basis of $V_h$ in which each $\phi_i$ is the tent function with $supp(\phi_i)=(x_{i-1},x_{i+1})$ and verifying $\phi_i(x_j)=\delta_{i,j}$, at the end we are reduced to solve the linear system</p>

<script type="math/tex; mode=display">\begin{align*}
\mathcal A_h u=F,
\end{align*}</script>

<p>where the stiffness matrix $\mathcal A_h\in \RR^{N\times N}$ has components</p>

<script type="math/tex; mode=display">\begin{align}\label{stiffness_nc}
a_{i,j}=\frac{\ccs}{2} \int_{\RR}\int_{\RR}\frac{(\phi_i(x)-\phi_i(y))(\phi_j(x)-\phi_j(y))}{|x-y|^{1+2s} }\,dxdy, \;\;\; i,j = 1,\ldots,N,
\end{align}</script>

<p>while the vector $F\in\RR^N$ is given by $F=(F_1,\ldots,F_N)$ with</p>

<script type="math/tex; mode=display">\begin{align*}
F_i = \langle f,\phi_i\rangle = \int_{-L}^L f\phi_i\,dx,\;\;\; i=1,\ldots,N.
\end{align*}</script>

<p>The construction of the stiffness matrix $\mathcal A_h$ is done in three steps, since its elements can be computed differentiating among three well defined regions: the upper triangle, corresponding to indices $j\geq i+2$, the upper diagonal corresponding to $j=i+1$, and the diagonal corresponding to $j=i$. In each of these regions, the intersections among the support of the basis functions are different, thus generating different values of the bilinear form.</p>

<p>After several computations, we obtain the following expressions for the elements of the stiffness matrix $\mathcal{A}_h$: for $s\neq 1/2$</p>

<script type="math/tex; mode=display">\begin{align*}
a_{i,j} = -h^{1-2s} \begin{cases}
\displaystyle \,\frac{4(k+1)^{3-2s} + 4(k-1)^{3-2s}-6k^{3-2s}-(k+2)^{3-2s}-(k-2)^{3-2s} }{2s(1-2s)(1-s)(3-2s)},  \displaystyle k=j-i,\,k\geq 2
\\
\\
\displaystyle\frac{3^{3-2s}-2^{5-2s}+7}{2s(1-2s)(1-s)(3-2s)},  \displaystyle j=i+1
\\
\\
\displaystyle\frac{2^{3-2s}-4}{s(1-2s)(1-s)(3-2s)},  \displaystyle j=i.
\end{cases}
\end{align*}</script>

<p>For $s=1/2$, instead, we have</p>

<script type="math/tex; mode=display">\begin{align*}
a_{i,j} = \begin{cases}
-4(j-i+1)^2\log(j-i+1)-4(j-i-1)^2\log(j-i-1)
\\
\;\;\;+6(j-i)^2\log(j-i)+(j-i+2)^2\log(j-i+2)+(j-i-2)^2\log(j-i-2),  \displaystyle j> i+2
\\
\\
56\ln(2)-36\ln(3),  \displaystyle j= i+2.
\\
\\
\displaystyle 9\ln 3-16\ln 2,  \displaystyle j=i+1
\\
\\
\displaystyle 8\ln 2,  \displaystyle j=i.
\end{cases}
\end{align*}</script>

<h4>Control problem for the fractional heat equation</h4>
<p>We employ the so called penalised Hilbert Uniqueness Method (HUM) that deals with the resolution of the following minimization problem: find</p>

<script type="math/tex; mode=display">\begin{align}\label{min_je}
\varphi^T_\varepsilon=\min_{\varphi\in L^2(-1,1)} J_\varepsilon (\varphi^T)
\end{align}</script>

<p>where</p>

<script type="math/tex; mode=display">\begin{align}\label{penalized_fun}

\renewcommand{\norm}[2]{ {\left\|#1\right\|}_{#2} }

J_\varepsilon(\phi^T):=\frac{1}{2}\int_0^T\int_{\omega}|\varphi|^2\,dxdt + \frac{\varepsilon}{2}\norm{\varphi^T}{L^2(-1,1)}^2 + \int_{\Omega} z_0\varphi(0)\,dx,
\end{align}</script>

<p>where $\varphi$ is the solution to the adjoint problem</p>

<script type="math/tex; mode=display">\begin{align*}
\begin{cases}
-\varphi_t+\ffl{s}{\varphi}=0,  (x,t)\in (-1,1)\times(0,T)
\\
\varphi = 0,  (x,t)\in\big[\RR\setminus(-1,1)\big]\times(0,T)
\\
\varphi(x,T)=\varphi^T(x),  x\in (-1,1).
\end{cases}
\end{align*}</script>

<p>Then, the approximate and null controllability properties of the system, for a given initial datum $z_0$, can be expressed in terms of the behavior of the penalized HUM approach.</p>

<p>In particular, according to <a href="#boyer2013penalised">[2,Theorem 1.7]</a> we have:</p>

<ul>
 	<li style="list-style-type: none;">
<ul>
 	<li>The equation is approximately controllable at time $T$ from the initial datum $z_0$ if and only if</li>
</ul>
</li>
</ul>

<script type="math/tex; mode=display">\begin{align*}
\varphi_\varepsilon^T\rightarrow 0,\;\;\;\textrm{ as }\;\varepsilon\to 0.
\end{align*}</script>

<ul>
 	<li style="list-style-type: none;">
<ul>
 	<li>The equation is null-controllable at time $T$ from the initial datum $z_0$ if and only if</li>
</ul>
</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
M_{z_0}^2:=2\sup_{\varepsilon>0}\left( \inf_{L^2(0,T;L^2(\omega))}J_\varepsilon\right)<+\infty.
\end{align*} %]]></script>

<p>In this case, we have</p>

<script type="math/tex; mode=display">\begin{align*}

\renewcommand{\norm}[2]{ {\left\|#1\right\|}_{#2} }

\norm{g}{L^2(0,T;L^2(\omega))}\leq M_{z_0},\nonumber
\\
\norm{\varphi_\varepsilon^T}{L^2(-L,L)}\leq M_{z_0}\sqrt{\varepsilon}.
\end{align*}</script>

<h3>Numerical results</h3>
<p>Here, we present the numerical simulations corresponding to our algorithms. We provide a complete discussion of the results obtained.</p>

<p>First of all, in order to test numerically the accuracy of our method for the discretization of the elliptic equation (1) we use the following problem</p>

<script type="math/tex; mode=display">\begin{align}\label{PE_real}
\left\{\begin{array}{ll}
\ffl{s}{u} = 1,  x\in(-L,L)
\\
u\equiv 0,  x\in\RR\setminus(-L,L).
\end{array}\right.
\end{align}</script>

<p>In this particular case, the solution can be expressed as follows</p>

<script type="math/tex; mode=display">\begin{align}\label{real_sol}
u(x)=\frac{2^{-2s}\sqrt{\pi} }{\Gamma\left(\frac{1+2s}{2}\right)\Gamma(1+s)}\Big(L^2-x^2\Big)^s.
\end{align}</script>

<p>In figure 1 and figure 2, we show a comparison for different values of $s$ between the exact solution (8) and the computed numerical approximation. Here we consider $L=1$ and $N=50$. One can notice that, when $s=0.1$, the computed solution is to a certain extent different from the exact solution. However, one should be careful with such result and a more precise analysis of the error should be carried.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig1.jpg" alt="Figure 1" width="800" /> Figure 1: Plot for different values of $s&lt;1/2$.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig2.jpg" alt="Figure 2" width="800" /> Figure 2: Plot for different values of $s\geq 1/2$.</p>

<p>In figure 3, we present the computational errors evaluated for different values of $s$ and $h$.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig3.jpg" alt="Figure 3" width="600" /> Figure 3: Convergence of the error.</p>

<p>The rates of convergence shown are of order (in $h$) of $1/2$. This is in accordance with the known theoretical results (see, e.g., <a href="#acosta2017short">[1,Theorem 4.6]</a>). One can see that the convergence rate is maintained also for small values of $s$. Since it is well-known that the notion of trace is not defined for the spaces $H^s(-L,L)$ with $s\leq 1/2$, it is somehow natural that we cannot expect a point-wise convergence in this case.</p>
<h4>Control experiments</h4>
<p>We present some numerical results for the controllability of the fractional heat equation (3). We use the finite-element approximation of $\ffl{s}{}$ for the space discretization and the implicit Euler scheme in the time variable. We choose the penalization term <em>ε</em> as a function of <em>h</em>. A practical rule (<a href="#boyer2013penalised">[2]</a>) is to choose $\phi(h)\sim h^{2p}$ where $p$ is the order of accuracy in space of the numerical method used for the discretization of the spatial operator involved. In this case, we take $p=1/2$.
In figure 4, we observe the time evolution of the uncontrolled solution as well as the controlled solution. Here, we set $s=0.8$, $\omega=(-0.3,0.8)$ and $T=0.3$, and choose $z_0(x) = \sin(\pi x)$. The control domain is the highlighted zone on the plane $(t,x)$. As expected, we observe that the uncontrolled solution decays with time, but does not reach zero at time $T$, while the controlled solution does.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig4.jpg" alt="Figure 4" width="800" /> Figure 4: Time evolution of system (3).</p>

<p>In figure 5, for $s=0.8$ we present the computed values of various quantities of interest when the mesh size goes to zero. More precisely, we observe that the control cost and the optimal energy remain bounded as $h\to 0$. On the other hand, we see that</p>

<script type="math/tex; mode=display">\begin{align}\label{control_norm_behavior}
|y(T)|_{L^2(-1,1)}\,\sim\,C\sqrt{\phi(h)}=Ch^{1/2}.
\end{align}</script>

<p>We know that, for $s=0.8$, system (3) is null controllable. This is now confirmed by (9), according to <a href="#boyer2013penalised">[2,Theorem 1.7]</a>. In fact, the same experiment can be repeated for different values of $s&gt;1/2$, obtaining the same conclusions.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig5.jpg" alt="Figure 5" width="600" /> Figure 5: Convergence properties of the method for controllability of the fractional heat equation.</p>

<p>In figure 6, we illustrate the numerical results for the case $s\leq 1/2$. We observe that the cost of the control and the optimal energy increase in both cases, while the target $y(T)$ tends to zero with a slower rate than $h^{1/2}$. This seems to confirm that a uniform observability estimate for (3) does not hold and that we can only expect to have approximate controllability.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/PoissonEqNumericsFig6.jpg" alt="Figure 6" width="800" /> Figure 6: Convergence properties of the method for $s&lt;1/2$. Same legend as in figure 5.</p>

<p>VIDEOS:</p>
<ol>
 	<li>Uncontrolled dynamics with s = 0.8 and T = 0.2 s - the solution dissipates but the zero state is not reached.
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/10/libre_frac.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/10/libre_frac.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
</li>
 	<li>Controlled dynamics with s = 0.8, T = 0.2 s and \omega = (−0.3, 0.8) - the zero state is reached.
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/10/soly_control_frac.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/10/soly_control_frac.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
</li>
</ol>

<!--h4>Useful links</h5-->
<h3>Bibliography</h3>

<p><strong>[1]</strong> Acosta, G., Bersetche, F. M., and Borthagaray, J. P. <a href="http://www.sciencedirect.com/science/article/pii/S0898122117303310" name="acosta2017short"><em>A short FE implementation for a 2d homogeneous Dirichlet problem of a Fractional Laplacian</em></a> Comput. Math. Appl. (2017).</p>

<p><strong>[2]</strong> Boyer, F <a href="https://www.esaim-proc.org/articles/proc/abs/2013/03/proc134102/proc134102.html" name="boyer2013penalised"><em>On the penalized hum approach and its applications to the numerical approximation of null-controls for parabolic problems</em></a> ESAIM: Proceedings vol. 41 (2013), pp. 15–58.</p>

<p><strong>[3]</strong> Micu, S., and Zuazua, E. <a href="http://epubs.siam.org/doi/abs/10.1137/S036301290444263X" name="micu2006controllability"><em>On the controllability of a fractional order parabolic equation.</em></a> SIAM J. Control Optim., vol. 44, no. 6 (2006), pp. 1950–1972.</p>

<p><strong>[4]</strong> Miller, L. <a href="https://hal.archives-ouvertes.fr/hal-00008809/document" name="miller2006controllability"><em>On the controllability of anomalous diffusions generated by the fractional Laplacian.</em></a> Math. Control Signals Systems, vol. 18, no. 3 (2006), pp. 260–271.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3&gt;Introduction&lt;/h3&gt;
</code></pre>
</div>

<p>We are interested in optimal control problems subject to a class of diffusion-reaction systems that describes the growth and spread of an introduced population of organisms</p>

<script type="math/tex; mode=display">\begin{equation}  \label{pde}
y_t - y_{xx} = f(y), \quad x\in \mathbb{R}, \quad t \in \mathbb{R}^+,  
\end{equation}</script>

<p>where</p>

<script type="math/tex; mode=display">\begin{equation}  \label{fyatet}
f(y)=a y(1-y)(\theta-y),
\end{equation}</script>

<p>is the reaction term that represents local reactions, and $y(t, x) : \mathbb{R}^+ \times \mathbb{R} \rightarrow \mathbb{R}$ is the state of the system. Here $a&lt;0$ and $\theta \in [0,1]$ are two real parameters.</p>

<p>State $y$ represents the local population density. The ``growth’’ of $y$ is subject to an Allee effect (described by the reaction term $f$) in addition to migration (described by the term $y_{xx}$). Allee effect exists for a wide variety of reasons such as less efficient feeding at low densities and reduced effectiveness of vigilance and anti-predator defenses.</p>

<p>The value of $\vert a \vert $ represents the reproductive rate, and the parameter $\theta \in (0,1)$ is the local critical density or Allee threshold $\theta$ that determines the sign (positive or negative) the population growth. Note that, in some literature, the parameter $\theta$ (Allee threshold) has been supposed to be a dynamic parameter that changes with respect to the evolution of the species. Therefore, by means of biological control (e.g. importation of predators), environmental control (e.g. food supply), modern technology (e.g. DNA manipulations), the birth rate and the Allee threshold should be able to be modified. That is to say, we can consider the parameters $a$ and $\theta$ as the control of the system (\ref{pde}).</p>

<p>Note that the reaction term $f$ has three zeros $0$, $\theta$, and $1$, which correspond to three constant solutions of the system (\ref{pde}).
For system (\ref{pde}), there is a propagation phenomenon: one of the state $y=0$, or $y=1$, or $y=\theta$, propagates in the space.
This phenomenon is generally described by <i>traveling wave solution</i> of the form,</p>

<script type="math/tex; mode=display">\begin{equation} \label{tw}
y(t,x) = Y(x - ct), \quad x \in \mathbb{R}
\end{equation}</script>

<p>which connects two of the three constant solutions of the system (\ref{pde}). Here the constant $c \in \mathbb{R}$ is the wave speed, and $Y$ is called the wave profile. Typically, the wave speed and the wave profile depend on the parameters $a$ and $\theta$.</p>

<p>Given a bounded domain $\Omega \subset \mathbb{R}$, our optimal problem is then to choose optimal (control) parameters $a$ and $\theta$ such that the system (\ref{pde}) goes from a given initial state $y(0,x) = y_0(x) \in [0,1]$, $x\in \Omega$ to a final state $y(T,x)$, $x\in \Omega$ which minimizes the distance between this final state and an expected traveling wave solution $y^d$ of the form (\ref{tw}).</p>

<h3>Optimal control problem</h3>

<p>We consider the following optimal control problem $P_{opt}$.</p>

<p>Let $\Omega=[-L,L]\subset\mathbb{ {R} }$ and $T\in\mathbb{ {R}^{+} }$ be the given domain and final time, respectively. Find $u=(a,\theta)$ that minimizes the cost functional</p>

<script type="math/tex; mode=display">\begin{equation}
\label{costfun}
J(u)=\int_{\Omega}|y(T,x)-y^{d}(x)|^{2}dx+K\int_{0}^{T}|\dot{ {a} }(t)|^{2}+|\dot{ {\theta} }(t)|^{2}dt,
\end{equation}</script>

<p>such that the state $y$ satisfies</p>

<script type="math/tex; mode=display">\begin{equation}
\label{eqn_difreac}
y_{t}(t,x)-\triangle y(t,x)=f(x,u(t)),\quad (t,x)\in[0,T]\times\Omega,
\end{equation}</script>

<p>$\partial_{x}y(t,x)=0,\quad t\in[0,T],\quad x\in\partial\Omega$ , where $f(x,u(t))=a(t)y(t,x)(1-y(t,x))(\theta(t)-y(t,x))$, and the control $u=(a,\theta)$ satisfies $a(t)\in[a_{min},a_{max}],\quad,\theta(t)\in[\theta_{min},\theta_{max}]\quad t\in[0,T]$, where $y^{d}$ is a desired traveling wave solution of the form (\ref{tw}),
$a_{min},a_{max}$ are non positive constants, and $\theta_{max},\theta_{min}$ are constants between $0$ and $1$.</p>

<p>To solve this problem numerically with AMPL+(an optimization) solver, we need to discretize the problem and transform it into a nonlinear optimization problem.</p>

<p>Let $N_{t}$ and $N_{x}$ be two positive integers. Define a subdivision of time $0=t_{0}&lt;t_{1}&lt;\cdots&lt;t_{N_{t} }=T$ and a subdivision of space $-L=x_{0}&lt;x^{1}&lt;\cdots&lt;x^{N_{x} }=L$. For any integer $k\in[0,N_{t}-1]$ and $j\in[0,N_{x}-1]$, let $\Delta t_{k}:=t_{k+1}-t_{k}$ and $\Delta x_{j}=x^{j+1}-x^{j}$ be the time and space step size, respectively. Hence, we get a grid of points in the $(t,x)$ plane. Denote then $y_{j}^{k}$ the value of $y$ at the grid point $(t_{k},x^{j})$. Without loss of generality, we assume that the subdivisions are uniform, i.e., all the time (resp. space) intervals are equal, and we denote the time step by $\Delta t$ and the space step by $\Delta x$.</p>

<p>We can now write the discrete version of the cost functional (\ref{costfun}) by</p>

<script type="math/tex; mode=display">\begin{equation}
\label{pb_ocp_dist2}
J^D(u)=\sum_{j=0}^{N_x}|y_{j}^{N_t}-y^d(x^j)|^2 \Delta x^2+\frac{K}{\Delta t^2}\sum_{k=1}^{N_t}\left(|a^{k}-a^{k-1}|^2+|\theta^{k}-\theta^{k-1}|^2 \right)
\end{equation}</script>

<p>Then, we need to discretize the state equation (\ref{eqn_difreac}). For the stability of numerical calculations, we use implicit finite difference schemes. Recall that the basic idea of finite difference schemes is to replace derivatives by finite differences. Here, we use Crank-Nicolson Scheme, which is second-order accurate, and thus we approximate equation (\ref{eqn_difreac}) by</p>

<script type="math/tex; mode=display">\begin{equation}
\label{pb_disc_cn}
\frac{y_j^{k+1} - y_j^k}{\Delta t} = \frac{1}{2} \big( \frac{y_{j+1}^{k+1} - 2 y_{j}^{k+1} + y_{j-1}^{k+1} }{| \Delta x|^2} + \frac{y_{j+1}^{k} - 2 y_{j}^{k+1}+ y_{j-1}^{k+1} }{| \Delta x|^2} \big) + \frac{ f(y_j^{k+1},u^{k+1}) + f(y_j^k,u^k)}{2},
\end{equation}</script>

<p>for $j=1,\cdots,N_{x}-1,\quad k=1,\cdots,N_{t}-1$.</p>

<p>Let us denote the discretized optimal problem by $P_{D}$. Then the problem is to minimize the discretized cost functional (\ref{pb_ocp_dist2}), such that the dynamical constraints (\ref{pb_disc_cn}), initial conditions</p>

<p>$$
y_i^0 = y_0(x^i),\quad i= 1,\cdots, N_x,</p>

<p>$$
boundary conditions</p>

<script type="math/tex; mode=display">y_{0}^k = y_{1}^k, \quad y_{N_x}^k = y_{N_x-1}^k, \quad k=0,\cdots,N_t,</script>

<p>and control constraints</p>

<script type="math/tex; mode=display">a^k \in [a_{min},a_{max}], \quad \theta^k \in [\theta_{min},\theta_{max}],\quad k=0,\cdots,N_t.</script>

<p>are all satisfied.</p>

<p>Now we have transformed the original optimal control problem $ P_{opt} $
into a nonlinear finite-dimensional optimization problem $P_{D}$. Note that in problem $P_{D}$, the unknowns are the state and the control at each discretization point. We solve this problem by programming in AMPL language, combined with IPOPT optimization solver. Before describing the AMPL program in detail, we give a numerical example.</p>

<h3>A numerical example</h3>

<p>Let $K=0.01$, $\delta=0.001$, and the initial data to be a step function,</p>

<script type="math/tex; mode=display">% <![CDATA[
y_{0}(x)=\begin{cases}
\theta_{0}-\delta & x>0\\
0 & x<0
\end{cases} %]]></script>

<p>Let us set, moreover, $a\in[-5,0]$. The optimal solution can then be obtained within $10\,s$, and the final cost $J(u)$ is about $5\times10^{-4}$, with its first term</p>

<script type="math/tex; mode=display">J_{0}(u):=\int_{\Omega}|y(T,x)-y^{d}(x)|^{2}dx=1\times10^{-4}</script>

<p>The obtained optimal solution is illustrated in the Figure 1. In the right subfigure, $u_{1}=a$ and $u_{2}=\theta$.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/ex2_1.png" alt="figure1" width="969" height="325" class="size-full wp-image-01" /><i align="aligncenter">Figure 1: state $y(t,x)$ (left), state $y(\cdot,x)$ (middle), and control $u(t)=(u_1,u_2)$, $u_1=a$, $u_2=\theta$ (right).</i></p>

<h3>AMPL code</h3>

<p>In this section, we introduce how to solve the optimal control problem $P_{D}$ with AMPL. First, we need to define parameters that will be used, for example, the values of $L,T,N_{t},N_{x}$, etc.</p>

<pre>
<span style="color: green;"># Parameters of discretization </span>
<span style="color: green;">param Nt := 250*2; </span>
<span style="color: green;">param Nx := 50; </span>
<span style="color: green;">param L := 30; </span>
<span style="color: green;">param tf := 50; </span>
<span style="color: green;">param dx := 2*L/Nx; </span>
<span style="color: green;">param dt := tf/Nt; </span>
<span style="color: green;">param ymax := 0.6; </span>
<span style="color: green;">set kx ordered := 0..Nx; </span>
<span style="color: green;">set kt ordered := 0..Nt; </span>
<span style="color: green;">param x{j in kx}; </span>
<span style="color: green;">let {j in kx} x[j] := -L+j*dx; </span>
<span style="color: green;">param t{i in kt\}; </span>
<span style="color: green;">let {i in kt} t[i] := i*dt;</span>
<span style="color: green;"></span>
<span style="color: green;"># Parameters of control problem</span>
<span style="color: green;">param u1max := 5; # a_max </span>
<span style="color: green;">param u1min := -5; # a_min </span>
<span style="color: green;">param u2max := 1; # tet_max </span>
<span style="color: green;">param u2min := 0; # tet_min </span>
<span style="color: green;">param tet0 := 0.7;</span>
<span style="color: green;">param tetf := 0.4; </span>
<span style="color: green;">param a0 := -1; </span>
<span style="color: green;">param af := -0.2; </span>
<span style="color: green;">param Ktet := 0.01; </span>
<span style="color: green;">param Ka := 0.01; </span>
<span style="color: green;">param x1 := 0;</span>
<span style="color: green;"></span>
<span style="color: green;"># Parameters of initial data </span>
<span style="color: green;">param A0 := sqrt(-a0); </span>
<span style="color: green;">param c0 := -A0*sqrt(2)*(1/2-tet0); </span>
<span style="color: green;">param y0 {j in kx};</span>
<span style="color: green;">let {j in 0..Nx/2} y0[j] := 0; </span>
<span style="color: green;">let {j in Nx/2+1..Nx} y0[j] := tet0-0.01;</span>
<span style="color: green;"></span>
<span style="color: green;"># Parameters of desired solution</span>
<span style="color: green;">param Af := sqrt(-af); </span>
<span style="color: green;">param cf := -Af*sqrt(2)*(1/2-tetf); </span>
<span style="color: green;">param yobj{i in kx}; </span>
<span style="color: green;">param x2 := x1+cf*Nt*dt;</span>
<span style="color: green;">let {j in kx} yobj[j] := 0.35 ;</span>
<span style="color: green;"></span>
<span style="color: green;"># Parametre for initialisation \par</span>
<span style="color: green;"># (0 =&gt; rien; 1 =&gt; constant; 2 =&gt; init.txt) </span>
<span style="color: green;">param Init_Type = 1;</span>
</pre>

<p>After defining all parameters, we can now define the optimal control problem $P_{D}$., including the cost functional and all constraints on the state and on the control.</p>

<pre>
<span style="color: green;"># Declare the variables and their bounds </span>
<span style="color: green;">var a{i in kt} &gt;= u1min, &lt;= u1max; </span>
<span style="color: green;">var tet{i in kt} &gt;= u2min, &lt;= u2max; </span>
<span style="color: green;">var y{i in kt, j in kx} &gt;= 0, &lt;= 1;</span>
<span style="color: green;"></span>
<span style="color: green;"># Specify the objective function</span>
minimize obj: sum{j in kx} ( ( y[Nt,j] - yobj[j])$\textasciicircum{}2$
+ Ktet*sum{j in kt diff{0} } (tet[j]-tet[j-1])$\textasciicircum{}2$
+ Ka*sum{j in kt diff{0} } (a[j]-a[j-1])$\textasciicircum{}2;$
</pre>

<pre>
<span style="color: green;"># Contraints of the control </span>
subject to c1: tet[0] - tet0 = 0;
subject to c2: a[0] - a0 = 0;
subject to c3: tet[Nt] - tetf = 0;
subject to c4: a[Nt] - af = 0;

<span style="color: green;"># Initial data</span>
subject to i1 {j in kx}: y[0,j] = y0[j] ;

<span style="color: green;"># Dynamical constraints (Backward ) </span>
<b>subject</b> to d1 {i in kt diff{Nt}, j in kx diff {0,Nx} }:
&amp;nbsp <b></b>(y[i+1,j] - y[i,j]) - 1/2*dt*( y[i+1,j+1]-2*y[i+1,j]+
&amp;nbsp <b></b>y[i+1,j-1]+y[i,j+1]-2*y[i,j]+y[i,j-1])/$dx\textasciicircum{}2$-
&amp;nbsp <b></b>1/2*dt*( a[i+1]*y[i+1,j]*(1 - y[i+1,j]) *(tet[i+1]- y[i+1,j])+
&amp;nbsp <b></b>a[i]*y[i,j]*(1 - y[i,j]) *(tet[i]- y[i,j])) = 0;

<span style="color: green;"># Boundary constraints</span>
subject to b1 {i in kt diff{0} }: y[i,1] - y[i,0] = 0;
subject to b2 {i in kt diff{0} }: y[i,Nx] - y[i,Nx-1] = 0;
</pre>

<pre>
<span style="color: green;"># Initialization of state and control variables</span>
<b>if</b> (Init_Type == 1) then {
&amp;nbsp <b>let</b> {j in kt} tet[j] := tetf;
&amp;nbsp <b>let</b> {j in kt} a[j] := 0;
&amp;nbsp <b>for</b> {i in kt diff{0},j in kx}{
&amp;nbsp &amp;nbsp<b>let</b> y[i,j] := ymax*exp(Af*(-L+j*dx-cf*i*dt)/sqrt(2))/
&amp;nbsp &amp;nbsp &amp;nbsp<b></b>(1 + exp(Af*(-L+j*dx-cf*i*dt)/sqrt(2)));
&amp;nbsp <b>}</b>
<b>};</b>
<span style="color: green;"># Initialisation avec $\textquotedbl{}init.txt\textquotedbl{} $(only state and control)</span>
<b>if</b> (Init_Type == 2) then {
&amp;nbsp <b>read</b> {i in kt} (a[i],tet[i]) &lt; init.txt;
 <b>read</b> {i in kt, j in kx} (y[i,j]) &lt; init.txt;
<b>};</b>
</pre>

<p>Now the optimal control problem is defined, we can finally solve it. Here we use IPOPT solver, which implements a primal-dual
interior point method. Recall that an interior point method is a linear or nonlinear programming method. Of course, one can also choose other appropriate optimization solvers.</p>

<pre>
<span style="color: green;"># tell ampl to use the ipopt executable as a solver </span>
<span style="color: green;"># make sure ipopt is in the path! </span>
option solver ipopt;

<span style="color: green;"># solve the problem option </span>
ipopt_options 'max_iter=1000
tol=1e-6';
solve;
</pre>

<p>To see the optimization result, one can print results into txt files, for example:</p>

<pre><span style="color: green;"># print the solution to out.txt</span>
<b>option</b> display_precision 6;
<b>printf</b>: $\textquotedbl{}obj=\textquotedbl{} &gt;&gt;\textcompwordmark{}$ out.txt;
<b>printf</b>: $\textquotedbl{} \%24.16e; \textbackslash{}n\textquotedbl{},
obj &gt;&gt;\textcompwordmark{}$ out.txt;
</pre>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h5&gt;1. Numerical experiments&lt;/h5&gt;
</code></pre>
</div>

<p>Consider the one dimensional linear Vlasov-Fokker-Planck (VPFP) as following.</p>

<script type="math/tex; mode=display">\begin{equation}
\begin{cases}
	\delta_tf + \sigma_1v\delta_x f - \frac{\sigma_2}{\epsilon} \delta_x\phi\delta_v f =\frac{\sigma_3}{\epsilon}\delta_v\ (v f +\delta_vf\ ),  t>0, x\in[0,2\pi], v\in \mathbb{R}, \label{eq: VPFP}\\
	f(0, x,v,z) = f_0(x,v,z),  z\in [a,b].
	\end{cases}
\end{equation}</script>

<p>In the numerical experiments, <strong>we compare the results from the greedy algorithm with the results from the polynomial interpolation of the quadrature points.</strong> we set $\epsilon = 1, T = 0.5$ for all examples. More specifically, we set</p>

<script type="math/tex; mode=display">\text{error} = \sum_{i=1}^{50}\int{ {( \hat{f}(T, x, v, z_i) - f(T, x,v,z_i) )}^2} dxdv \hat{f}(T, x,v,z_i)</script>

<p>is the approximation solution obtained from either method, $f(T, x,v,z_i)$ is the exact solution. $z_i$ is uniformly chosen from $[a,b]$. ${\textbf{Dimension}}$ refers to the number of snap shots.</p>

<p>Observe Figure 1-6, we found that the Greedy algorithm converges to the solution faster than the other method. Especially, when there is discontinuity,  the polynomial interpolation doesn’t converge as dimension increases, however, the Greedy algorithm still converges and almost keeps the same convergent rate.</p>

<p><strong>Algorithm 1.1. The algorithm for the polynomial interpolation:</strong></p>

<p>For <strong>Dimension</strong> $= n$, ${\alpha_i}_{i=1}^n$ is the n roots of $n$-th order Legendre polynomial, and let</p>

<script type="math/tex; mode=display">\begin{equation}
	z_i ^\ast= \frac{b-a}{2}\alpha_i + \frac{a+b}{2},  1\leq i \leq n.\label{}
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
	f_i = f(T, x,v, z_i ^\ast) \text{ be the exact solution at time T}.\label{}
\end{equation}</script>

<p>Then by Lagrange interpolation,</p>

<script type="math/tex; mode=display">\begin{align}
	\hat{f}(T,x,v,z) = \sum_{i=1}^n l_i(z)f_i, l_i = \prod_{j\neq i} \frac{z-z_j ^\ast}{z_i ^\ast - z_j ^\ast}
\end{align}</script>

<h3>1.1 Linear VFP with parametric initial data</h3>
<p>In the first experiment, we consider the case where the parameter $z\in[1,5]$ only involved in the initial data,
<script type="math/tex">\begin{equation}
\sigma_1 = \sigma_2 = \sigma_3 = 1, \delta _x\phi = \cos(x),   
\end{equation}</script></p>

<p>Figure 1:</p>

<script type="math/tex; mode=display">\begin{equation} f_0(x,v,z) = \frac{1}{\sqrt{2\pi}} (2+\frac{\sin(x)}{z}) \text{exp} (-\frac{ |v+\cos(x) + \frac{z}{10} |^2}{2} ).\end{equation}</script>

<p>Figure 2:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation} f_0(x,v,z) =\left\{
\begin{array}{rl}
\frac{1}{\sqrt{2\pi}} (2+\frac{\sin(x)}{z}) \text{exp} (-\frac{ |v+\cos(x) + \frac{z}{10} |^2}{2} ), z<3\\
\frac{1}{\sqrt{2\pi}} (2+\frac{\sin(x)}{z}) \text{exp} (-\frac{ |v+\cos(x) + \frac{z+1}{10} |^2}{2} ), z\geq3.
\end{array}
\right.\end{equation} %]]></script>

<p><strong>Algorithm 1.2. The algorithm for PDE with only parameter in initial data:</strong>
<strong>Offline:</strong></p>

<p>Step 1: Set $N = {z_i: z_i = i\delta_z, \delta_z = \frac{b-a}{N_z}, i = 0,1, \dots, N_z}$, we set $N_z = 100$ in this case.</p>

<script type="math/tex; mode=display">\begin{equation}
z_1^\ast = \text{argmax}_{z\in N} || f_0(x,v,z) || ^2,
\end{equation}</script>

<p>where $ \vert f \vert^2 = \int f^2 dxdv$.</p>

<p>Step 2: After obtaining $z_i^\ast, f_i = f_0(x,v,z_i^\ast)$, $i =1, \dots, n-1$,</p>

<script type="math/tex; mode=display">\begin{equation}
z_n^\ast = \text{argmax}_{z\in N\backslash\{z_i^\ast \}_{i=1}^{n-1} } || f_0(x,v,z) - P^{n-1} f_0(x,v,z) ||^2,
\end{equation}</script>

<p>where $P^{n-1} f_0$ is the projection onto the subspace spanned by $f_1, \dots, f_{n-1}$</p>

<p>Step 3: Stops when</p>

<script type="math/tex; mode=display">\begin{equation}
\max_{z\in N\backslash\{z_i^\ast\}_{i=1}^{n-1} } || f_0(x,v,z) - P^{n-1} f_0(x,v,z)||^2 \leq \epsilon
\end{equation}</script>

<p><strong>Online:</strong> After we obtained the snap shots ${z_i^\ast}_{i=1}^n$,</p>

<p>Step 1: Orthogonalize ${f_i}_{i=1}^n$,
         and calculate the corresponding</p>

<script type="math/tex; mode=display">{f^T_i = f(T,x,v,z_i)}_{i=1}^n</script>

<p>Step 2: for any given $z$, one can approximate $f(T, x,v,z)$ by</p>

<script type="math/tex; mode=display">\begin{equation}
a_i = \langle f_0(x,v,z), f_i\rangle,  \hat{f}(x,v, z) = \sum_{i = 1}^na_if^T_i.
\end{equation}</script>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq1_cts.jpg" alt="figure1" class="size-full wp-image-01" /><i align="aligncenter">Figure 1: Continuous initial data</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq1_discts.jpg" alt="figure2" class="size-full wp-image-02" /><i align="aligncenter">Figure 2: Discontinuous initial data</i></p>

<h3>1.2 Linear parametric VFP with deterministic initial data</h3>
<p>In the second experiment, we consider the case where the parameter $z\in[1,5]$ only involved in the PDE,</p>

<script type="math/tex; mode=display">\begin{equation}
 f_0(x,v,z) = \frac{1}{\sqrt{2\pi}} ( 2+\sin(x) ) \text{exp} ( -\frac{|v+\cos(x)|^2}{2} )
\end{equation}</script>

<p>Figure 3:</p>

<script type="math/tex; mode=display">\begin{equation}\sigma_1 = 1+\frac{1.5}{z}, \sigma_2 = \sigma_3 = 1+5e^{\frac{1}{z}}, \delta_x\phi = \cos(x)+\frac{z}{10};\end{equation}</script>

<p>Figure 4:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\sigma_1 = 1+\frac{1.5}{z}, \sigma_2 = \sigma_3 = 1+5e^{\frac{1}{z}}, \delta_x\phi =\left\{
\begin{array}{rl}
& \cos(x)+\frac{z}{10}, z<3\\
&\cos(x)+\frac{z+1}{10}, z\geq3
\end{array}
\right.
\end{equation} %]]></script>

<p><strong>Algorithm 1.3. The algorithm for PDE with only parameters in PDE:</strong>
<strong>Offline:</strong> Set $N = {z_i: z_i = i\delta_z, \delta_z = \frac{b-a}{N_z}, i = 0,1, \dots, N_z}$, we set $N_z = 100$ in this case.</p>

<p>Step 1: choose</p>

<script type="math/tex; mode=display">z_1^\ast = argmax_{z \in N} || ( \sigma_1,\sigma_2,\sigma_3 )||^2</script>

<p>Step 2: After obtaining $z_i^\ast, f_i = f(T,x,v,z_i^\ast)$, $i =1, \dots, n-1$,</p>

<script type="math/tex; mode=display">\begin{equation}
z_n^\ast = argmax_{z\in N\backslash\{z_i^\ast\}_{i=1}^{n-1}} [ \min_{\hat{f} = \sum a_if_i,  \sum a_i = 1}
|| \delta_t\hat{f} + \underbrace{ \sigma_1(z)v\delta_x \hat{f} - \frac{\sigma_2(z)}{\epsilon} \delta_x\phi\delta_v \hat{f} - \frac{\sigma_3(z)}{\epsilon}\delta_v ( v \hat{f} + \delta_v\hat{f} ) }_{A(z)\hat{f} } ||^2 ],
\label{linear z_star}
\end{equation}</script>

<p>Step 3: Stops when the above maximum residual smaller than $\epsilon$.</p>

<p><strong>Online:</strong> After we obtained the snap shots ${z_i}_{i=1}^n$,
and the corresponding $f_i = f(T, x,v,z_i)$,</p>

<script type="math/tex; mode=display">\begin{equation}
\hat{f} = argmin_{\hat{f} = \sum a_if_i,  \sum a_i = 1} || \delta_t\hat{f} + \underbrace{\sigma_1(z)v\delta_x \hat{f} - \frac{\sigma_2(z)}{\epsilon} \delta_x\phi\delta_v \hat{f} - \frac{\sigma_3(z)}{\epsilon}\delta_v (v \hat{f} +\delta_v\hat{f} ) }_{A(z)\hat{f} } ||^2
\end{equation}</script>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq2_cts.jpg" alt="figure3" class="size-full wp-image-03" /><i align="aligncenter">Figure 3: Continuous parameter in PDE</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq2_discts.jpg" alt="figure4" class="size-full wp-image-04" /><i align="aligncenter">Figure 4: Discontinuous parameter in PDE</i></p>

<h3>1.3 Linear parametric VFP with parametric initial data</h3>
<p>In the third experiment, we consider the case where the parameter $z\in[1,5]$ involved in both the initial data and the PDE</p>

<script type="math/tex; mode=display">\begin{equation}\sigma_1 = 1+\frac{1.5}{z}, \sigma_2 = \sigma_3 = 1+5e^{\frac{1}{z}}, f_0(x,v,z) = \frac{1}{\sqrt{2\pi}}(2+\frac{\sin(x)}{z}) \text{exp}(-\frac{|v+\delta_x\phi|^2}{2})
\end{equation}</script>

<p>Figure 5:</p>

<script type="math/tex; mode=display">\begin{equation}\delta_x\phi = \cos(x) + \frac{z}{10}, \text{for }t\geq 0,\end{equation}</script>

<p>Figure 6:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\delta_x\phi =\left\{\begin{array}{rl}& \cos(x)+\frac{z}{10}, z<3\\&\cos(x)+\frac{z+1}{10}, z\geq3\end{array}\right. \text{for }t\geq 0.\end{equation} %]]></script>

<p><strong>Algorithm 1.4. The algorithm for PDE with parameters in PDE and initial data:</strong></p>

<p><strong>Offline:</strong> Set $N = {z_i: z_i = i\delta_z, \delta_z = \frac{b-a}{N_z}, i = 0,1, \dots, N_z}$, we set $N_z = 10000$ in this case.</p>

<p>Step 1: Using Algorithm 1.4 to obtain 50 snap shots out of $N$
        to form a new set $N^\ast$.
Step 2: Using Algorithm 1.3 to get snap shot ${ z_i^\ast }_{i=1}^n$</p>

<p><strong>Online:</strong> Same as Algorithm 1.3.</p>

<p><strong>Remark 1.5.</strong> In the experiments, the exact solution $f(T,x,v,z)$
refers to the numerical solution to VFP, that is, $f(T,x,v,z)$ is a
$N_x\times N_v$ dimensional vector obtained by the following scheme</p>

<script type="math/tex; mode=display">\begin{equation}
\frac{f^{n+1}_{i,j} - f^n_{i,j}}{\delta_t} +\sigma_1 (v\delta_xf)^n_{i,j} = \frac{\sigma_3}{\epsilon}P(f^{n+1}_{i,j})
\end{equation}</script>

<p>where $P(f)$ is the discretization of
$\delta_v (M\delta_v (\frac{f}{M}))$,</p>

<script type="math/tex; mode=display">M = \frac{1}{\sqrt{2\pi}}e^{-\frac{|v+\frac{\sigma_2}{\sigma_3}\delta_x\phi|^2}{2}}</script>

<p><strong>Remark 1.6.</strong> For the matlab coding, the algorithm for the examples is in the “graph.m” file of the folder “eq1”, “eq2”, “eq3” respectively.  You can change the coefficients in “sig_1”, “sig_2”, “sig_3”, and the electric field in “fcn_phi_x”, and initial data in “fcn_phi_x_0”, “fcn_rho_0”.</p>

<p>P.S. Remember to change the path of other functions at the beginning of “graph.m”.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq3_cts.jpg" alt="figure5" class="size-full wp-image-05" /><i align="aligncenter">Figure 5: Continuous parameter in PDE and initial data</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/12/eq3_discts.jpg" alt="figure6" class="size-full wp-image-06" /><i align="aligncenter">Figure 6: Discontinuous parameter in PDE and initial data</i></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3&gt;Solving the driving problem with a repulsion force&lt;/h3&gt;
</code></pre>
</div>

<p><img class=" wp-image-1163" src="https://cmc.deusto.eus/wp-content/uploads/2017/03/vector.png" alt="Guidance by repulsion model: driver and evader vectors" width="351" height="190" /> Figure1: The model describes the interaction between two agent: a driver (in red) and an evader (in blue).</p>

<p>The standard approach for solving a driving problem is a leadership strategy, based on the attraction that a driver agent exerts on other agents, [<a href="#borzi2015modeling">1</a>],[<a href="#caponigro2015sparse">2</a>],[<a href="#ginelli2015intermittent">3</a>]. Repulsion forces are mostly used for collision avoidance, defending a target or describing the need for personal space [<a href="#ginelli2015intermittent">3</a>], [<a href="#escobedo2014group">4</a>]. We present a “guidance by repulsion” model [<a href="#escobedo2016optimal">5</a>] describing the behaviour of two agents, a driver and an evader. The driver follows the guided but cannot be arbitrarily close to it, while the evader tries to move away from the driver beyond a short distance. The key ingredient of the model is that the driver can display a circumvention motion around the evader, in such a way that the trajectory of the evader is modified due to the repulsion that the driver exerts on the evader. We propose different open loop strategies for driving the evader from any given point to another assuming that both switching the control and keeping the circumvention mode active have a cost. However, numerical simulations show that the system is highly sensitive to small variations in the activation of the circumvention motion, so a general open-loop control would not be of practical interest. We then propose a feedback control law that avoids an excessive use of the circumvention mode, finding numerically that the feedback law significantly reduces the cost obtained with the open-loop control.</p>
<h3>The "Guidance by Repulsion" model</h3>

<script type="math/tex; mode=display">\begin{equation}
\dot{\vec{u}}_d(t)  = \vec{v}_d(t),
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\dot{\vec{u}}_e(t)  = \vec{v}_e(t),
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\dot{\vec{v}}_d(t)  = {1 \over m_d}
\left[
- C^E_D {\vec{u}(t) \over \|\vec{u}(t)\|^2}
\left( 1 - {\delta_c^2 \over \|\vec{u}(t)\|^2} \right) - \nu_d \vec{v}_d(t)
\right.
\nonumber
\\

\left.
- C_{\rm R} {\delta_1^4 \over \|\vec{u}(t)\|^4}
\left( \vec{u}_d(t) - \vec{u}_e(t) - \kappa(t) \delta_2 \,
{\vec{u}^\bot \over \| \vec{u}(t) \|} \right) \right],
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\dot{\vec{v}}_e(t)  = {1 \over m_e}
\left[ C^D_E { \vec{u}(t) \over \|\vec{u}(t)\|^2}
- \nu_e \vec{v}_e(t) \right],
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\vec{u}_d(t_0)  = \vec{u}_d^0,  \vec{u}_e(t_0) = \vec{u}_e^0,
\vec{v}_d(t_0) = 0  \mbox{and}  \vec{v}_e(t_0) = 0.
\end{equation}</script>

<p>where $\vec{u}_d, \vec{v}_d \in \mathbb{R}^2$ are driver’s position vector and velocity vector respectively. $\vec{u}_e, \vec{v}_e \in \mathbb{R}^2$ are evader’s position vector and velocity vector respectively (Figure 1).</p>

<p><img class="size-full wp-image-1188" src="https://cmc.deusto.eus/wp-content/uploads/2017/03/driverEvader.png" alt="Driver-Evader forces" width="583" height="229" /> Figure 2: When the distance between both agents is larger than the critical distance $\delta_c$, the force acting on the driver attracts it toward the evader. If the driver is closer than $\delta_c$ from the evader, the force acting on the driver becomes a repulsion force. Note that, independently of the distance between agents, the force exerted by the driver on the evader is repulsive.</p>

<p>The control variable is $\kappa(t) \in {-1, 0,1 }$. $\delta_1, \delta_2, \delta_c$ are distances. $C_R, C_D^E, C_E^D$ are coefficients of the atraction-repulsion force and circumvection force. $m_e, m_d$ are the masses of the evader and the driver. $\nu_e, \nu_d$ are the frictions of the evader and the driver (see Figure 2 and Figure 3).</p>

<p><img class="size-full wp-image-1189" src="https://cmc.deusto.eus/wp-content/uploads/2017/03/circunvection.png" alt="Circunvection force." width="346" height="235" /> Figure 3: The circunvection force acting on the driver is effective only when both agents are closes that $\delta_1$, while $\delta_2$ is the distance left by the driver when it makes the circunvection manoeuvre.</p>
<h3>The optimal control problem and the feedback law</h3>
<p>Let denote by $B_\rho(T)$ a ball of radius $\rho$ centered in the target $T$, $N_{\rm ig}(\kappa)$ is the number of times that $\kappa(t)$ changes from 0 to $\pm 1$ and ${\cal C}(\kappa) = \int_{t_0}^{t_f} | \kappa(t) | dt$.
We define the cost functional:</p>

<script type="math/tex; mode=display">\begin{align}
J(\kappa) \stackrel{def}{=} \sigma_1 N_{\rm ig}(\kappa) + \sigma_2 \, {\cal C}(\kappa),
\end{align}</script>

<p>and we formulate the optimal control problem:</p>

<script type="math/tex; mode=display">\begin{align}
(OCP) \; \left\{
\begin{array}{ll}
{\rm Min} \, J(\kappa) = \sigma_1 N_{\rm ig}(\kappa) + \sigma_2 \, {\cal C}(\kappa) \\
\kappa \in U_{\rm ad} =  \big\{ \kappa : [t_0,t_f] \to \{-1,0,1\} \\  \mbox{ such that }
\vec{u}_e(t_f) \in B_\rho(T) \big\}
\end{array}
\right.
\end{align}</script>

<p>For systems that are subject to conditions of high sensitivity, closed-loop or feedback controls offer the possibility of correcting the state of the system for deviations from the desired behaviour instantaneously.
The feedback control law is based on: 1- the alignment of the driver and the evader with the target point $T$ is easier to observe the orientation of the vector $\vec{v}_e(t)$ 2- when the driver is sufficiently far from the evader, $\kappa(t)$ can be set to zero.
We define the alignment of the agents and the characteristic function:</p>

<script type="math/tex; mode=display">\begin{align}
a(t) = (\vec{u}_T - \vec{u}_d) \cdot (\vec{u}_e - \vec{u}_d)^\bot% \\
%= (u_T^x - u_d^x)(u_d^y - u_e^y) + (u_T^y -u_d^y)(u_e^x-u_d^x). %
\end{align}</script>

<script type="math/tex; mode=display">\begin{eqnarray}
{\cal X}(t) = \left\{
\begin{array}{cl}
0  \mbox{ if } r^3(t) \gg \delta_2, \\
1  \mbox{ if not},
\end{array}
\right.
\end{eqnarray}</script>

<p>The feedback control law can then be written as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray}
\kappa_{\rm F}(t) = {\cal X}(t) \times \left\{
\begin{array}{cl}
0  \mbox{ if } |a(t)| \le \bar{a} \\
%\mbox{ and }(\vec{u}_e - \vec{u}_T) \cdot (\vec{u}_e - \vec{u}_d) &lt; 0,% \\ {\rm sign}\{a(t)\}  \mbox{ if } |a(t)| &gt; \bar{a}
%\; \mbox{ or }\; \, (\vec{u}_e - \vec{u}_T) \cdot (\vec{u}_e - \vec{u}_d) \ge 0 .
\end{array}
\right.
\label{fidbaclaw}
\end{eqnarray} %]]></script>

<p><img class="size-full wp-image-1193" src="https://cmc.deusto.eus/wp-content/uploads/2017/03/feed2.png" alt="Agents’ trajectories for the feedback law." width="600" height="280" /> Figure 4: Agents’ trajectories for the feedback law.</p>
<h3>Perspectives</h3>
<ul>
	<li>Formulate the problem for N evader and study the evolution of the cost depending on the number on evaders</li>
	<li>The sheepherding problem is an example of the use of repulsion forces for guiding a flock. One of the close future work is building a sheepherding model, including stochastic terms in it, using experimental data.</li>
	<li>Prove the controllability of the problem.</li>
	<li>Study the sensibility and the efficiency of the model depending on the parameters of the model, in special on the critical distances.</li>
	<li>Mean--field theorem for the guidance by repulsion model passing to the limit in the number of evaders, $N \rightarrow \infty$, as in [<a href="#carrillo2014derivation">6</a>].</li>
	<li>Study of the problem for N evaders and M drivers.</li>
	<li>Formulate the problem in $\mathbb{R}^3$.</li>
</ul>
<h3>References</h3>
<p><strong>[1]</strong> Alfio Borzì and Suttida Wongkaew. <a href="http://www.worldscientific.com/doi/abs/10.1142/S0218202515500098" name="borzi2015modeling"><em>Modeling and control through leadership of a refined flocking system.</em></a> Mathematical Models and Methods in Applied Sciences,25(02):255–282, 2015.</p>
<p><strong>[2]</strong> Marco Caponigro, Massimo Fornasier, Benedetto Piccoli, and Emmanuel Trélat. <a href="https://arxiv.org/abs/1210.5739" name="caponigro2015sparse"><em>Sparse stabilization and control of alignment models.</em></a> Mathematical Models and Methods in Applied Sciences, 25(03):521–564, 2015.</p>
<p><strong>[3]</strong> Francesco Ginelli, Fernando Peruani, Marie-Helène Pillot, Hugues Chaté, Guy Theraulaz, and Richard Bon. <a href="http://www.pnas.org/content/112/41/12729.abstract" name="ginelli2015intermittent"><em>Intermittent collective dynamics emerge from conflicting imperatives in sheep herds.</em></a> Proceedings of the National Academy of Sciences, 112(41):12729–12734, 2015.</p>
<p><strong>[4]</strong> R Escobedo, C Muro, L Spector, and RP Coppinger. <a href="http://rsif.royalsocietypublishing.org/content/11/95/20140204" name="escobedo2014group"><em>Group size, individual role differentiation and effectiveness of cooperation in a homogeneous group of hunters.</em></a> Journal of the Royal Society Interface, 11(95):20140204, 2014.</p>
<p><strong>[5]</strong> Ramón Escobedo, Aitziber Ibañez, and Enrique Zuazua. <a href="http://www.sciencedirect.com/science/article/pii/S1007570416300363" name="escobedo2016optimal"><em>Optimal strategies for driving a mobile agent in a guidance by repulsion model.</em></a> Communications in Nonlinear Science and Numerical Simulation, 39:58–72, 2016.</p>
<p><strong>[6]</strong> José Antonio Carrillo, Young-Pil Choi, and Maxime Hauray. <a href="https://arxiv.org/abs/1304.5776" name="carrillo2014derivation"><em>The derivation of swarming models: mean-field limit and wasserstein distances.</em></a> In Collective dynamics from bacteria to crowds, pages 1–46.Springer, 2014.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3&gt;1 Introduction&lt;/h3&gt;
</code></pre>
</div>

<p>We are interested in the numerical discretization of the  Kolmogorov equation [12]</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{kolmo}
\left\{
\begin{array}{lll}
\partial_t f - \mu \partial_{xx} f - v(x) \partial_y f =0, & (x,y)\in\RR^2, t>0,\\
f(x,y,0) =f_0(x,y),      & (x,y)\in\RR^2
\end{array}
\right.
\end{equation} %]]></script>

<p>where $\mu&gt;0$ is a diffusive  function and  $v$ a potential function.<br />
This is one example of degenerate advection-diffusion equations which have the property of hypo-ellipticity (see for instance, [6, 13, 14]), ensuring the $C^\infty$ regularity of solutions for $t&gt;0$ ([6]).<br />
In the present case, the generator of the semigroup is constituted by the superposition of operators  $\mu \partial_{xx}$ and $ v(x) \partial_y $. Despite the presence of a first order term, that could lead to transport phenomena and, consequently, to the lack of smoothing, the regularizing effect is ensured by the fact that the commutator of these two operators is non-trivial, allowing to gain regularity in the variable $y$. A full characterization of hypo-ellipticity can be found in [6].</p>

<p>Solutions of (1) experience also  decay properties as $t\to  \infty$. This is also a manifestation of hypo-coercivity (in the sense developed by Villani [13], [14]) as a byproduct of the hidden interaction  of the two operators entering in the generator of the semigroup.</p>

<p>In this particular case $\mu=1$ and $v(x)=x$, using the Fourier transform, the fundamental solution of (1) (starting from an initial Dirac mass $\delta_{(x_0, y_0)}$) can be computed explicitly getting the following anisotropic Gaussian kernel</p>

<script type="math/tex; mode=display">\begin{equation*}\label{kernel}
    K_{(x_0, y_0)}(x,y,t)  =
     \frac{1}{3\pi^2 t^2}
          exp \bigg[ -\frac{1}{\pi^2}\left(
                                    \frac{3| y-(y_0+tx_0) |^2}{t^3} +
                                    \frac{3(y-(y_0+tx_0)) (x-x_0)}{t^2}      +
                                    \frac{| x-x_0 |^2}{t}
                                    \right)
                \bigg]
  \end{equation*}</script>

<p>which exhibits different diffusivity and decay scales in the variables $x$ and $y$.
In view of the structure of the fundamental solution, one can deduce the following decay rates:</p>

<script type="math/tex; mode=display">\begin{equation}\label{decay}
\| f(t)\|_{L^2}+ \sqrt t\,  \| \partial_x f(t) \|_{L^2}+ t^{\frac 32} \|\partial_y f(t)\| _{L^2}\leq C ||f_0||_{L^2}
\end{equation}</script>

<p>for solutions with initial data $f_0$ in $L^2$. Similar decay properties can be predicted by scaling arguments, due to the invariance properties of the equation in (\ref{kolmo}).</p>

<p>These decay properties are of anisotropic nature and of a different rate  in the  $x$ and $y$-directions. Indeed, in the $x$-direction, as in the classical heat equation,  we observe a decay rate of the order of $t^{-1/2}$, while, in the $y$-variable, the decay is of order  $t^{-3/2}$.</p>

<p>The obtention of these decay properties by energy methods has been a challenging topic of particular interest when dealing with more general convection-diffusion models that do not allow the explicit computation of the kernel. In this effort, the asymptotic behavior of Kolmogorov equation and several other relevant kinetic models was investigated intensively through the concept and techniques of hypo-coercivity,  which allow to make explicit the hidden diffusivity and dissipativity of the involved operators  (see [13], [14] and the previous references therein).</p>

<p>The literature on the asymptotic behaviour of models related with Kolmogorov equation is huge. We refer for instance to [8], [9], [2] for earlier works, and to [4], [5] for more recent approaches. Roughly speaking, it is by now well known that, constructing well-adapted Lyapunov functionals through  variations of the natural energy of the system,  one can  make the dissipativity properties of the semigroup  emerge and  then obtain the sharp decay rates. These techniques have been developed also in other contexts such as partially dissipative hyperbolic systems (see [1]).</p>

<p>In [10] Porretta and Zuazua introduces a numerical scheme that preserves this hypo-coercivity property at the numerical level, uniformly on the mesh-size parameters. The issue is relevant from a computational point of view since, as it has been observed in a number of contexts (wave propagation, dispersivity of Schrödinger equations, conservation laws, etc. [15], [7]), the convergence property in the classical sense of numerical analysis (a property that concerns finite-time horizons) is not sufficient to ensure the asymptotic behavior of the PDE solutions to be captured correctly. The fact that the numerical approximation schemes preserve the decay properties of continuous solutions can be considered as a manifestation of the property of <i>numerical hypo-coercivity.</i></p>

<p>In [3] Foster <i>et al</i> introduces a numerical scheme which preserves the long time behavior of solutions to the Kolmogorov equation. The method presented is based on a self-similar change of variables technique to transform the Kolmogorov equation into a new form, such that the problem of designing structure preserving schemes, for the original equation, amounts to building a standard scheme for the transformed equation. We also present an analysis for the operator splitting technique for the self-similar method and numerical results for the described scheme.</p>

<p>Here, instead of, we investigate this behavior using the characteristics-Galerkin finite element method (trough Freefem++ [11])  and in particular, we confront the  results to those obtained in [3].</p>

<h4>2 Description of the numerical scheme</h4>
<p>At the numerical level, we employ a finite element method based on characteristics-Galerkin technique, and for the sake of simplicity and ease,  we use the Freefem ++ software ([11]). As described above, solution of Equation (1) does not only diffuses in the direction of x, by the effect of the diffusion operator $\partial_{xx} f$, but it is also diffuses in the direction of $y$, due to the transport equation $\partial_t f   - v(x) \partial_y f$. We will treat both effects, transport and diffusion separately,   using the characteristics method, that we recall hereafter, for the equation $\partial_t f   - v(x) \partial_y f$ and linear or quadratic  finite element to discretise  the diffusion term.</p>
<h3>2.1 Transport</h3>
<!--\label{SectionTransport}-->
<p>Let us consider the following scalar two dimensional transport equation</p>

<script type="math/tex; mode=display">\begin{equation}\label{transport}
\partial_t f +  c \cdot \nabla f = g, \quad  c \in\RR^2 \textrm{ in } \Omega \subset\RR^2 \times (0,T)
\end{equation}</script>

<p>for some function $g$. Let (x,y,t)$\in \mathbb{R}^2 \times \mathbb{R}^+$. This transport equation can be written using the total derivative</p>

<script type="math/tex; mode=display">\begin{equation}\label{td}
\frac{d}{ds} f( X_{x,y,t}(s),s) = g
\end{equation}</script>

<p>if and only if the curve $( X_{x,y,t}(s),s)$ satisfies the system of ordinary differential equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{odec}
\left\{
\begin{array}{ll}
\frac{d}{ds} X_{x,y,t}(s) =  c( X_{x,y,t}(s),s),&  \forall s\in(0,t), \\
 X_{x,y,t}(t) = (x,y) \\
\end{array}\right.
\end{equation} %]]></script>

<p>Under suitable assumptions on $ c$, the problem is well defined and there exists a unique solution to (6) $ X_{x,y,t}$, called the characteristic curve reaching (or passing from)  the point $(x,y)$ at time $t$.
Since we cannot compute explicitly, in general,  the solution of the equation (6), hence (4), we look for an approximate solution. Noting $\delta t&gt;0$ the time step and $t_{n+1} = t_n + \delta t$, an easy manner to approximate the solution of Equation (4) is to perform a backward convection by the method of characteristic</p>

<script type="math/tex; mode=display">\begin{equation}\label{approxMOC}
 \frac{1}{\delta t} \left(f^{n+1}(x,y)-f^{n}( X_{x,y,t_n}(x))\right) = g^n(x,y)
\end{equation}</script>

<p>where $f^n(x,y) = f(x,y,t_n)$ and $ X_{x,y,t_n}(x)$ is an approximation, as shown  below, of the solution at time $t_n=n \delta t$ of the ordinary differential equation (6) for $s\in(t_n,t_{n+1})$ with  the final data $ X_{x,y,t}(t_{n+1}) = (x,y)$.</p>

<p>Assuming $f$ regular enough, by Taylor expansion, one can write</p>

<script type="math/tex; mode=display">f^n( X_{x,y,t}(t_{n}))=f^n( X_{x,y,t}(t_{n+1})) - \delta t \  c( X_{x,y,t_n}(t_n),t_n) \cdot \nabla f^n(x)  + O(\delta t^2)</script>

<p>Applying also a Taylor expansion to the function $t\mapsto f^n((x,y)-t  c( X_{x,y,t_n}(t_n),t_n))$, we get</p>

<script type="math/tex; mode=display">f^n((x,y)-t  c( X_{x,y,t_n}(t_n),t_n)) = f^n( X_{x,y,t}(t_{n+1})) - \delta t \  c( X_{x,y,t_n}(t_n),t_n) \cdot \nabla f^n(x)  + O(\delta t^2)</script>

<p>and therefore one can approximate $f^n( X_{x,y,t}(t_{n}))$   by $f^n((x,y)- \delta t \  c( X_{x,y,t_n}(t_n),t_n))$. For the sake of clarity, in the sequel, we note $X(t)$ the characteristic curve passing through the point $(x,y)$ at time $t$.</p>

<h3>2.2 Numerical algorithm</h3>
<p>For numerical purpose, we consider Equation (1) in $\Omega \subset \mathbb{R}^2$ with homogeneous Neumann boundary conditions. Keeping in mind the characteristic method,  Equation (1) can be written</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{kolmo2}
\left\{
\begin{array}{lll}
\frac{d}{dt} f( X(t)) - \mbox{div}(A \nabla f) =0, & (x,y)\in\Omega, t\in (0,T), T>0\\
A \nabla f \cdot  n =0, & \textrm{ in } \partial\Omega\\
f(x,y,0) =f_0(x,y),      & (x,y)\in\Omega
\end{array}
\right.
\end{equation} %]]></script>

<p>where $ n$ stands for the outward unit normal to $\Omega$, and  for all $s\in(0,t)$,   $ X$ is the solution of</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{odekolmo}
\left\{
\begin{array}{ll}
\frac{d}{ds} X(s) =  v( X_{x,y,t}(s)),&  \forall s\in(0,t), \\
 X(t) = (x,y) \ .\\
\end{array}\right.
\end{equation} %]]></script>

<p>Here, we use the following notations</p>

<script type="math/tex; mode=display">% <![CDATA[
v = \left(\begin{array}{c}            0\\-v           \end{array}\right)$ and $A = \left(\begin{array}{cc}            \mu& 0\\0&0           \end{array}\right) %]]></script>

<p>Formally, thus, one can write, for any $\varphi \in V$ for some functional space, the weak form of Equation (8) as follows</p>

<script type="math/tex; mode=display">\begin{equation}\label{weakform1}
\int_{\Omega}  \frac{d}{dt} f(X(t)) \varphi \ dx dy + \int_{\Omega} A \nabla f \cdot \nabla \varphi \ dx dy  = 0
\end{equation}</script>

<p>Let us denote $t_0&lt;t_1&lt;\ldots &lt; t_M = T$ be the discrete time with $t_n = n \delta t$ where $\delta t$ denotes the time step. We set  $M = T/\delta t$. <br />
Using the method of characteristic for the total derivative (see section 2.1), the weak form (10) can be approximated by</p>

<script type="math/tex; mode=display">\begin{equation*}
\int_{\Omega}  \frac{1}{\delta t}\left(f^{n+1}-f^n \circ  X^n  \right)\varphi  \ dx dy + \int_{\Omega} A \nabla f^{n+1} \cdot \nabla \varphi \ dx dy  = 0
\end{equation*}</script>

<p>or</p>

<script type="math/tex; mode=display">\begin{equation}\label{weakform2}
a(f^{n+1},\varphi) = (f^n,\varphi)
\end{equation}</script>

<p>where
<script type="math/tex">a(f,\varphi) = ((I/ \delta t+A\nabla)f,\varphi) \ .</script>
Here $(\cdot,\cdot)$ is the inner product in $L^2(\Omega)$.</p>

<p>Therefore, denoting $\tau_h$ a partition of $\Omega$ by triangles and $V_h$ the $P_k$-finite element space (of degree $k$),
the weak discrete form of the problem (8) is</p>

<p>Find ${f_h^n}_{n=1}^{M=T/\delta t} \subset V_h$ such that for $n=1,\dots, M$,</p>

<script type="math/tex; mode=display">a(f_h^n,\varphi_h) = (f^n,\varphi_h), \ \forall \varphi_h \in V_h \ .</script>

<p>The Freefem++ script corresponding to the problem may as follows
&lt;/ol&gt;
Freefem++ CODE:</p>
<ol>
 	<li value="1">Freefem++ code for prog_control.m:
<pre>
<span style="color: green;"></span>
<span style="color: green;">/*</span>
<span style="color: green;">C****************************************************************************C</span>
<span style="color: green;">C                                                                            C</span>
<span style="color: green;">C     This program solve the Kolmogorov equation                             C </span>
<span style="color: green;">C     f_t-mu*f_{xx}-v(x) f_y = 0 on Omega x [0,T]                            C  </span>
<span style="color: green;">C     with free boundary conditions                                          C</span>
<span style="color: green;">C     using the Characteristic-Galerkin Finite Element Method                C </span>
<span style="color: green;">C********************************************C*******************************C</span>
<span style="color: green;">C     f(i,j)   ==&gt; unknown scalar function   C</span>
<span style="color: green;">C     phi(i,j) ==&gt; test function             C</span>
<span style="color: green;">C     v(i)     ==&gt; scalar potential function C</span>
<span style="color: green;">C********************************************C</span>
<span style="color: green;">*/      </span>
<span style="color: green;"></span>
<span style="color: green;">//Omega : square mesh [0,20]x[0,20] </span>
<span style="color: green;">real aa = 10;</span>
<span style="color: green;">real x0=-aa,x1=aa;</span>
<span style="color: green;">real y0=-aa,y1=aa;</span>
<span style="color: green;">int m = 100;</span>
<span style="color: green;">mesh Th=square(m,m,[x0+(x1-x0)*x,y0+(y1-y0)*y]);</span>
<span style="color: green;"></span>
<span style="color: green;"></span>
<span style="color: green;">real Tf  = 10,     </span>
<span style="color: green;">     dt  = 0.01,  </span>
<span style="color: green;">     mu  = 1;    // viscosity parameter (see equation above)</span>
<span style="color: green;">     </span>
<span style="color: green;"></span>
<span style="color: green;">fespace Vh(Th,P2);     // P1 linear finite element</span>
<span style="color: green;">Vh f0 = exp(-x^2-y^2), // initial data</span>
<span style="color: green;">   phi,                // test function</span>
<span style="color: green;">   v=-x,</span>
<span style="color: green;">   f;</span>
<span style="color: green;"></span>
<span style="color: green;">   </span>
<span style="color: green;">for(real t=0;t&lt;=Tf;t=t+dt)</span>
<span style="color: green;">{</span>
<span style="color: green;">  Vh c=convect([0,v(x,y)],-dt,f0);</span>
<span style="color: green;">  solve Kolmogorov(f,phi)</span>
<span style="color: green;">            = </span>
<span style="color: green;">              int2d(Th)(f*phi/dt +mu*(dx(f)*dx(phi)))</span>
<span style="color: green;">    	    - int2d(Th)(c/dt*phi)</span>
<span style="color: green;">	    ;</span>
<span style="color: green;">  f0=f;</span>
<span style="color: green;">}</span>
<span style="color: green;"></span>
</pre>
<h4>3 Numerical experiment</h4>
In this section we present a test case, [3], for which we confront to an exact solution of the Kolmogorov Equation (1) with $\mu=1$ and $v(x)=x$. In particular, we compare our results to the one obtained in [3]. For our numerical test case, we have used linear finite element.
The initial value problem (1) with the initial data $f_0(x,y) = \exp(-x^2-y^2)$ admits the following exact solution
$$f_{ex}(x,y,t) = \frac{\exp\left(-\frac{(( 3+3t^2 +4t^3)x^2 +6t(1+2t)xy+3(1+4t)y^2)}{(3+12t+4t^3 +4t^4)}\right)}{\sqrt{1 + 4 t + 4/3 t^2 + 4/3 t^4}} \ . $$
As done in [3], for each numerical tests, we have considered the time interval, and problem domain to be respectively $[0, T=10]$ and $\Omega = [−10, 10] \times [−10,10]$, The time step is kept constant equal to $\delta t = 0.01$ and the number of triangles along each side of the domain is given by $m=50$, $100$ and $150$.
As one can see in the video above, the support for the function grows beyond the problem domain in the given time interval and interact with boundary conditions. This interaction, since we do not use here transparent boundary conditions, increases the error as one can also observe in Figure 1. We also show the time evolution of $\|f(\cdot,t)-f_{ex}(\cdot,t)\|_2$, $\|\partial_xf(\cdot,t)\|_2$, $\|\partial_y f(\cdot,t)\|_2$ and
$$D(t)=\left(\| f(t)\|_{L^2}+ \sqrt t\,  \| \partial_x f(t) \|_{L^2}+ t^{\frac 32} \|\partial_y f(t)\| _{L^2}\right)/||f_0||_{L^2} \ ,$$  in Figure 2. The $L_2$ error at time time $T=10$ is approximately $0.0072$ as one can see in Figure 2(a). Moreover, the error $\int_0^T \| f(\cdot,t)-f_{ex}(\cdot,t)\|_2 dt $ is approximately of order $0.02$. We also observe, due to the interaction with the boundary conditions that the errors increase sensibly for each numerical experiments approximately at time $t\approx 8.5$. Therefore, in order to  compute the numerical order  of convergence, we have computed for each $m$, $m\mapsto \max_t\left( \|f(\cdot,t)-f_{ex}(\cdot,t)\|_2\right)$. We find almost the order $1$ which is satisfactory.  Finally, we have computed the quantity
$$D(t) =\left(\| f(t)\|_{L^2}+ \sqrt t\,  \| \partial_x f(t) \|_{L^2}+ t^{\frac 32} \|\partial_y f(t)\| _{L^2}\right)/||f_0||_{L^2}\ , $$
for which we numerically show that the constant for the decay rates is $C=1$ as shown in Figure 2(d)

<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/11/Kolmogorov1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/11/Kolmogorov1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
<i>Movie 1: Numerical simulation of the test case .</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/freefemsol100.eps_.jpg" alt="Freefem solution with m=100" width="562" height="446" class="size-full wp-image-01" /> <i align="aligncenter">Figure 1.a: Numerical and exact solution at time $T=10$, Freefem solution with $m=100$</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/exactsol100.eps_.jpg" alt="Exact solution" width="562" height="446" class="size-full wp-image-02" /> <i align="aligncenter">Figure 1.b: Numerical and exact solution at time $T=10$, Exact solution</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/L2error.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-1" /> <i align="aligncenter">Figure 2.a: $L_2$ errors, $t\mapsto\|f(\cdot,t)-f_{ex}(\cdot,t)\|_2$</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/L2normdx.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-2" /> <i align="aligncenter">Figure 2.b: $L_2$ errors, $t\mapsto \|\partial_xf(\cdot,t)\|_2$</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/L2normdy.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-3" /> <i align="aligncenter">Figure 2.c: $L_2$ errors, $t\mapsto \|\partial_yf(\cdot,t)\|_2$</i>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/L2ez.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-4" /> <i align="aligncenter">Figure 2.d: $L_2$ errors,$t\mapsto D(t)$</i>



To end, we present a last numerical simulation of rotating and moving initial data.
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/11/Kolmogorov2.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/11/Kolmogorov2.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
<i>Movie 2: Numerical simulation on $\Omega = [0,10]\times[0,20]$, $[0,T=0.6]$ with $\mu=10^{-3}$, $v(x)=-x$  and $f_0(x,y) = 20 \exp(-(y-15)^2) \exp(-0.1(x-10)^2)$.</i>

<h4>Bibliography</h4>

<p><strong>[1]</strong> K. Beauchard and E. Zuazua, <a href=""><em><i>Sharp large time asymptotics for partially dissipative hyperbolic systems</i></em></a>, Arch. Ration. Mech. Anal. 199 (2011) 177-7227.</p>
<p><strong>[2]</strong> A. Carpio, <a href=""><em><i>Long-time behavior for solutions of the Vlasov-Poisson-Fokker-Planck equation</i></em></a>, Mathematical methods in the applied sciences 21 (1998), 985-1014.</p>
<p><strong>[3]</strong> E. L. Foster, J. Lohéac and  M.-B. Tran, <a href=""><em><i> A Structure Preserving Scheme for the Kolmogorov Equation</i></em></a>, preprint   2014 (arXiv:1411.1019v3).</p>
<p><strong>[4]</strong> F. Hérau, <a href=""><em><i>Short and long time behavior of the Fokker-Planck equation in a confining potential and applications</i></em></a>, J.  Funct.  Anal. 244 (2007), 95-118.</p>
<p><strong>[5]</strong> F. Hérau  and F. Nier, <a href=""><em><i>Isotropic hypoellipticity and trend to equilibrium for the Fokker-Planck equation with a high-degree potential</i></em></a>,  Arch. Ration. Mech. Anal. 171 (2004), 151-218.</p>
<p><strong>[6]</strong> L. Höormander, <a href=""><em><i>Hypoelliptic second order differential equations</i></em></a>,  Acta Math. 119 (1967), 147-171.</p>
<p><strong>[7]</strong> L. Ignat, A. Pozo and E. Zuazua, <a href=""><em><i>Large-time asymptotics, vanishing viscosity and numerics for 1-D scalar conservation laws</i></em></a>, Math of Computation, to appear.</p>
<p><strong>[8]</strong> A. M. Il'in, <a href=""><em><i>On a class of ultraparabolic equations</i></em></a>, Soviet Math. Dokl. 5  (1964), 1673-1676.</p>
<p><strong>[9]</strong> A. M. Il'in and R. Z. Kasminsky, <a href=""><em><i> On the equations of Brownian motion</i></em></a>, Theory Probab. Appl. 9 (1964), 421-444.</p>
<p><strong>[10]</strong> A. Porretta and E. Zuazua, <a href=""><em><i>Numerical hypocoercivity for the Kolmogorov equation</i></em></a>, Mathematics of Computation 86.303 (2017): 97-119.</p>
<p><strong>[11]</strong> Frédéric Hecht, Olivier Pironneau, A~Le~Hyaric and K~Ohtsuka, <a href=""><em><i>Freefem++ manual</i></em></a>, 2005.</p>
<p><strong>[12]</strong> A. Kolmogoroff, <a href=""><em><i>Zufallige bewegungen (zur theorie der brownschen bewegung)</i></em></a><i> Annals of Mathematics</i>, pages 116--117, 1934.</p>
<p><strong>[13]</strong> C. Villani, <a href=""><em><i>Hypocoercivity</i></em></a>, Mem. Amer. Math. Soc. 202  (2009).</p>
<p><strong>[14]</strong> C. Villani, <a href=""><em><i>Hypocoercive diffusion operators</i></em></a>, In International Congress of Mathematicians, Vol. III, 473-498.  Eur. Math. Soc. Zürich, 2006.</p>
<p><strong>[15]</strong> E. Zuazua, <a href=""><em><i>Propagation, observation, and control of waves approximated by finite difference methods</i></em></a>, SIAM Review, 47 (2) (2005), 197-243.</p>
</li></ol>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;&lt;!--h5&gt;Introduction&lt;/h5--&gt;
</code></pre>
</div>
<h4>1. Adjoint estimation: low or high order?</h4>
<p>Adjoint methods have been systematically associated to the optimal control design [5] and their applications to aerodynamics [1, 4]. During the last decades, several works were oriented to develop a robust control theory based on the concepts of observability, optimality and controllability for linear and non-linear equations and systems of equations [2, 10, 11, 12].</p>
<p>Since the discrete approach forces to use the discrete adjoint problem of the flow solver to numerically solve the adjoint equation, the continuous approach is adopted due to its valuable flexibility of using different solvers for the flow and adjoint equations. It is well known that problems where high frequencies play an important role such as the control of wave equation [11]</p>
<p>The focus is put on the 2D linear scalar transport equation, that can be expressed in a conservative form as follows:<br />
<a name="id2808901204"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (1) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e9a3e84e11b880fa56f25a9a5fca2a9c_l3.png" height="42" width="357" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#116;&#41;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#40;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#32;&#117;&#41;&#32;&#61;&#32;&#48;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;&#61;&#117;&#95;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-50c719d4de6535419310ba5de09c69d7_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#61;&#118;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="88" style="vertical-align: -5px;" /> is a time-independent velocity field of propagation.</p>
<p>Given a target function <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e53901f63bf7a3536ed715227f91b733_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#42;&#61;&#117;&#94;&#42;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="104" style="vertical-align: -5px;" />, the aim in the 2D inverse design problem consists in finding <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-bd421b5f9cc4b54f52392081f3df2e0a_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#95;&#48;" title="Rendered by QuickLaTeX.com" height="12" width="16" style="vertical-align: -3px;" /> such that <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-2c6549776d1bcc59f9dfb850cc125f02_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#84;&#41;&#32;&#92;&#115;&#105;&#109;&#32;&#117;&#94;&#42;" title="Rendered by QuickLaTeX.com" height="20" width="80" style="vertical-align: -5px;" /> via the minimization of a functional <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ddf177ca226c96c8850a9a3f591986ef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#74;" title="Rendered by QuickLaTeX.com" height="14" width="10" style="vertical-align: 0px;" />:</p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (2) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-b1d8ce1bed01da9014c779df45dd842a_l3.png" height="40" width="171" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#74;&#40;&#117;&#41;&#61;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#49;&#125;&#123;&#50;&#125;&#32;&#124;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#124;&#94;&#50; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>This problem can be easily addressed by simply solving the transport equation backwards in time because of the time reversibility of the model. But such a simple approach fails as soon as the model involves nonlinearities (leading to shock discontinuities) or diffusive terms, making the system time-irreversible.</p>
<p>We are thus interested in the development of gradient descent methods with the aid of the adjoint equation (solved backwards in time) that can be easily deduced<br />
<a name="id3132551628"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (3) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-36c03fbd94e90faf1d1ed1488ffdaf49_l3.png" height="42" width="397" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#45;&#32;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#120;&#44;&#121;&#44;&#116;&#41;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#45;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#61;&#32;&#48;&#44;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#84;&#41;&#61;&#32;&#117;&#40;&#84;&#41;&#45;&#32;&#117;&#94;&#42; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-4ef8cf94d8f10416a5234a5f6b3f695e_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#61;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#120;&#44;&#121;&#44;&#116;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="107" style="vertical-align: -5px;" /> is the adjoint variable.</p>
<p>In order to achieve a good match with the continuous solutions, high order numerical schemes need to be used for the forward state equation (<a href="#id2808901204">1</a>). Here we shall use a second order scheme. Our main objective is to test the convenience of using the same order of accuracy when solving the adjoint equation or, by the contrary, to employ a low order one. When implementing the gradient descent iterations, the numerical scheme employed for solving the adjoint equation determines the direction of descent. Hence, different solvers for the adjoint system provide different results that can be compared in terms of accuracy and efficiency.</p>
<p>A gradient-adjoint iterative method is based on iterating a loop where the equation of state (flow equation) is solved in a forward sense while the adjoint equation, which is of hyperbolic nature as well, is solved backwards in time (see Figure 1).<br />
<figure id="attachment_349" style="width: 562px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/loop.eps_.jpg" alt="Iteration of the 2D inverse design." width="562" height="446" class="size-full wp-image-349" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 1. Iteration of the 2D inverse design</i></figcaption></figure></p>
<p>The adequate resolution of this loop is the main question addressed in this work, paying attention not only to accuracy but also to reducing its computational complexity. One could expect that the choice of high order numerical methods to solve both the equation of state and the adjoint one should provide the best results in terms of accuracy, at the prize of a high computational cost. But this is not always true and it is possible to relax the necessity of using the same order of accuracy for the resolution of the adjoint equation, not only reducing considerably the computational time needed by the complete loop but also achieving the same order of accuracy on the approximation of the inverse design, which is our ultimate goal.</p>
<h4>2. 2D linear equation and continuous adjoint derivation</h4>
<p>We focus on the following conservative linear transport scalar equation with an heterogeneous time-independent vector field <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-89ef819400fd901a038118409f8d68d1_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#61;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#40;&#120;&#44;&#121;&#41;&#58;" title="Rendered by QuickLaTeX.com" height="20" width="97" style="vertical-align: -5px;" /><br />
<a name="id3868366351"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 41px;"><span class="ql-right-eqno"> (4) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f7f68ed6539e16a8d751a203049530ab_l3.png" height="41" width="148" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#40;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#32;&#117;&#41;&#32;&#61;&#32;&#48;&#32;&#46; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Obviously, the solution <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-7096bbe46940b5edd35b070bbfad6116_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#61;&#117;&#40;&#120;&#44;&#32;&#121;&#44;&#32;&#116;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="104" style="vertical-align: -5px;" /> exists and it is unique and can be determined by means of the method of characteristics provided <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-970ae81c692225b067b830b9d1218145_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;" title="Rendered by QuickLaTeX.com" height="9" width="9" style="vertical-align: 0px;" /> is smooth enough (say, <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a48f6182579bff650197c4d2372e626d_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#67;&#94;&#49;" title="Rendered by QuickLaTeX.com" height="16" width="19" style="vertical-align: 0px;" />). Thus, for all initial data <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-68beca4bcad52262077bea01e058fe48_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#95;&#48;&#32;&#92;&#105;&#110;&#32;&#76;&#94;&#50;&#40;&#92;&#109;&#97;&#116;&#104;&#98;&#98;&#123;&#82;&#125;&#94;&#50;&#41;" title="Rendered by QuickLaTeX.com" height="21" width="94" style="vertical-align: -5px;" /> there exists an unique solution in the class <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-de30d63fe67346256424d4f29592b08c_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#67;&#40;&#091;&#48;&#44;&#32;&#84;&#093;&#59;&#32;&#76;&#94;&#50;&#40;&#92;&#109;&#97;&#116;&#104;&#98;&#98;&#123;&#82;&#125;&#94;&#50;&#41;&#41;" title="Rendered by QuickLaTeX.com" height="22" width="131" style="vertical-align: -6px;" />.</p>
<p>Let us consider the inverse design problem: Given a target function <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f9563da9419611e9de3c4b493dc857ad_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#42;&#32;&#61;&#32;&#117;&#94;&#42;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="104" style="vertical-align: -5px;" /> at <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f86a2227fd048f89ba8ff7295f735387_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#84;" title="Rendered by QuickLaTeX.com" height="15" width="45" style="vertical-align: -1px;" />, to determine the initial condition <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-bd421b5f9cc4b54f52392081f3df2e0a_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#95;&#48;" title="Rendered by QuickLaTeX.com" height="12" width="16" style="vertical-align: -3px;" /> such that <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-62163ada462a925a2d935909d0289c0b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#32;&#121;&#44;&#32;&#84;&#41;&#32;&#92;&#101;&#113;&#117;&#105;&#118;&#32;&#117;&#94;&#42;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="162" style="vertical-align: -5px;" />.</p>
<p>The problem could be easily addressed solving the equation (<a href="#id3868366351">4</a>) backwards in time from the final datum <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e683cf490d4bbfa843678bd48a89442b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#42;" title="Rendered by QuickLaTeX.com" height="14" width="16" style="vertical-align: 0px;" /> at <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f86a2227fd048f89ba8ff7295f735387_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#84;" title="Rendered by QuickLaTeX.com" height="15" width="45" style="vertical-align: -1px;" />, to determine <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-19483e298575adce51f93a9ea510f4c0_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#95;&#48;&#61;&#117;&#40;&#120;&#44;&#32;&#121;&#44;&#32;&#48;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="112" style="vertical-align: -5px;" /> exactly. But we are interested in addressing it from the point of view of optimal control. Let us therefore define the following functional, as a classical measure of the quadratic error with respect to the target function <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e683cf490d4bbfa843678bd48a89442b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#42;" title="Rendered by QuickLaTeX.com" height="14" width="16" style="vertical-align: 0px;" />:<br />
<a name="id2452523698"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (5) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-140a9df2851e710c02965eb0e3d7045e_l3.png" height="42" width="231" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#74;&#40;&#117;&#41;&#61;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#49;&#125;&#123;&#50;&#125;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#108;&#101;&#102;&#116;&#40;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#32;&#92;&#114;&#105;&#103;&#104;&#116;&#41;&#94;&#50;&#32;&#100;&#83; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>The derivation of the adjoint equation can be achieved by simply multiplying by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-4ef8cf94d8f10416a5234a5f6b3f695e_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#61;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#120;&#44;&#121;&#44;&#116;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="107" style="vertical-align: -5px;" /> and integrating over a control volume <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-2d4c316831b8619f3e16c795ef05083a_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;&#32;&#92;&#116;&#105;&#109;&#101;&#115;&#32;&#091;&#48;&#44;&#84;&#093;" title="Rendered by QuickLaTeX.com" height="20" width="77" style="vertical-align: -6px;" /></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (6) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-dc7867038de1fe60ac54b60e06004ea7_l3.png" height="42" width="288" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#108;&#101;&#102;&#116;&#40;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#40;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#117;&#41;&#32;&#92;&#114;&#105;&#103;&#104;&#116;&#41;&#32;&#100;&#83;&#32;&#100;&#116;&#61;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Integrating by parts</p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (7) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5a75e7a548b300f9146ac534a6b95e64_l3.png" height="42" width="613" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#117;&#32;&#92;&#118;&#101;&#114;&#116;&#95;&#48;&#94;&#84;&#32;&#100;&#83;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#117;&#32;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#100;&#83;&#32;&#100;&#116;&#32;&#43; &#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#111;&#105;&#110;&#116;&#95;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#117;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#110;&#125;&#32;&#100;&#108;&#32;&#100;&#116;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#117;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#100;&#83;&#32;&#100;&#116;&#61;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-2b649edb8c76189fb68ece8b821c6ab8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;" title="Rendered by QuickLaTeX.com" height="14" width="24" style="vertical-align: 0px;" /> is the boundary and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-400cb5ccfdc03d5cef3e429d63ef6583_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#110;&#125;" title="Rendered by QuickLaTeX.com" height="9" width="9" style="vertical-align: 0px;" /> is the outward normal direction to the surface <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-935eef2f3e0a194501d32e2cd067ff88_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;" title="Rendered by QuickLaTeX.com" height="13" width="13" style="vertical-align: 0px;" /> respectively.</p>
<p>It is feasible to take Gateaux derivatives with respect to the variable <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ca96e0dc0bb325e9ad1b1243f2050152_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;" title="Rendered by QuickLaTeX.com" height="9" width="9" style="vertical-align: 0px;" /> in this identity getting:<br />
<a name="id1756110249"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (8) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-6888056be85cb5ec7b6093e138c2755e_l3.png" height="42" width="624" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#118;&#101;&#114;&#116;&#95;&#48;&#94;&#84;&#32;&#100;&#83;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#100;&#83;&#32;&#100;&#116;&#32;&#43; &#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#111;&#105;&#110;&#116;&#95;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#110;&#125;&#32;&#100;&#108;&#32;&#100;&#116;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#100;&#83;&#32;&#100;&#116;&#61;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Gathering appropriately the terms:<br />
<a name="id234599505"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 71px;"><span class="ql-right-eqno"> (9) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-209277fde91a6777ed62d2d0e243b892_l3.png" height="71" width="591" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#111;&#118;&#101;&#114;&#98;&#114;&#97;&#99;&#101;&#123;&#92;&#108;&#101;&#102;&#116;&#40;&#32;&#45;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#45;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#114;&#105;&#103;&#104;&#116;&#41;&#125;&#94;&#123;&#40;&#92;&#115;&#104;&#97;&#114;&#112;&#41;&#125;&#32;&#100;&#83;&#32;&#100;&#116;&#32;&#43;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#118;&#101;&#114;&#116;&#95;&#48;&#94;&#84;&#32;&#100;&#83;&#32;&#43;&#32;&#92;&#111;&#118;&#101;&#114;&#98;&#114;&#97;&#99;&#101;&#123; &#92;&#105;&#110;&#116;&#95;&#48;&#94;&#84;&#32;&#92;&#111;&#105;&#110;&#116;&#95;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#110;&#125;&#32;&#100;&#108;&#32;&#100;&#116;&#125;&#94;&#123;&#40;&#92;&#115;&#104;&#97;&#114;&#112;&#32;&#92;&#115;&#104;&#97;&#114;&#112;&#41;&#125;&#32;&#61;&#32;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Let us select <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-939150555b7a7fa3091e0b4fde55095d_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#40;&#92;&#115;&#104;&#97;&#114;&#112;&#41;&#32;&#61;&#32;&#48;" title="Rendered by QuickLaTeX.com" height="20" width="55" style="vertical-align: -5px;" /><br />
<a name="id489333017"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 41px;"><span class="ql-right-eqno"> (10) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-2856d200a992b733bb018a0d0f960b6e_l3.png" height="41" width="147" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#45;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#45;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#61;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>and appropriate boundary conditions for <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ec7e7a9db1763eb6501b50e3bce904d8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#40;&#92;&#115;&#104;&#97;&#114;&#112;&#32;&#92;&#115;&#104;&#97;&#114;&#112;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="26" style="vertical-align: -5px;" /> = 0. Hence (9) becomes</p>
<p><a name="id976999153"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (11) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-9057b2491d4be9d4cc99b436123ccb5f_l3.png" height="40" width="284" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#108;&#101;&#102;&#116;&#091;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#40;&#84;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#40;&#84;&#41;&#32;&#45;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#48;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#40;&#48;&#41;&#92;&#114;&#105;&#103;&#104;&#116;&#093;&#32;&#100;&#83;&#32;&#61;&#32;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Assuming <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-85f3220a7fc839ca0b7fda84d63fa617_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#84;&#41;&#32;&#61;&#32;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;" title="Rendered by QuickLaTeX.com" height="20" width="143" style="vertical-align: -5px;" /><br />
<a name="id1644388199"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (12) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-da0e0609e02333827e3754a87ca9e729_l3.png" height="40" width="338" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#40;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#40;&#84;&#41;&#32;&#100;&#83;&#32;&#61;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#48;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#40;&#48;&#41;&#32;&#100;&#83; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>On the other hand, it is also feasible to take the first variation of <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ddf177ca226c96c8850a9a3f591986ef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#74;" title="Rendered by QuickLaTeX.com" height="14" width="10" style="vertical-align: 0px;" /> with respect to <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ca96e0dc0bb325e9ad1b1243f2050152_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;" title="Rendered by QuickLaTeX.com" height="9" width="9" style="vertical-align: 0px;" /> in (<a href="#id2452523698">5</a>)<br />
<a name="id3310359949"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (13) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-87b4e695e63bce19cd51f23b0cc53146_l3.png" height="40" width="265" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#100;&#101;&#108;&#116;&#97;&#32;&#74;&#40;&#117;&#41;&#61;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#40;&#84;&#41;&#32;&#92;&#108;&#101;&#102;&#116;&#40;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#32;&#92;&#114;&#105;&#103;&#104;&#116;&#41;&#32;&#100;&#83; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Finally,<br />
<a name="id3472992234"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (14) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f484e2bfae818579ba2d92c36ef70605_l3.png" height="40" width="408" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#100;&#101;&#108;&#116;&#97;&#32;&#74;&#40;&#117;&#41;&#32;&#61;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#40;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#32;&#40;&#84;&#41;&#32;&#100;&#83;&#32;&#61;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#125;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#48;&#41;&#32;&#92;&#100;&#101;&#108;&#116;&#97;&#32;&#117;&#40;&#48;&#41;&#32;&#100;&#83; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>This derivation led to the adjoint equation <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-c22318e8b063b8569692358f59cf89dd_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#40;&#92;&#115;&#104;&#97;&#114;&#112;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="19" style="vertical-align: -5px;" />:<br />
<a name="id2160690333"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 41px;"><span class="ql-right-eqno"> (15) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-30b668b0f67ea240c8757054ec172940_l3.png" height="41" width="333" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#45;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#45;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#61;&#48;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#84;&#41;&#32;&#61;&#32;&#117;&#40;&#84;&#41;&#45;&#117;&#94;&#42;&#44; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5d352209bb975d7a80f24c8fb25c2c2b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#61;&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#120;&#44;&#121;&#44;&#116;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="107" style="vertical-align: -5px;" /> being the adjoint variable.</p>
<p>This equation measures the sensitivity of the solution to changes in the initial condition. It is worth mentioning that the adjoint equation is solved backwards in time (from <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f86a2227fd048f89ba8ff7295f735387_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#84;" title="Rendered by QuickLaTeX.com" height="15" width="45" style="vertical-align: -1px;" /> to <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-1af17191fcef4df29d5eef02e6c2bf91_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#48;" title="Rendered by QuickLaTeX.com" height="15" width="41" style="vertical-align: -1px;" />). In fact, system (<a href="#id2160690333">15</a>) is well-posed if and only if the original system is well posed in the forward sense.</p>
<h4>3. Numerical schemes</h4>
<p>In order to obtain a numerical solution based on a finite volume approach, (<a href="#id3868366351">4</a>) is integrated in a control volume <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e713a5583244ff2e528fd3d4199b2ae3_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#32;&#92;&#116;&#105;&#109;&#101;&#115;&#32;&#091;&#116;&#94;&#110;&#44;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#093;" title="Rendered by QuickLaTeX.com" height="22" width="112" style="vertical-align: -6px;" /> where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-7d72e89d608d7ba733d1376f4e5e7129_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;" title="Rendered by QuickLaTeX.com" height="16" width="19" style="vertical-align: -3px;" /> represents each computational cell of the domain and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-1ed54c00626c62ad43745a7c5d9a6822_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#61;&#116;&#94;&#110;&#43;&#92;&#68;&#101;&#108;&#116;&#97;&#32;&#116;" title="Rendered by QuickLaTeX.com" height="18" width="123" style="vertical-align: -2px;" /></p>
<p class="ql-center-displayed-equation" style="line-height: 49px;"><span class="ql-right-eqno"> (16) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-6a5e93b5bbf327d2fd09e119ea7b0a0c_l3.png" height="49" width="295" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#116;&#94;&#110;&#125;&#94;&#123;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#125;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#92;&#108;&#101;&#102;&#116;&#40;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#40;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#117;&#41;&#32;&#92;&#114;&#105;&#103;&#104;&#116;&#41;&#32;&#100;&#83;&#32;&#100;&#116;&#61;&#32;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Using the Gauss divergence theorem<br />
<a name="id2364164987"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 48px;"><span class="ql-right-eqno"> (17) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-3e07d2c135741efa1ab7838f5da807fc_l3.png" height="48" width="522" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#41;&#100;&#83;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#116;&#94;&#123;&#110;&#125;&#41;&#100;&#83;&#32;&#43;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#116;&#94;&#110;&#125;&#94;&#123;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#125;&#32;&#92;&#111;&#105;&#110;&#116;&#95;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#102;&#125;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#110;&#125;&#32;&#92;&#59;&#32;&#100;&#109;&#32;&#92;&#59;&#32;&#100;&#116;&#61;&#32;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ce7806862f77c8c8a2b0b8c364077310_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#102;&#125;&#32;&#61;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#118;&#125;&#32;&#117;" title="Rendered by QuickLaTeX.com" height="14" width="51" style="vertical-align: 0px;" /> is the flux, <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-6be11a5a16c770aacf04114b79d80e3b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;" title="Rendered by QuickLaTeX.com" height="17" width="30" style="vertical-align: -3px;" /> denotes the surface surrounding the volume <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-7d72e89d608d7ba733d1376f4e5e7129_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;" title="Rendered by QuickLaTeX.com" height="16" width="19" style="vertical-align: -3px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f717fca1a35be34459a1847549a13dde_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#110;&#125;&#61;&#40;&#110;&#95;&#120;&#44;&#110;&#95;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="21" width="94" style="vertical-align: -6px;" /> its unit normal vector. The last contour integral in (<a href="#id2364164987">17</a>) can be replaced by the sum of the fluxes defined at each edge <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-da785b053ff378eed556e47adadc339c_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#107;" title="Rendered by QuickLaTeX.com" height="14" width="10" style="vertical-align: 0px;" /> of length <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-6f44504a25a3fc1bad03d7f1b659449d_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#108;&#95;&#107;" title="Rendered by QuickLaTeX.com" height="17" width="11" style="vertical-align: -3px;" />:<br />
<a name="id2854128122"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 53px;"><span class="ql-right-eqno"> (18) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-c346383c1a72e1187874488309deeac2_l3.png" height="53" width="510" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#41;&#100;&#83;&#32;&#45;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#92;&#79;&#109;&#101;&#103;&#97;&#95;&#105;&#125;&#32;&#117;&#40;&#120;&#44;&#121;&#44;&#116;&#94;&#123;&#110;&#125;&#41;&#100;&#83;&#32;&#43;&#32;&#92;&#105;&#110;&#116;&#95;&#123;&#116;&#94;&#110;&#125;&#94;&#123;&#116;&#94;&#123;&#110;&#43;&#49;&#125;&#125;&#32;&#92;&#115;&#117;&#109;&#92;&#108;&#105;&#109;&#105;&#116;&#115;&#95;&#123;&#107;&#61;&#49;&#125;&#94;&#123;&#78;&#95;&#69;&#125;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#102;&#125;&#95;&#107;&#32;&#92;&#116;&#101;&#120;&#116;&#98;&#102;&#123;&#110;&#125;&#95;&#107;&#32;&#108;&#95;&#107;&#32;&#100;&#116;&#61;&#32;&#48; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>with <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-103682a409e6b318185c972df4317475_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#78;&#95;&#69;" title="Rendered by QuickLaTeX.com" height="17" width="23" style="vertical-align: -3px;" /> is the number of edges of each cell <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-76f659eac61b53ea391c745b0c71fca3_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#105;" title="Rendered by QuickLaTeX.com" height="14" width="5" style="vertical-align: 0px;" /> (<img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f2e57efadd760689fb27eeb2ec638e37_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#78;&#95;&#69;&#61;&#51;" title="Rendered by QuickLaTeX.com" height="17" width="58" style="vertical-align: -3px;" /> is for triangular grids) with neighbouring cells <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-921604e76e15f16aca895006fdc22edb_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#106;&#95;&#107;" title="Rendered by QuickLaTeX.com" height="18" width="15" style="vertical-align: -4px;" />. Figure 2 clarifies the meaning of each variable.<br />
<figure id="attachment_348" style="width: 562px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/sketch.jpg" alt="Sketch of the 2D finite volume approach." width="562" height="446" class="size-full wp-image-348" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 2. Sketch of the 2D finite volume approach</i></figcaption></figure></p>
<p>In this work two numerical schemes are proposed: a first order upwind (FOU) scheme and a second order upwind (SOU) scheme based on MUSCL-Hancock approach. The details of the implementation can be found in [7] and [6, 9] respectively. The use of a SOU scheme for the flow equation (forward) is mandatory in order to achieve the best accuracy since the FOU scheme is unable to capture the detail for the equation of state when trying to reach the target function. The issue of using one or another approach for solving the adjoint equation and, consequently, the gradient direction approach, is worth analysing.</p>
<h4>4. Test case: Doswell frontogenesis</h4>
<p>This test case was firstly proposed (in a forward sense) in [3]. It symbolizes the presence of horizontal temperature gradients and fronts in the context of meteorological dynamics. The original problem consists of a computational domain <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-46ef7f79829f85449491de1fcd817e4b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#79;&#109;&#101;&#103;&#97;&#61;&#091;&#45;&#53;&#44;&#53;&#093;" title="Rendered by QuickLaTeX.com" height="20" width="89" style="vertical-align: -6px;" /> with open boundary conditions in which a front defined by the following initial condition:<br />
<a name="id1808989430"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 42px;"><span class="ql-right-eqno"> (19) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-eb67818383ec5c06a1c0a92d06638a60_l3.png" height="42" width="172" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;&#61;&#92;&#116;&#97;&#110;&#104;&#92;&#108;&#101;&#102;&#116;&#40;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#121;&#125;&#123;&#92;&#100;&#101;&#108;&#116;&#97;&#125;&#92;&#114;&#105;&#103;&#104;&#116;&#41; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>is advected under the velocity field given by</p>
<p class="ql-center-displayed-equation" style="line-height: 40px;"><span class="ql-right-eqno"> (20) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-941bea2d8c5c4a7e149700faf530a629_l3.png" height="40" width="562" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#61;&#40;&#45;&#121;&#32;&#92;&#32;&#103;&#40;&#114;&#41;&#44;&#120;&#32;&#92;&#32;&#103;&#40;&#114;&#41;&#41;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#103;&#40;&#114;&#41;&#61;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#49;&#125;&#123;&#114;&#125;&#32;&#92;&#111;&#118;&#101;&#114;&#108;&#105;&#110;&#101;&#123;&#118;&#125;&#32;&#92;&#32;&#92;&#116;&#101;&#120;&#116;&#123;&#115;&#101;&#99;&#104;&#125;&#94;&#50;&#40;&#114;&#41;&#32;&#92;&#116;&#97;&#110;&#104;&#40;&#114;&#41;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#92;&#111;&#118;&#101;&#114;&#108;&#105;&#110;&#101;&#123;&#118;&#125;&#61;&#50;&#46;&#53;&#57;&#56;&#48;&#55; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>where <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-48af324422cc583dd084e15a5f79c588_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#114;&#61;&#92;&#115;&#113;&#114;&#116;&#123;&#120;&#94;&#50;&#43;&#121;&#94;&#50;&#125;" title="Rendered by QuickLaTeX.com" height="21" width="111" style="vertical-align: -4px;" />. The exact solution (the projection or restriction of the analytical solution on the computational mesh) on the whole space <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-87d9474a86518670a57fb9024432e996_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#109;&#97;&#116;&#104;&#98;&#98;&#123;&#82;&#125;&#94;&#50;" title="Rendered by QuickLaTeX.com" height="16" width="21" style="vertical-align: 0px;" /> has the following explicit form:</p>
<p><a name="id4037667042"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 43px;"><span class="ql-right-eqno"> (21) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-c990281a65e430f338a668c0f3cbcc6f_l3.png" height="43" width="331" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#117;&#40;&#120;&#44;&#121;&#44;&#116;&#41;&#61;&#92;&#116;&#97;&#110;&#104;&#92;&#108;&#101;&#102;&#116;&#40;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#121;&#32;&#92;&#99;&#111;&#115;&#40;&#103;&#116;&#41;&#32;&#45;&#32;&#120;&#32;&#92;&#32;&#92;&#115;&#105;&#110;&#40;&#103;&#116;&#41;&#125;&#123;&#92;&#100;&#101;&#108;&#116;&#97;&#125;&#92;&#114;&#105;&#103;&#104;&#116;&#41; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>It is important to mention that the velocity field is divergence-free. The state equation can the be written similarly in divergence or non-divergence form:</p>
<p class="ql-center-displayed-equation" style="line-height: 41px;"><span class="ql-right-eqno"> (22) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-4165c9e553f4e7885a66dc9b8906fb39_l3.png" height="41" width="286" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#100;&#102;&#114;&#97;&amp;##99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#40;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#32;&#117;&#41;&#32;&#61;&#32;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#117;&#125;&#123;&#92;&#112;&#97;&#114;&#116;&#105;&#97;&#108;&#32;&#116;&#125;&#32;&#43;&#32;&#40;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#41;&#32;&#117;&#61;&#48;&#44; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>because</p>
<p class="ql-center-displayed-equation" style="line-height: 17px;"><span class="ql-right-eqno"> &nbsp; </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-49e362893033310594c5349ebaf6b112_l3.png" height="17" width="77" class="ql-img-displayed-equation quicklatex-auto-format" alt="&#92;&#091;&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#109;&#97;&#116;&#104;&#98;&#102;&#123;&#118;&#125;&#32;&#92;&#101;&#113;&#117;&#105;&#118;&#32;&#48;&#44;&#92;&#093;" title="Rendered by QuickLaTeX.com" /></p>
<p>This allows us to formulate the problem of inverse design. Given the exact value of the solution at time <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f86a2227fd048f89ba8ff7295f735387_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#84;" title="Rendered by QuickLaTeX.com" height="15" width="45" style="vertical-align: -1px;" />, i.e. giving (<a href="#id4037667042">21</a>) as a target function at <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-f86a2227fd048f89ba8ff7295f735387_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#116;&#61;&#84;" title="Rendered by QuickLaTeX.com" height="15" width="45" style="vertical-align: -1px;" />, we aim to recover by a computational version of the gradient-adjoint methodology described above, an accurate and efficient approximation of the initial datum (<a href="#id1808989430">19</a>).</p>
<p>In our numerical experiments we take the values <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-0b67a2dd1c7985c6cc60c86d54f8dee8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#100;&#101;&#108;&#116;&#97;&#61;&#49;" title="Rendered by QuickLaTeX.com" height="14" width="42" style="vertical-align: 0px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-56771b082318c68ab77b07b4f6de69ce_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#84;&#61;&#52;&#115;" title="Rendered by QuickLaTeX.com" height="14" width="55" style="vertical-align: 0px;" />. The exact initial condition and the exact target are shown in Figure 3 (left and right respectively). As can be seen, the target presents a vortex-type profile, due to the heterogeneous geometry of the velocity field.</p>
<p>Our goal is to build a numerical method capable of predicting accurately and efficiently an approximation of (<a href="#id1808989430">19</a>) out of the target (<a href="#id4037667042">21</a>) by means of a numerical version of the optimisation algorithm above.</p>
<p><!--table width="100%">


<tr>


<td>
[caption id="attachment_1" align="aligncenter" width="231"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellLegend_u0.jpg" alt="L_2 errors" width="231" height="446" class="size-full wp-image-1" /> [/caption]
</td>




<td>
[caption id="attachment_2" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellExact_u0.jpg" alt="L_2 errors"  width="562" height="446" class="size-full wp-image-2" /> [/caption]
</td>




<td>
[caption id="attachment_3" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellExact_uT.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-3"  /> [/caption]
</td>




<td>
[caption id="attachment_4" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellLegend_uT.eps_.jpg" alt="L_2 errors" width="562" height="446"  class="size-medium wp-image-4" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_3" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure03.jpg" alt="Figure 3" width="1233" height="535" class="size-full wp-image-3" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 3: Doswell frontogenesis: Exact initial condition (left) and target function (right) for the inverse problem</i></figcaption></figure></p>
<p>The domain is discretized in 39998 unstructured triangles using <i>Triangle</i> [8] in a uniform Delaunay mesh. The initial condition for the first iteration is <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ced16b0bf76e477959072207a391d07b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#48;&#40;&#120;&#44;&#121;&#44;&#48;&#41;&#61;&#48;" title="Rendered by QuickLaTeX.com" height="21" width="113" style="vertical-align: -5px;" />. Both the forward and backward resolution are parallelized with OPENMP in 4 cores. The maximum number of iterations for the gradient method is set to 75, a constant step <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-e3d3b3832910e781276f174031db070f_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#118;&#97;&#114;&#101;&#112;&#115;&#105;&#108;&#111;&#110;&#61;&#48;&#46;&#53;" title="Rendered by QuickLaTeX.com" height="14" width="57" style="vertical-align: 0px;" /> is selected and the Courant number is set to <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-921be6463c87a1d3f0f95f3b323c006e_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#67;&#70;&#76;&#61;&#48;&#46;&#53;" title="Rendered by QuickLaTeX.com" height="14" width="84" style="vertical-align: 0px;" />.</p>
<p>Additionally, the step size <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-84590752e1778f03d293c972f9f2b81a_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#118;&#97;&#114;&#101;&#112;&#115;&#105;&#108;&#111;&#110;" title="Rendered by QuickLaTeX.com" height="9" width="8" style="vertical-align: 0px;" /> is set as a constant at the beginning of each iteration. However, if the convergence is not guaranteed, i.e., <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-0a7984d8454e25bcb3b6fe6fa7c099f7_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#74;&#94;&#123;&#107;&#43;&#49;&#125;&#62;&#61;&#74;&#94;&#107;" title="Rendered by QuickLaTeX.com" height="17" width="96" style="vertical-align: -1px;" />, the step size is halved until <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-1bd51b5296f2306b888d2d4f533985c5_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#74;&#94;&#123;&#107;&#43;&#49;&#125;&#60;&#74;&#94;&#107;" title="Rendered by QuickLaTeX.com" height="18" width="82" style="vertical-align: -2px;" />. Therefore, the stopping criteria for the iterative algorithm are:</p>
<ol>
<li> To reach the maximum number of iterations</li>
<li> To achieve the maximum allowable error of the functional, in this case, <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-34db956f2bdeb30eb9d8dbff34707d63_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#49;&#48;&#94;&#123;&#45;&#57;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="35" style="vertical-align: 0px;" /></li>
<li> To descend below <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-30bc3ea2f95c1fbbc940344aefba41a0_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#118;&#97;&#114;&#101;&#112;&#115;&#105;&#108;&#111;&#110;&#95;&#123;&#109;&#105;&#110;&#125;&#32;&#61;&#32;&#49;&#48;&#94;&#123;&#45;&#54;&#125;" title="Rendered by QuickLaTeX.com" height="19" width="95" style="vertical-align: -3px;" /> when halving the step size <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-84590752e1778f03d293c972f9f2b81a_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#118;&#97;&#114;&#101;&#112;&#115;&#105;&#108;&#111;&#110;" title="Rendered by QuickLaTeX.com" height="9" width="8" style="vertical-align: 0px;" /> trying to achieve convergence.</li>
</ol>
<p>The numerical results are shown in Figures 4, 5 and 6 for the target <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-15280474116fc5ccee16cbd3f5502660_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#84;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="74" style="vertical-align: -5px;" />, initial condition <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ccd995a9094d46a3d094500b8ae69bc2_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="70" style="vertical-align: -5px;" /> and adjoint <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-8e1c9c50773cab4bcc7025ecfa04b82c_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#32;&#40;&#120;&#44;&#121;&#44;&#48;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="71" style="vertical-align: -5px;" /> respectively at the last iteration of the gradient method. On the left side the <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> approach is displayed while the <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> resolution is illustrated on the right side.</p>
<p><!--table width="100%">


<tr>


<td>
[caption id="attachment_5" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellFOU_uT.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-5" /> [/caption]
</td>




<td>
[caption id="attachment_6" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellSOU_uT.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-6" /> [/caption]
</td>




<td>
[caption id="attachment_7" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellLegend_uT.jpg" alt="L_2 errors" width="562" height="446"  class="size-full wp-image-7" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_4" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure04.jpg" alt="Figure 4" width="1233" height="535" class="size-full wp-image-4" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 4: Doswell frontogenesis: Numerical target <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-15280474116fc5ccee16cbd3f5502660_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#84;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="74" style="vertical-align: -5px;" /> achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> (left) and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> (right)</i></figcaption></figure><br />
<!--table width="100%">


<tr>


<td>
[caption id="attachment_8" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellFOU_u0.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-8" /> [/caption]
</td>




<td>
[caption id="attachment_9" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellSOU_u0.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-9" /> [/caption]
</td>




<td>
[caption id="attachment_10" align="aligncenter" height="562" ]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellLegend_u0.jpg" alt="L_2 errors"  width="562" height="446" class="size-full wp-image-10" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_4" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure05.jpg" alt="Figure 5" width="1233" height="535" class="size-full wp-image-5" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 5: Doswell frontogenesis: Numerical initial condition <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ccd995a9094d46a3d094500b8ae69bc2_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="70" style="vertical-align: -5px;" /> achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> (left) and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> (right)</i></figcaption></figure></p>
<p>In order to complete the qualitative results, the error computed as the difference between the exact and the numerical approximation is displayed in Figures 7 and 8 for the target <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-8ab130fe2665eca0880e1cd9876e9939_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#84;&#41;&#32;&#45;&#32;&#117;&#94;&#42;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="159" style="vertical-align: -5px;" /> and the initial datum <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-d650b3a0651e369d9401d8338a5650f8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;&#32;&#45;&#32;&#117;&#94;&#101;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="156" style="vertical-align: -5px;" />.</p>
<p><!--table width="100%">


<tr>


<td>
[caption id="attachment_11" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellFOU_adj.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-11" /> [/caption]
</td>




<td>
[caption id="attachment_12" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellSOU_adj.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-12" /> [/caption]
</td>




<td>
[caption id="attachment_13" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/doswellLegend_adj.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-13" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_6" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure06.jpg" alt="Figure 6" width="1233" height="535" class="size-full wp-image-6" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 6: Doswell frontogenesis: Numerical adjoint variable <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-d3cff7a72b42d080ab8451c9a36f22cd_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#115;&#105;&#103;&#109;&#97;&#40;&#120;&#44;&#121;&#44;&#48;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="71" style="vertical-align: -5px;" /> achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> (left) and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> (right)</i></figcaption></figure></p>
<p><!--table width="100%">


<tr>


<td>
[caption id="attachment_14" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/diffuT_FOU.png.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-14" /> [/caption]
</td>




<td>
[caption id="attachment_15" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/diffuT_SOU.png.eps_.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-15" /> [/caption]
</td>




<td>
[caption id="attachment_16" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/legendDiffuT.jpg" alt="L_2 errors" width="562" height="446" class="size-full wp-image-16" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_7" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure07.jpg" alt="Figure 7" width="1233" height="535" class="size-full wp-image-7" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 7: Doswell frontogenesis: Target error <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-8ab130fe2665eca0880e1cd9876e9939_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#84;&#41;&#32;&#45;&#32;&#117;&#94;&#42;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="159" style="vertical-align: -5px;" /> achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> (left) and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> (right)</i></figcaption></figure></p>
<p><!--table width="100%">


<tr>


<td>
[caption id="attachment_17" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/diffu0_FOU.jpg" alt="L_2 errors"  width="562" height="446"  class="size-full wp-image-17" /> [/caption]
</td>




<td>
[caption id="attachment_18" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/diffu0_SOU.jpg" alt="L_2 errors"  width="562" height="446"  class="size-full wp-image-18" /> [/caption]
</td>




<td>
[caption id="attachment_19" align="aligncenter" width="562"]<img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/legendDiffu0.jpg" alt="L_2 errors"  width="125" height="446"  class="size-full wp-image-19" /> [/caption]
</td>


</tr>


</table-->
<figure id="attachment_8" style="width: 1000px" class="wp-caption aligncenter"><img src="http://cmc.deusto.eus/wp-content/uploads/2017/11/figure08.jpg" alt="Figure 7" width="1233" height="535" class="size-full wp-image-8" /><figcaption class="wp-caption-text"><i align="aligncenter">Figure 8: Doswell frontogenesis: Initial datum error <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-d650b3a0651e369d9401d8338a5650f8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#40;&#120;&#44;&#121;&#44;&#48;&#41;&#32;&#45;&#32;&#117;&#94;&#101;&#40;&#120;&#44;&#121;&#41;" title="Rendered by QuickLaTeX.com" height="20" width="156" style="vertical-align: -5px;" /> achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> (left) and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> (right)</i></figcaption></figure></p>
<p>Quantitative results can be obtained by means of the computation of <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a85046948103e25fba30bb74a008ae93_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#50;" title="Rendered by QuickLaTeX.com" height="17" width="17" style="vertical-align: -3px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a5978030bdf2e33c5f20248b7890641c_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#123;&#92;&#105;&#110;&#102;&#116;&#121;&#125;" title="Rendered by QuickLaTeX.com" height="18" width="24" style="vertical-align: -4px;" /> norms, not only with respect to the target function but also to the known exact initial condition <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-8d8312fb4575ee14f33a12f12eee253e_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#101;" title="Rendered by QuickLaTeX.com" height="14" width="16" style="vertical-align: 0px;" /> in order to evaluate the results achieved by <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" />:<br />
<a name="id3463475655"></a></p>
<p class="ql-center-displayed-equation" style="line-height: 132px;"><span class="ql-right-eqno"> (23) </span><span class="ql-left-eqno"> &nbsp; </span><img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-2bbbc34f33882a67fb453c742ffc35ff_l3.png" height="132" width="577" class="ql-img-displayed-equation quicklatex-auto-format" alt=" &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; &#92;&#98;&#101;&#103;&#105;&#110;&#123;&#115;&#112;&#108;&#105;&#116;&#125; &#76;&#95;&#50;&#32;&#40;&#117;&#94;&#84;&#41;&#32;&#61;&#32;&#92;&#115;&#113;&#114;&#116;&#123;&#92;&#115;&#117;&#109;&#95;&#105;&#94;&#78;&#32;&#40;&#117;&#40;&#120;&#95;&#105;&#44;&#84;&#41;&#45;&#117;&#94;&#42;&#40;&#120;&#95;&#105;&#41;&#41;&#94;&#50;&#125;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#76;&#95;&#123;&#92;&#105;&#110;&#102;&#116;&#121;&#125;&#32;&#40;&#117;&#94;&#84;&#41;&#32;&#61;&#32;&#92;&#109;&#97;&#120;&#95;&#105;&#32;&#124;&#117;&#40;&#120;&#95;&#105;&#44;&#84;&#41;&#45;&#117;&#94;&#42;&#40;&#120;&#95;&#105;&#41;&#124;&#32;&#92;&#92; &#76;&#95;&#50;&#32;&#40;&#117;&#94;&#48;&#41;&#32;&#61;&#32;&#92;&#115;&#113;&#114;&#116;&#123;&#92;&#115;&#117;&#109;&#95;&#105;&#94;&#78;&#32;&#40;&#117;&#40;&#120;&#95;&#105;&#44;&#48;&#41;&#45;&#117;&#94;&#101;&#40;&#120;&#95;&#105;&#41;&#41;&#94;&#50;&#125;&#32;&#92;&#113;&#113;&#117;&#97;&#100;&#32;&#76;&#95;&#123;&#92;&#105;&#110;&#102;&#116;&#121;&#125;&#32;&#40;&#117;&#94;&#48;&#41;&#32;&#61;&#32;&#92;&#109;&#97;&#120;&#95;&#105;&#32;&#124;&#117;&#40;&#120;&#95;&#105;&#44;&#48;&#41;&#45;&#117;&#94;&#101;&#40;&#120;&#95;&#105;&#41;&#124; &#92;&#101;&#110;&#100;&#123;&#115;&#112;&#108;&#105;&#116;&#125; &#92;&#101;&#110;&#100;&#123;&#101;&#113;&#117;&#97;&#116;&#105;&#111;&#110;&#42;&#125; " title="Rendered by QuickLaTeX.com" /></p>
<p>Table 1 condenses this information as well as the number of iterations and the CPU time for each proposed scheme. For the sake of clarity and for each comparison, the best results are highlighted in bold font.</p>
<table width="100%">
<tr>
<th> Scheme </th>
<th> <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a85046948103e25fba30bb74a008ae93_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#50;" title="Rendered by QuickLaTeX.com" height="17" width="17" style="vertical-align: -3px;" /> (<img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-55b08c6b8db1d876d0e8e76cc21c498b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#84;" title="Rendered by QuickLaTeX.com" height="16" width="19" style="vertical-align: 0px;" />) </th>
<th> <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-01cfd5ffded0366d1126a740fd5b4abe_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#92;&#105;&#110;&#102;&#116;&#121;" title="Rendered by QuickLaTeX.com" height="18" width="24" style="vertical-align: -4px;" /> (<img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-55b08c6b8db1d876d0e8e76cc21c498b_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#84;" title="Rendered by QuickLaTeX.com" height="16" width="19" style="vertical-align: 0px;" />) </th>
<th> <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a85046948103e25fba30bb74a008ae93_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#50;" title="Rendered by QuickLaTeX.com" height="17" width="17" style="vertical-align: -3px;" /> (<img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ca25e1ef94b9399e0e1ff81669ad2633_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#48;" title="Rendered by QuickLaTeX.com" height="16" width="16" style="vertical-align: 0px;" />) </th>
<th> <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-01cfd5ffded0366d1126a740fd5b4abe_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#92;&#105;&#110;&#102;&#116;&#121;" title="Rendered by QuickLaTeX.com" height="18" width="24" style="vertical-align: -4px;" /> (<img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-ca25e1ef94b9399e0e1ff81669ad2633_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#117;&#94;&#48;" title="Rendered by QuickLaTeX.com" height="16" width="16" style="vertical-align: 0px;" />) </th>
<th> nIters </th>
<th> CPU Time (s)</th>
</tr>
<tr>
<td>
FOU
</td>
<td> 1.37127e+00 </td>
<td> 1.37078e-01 </td>
<td> <b>1.36043e+00</b> </td>
<td> <b>8.64870e-02</b> </td>
<td> 75 </td>
<td> 366.26 </td>
</tr>
<tr>
<td>
SOU
</td>
<td> <b>1.23889e+00</b> </td>
<td> <b>1.34271e-01</b> </td>
<td> 1.88749e+00 </td>
<td> 1.40718e-01 </td>
<td> 45 </td>
<td> 488.61 </td>
</tr>
<table width="100%">
<i align="aligncenter">Table 1: Doswell Frontogenesis: <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a85046948103e25fba30bb74a008ae93_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#50;" title="Rendered by QuickLaTeX.com" height="17" width="17" style="vertical-align: -3px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-a5978030bdf2e33c5f20248b7890641c_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#76;&#95;&#123;&#92;&#105;&#110;&#102;&#116;&#121;&#125;" title="Rendered by QuickLaTeX.com" height="18" width="24" style="vertical-align: -4px;" /> norms, number of iterations and CPU time for the <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-22ddc8f838545c0f873cfb1952f0eaef_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#70;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="57" style="vertical-align: 0px;" /> and <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /></i>  &lt;/p&gt;
<p>Note that the number of iterations for the <img src="https://cmc.deusto.eus/wp-content/ql-cache/quicklatex.com-5ae14ab8f471a16e2da78cf344191eb8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#110;&#97;&#98;&#108;&#97;&#32;&#74;&#94;&#123;&#83;&#79;&#85;&#125;" title="Rendered by QuickLaTeX.com" height="16" width="56" style="vertical-align: 0px;" /> approach does not reach the maximum number of iterations set at the beginning of the inverse design process because at iteration 45, the functional is not able to diminish its value to the next iteration due to the deterioration of the initial condition by the high frequencies.</p>
</table></table>
<p>&lt;/p&gt;</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h5&gt;1. Problem formulation&lt;/h5&gt;
</code></pre>
</div>
<p>Let $\Omega\subset \mathbb R^d$ be an open and bounded Lipschitz Domain and consider the parameter dependent parabolic equation with Dirichlet boundary conditions</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{heat_intro}
\begin{cases}
y_{t}-\text{div}(a(x,\nu)\nabla y) +c\, y=\chi_\omega u \quad &\text{in } Q=\Omega\times(0,T), \\
y=0 \quad &\text{on } \Sigma=\partial\Omega\times(0,T), \\
y(x,0)=y^0(x) \quad&\text{in } \Omega,
\end{cases}
\end{equation} %]]></script>

<p>where $y=y(x,t;\nu)$ is the state, $u=u(x,t)$ is a control function and $y_0$ is given initial datum.</p>

<p>In (1), $a(x,\nu)$ is a scalar $L^\infty(\Omega)$ coefficient depending on some parameter $\nu$ and $c=c(x)\in L^\infty(\Omega)$ is given. To abridge the notation, we will denote $a_\nu=a(x,\nu)$.</p>

<p>Now, consider the following associated optimal control problem</p>

<script type="math/tex; mode=display">\begin{equation}\label{min_evo_intro}
\min_{u\in L^2(0,T;L^2(\omega))} \, J^T(u)=\frac{1}{2}\int_{0}^T|u(t)|^2_{L^2(\omega)}+\frac{\beta}{2}\int_{0}^T\|y(t)-y_d\|^2_{L^2(\Omega)},
\end{equation}</script>

<p>where $y$ is the solution to (1), $y_d\in L^2(\Omega)$ is a desired observation and $\beta&gt;0$ is given.</p>

<p>It is classical to prove (see e.g., [3]) that the minimization problem (2) has a unique optimal solution that hereinafter we denote by  $(u^T,y^T)$. Moreover, the optimal control is given by</p>

<script type="math/tex; mode=display">\begin{equation*}\label{opt_evo}
u^T=-\chi_\omega p^T
\end{equation*}</script>

<p>where $q^T$ can be found from the solution $(y^T,p^T)$ of the optimality system</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{opt_sys_evolution}
\begin{cases}
y^T_t-\text{div}(a_\nu \nabla y^T) +c\, y^T =-\chi_\omega p^T, \quad &\text{in } Q, \\
-p_t^T-\text{div}(a_\nu \nabla p^T) +c\, p^T=\beta\,(y^T-y_d), \quad &\text{in } Q, \\
y^T=q^T=0, \quad &\text{on } \Sigma, \\
y^T(x,0)=y^0, \quad q^T(x,T)=0, \quad &\text{in } \Omega.
\end{cases}
\end{equation} %]]></script>

<p>In this work, we use a combination of (weak) greedy methods and the so-called <i>turnpike</i> property to determine the most relevant values of a parameter-space providing the best possible approximation of the set of parameter dependent optimal controls.</p>

<p>Firstly, we will use the <i>turnpike</i> property to reduce the problem of computing the time-dependent optimal controls $u^T$ by computing asymptotic simplifications.</p>

<p>To this end, we begin by considering the stationary version of the state equation</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{steady_state}
\begin{cases}
-\text{div}(a_\nu \nabla y)+c \, y=\chi_\omega u \quad &\text{in } \Omega, \\
y=0 \quad &\text{on } \partial \Omega. \\
\end{cases}
\end{equation} %]]></script>

<p>Now, consider the corresponding minimization problem</p>

<script type="math/tex; mode=display">\begin{equation}\label{min_steady_intro}
\min_{u\in L^2(\omega)} \, J(u)=\frac{1}{2}|u|^2_{L^2(\omega)}+\frac{\beta}{2}\|y-y_d\|^2_{L^2(\Omega)}.
\end{equation}</script>

<p>As before, one can prove that, since $J$ is strictly convex, continuous and coercive, the minimization problem (5) has a unique optimal solution $(\bar u, \bar y)$, where the optimal control is characterized by</p>

<script type="math/tex; mode=display">\begin{equation*}
\bar u=-\chi_\omega \bar p,
\end{equation*}</script>

<p>and $(\bar y, \bar p)$ solve the optimality system</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{opt_sys_steady}
\begin{cases}
-\text{div}(a_\nu \nabla \bar y) +c\, \bar y=-\chi_\omega \bar p, \quad &\text{in } \Omega, \\
-\text{div}(a_\nu \nabla \bar p) +c\, \bar p=\beta\,(\bar y-y_d), \quad &\text{in } \Omega, \\
\bar y=\bar p=0, \quad &\text{on } \partial \Omega. \\
\end{cases}
\end{equation} %]]></script>

<p>A natural question that arises in this context is to which extent the long horizon optimal controls and states $(u^T(t),y^T(t))$ approach the steady ones $(\bar u,\bar y)$ as $T\to +\infty$. According to [4], we have the following result:
<strong>Theorem 1.1</strong>
Let us consider the control problem (2) and let $(u^T,y^T)$ be the optimal control and state. Then, there exists $\mu&gt;0$ such that</p>

<script type="math/tex; mode=display">\begin{equation}\label{conv_exponential}
\|y^T(t)-\bar y\|_{L^2(\Omega)}+\|u^T(t)-\bar u\|_{L^2(\Omega)} \leq K\left( e^{-\mu t}+e^{-\mu(T-t)}\right), \quad \forall t\in [0,T],
\end{equation}</script>

<p>where $(\bar u,\bar y)$ is the optimal control and state corresponding to (6).
<!--end{theorem}--></p>

<p>This means that we have exponential convergence of the finite horizon control problems to their steady state version as $T$ tends to infinity.</p>

<p>Thanks to Theorem 1.1, we can now focus our attention on the steady system (4). We begin by assuming the following hypotheses:</p>

<ul>
  <li><strong>H1</strong> The parameter $\nu$ ranges within a compact set $\mathcal K \subseteq \mathbb{R}^d$.</li>
  <li><strong>H2</strong> The coefficient functions $a_\nu$ are bounded functions satisfying uniform coercive and boundedness estimates:
<script type="math/tex">% <![CDATA[
\begin{equation*}
\begin{aligned}
  &  0 < a_1\leq  | a_\nu|_{L^\infty(\Omega)} \leq a_2,\quad  &\nu \in K
\label{UEA}
\end{aligned}
\end{equation*} %]]></script></li>
</ul>

<p>In addition, $a_\nu$ depend on $\nu$ in an analytic manner.</p>

<p>Then, the main idea is to propose a methodology to determine an optimal selection of a finite number of realizations of the parameter $\nu$ so that all controls, for all possible values of $\nu$, are optimally approximated. More precisely, the problem can be formulated as follows:
<strong>Problem 1.2</strong>
Let us consider the set of controls verifying (5) for each possible value $\nu \in \mathcal K$. That is,</p>

<script type="math/tex; mode=display">\begin{equation}
\overline{\mathcal U}=\left\{\bar  u_\nu : \nu\in \mathcal K\right\}.
\end{equation}</script>

<p>This control set is compact in $L^2(\omega)$.</p>

<p>Given $\varepsilon&gt;0$, we seek to determine a family of parameters ${\nu_1,\ldots,\nu_n}$ in $\mathcal K$, whose cardinality $n$ depends on $\varepsilon$, so that the corresponding controls, denoted by $u_{\nu_1},\ldots,u_{\nu_n}$ are such that for every $\nu\in \mathcal K$, there exists $u_\nu^\star\in \text{span}{u_{\nu_1},\ldots,u_{\nu_n}}$ such that</p>

<script type="math/tex; mode=display">\begin{equation*}
\|u_\nu^\star-\bar u_\nu\|\leq \varepsilon.
\end{equation*}</script>

<!--end{problem}-->
<!--/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////-->
<h4>2. Greedy optimal control for elliptic problems</h4>
<h5>2.1. Preliminaries on (weak) greedy algorithms</h5>

<p>In this section, we present a short introduction about linear approximation theory of parametric problems based on (weak) greedy algorithms. For a more detailed read, we refer, for instance, to [1, 2]. In general, the goal is to approximate a  compact set $\mathcal K$ in a Banach space $X$ by a sequence of finite dimensional subspaces $V_n$ of dimension $n$.</p>

<p>The algorithm reads as follows.</p>

<p>The algorithm produces a finite dimensional space $V_n$ that approximates the set $\mathcal K$ within precision $\varepsilon$.</p>

<p>The best choice of an approximating space $V_n$ is the one producing the smallest approximation error. This smallest error for a compact set $\mathcal K$ is called the <i>Kolmogorov $n$-width of $\mathcal K$</i>, and is defined as</p>

<script type="math/tex; mode=display">\begin{equation*}
d_n(\mathcal K):=\inf_{\dim Y=n} \sup_{x\in \mathcal K} \, \inf_{y\in Y}  \|{x-y}\|_X\,.
\end{equation*}</script>

<p>It measures how well $\mathcal K$ can be approximated by a subspace in $X$  of a fixed dimension $n$.</p>

<h4>Algorithm 1: Weak greedy algorithm</h4>
<p><strong>initialize:</strong> fix $\gamma\in (0,1]$ and a tolerance parameter $\varepsilon&gt;0$;</p>
<ol>
<li> In the first step, choose $x_1\in\mathcal K$ such that</li>
<li>$\|x_1\|_{ X}\geq \gamma \max_{x\in\mathcal K}\|x\|_X$</li>
<li>At the general step, having found $x_1,\ldots,x_n$ denote </li>
<li>

$$
\begin{equation}
  \label{dist_algo}
$V_n=\text{span}\{x_1,\ldots,x_n\} \quad\text{and}\quad  \sigma_n(\mathcal K):=\max_{x\in \mathcal K}\text{dist}(x,V_n)$;
\end{equation}
$$

</li>
<li><strong>repeat</strong></li>
<li> choose $x_{n+1}$ such that</li>
<li><div align="center">

$$
\text{dist}(x_{n+1},V_n)\geq \gamma\sigma_n(\mathcal K)
$$

</div>
</li>
<li><strong>until</strong>$\sigma_n(\mathcal K)&lt;\varepsilon$</li>
</ol>
<p>&lt;/pre&gt;</p>

<h4>2.2. Definition of the residual</h4>

<p>The main goals of this work is to apply the greedy approach to the family of parameter dependent steady state optimal control problems</p>

<script type="math/tex; mode=display">\begin{equation}\label{min_P}
\left(\mathcal{P}\right) \ \ \ \ \ \ \ \min_{u\in L^2(\omega)} \left\{ J_\nu( u)\right\},
\end{equation}</script>

<p>where $J$ is the cost functional given by</p>

<script type="math/tex; mode=display">\begin{equation*}
\label{J}
J_\nu( u) = \frac{1}{2} |{u}|_{L^2(\omega)}^2 \ + \  \frac{1}{2}   |y_\nu(u)-y^d|^2_{L^2(\Omega)},
\end{equation*}</script>

<p>while $y_\nu(u)$ is the solution to (4).</p>

<p>Essential for an effective application of a greedy algorithm is the construction of a residual by which one can estimate the distance between two (possible unknowns) controls by some easily computable quantity.</p>

<p>In this way, we introduce the residual operator as</p>

<script type="math/tex; mode=display">\begin{equation}
  \label{res}
  \begin{aligned}
    R_\nu(p,y):=\left(
    \begin{matrix}  L_\nu  y+ \chi_\omega p\\
   L_\nu p- \beta\left( y - y^d\right) \\
   \end{matrix}\right).
  \end{aligned}
\end{equation}</script>

<p>The residual $R_\nu(p,y)$ introduced in the previous subsection  enable us to construct a weak greedy algorithm for an effective construction of an approximating linear space of the control manifold. The precise description of the the algorithm is given below
We can summarize the obtained results in the following theorem
<strong>Theorem 2.1</strong>
   The proposed greedy algorithm provides the  following estimates  on the approximate control and approximate optimal state</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
     \begin{aligned}
       & \bullet\quad |u_\nu^\star - \bar u_\nu|_{L^2(\Omega)} \leq \varepsilon, \\
       & \bullet \quad | y_\nu^\star - \bar y_\nu|_{\Omega}
       \leq \left({\varepsilon \over \alpha_1 }\right)
 \end{aligned}
   \end{equation*} %]]></script>

<!--end{theorem}-->
<!--/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////-->
<h4>3. Numerical experiments</h4>
<p>We present here two numerical examples where the greedy approach is applied. To illustrate the procedure, we consider the two dimensional domain $\Omega=(0,1)^2$. We use the elementary finite difference (FD) method. We will approximate the elliptic operator $\mathcal A=-\text{div}(a_\nu\nabla \,\cdot)$ with homogeneous Dirichlet boundary conditions, by using the standard 5-point discretization.</p>

<h4>3.1. Greedy test # 1</h4>
<p>Let us consider a coefficient $a_\nu$ of the form</p>

<script type="math/tex; mode=display">\begin{equation}\label{coef_exp1}
a_\nu(x)=1+\nu(x_1^2+x_2^2)
\end{equation}</script>

<p>where we assume that</p>

<script type="math/tex; mode=display">\begin{equation}\label{range_exp1}
\nu\in [1,10]=\mathcal K.
\end{equation}</script>

<p>In this way, we can readily verify that $a_\nu$ satisfies <b>H1</b> and <b>H2</b>.</p>

<p>On the other hand, we take the coefficient $c$ as</p>

<script type="math/tex; mode=display">\begin{equation*}
c(x)=\sin(\pi x_1)\sin(\pi x_2).
\end{equation*}</script>

<p>which clearly fulfills the condition $c\geq 0$. For the optimal control problem, we set the parameter $\beta=10^4$ while the desired target is the $x_2$-independent function</p>

<script type="math/tex; mode=display">\begin{equation*}
y^d(x)=\sin(2\pi x_1).
\end{equation*}</script>

<p>We take $\omega$ as the region $(0.2,0.5)\times(0,5,0.9)\cup(0.5,0.9)\times(0.1,0.9)$ in the $x_1x_2$-plane (see Figure 2.B).</p>

<h4>Algorithm 2: Greedy control algorithm - offline part</h4>
<p><strong>Initialize:</strong> Fix the approximation error $\varepsilon&gt;0$.</p>
<ol>
<li><strong>STEP 1: (discretisation)</strong></li>
<li>Choose a finite subset $\tilde{\mathcal K}$ such that

$$\forall{\nu} \in \mathcal K \quad  dist(\nu, \tilde{\mathcal K}) &lt;\delta$$

</li>
<li>for  $\delta&gt;0$ a discretization constant.</li>
<li><strong>STEP 2: (Choosing $\nu_1$)</strong></li>
<li>Check the inequality

$$

    \begin{equation}\label{1st_stop}
    	\max_{\tilde{\nu} \in \tilde{\mathcal K}} \|\beta y^{d}_{\nu}\|_{H^{-1}\Omega} &lt;\frac{\varepsilon} 2.\;
    \end{equation}

$$

</li>
<li>If it is satisfied, stop the algorithm. Otherwise, choose the first parameter value as

$$
    \begin{equation}\label{first_sel}
    \nu_1 \in arg\max_{\tilde{\nu} \in \tilde{\mathcal K}} \{ \|y^{d}_{\nu}\|_{H^{-1}(\Omega)}\}.;
    \end{equation}
$$

</li>
<li>and find corresponding optimal primal and dual states $\bar y_1, \bar p_1$;</li>
<li><strong>STEP 3: (Choosing $\nu_{j+1}$)</strong></li>
<li>Having chosen $\nu_1, \ldots, \nu_j$ calculate $R_{\tilde \nu}(\bar p_j, 0)$ and  $R_{\tilde \nu}(0, \bar y_j)$ for each $\tilde \nu \in \tilde{\mathcal K}$.</li>
<li>Check the approximation criteria
<div align="center">

$$

\begin{equation}
\label{stop_crit}
\max_{\tilde\nu \in \tilde{\mathcal K}}   ||\inf_{( p,  y) \in (\overline{\mathcal P}_j, \overline{\mathcal  Y}_j)}
R_{\tilde \nu}(p,  y) ||_{H^{-1}(\Omega)}
&lt; \frac{\varepsilon}2.
\end{equation}

$$

</div>
</li>
<li>If the inequality is satisfied, stop the algorithm. Otherwise, determine the next  parameter value as
<div align="center">

$$

\begin{equation}
\label{step_j}
\nu_{j+1}\in arg\max_{\tilde \nu \in \tilde{\mathcal K}}
|| \inf_{( p,  y) \in (\overline{\mathcal P}_j, \overline{\mathcal  Y}_j)} R_{\tilde \nu}(p,  y) ||_{H^{-1}(\Omega)},
\end{equation}

$$

</div>
</li>
<li>Find the corresponding optimal primal and dual states $\bar y_{j+1}, \bar p_{j+1}$ and repeat Step 3.</li>
</ol>

<p>Since the functional $J_\nu$ is quadratic and coercive, a standard conjugate gradient (CG) algorithm is a simple choice to solve the minimization problem (5). For a given $\nu\in\mathcal K$ one can directly solve the minimization problem (10). The average time for computing the corresponding control up to a given tolerance of $10^{-8}$ using the CG is around six seconds.</p>

<p>Hypotheses <b>H1</b> and <b>H2</b> allow us to implement a <i>naive</i> approach for approximating the parameterized control set $\bar{\mathcal U}(\mathcal K)$. This approach consists in discretizing the parameter set in a very fine mesh, that we denote it by $\tilde{\mathcal K}$, and then computing the corresponding control for each parameter in this finite-dimensional set.</p>

<p>Let us take $\tilde{\mathcal K}$ as the uniform discretization of the interval (13) in $k=100$ values. Then, the <i>naive</i> approach amounts to solve 100 different times the minimization problem (10). The whole process takes around $600$ seconds.</p>

<p>We apply the greedy procedure described in Algorithm 2 over the set $\tilde{\mathcal K}$ and choosing a precision of $\varepsilon=0.005$. The algorithm stops after seven iterations selecting 7 (out of 100) parameter values. The time needed to finish the offline part of the greedy algorithm takes 476 seconds.</p>

<p>[c
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure1a.jpg" alt="Figure 1 a" width="446" height="446" class="size-full wp-image-01" /> <i align="aligncenter">Figure 1.A: Numerical results of the greedy test #1. Distribution of the selected parameters</i>
[c
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure1b.jpg" alt="Figure 1 b" width="446" height="446" class="size-full wp-image-02" /> <i align="aligncenter">Figure 1.B: Numerical results of the greedy test #1. Aproximation error</i>                                          <br />
The way the parameters are chosen for this test is illustrated in Figure 1.A. In Figure 1.B, we plot the approximation rate of the  greedy algorithm  corresponding to</p>

<script type="math/tex; mode=display">\begin{equation*}
\sigma_n(\tilde{\mathcal K})=\max_{\nu\in\tilde{\mathcal K}} \Big((\bar p_\nu,\bar y_\nu),(\bar {\mathcal P}_n,\bar {\mathcal Y}_n)\Big).
\end{equation*}</script>

<p>Such plot suggests an exponential decay of the approximation rate $\sigma_n$, which is in accordance with the greedy theory.</p>

<p>Once the offline part is completed, we can construct (approximate) optimal controls by choosing a suitable combination of the optimal states $\bar p_{\nu_i}$.</p>

<p>In Figure 2, we plot the approximation of the real control with the greedy algorithm for $\nu=\sqrt 2$. The approximated control is nearly identical to the obtained by minimizing directly functional (5) for the associated value $\nu=\sqrt{2}$. In fact, one can obtain for this particular experiment that</p>

<script type="math/tex; mode=display">\begin{equation*}
\|\bar{u}_{\sqrt 2}- u_{\sqrt 2}^\star\|_{L^2(\Omega)}\approx 4.61\times 10^{-5}.
\end{equation*}</script>

<p>In spite of obtaining almost the same solution, the convergence of conjugate gradient method takes 5.4 s compared to 0.488 s in the online greedy part. This fact also shows the computational efficiency of the proposed algorithm.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_control_test1.jpg" alt="greedy_control_test1" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 2.A: Approximated control by greedy methods. The approximated control $x\mapsto \bar u^\star_{\sqrt 2}\,(x)$</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/control_region_test1.jpg" alt="control_region_test1" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 2.B: Approximated control by greedy methods. The control set $\omega$</i></p>

<p>In Figure 3.A, we plot the solution to (4) using the approximated control $u_{\sqrt{2}}^\star$. As for the control, we can compute the difference between the real optimal state against the approximate optimal state $\bar y^\star_{\sqrt 2}$. In this particular test, we obtain the following estimate</p>

<script type="math/tex; mode=display">\begin{equation*}
\|\bar{y}_{\sqrt 2}- y_{\sqrt 2}^\star\|_{L^2(\Omega)}\approx 7.14\times 10^{-7}.
\end{equation*}</script>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_state_top_test1.jpg" alt="greedy_state_top_test1" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 3.A: Controlled solution. The state $x\mapsto \bar y^\star_{\sqrt 2}(x)$</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_state_target_test1.jpg" alt="greedy_state_target_test1" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 3.B: Controlled solution. The state $\bar y^\star_{\sqrt{2}}$ and the target function $y^d$ (dashed)</i></p>

<h4>3.2. Greedy test # 2</h4>
<p>Here, we present a series of experiments for the case when the potential fulfills $c(x)\leq 0$. This will be of particular interest in the discussion of the following section.</p>

<p>We consider again the coefficient (12) and the parameter $\nu$ within the range (13), as in the previous test. For this particular case, we choose a constant function $c$ and the desired target as follows</p>

<script type="math/tex; mode=display">\begin{equation*}
c(x)\equiv-37 \quad{\text{and}}\quad y^d(x)=\sin(\pi x_1)
\end{equation*}</script>

<p>We will use as a control region the shape depicted in figure 4. For this particular test, the average time for computing the optimal control  for different values of $\nu$ is around nine seconds. Implementing the <i>naive</i> approach for the refined mesh $\tilde{\mathcal K}$ implies that at least 900 seconds are needed to finish this process.</p>

<p>Using our computational tool, we choose again the approximation tolerance $\varepsilon=0.005$. The greedy algorithm stops after nine iterations. We present in figure 5a the selected parameters in the order they were chosen by the program. The elapsed time for completing the offline process is 678 seconds.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure4.jpg" alt="Figure 4" width="446" height="446" class="size-full wp-image-04" /><i align="aligncenter">Figure 4: Control region for the second test.</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure5a.jpg" alt="Figure 5 a" width="446" height="446" class="size-full wp-image-05" /><i align="aligncenter">Figure 5.A: Numerical results of the greedy test #2. Distribution of the selected parameters</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure5b.jpg" alt="Figure 5 b" width="446" height="446" class="size-full wp-image-05" /><i align="aligncenter">Figure 5.B: Numerical results of the greedy test #2. Aproximation error</i></p>

<p>In Figure 6 we plot the approximation  of the optimal control obtained  by the greedy method for a chosen value of $\nu=7/5$, while in Figure 7 we show corresponding controlled state and a comparison with the target $y^d$. For this particular test, the elapsed time to compute the online control is 0.406 seconds while the convergence of the CG to compute the optimal control takes 15.9 seconds. The approximation error with respect to the real control is</p>

<script type="math/tex; mode=display">\begin{equation*}
\|\bar u_{7/5}- u^\star_{7/5}\|_{L^2(\Omega)}\approx 1.46\times 10^{-4},
\end{equation*}</script>

<p>while the approximation error for the state using the real and approximated control is</p>

<script type="math/tex; mode=display">\begin{equation*}
\|\bar y_{7/5}- y^\star_{7/5}\|_{L^2(\Omega)}\approx 4.78\times 10^{-5}.
\end{equation*}</script>

<p>In Figure 7, we observe that the approximation to the desired target $y^d$  is (to a certain extent) better than the one we obtain in greedy test #1. This is because  the chosen $y^d$ does not change sign in the domain $\Omega$ (cf. Figure 3.B).</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_control_test2.jpg" alt="greedy_control_test2" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 6: The approximated control $x\mapsto \bar u^\star_{7/5}(x)$.</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_state_top_test1.jpg" alt="greedy_state_top_test1" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 7.A: Controlled solution. The state $x\mapsto \bar y^\star_{\sqrt 2}(x)$</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/greedy_state_target_test1.jpg" alt="greedy_state_target_test1" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 7.B: Controlled solution. The state $\bar y^\star_{\sqrt{2}}$ and the target function $y^d$ (dashed)</i></p>

<p>where $y$ is solution to the parabolic problem</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{evo_turn_6}
\begin{cases}
y_t-\div(a_\nu \nabla y)+c\, y=1_\omega u, \quad &\text{in } \Omega\times(0,T), \\
y=0, \quad &\text{on } \partial \Omega\times(0,T), \\
y(x,0)=y^0(x), \quad &\text{in } \Omega.
\end{cases}
\end{equation} %]]></script>

<p>Here, we present a series of experiments related to the (approximated) optimal steady controls in Sections 3.1 and 3.2. We use them to control the corresponding evolution equation and test their efficiency. We will differentiate two main cases to be studied.</p>

<h4>The case $c(x)\geq 0$</h4>
<p>In addition to the parameters already set in the greedy test #1 (see Section 3.1), let us take</p>

<ul>
  <li>$T=3$</li>
  <li>$y^0(x)\equiv 0$</li>
</ul>

<p>In this stage, we are going to use the optimal control $\bar u^\star_{\sqrt 2}$ as a time-independent control for system (18). More precisely, we take</p>

<script type="math/tex; mode=display">\begin{equation}\label{control_exp51}
u(x,t)=\bar u^\star_{\sqrt 2}(x) \quad\text{for }t\in (0,T).
\end{equation}</script>

<p>By plugging such control into equation (18), we obtain the controlled solution displayed in Figure 8. We see that this control steers $y$ away from the initial condition at time $t=0$ and reaches in a short amount of time a region near the optimal steady state $\bar y^\star_{\sqrt{2}}$ (cf. Figure 8.C).</p>

<p>For this experiment, the efficiency of the time-independent control is closely related to the fact that $c(x)\geq 0$. In particular, the conditions on the coefficients $a_\nu$ and $c$ allow to prove that the uncontrolled system (18) is exponentially stable regardless of the initial datum.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/evo_a_test1.jpg" alt="evo_a_test1" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 8.A: Evolution in time for a stable system controlled with the steady control approximated by greedy procedure. $t=0$</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/evo_b_test1.jpg" alt="evo_b_test1" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 8.B: Evolution in time for a stable system controlled with the steady control approximated by greedy procedure. (B) $t=0.025$</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/evo_c_test1.jpg" alt="evo_c_test1" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 8.C: Evolution in time for a stable system controlled with the steady control approximated by greedy procedure. (C) $t\in(0.1,3)$</i></p>

<p>In Figure 9, we illustrate the efficiency of the steady control by plotting different curves representing the time evolution of the $L^2$-norm of $y$ solution to (18) with different initial datums and taking (19) as a control. To compare, we have computed the time-dependent solution $y^T(t)$ associated to the optimal control $u^T(t)$, obtained by minimizing (17), for the given parameter $\nu=\sqrt{2}$ and $y_0(x)=0$.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure9.jpg" alt="Figure 9" width="446" height="446" class="size-full wp-image-09" /><i align="aligncenter">Figure 9: Time evolution comparison for system (18) controlled with turnpike control versus steady control and different initial datum: $y_0(x)=\bar y^\star_{7/5}(x)$, $y_0(x)=0$ and $\tilde y_0(x)=\chi_{(0.4,0.9)^2}(x)$.</i>
.&lt;/i&gt;</p>

<h4>The case $c(x)&lt; 0$</h4>
<p>Let us take the parameters and results in the greedy test #2 shown in Section 3.2 together with $y_0(x)=0$ and $T=3$. As before, we can put the (approximated) steady control $\bar u^\star_{7/5}(x)$ in system (18) and test its performance. Recall that we have chosen $c(x)\equiv -37$. We show in Figure 10 the solution to the evolution problem using the steady control $\bar u^\star_{7/5}$. We see that in this case, the steady control lacks to stabilize the system around the steady state shown in figure 10.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/evo_a_test2.jpg" alt="evo_a_test2" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 10.A: Evolution in time for an unstable system controlled with the steady control approximated by means of the greedy approach. $t=0$</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/evo_b_test2.jpg" alt="evo_b_test2" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 10.B: Evolution in time for an unstable system controlled with the steady control approximated by means of the greedy approach. $t=0.03$</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/evo_c_test2.jpg" alt="evo_c_test2" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 10.C: Evolution in time for an unstable system controlled with the steady control approximated by means of the greedy approach. $t=0.3675$</i></p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/evo_d_test2.jpg" alt="evo_d_test2" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 10.D: Evolution in time for an unstable system controlled with the steady control approximated by means of the greedy approach. $t=1.1175$</i></p>

<p>In Figure 11, we present further experiments where we illustrate that for some initial data, the controlled solution $y$ grows in exponential manner. In fact, only for $y_0(x)=\bar y^\star_{7/5}$ and a sufficiently small neighborhood of this initial datum, the steady control is effective to control the underlying system.</p>

<p>For this particular case, to see the turnpike property it is necessary to compute the solution to the time-dependent minimization problem (18). We show in Figure 12, the time evolution of the optimal  controlled state and control and, as expected, we can see the asymptotic simplification towards the state and control for most of the time horizon. However, we can also see that the control makes a large effort at the beginning of the temporal interval to move the system to this steady state.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/11/figure11.jpg" alt="Figure 11" width="446" height="446" class="size-full wp-image-11" /><i align="aligncenter">Figure 11: Time evolution comparison for system for an unstable system controlled with steady control with different initial data: $y_0(x)=\bar y^\star_{7/5}(x)$, $y_0(x)=0$ and $\tilde y_0(x)=\chi_{(0.4,0.9)^2}(x)$.</i>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/figura12a.jpg" alt="figura12a" width="446" height="446" class="size-full wp-image-01" /><i align="aligncenter">Figure 12.A: Turnpike property for an unstable system. The optimal state&lt;/i
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/10/figura12b.jpg" alt="figura12b" width="446" height="446" class="size-full wp-image-02" /><i align="aligncenter">Figure 12.B: Turnpike property for an unstable system. The optimal control</i></i></p>

<p>Unlike the case $c(x)\geq 0$, there might be some coefficients $c(x)&lt;0$ such that steady controls, and in particular the approximated controls derived from the greedy approach, are not enough to control the evolution system.</p>

<h3>Bibliography</h3>

<p><strong>[1]</strong> A. Cohen and  R. DeVore <a href="" target="_blank"><em>Approximation of high-dimensional parametric PDEs.</em></a> Acta Numerica, 24, (2015), 1--159.</p>
<p><strong>[2]</strong> R. DeVore, (2005) <a href="" target="_blank"><em>The Theoretical Foundation of Reduced Basis Methods.</em></a> preprint.</p>
<p><strong>[3]</strong> J.-L Lions. <!--a href="" target="_blank"--><em>Optimal control of systems governed by partial differential equations.</em><!--/a--> Springer-Verlag, 1971.</p>
<p><strong>[4]</strong> A. Porretta and E. Zuazua. <a href="http://paginaspersonales.deusto.es/enrique.zuazua/documentos_public/archivos/publicaciones/optimal10.pdf" target="_blank"><em>Long time versus steady state optimal control.</em></a> SIAM Journal on Control and Optimization, 51, 6 (2013), 4242-4273.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3&gt;Introduction&lt;/h3&gt;
</code></pre>
</div>
<p>We introduce the following notation: $L^2=L^2\left(\Omega\right)$, $L^2_T=L^2\left(\Omega\times \left(0,T\right)\right)$,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray*}
	\langle u,v \rangle&=&\int_{\Omega}^{} u(x)v(x) \ dx;\\
	\langle u,v \rangle_T^2&=&\int_{0}^{T} \int_{\Omega}^{} u(x,t)v(x,t) \ dx \ dt
\end{eqnarray*} %]]></script>

<p>and the correspondent norms $\norm{\cdot}=\langle \cdot,\cdot\rangle$ and $\norm{\cdot}_T=\langle \cdot,\cdot\rangle_T$. Moreover, we define the norms</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray*}
	\norm{v}_{1}&=&\int_{\Omega}^{} \abs{v(x)} \ dx;\\
	\norm{v}_{1,T}&=&\int_{0}^{T} \int_{\Omega}^{} \abs{v(x,t)} \ dx \ dt.
\end{eqnarray*} %]]></script>

<p>We want to study the following optimal control problem:</p>

<script type="math/tex; mode=display">\begin{equation*}
\left(\mathcal{P}\right) \ \ \ \ \ \ \ \hat{u}\in argmin_{u\in L^2_T} \left\{J\left(u\right)=\alpha_c \norm{u}_{1,T} + \frac{\beta}{2}\norm{u}^2_{T}+\alpha_s \norm{Lu}_{1,T} + \frac{\gamma}{2}\norm{Lu-z}_{T}^2\right\},
\end{equation*}</script>

<p>where $L: \ L^2_T \to L^2_T$ is defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray*}
Lu&=&y
\end{eqnarray*} %]]></script>

<p>and $y$ is the solution of the PDE given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
y'+Ay=Bu & \left(\Omega \times \left(0,T\right)\right)\\
y=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
y(0)=0 & \left(\Omega\right).
\end{cases}
\end{equation*} %]]></script>

<p>Notice that, by integration by parts, $ L^*\mu=B^\ast p $, where $\varphi$ is solution of the adjoint equation:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
-p'+A^* p =\mu & \left(\Omega \times \left(0,T\right)\right)\\
p=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
p(T)=0 & \left(\Omega\right).
\end{cases}
\end{equation*} %]]></script>

<h3>Sparse control: $\alpha_c&gt;0$ ($\alpha_s=0$)</h3>
<h3>The stationary problem</h3>

<script type="math/tex; mode=display">\begin{equation*}
\left(\mathcal{S}\mathcal{P}_c\right) \ \ \ \ \ \ \ \bar{u}\in argmin_{u\in L^2} \left\{J_s\left(u\right)=\alpha_c \norm{u}_{1} + \frac{\beta}{2}\norm{u}^2+ \frac{\gamma}{2}\norm{y-z}^2: \ \ \ Ay=Bu \right\}.
\end{equation*}</script>

<h4>Optimality conditions</h4>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
A\bar{y}=B \ shrink(-B^*\bar{p},\frac{\alpha_c}{\beta}) & \left(\Omega\right)\\
A^*\bar{p}=\gamma\left(\bar{y}-z\right) & \left(\Omega\right)\\
\bar{y}=0, \ \bar{p}=0 & \left(\partial\Omega\right).
\end{cases}
\end{equation*} %]]></script>

<h4>Numerical algorithm</h4>
<p>In order to compute a numerical solution of problem</p>

<script type="math/tex; mode=display">\left(\mathcal{S}\mathcal{P}_c\right)</script>

<p>after a discretization by finite differences, we use a prox-prox splitting: first write the state as $y=A^{-1}Bu$, then</p>
<ul>
	<li> Proximal-point step:</li>

$$
\begin{equation*}
\begin{split}
\tilde{u}_{k} &amp; =argmin_{u\in L^2} \left\{\frac{\beta}{2}\norm{u}^2 + \frac{\gamma}{2}\norm{A^{-1}Bu-z}^2+ \frac{1}{2\lambda_k}\norm{u-u_k}^2\right\}\\
&amp; = \left[\left(\beta+\frac{1}{\lambda_k}\right)I+\gamma B^*A^{-*}A^{-1}B\right]^{-1}\left(\frac{1}{\lambda_k}u_k+\gamma B^*A^{-*}z\right).
\end{split}
\end{equation*}
$$

<li> Proximal-point step:</li>

$$
\begin{equation*}
	\begin{split}
	u_{k+1}&amp; =argmin_{u\in L^2} \left\{\alpha_c \norm{u}_{1,T} + \frac{1}{2\lambda_k}\norm{u-\tilde{u}_k}_{T}^2\right\}\\
	&amp; = shrink(\tilde{u}_k,\alpha_c \lambda_k).
	\end{split}
	\end{equation*}
$$

</ul>
<p><strong>Remark:</strong> Notice that, when $\alpha_s=0$, the solution of $\left(\mathcal{P}^c_s\right)$ is simply given by</p>

<script type="math/tex; mode=display">\bar{u}=\gamma \left[\beta I+\gamma B^*A^{-*}A^{-1}B\right]^{-1}B^*A^{-*}z.</script>

<h3>Evolutionary problem</h3>

<script type="math/tex; mode=display">\begin{equation*}
\left(\mathcal{P}_c\right) \ \ \ \ \ \ \ \hat{u}\in argmin_{u\in L^2_T} \left\{J\left(u\right)=\alpha_c \norm{u}_{1,T} + \frac{\beta}{2}\norm{u}^2_{T} + \frac{\gamma}{2}\norm{Lu-z}_{T}^2\right\}.
\end{equation*}</script>

<h4>Optimality conditions</h4>
<p>Define the classical Lagrangian</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\mathcal{L}\left(u,y,p\right)&=J\left(u\right)+\langle p, Bu-y'-Ay\rangle_T.
\end{split}
\end{equation*} %]]></script>

<p>By integration by parts, we have</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\mathcal{L}\left(u,y,p\right)&=\alpha_c \norm{u}_{1,T} + \frac{\beta}{2}\norm{u}^2_{T}+ \frac{\gamma}{2}\norm{y-z}_{T}^2 + \langle B^*p, u\rangle_T \\
& \quad + \langle p'-A^*p,y\rangle_T + \langle p(0),y(0)\rangle - \langle p(T),y(T)\rangle.
\end{split}
\end{equation*} %]]></script>

<p>Deriving with respect to the three variables $\left(u,y,p\right)$, we obtain the optimality system:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
\hat{y}'+A\hat{y}=B\hat{u} & \left(\Omega \times \left(0,T\right)\right)\\
-\hat{p}'+A^*\hat{p}=\gamma\left(y-z\right) & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=0, \ \hat{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
\hat{y}(0)=0, \ \hat{p}(T)=0 & \left(\Omega\right),
\end{cases}
\end{equation*} %]]></script>

<p>where the relation between the optimal control and the dual state is given by</p>

<script type="math/tex; mode=display">\begin{equation*}
0\in \alpha_c \ \partial \norm{\cdot}_{1,T} \left(\hat{u}\right) + \beta \hat{u} + B^*\hat{p}.
\end{equation*}</script>

<p>The latter is equivalent to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\hat{u}&=\left(\beta I+\alpha_c \ \partial \norm{\cdot}_{1,T} \right)^{-1}\left(-B^*\hat{p}\right)\\
&=argmin_{v\in L^2_T} \left\{ \alpha_c \norm{v}_{1,T}+\frac{1}{2\beta}\norm{v+B^*\hat{p}}_T^2 \right\}\\
&=shrink(-B^*\hat{p},\frac{\alpha_c}{\beta}),
\end{split}
\end{equation*} %]]></script>

<p>where the operator of $soft-shrinkage$ is defined by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
shrink(t,\alpha)=
\begin{cases}
t+\alpha & (t<-\alpha)\\
0 & (-\alpha\leq t \leq \alpha)\\
t-\alpha & (t>\alpha).
\end{cases}
\end{equation*} %]]></script>

<p>Finally,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
\hat{y}'+A\hat{y}=B \ shrink(-B^*\hat{p},\frac{\alpha_c}{\beta})& \left(\Omega \times \left(0,T\right)\right)\\
-\hat{p}'+A^*\hat{p}=\gamma\left(y-z\right) & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=0, \ \hat{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
\hat{y}(0)=0, \ \hat{p}(T)=0 & \left(\Omega\right).
\end{cases}
\end{equation*} %]]></script>

<h4>Numerical algorithm</h4>
<p>In order to compute a numerical solution of problem $\left(\mathcal{P}_c\right)$, after a discretization by finite differences, we use a grad-prox splitting:</p>
<ul>
	<li> Gradient step:</li>
$$
	\begin{equation*}
	\begin{split}
	\tilde{u}_{k} &amp; = u_k-\lambda_k \nabla_u \left[\frac{\beta}{2}\norm{u}^2_{T} + \frac{\gamma}{2}\norm{Lu-z}_{T}^2 \right]\left(u_k\right) \\
	&amp; = u_k-\lambda_k \left[\beta u_k+\gamma L^*\left(Lu_k-z\right)\right]\\
	&amp; = u_k - \lambda_k\left[\beta u_k+\gamma B^*p_k\right],
	\end{split}
	\end{equation*}
$$

where

$$
	\begin{equation*}
	\begin{cases}
	y_k'+Ay_k=Bu_k &amp; \left(\Omega \times \left(0,T\right)\right)\\
	y_k=0 &amp; \left(\partial\Omega\times \left(0,T\right)\right)\\
	y_k(0)=0 &amp; \left(\Omega\right)
	\end{cases}
	\end{equation*}
$$

and

$$
	\begin{equation*}
	\begin{cases}
	-p_k'+A^* p_k =y_k-z &amp; \left(\Omega \times \left(0,T\right)\right)\\
	p_k=0 &amp; \left(\partial\Omega\times \left(0,T\right)\right)\\
	p_k(T)=0 &amp; \left(\Omega\right).
	\end{cases}
	\end{equation*}
$$

<li> Proximal-point step:</li>

$$
\begin{equation*}
\begin{split}
u_{k+1}&amp; =argmin_{u\in L^2_T} \left\{\alpha_c \norm{u}_{1,T} + \frac{1}{2\lambda_k}\norm{u-\tilde{u}_k}_{T}^2\right\}\\
	&amp; = shrink(\tilde{u}_k,\alpha_c \lambda_k).
\end{split}
\end{equation*}
$$

</ul>
<p><strong>Remarks:</strong> Another possibility is to include the term $\frac{\beta}{2}\norm{u}^2_{T}$ in the proximal step.
Notice that, for</p>

<script type="math/tex; mode=display">f(u)=\frac{\beta}{2}\norm{u}^2_{T} + \frac{\gamma}{2}\norm{Lu-z}_{T}^2,</script>

<p>then $\nabla f$ is Lipschitz continuous. Indeed, for $u_i\in L^2_T$ ($i=1,2$), then</p>

<script type="math/tex; mode=display">\nabla f (u_i)=\beta u_i+\gamma B^{*}p_i,</script>

<p>where</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
y_i'+Ay_i=Bu_i & \left(\Omega \times \left(0,T\right)\right)\\
y_i=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
y_i(0)=0 & \left(\Omega\right)
\end{cases}
\end{equation*} %]]></script>

<p>and</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
-p_i'+A^* p_i=y_i-z & \left(\Omega \times \left(0,T\right)\right)\\
p_i=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
p_i(T)=0 & \left(\Omega\right).
\end{cases}
\end{equation*} %]]></script>

<p>By linearity $\delta y=y_2-y_1$ and $\delta p=p_2-p_1$ solve the same equations with right-hand-sides $B(u_2-u_1)$ and $\delta y$, respectively. Then</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\norm{\nabla f(u_2)-\nabla f(u_1)}&\leq \beta\norm{u_2-u_1}_T + \gamma \norm{B^*}\norm{\delta p}_T\\
&\leq \beta\norm{u_2-u_1}_T + \gamma \ C_{adj} \norm{B} \norm{\delta y}_T\\
& \leq \beta\norm{u_2-u_1}_T + \gamma \ C_{adj} C \ \norm{B} \norm{B(u_2-u_1)}_T\\
& \leq L \norm{u_2-u_1}_T,
\end{split}
\end{equation*} %]]></script>

<p>where we defined</p>

<script type="math/tex; mode=display">L=\beta+\gamma \ C_{adj} C \ \norm{B}^2.</script>

<p>In order the prox-grad method to converge, the restriction on the step size is given by</p>

<script type="math/tex; mode=display">% <![CDATA[
0<\lambda \leq \lambda_k \leq \Lambda <\frac{2}{L}. %]]></script>

<h3>Sparse state: $\alpha_s&gt;0$ ($\alpha_c=0$)</h3>

<script type="math/tex; mode=display">\begin{equation*}
\left(\mathcal{P}_s\right) \ \ \ \ \ \ \ \hat{u}\in argmin_{u\in L^2_T} \left\{J\left(u\right)=\frac{\beta}{2}\norm{u}^2_{T}+\alpha_s \norm{Lu}_{1,T} + \frac{\gamma}{2}\norm{Lu-z}_{T}^2\right\}.
\end{equation*}</script>

<h3>The stationary problem</h3>

<script type="math/tex; mode=display">\begin{equation*}
\left(\mathcal{S}\mathcal{P}_s\right) \ \ \ \ \ \ \ \bar{u}\in argmin_{u\in L^2} \left\{J_s\left(u\right)=\alpha_c \norm{u}_{1} + \frac{\beta}{2}\norm{u}^2+ \frac{\gamma}{2}\norm{y-z}^2: \ \ \ Ay=Bu \right\}.
\end{equation*}</script>

<h4>Optimality conditions</h4>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
A\bar{y}=-\frac{1}{\beta}BB^*\hat{p} & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=shrink(A^*\hat{p}+\gamma z,\frac{\alpha_s}{\gamma}) & \left(\Omega \times \left(0,T\right)\right)\\
\bar{y}=0, \ \bar{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right).
\end{cases}
\end{equation*} %]]></script>

<p>Finally, we obtain a single equation in the dual variable $p$:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
A \ shrink(A^*\bar{p}+\gamma z,\frac{\alpha_s}{\gamma})=-\frac{1}{\beta}BB^*\bar{p} & \left(\Omega \times \left(0,T\right)\right)\\
\bar{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right).
\end{cases}
\end{equation*} %]]></script>

<h4>Numerical algorithm</h4>
<p>In order to compute a numerical solution of problem $\left(\mathcal{P}_s\right)$, after a discretization by finite differences, we use a prox-prox splitting on the Augmented Energy: first write the state as $y=A^{-1}Bu$, then</p>
<ul>
	<li> Proximal-point step:</li>
$$
	\begin{equation*}
	\begin{split}
	u_{k+1} &amp; =argmin_{u\in L^2} \left\{\frac{\beta}{2}\norm{u}^2 + \frac{\gamma}{2}\norm{A^{-1}Bu-z}^2+\frac{\delta}{2\lambda_k}\norm{A^{-1}Bu-y_k}^2 +\frac{1}{2\lambda_k}\norm{u-u_k}^2\right\}\\
	&amp; = \left[\left(\beta+\frac{1}{\lambda_k}\right)I+\left(\gamma+\frac{\delta}{\lambda_k}\right) B^*A^{-*}A^{-1}B\right]^{-1}\left[\frac{1}{\lambda_k}u_k+ B^*A^{-*}\left(\gamma z+\frac{\delta}{\lambda_k}y_k\right)\right].
	\end{split}
	\end{equation*}
$$

	<li> Proximal-point step:</li>
$$
	\begin{equation*}
	\begin{split}
	y_{k+1}&amp; =argmin_{y\in L^2} \left\{
	\alpha_s \norm{y}_{1} + \frac{\delta}{2\lambda_k}\norm{y-A^{-1}Bu_{k+1}}^2+\frac{1}{2\lambda_k}\norm{y-y_k}_{T}^2\right\}\\
	&amp; = shrink(\tilde{y}_k,\tilde{\lambda}_k),
	\end{split}
	\end{equation*}
$$

	where we defined

$$
	\begin{eqnarray*}
		\tilde{y}_k &amp; = &amp; \frac{y_k+\delta A^{-1}B u_{k+1}}{1+\delta};\\
		\tilde{\lambda}_k &amp; = &amp; \frac{\alpha_s \lambda_k}{1+\delta}.
	\end{eqnarray*}
$$

</ul>
<p><strong>Remark:</strong> Notice that again, when $\alpha_s=0$, the solution of $\left(\mathcal{P}_s\right)$ is simply given by</p>

<script type="math/tex; mode=display">\bar{u}=\gamma \left[\beta I+\gamma B^*A^{-*}A^{-1}B\right]^{-1}B^*A^{-*}z.</script>

<h3>Evolutionary problem</h3>
<h4>Optimality conditions</h4>
<p>Define the classical Lagrangian</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\mathcal{L}\left(u,y,p\right)&=J\left(u\right)+\langle p, Bu-y'-Ay\rangle_T.
\end{split}
\end{equation*} %]]></script>

<p>By integration by parts, we have</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\mathcal{L}\left(u,y,p\right)&=\frac{\beta}{2}\norm{u}^2_{T}+\alpha_s \norm{y}_{1,T} +  \frac{\gamma}{2}\norm{y-z}_{T}^2 + \langle B^*p, u\rangle_T \\
& \quad + \langle p'-A^*p,y\rangle_T + \langle p(0),y(0)\rangle - \langle p(T),y(T)\rangle.
\end{split}
\end{equation*} %]]></script>

<p>Deriving with respect to the three variables $\left(u,y,p\right)$, we obtain the optimality system:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
\hat{y}'+A\hat{y}=B\hat{u} & \left(\Omega \times \left(0,T\right)\right)\\
-\hat{p}'+A^*\hat{p}\in\gamma\left(\hat{y}-z\right)+\alpha_s \ \partial \norm{\cdot}_{1,T} \left(\hat{y}\right) & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=0, \ \hat{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
\hat{y}(0)=0, \ \hat{p}(T)=0 & \left(\Omega\right),
\end{cases}
\end{equation*} %]]></script>

<p>where the relation between the optimal control and the dual state is given by</p>

<script type="math/tex; mode=display">\begin{equation*}
\hat{u} = -\frac{1}{\beta}B^*\hat{p}.
\end{equation*}</script>

<p>The adjoint equation is equivalent to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{split}
\hat{y}&=\left(\gamma I+\alpha_s \ \partial \norm{\cdot}_{1,T} \right)^{-1}\left(-\hat{p}'+A^*\hat{p}+\gamma z\right)\\
&=shrink(-\hat{p}'+A^*\hat{p}+\gamma z,\frac{\alpha_s}{\gamma}).
\end{split}
\end{equation*} %]]></script>

<p>Finally,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation*}
\begin{cases}
\hat{y}'+A\hat{y}=-\frac{1}{\beta}B B^*\hat{p} & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=shrink(-\hat{p}'+A^*\hat{p}+\gamma z,\frac{\alpha_s}{\gamma}) & \left(\Omega \times \left(0,T\right)\right)\\
\hat{y}=0, \ \hat{p}=0 & \left(\partial\Omega\times \left(0,T\right)\right)\\
\hat{y}(0)=0, \ \hat{p}(T)=0 & \left(\Omega\right),
\end{cases}
\end{equation*} %]]></script>

<h4>Numerical algorithm</h4>
<p>In order to compute a numerical solution of problem $\left(\mathcal{P}_s\right)$, after a discretization by finite differences, we use a grad-prox splitting on the following Augmented Energy:</p>

<script type="math/tex; mode=display">\begin{equation*}
\mathcal{L}_{\lambda}\left(u,y\right)=\frac{\beta}{2}\norm{u}^2_{T}+\alpha_s \norm{y}_{1,T}+ \frac{\gamma}{2}\norm{Lu-z}_{T}^2+\frac{\delta}{2\lambda}\norm{Lu-y}_{T}^2.
\end{equation*}</script>

<p>Then,</p>
<ul>
	<li> Gradient step:</li>
$$
	\begin{equation*}
	\begin{split}
	u_{k+1} &amp; = u_k-\lambda_k \nabla_u \left[\frac{\beta}{2}\norm{u}^2_{T}+ \frac{\gamma}{2}\norm{Lu-z}_{T}^2+\frac{\delta}{2\lambda}\norm{Lu-y}_{T}^2 \right]\left(u_k\right) \\
	&amp; = u_k-\lambda_k \left[\beta u_k+\gamma L^*\left(Lu_k-z\right)+\frac{\delta}{\lambda_k}L^*\left(Lu_k-y_k\right)\right]\\
	&amp; = \left(1-\beta\lambda_k\right)u_k - B^*p_k,
	\end{split}
	\end{equation*}
$$

where

$$
	\begin{equation*}
	\begin{cases}
	y_{u_k}'+Ay_{u_k}=Bu_k &amp; \left(\Omega \times \left(0,T\right)\right)\\
	y_{u_k}=0 &amp; \left(\partial\Omega\times \left(0,T\right)\right)\\
	y_{u_k}(0)=0 &amp; \left(\Omega\right)
	\end{cases}
	\end{equation*}
$$

and

$$
	\begin{equation*}
	\begin{cases}
	-p_k'+A^* p_k =\left(\gamma \lambda_k + \delta\right)y_{u_k}-\gamma \lambda_k z - \delta y_k &amp; \left(\Omega \times \left(0,T\right)\right)\\
	p_k=0 &amp; \left(\partial\Omega\times \left(0,T\right)\right)\\
	p_k(T)=0 &amp; \left(\Omega\right).
	\end{cases}
	\end{equation*}
$$

<li> Proximal-point step:</li>

$$
	\begin{equation*}
	\begin{split}
	y_{k+1}&amp; =argmin_{y\in L^2_T} \left\{\alpha_s \norm{y}_{1,T} + \frac{\delta}{2\lambda_k}\norm{y-Lu_{k+1}}_T^2+\frac{1}{2\lambda_k}\norm{y-y_k}_{T}^2\right\}\\
	&amp; = shrink(\tilde{y}_k,\tilde{\lambda}_k),
	\end{split}
	\end{equation*}
$$

where we defined
$$
	\begin{eqnarray*}
	\tilde{y}_k &amp; = &amp; \frac{y_k+\delta L u_{k+1}}{1+\delta};\\
	\tilde{\lambda}_k &amp; = &amp; \frac{\alpha_s \lambda_k}{1+\delta}.
	\end{eqnarray*}
$$
<ul>
<strong>Remark: </strong>Another possibility is to consider
$$
	\begin{equation*}
	\mathcal{L}_{\lambda}\left(u,y\right)=\frac{\beta}{2}\norm{u}^2_{T}+\alpha_s \norm{y}_{1,T}+ \frac{\gamma}{2}\norm{y-z}_{T}^2+\frac{\delta}{2\lambda}\norm{Lu-y}_{T}^2.
	\end{equation*}
$$

<h3>Computational experiments</h3>
In the following, we present the setting for the numerical experiments.
<ul>
	<li> Spacial domain: $\Omega=\left(0,1\right)$;</li>
	<li> Time interval: $\left[0,T\right]$, with $T=1$;</li>
	<li> Weight-parameters: $\alpha_c=[0, 0.01]$, $\alpha_s=[0, 0.65]$, $\beta=0.0001$ and $\gamma=1$;</li>
	<li> Trajectory target: $$z(x)=\mathcal{I}_{\left[x_a,x_b\right]},$$ where $x_a=1.7/3$, $x_b=3.5/4$;</li>
	<li> Control operator: for $x_1=1/7$ and $x_2=4/5$,
$$B=\mathcal{I}_{\left[x_1,x_2\right]};$$
    </li>

	<li> $A$ is the finite difference discretization of $-\Delta$;</li>
	<li> Numerical grid: $N_x=300$ in space, $N_t=100$ in time.</li>
</ul>
<h3>Stationary solutions</h3>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/uy_alphazero_staz.jpg" alt="Figure 1" width="600" /> Figure 1: $\alpha_c=\alpha_s=0$.  

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/uy_alpha_staz.jpg" alt="Figure 2" width="600" /> Figure 2: $\alpha_c=0.01$, $\alpha_s=0$.  

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/uy_alpha_staz-1.jpg" alt="Figure 3" width="600" /> Figure 3: $\alpha_c=0$, $\alpha_s=0.65$.

<h3>Evolutionary problem</h3>  
<h4>Optimal control</h4>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/u_alphazero_ev.jpg" alt="Figure 4 TOP" width="600" />Figure 4a: Optimal control for $\alpha_c=\alpha_s=0$. In red, the controllable subdomain; in blue, the stationary optimal controls.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/u_alpha_tot.jpg" alt="Figure 4 MIDDLE" width="600" />Figure 4b: Optimal control for $\alpha_c=0.01$, $\alpha_s=0$. In red, the controllable subdomain; in blue, the stationary optimal controls.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/u_alpha_tot-1.jpg" alt="Figure 4 BOTTOM" width="600" /> Figure 4c: Optimal control for $\alpha_c=0$, $\alpha_s=0.65$. In red, the controllable subdomain; in blue, the stationary optimal controls.
<h4>Optimal state</h4>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/y_alphazero_ev.jpg" alt="Figure 5 TOP" width="600" />Figure 5a: Optimal state for $\alpha_c=\alpha_s=0$ . In red, the target $z$; in blue, the stationary optimal states.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/y_alpha_tot.jpg" alt="Figure 5 MIDDLE" width="600" />Figure 5b: Optimal state for $\alpha_c=0.01$, $\alpha_s=0$. In red, the target $z$; in blue, the stationary optimal states.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/y_alpha_tot-1.jpg" alt="Figure 5 BOTTOM" width="600" /> Figure 5c: Optimal state for $\alpha_c=0$, $\alpha_s=0.65$. In red, the target $z$; in blue, the stationary optimal states.
<h4>Optimal adjoint</h4>
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/p_alphazero_ev.jpg" alt="Figure 6 TOP" width="600" />Figure 6a: Optimal adjoint for $\alpha_c=\alpha_s=0$.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/p_alpha_tot.jpg" alt="Figure 6 MIDDLE" width="600" />Figure 6b: Optimal adjoint for $\alpha_c=0.01$, $\alpha_s=0$.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/07/p_alpha_tot-1.jpg" alt="Figure 6 BOTTOM" width="600" /> Figure 6c: Optimal adjoint for $\alpha_c=0$, $\alpha_s=0.65$.

<h4>Bibliography</h4>
<strong>[1]</strong> Peypouquet, J. <a href="http://jpeypou.mat.utfsm.cl/wp-content/uploads/2014/05/Convex-Optimization.pdf"><em>Convex optimization in normed spaces: theory, methods and examples. With a foreword by Hedy Attouch.</em></a> Springer Briefs in Optimization. Springer, Cham, 2015. xiv+124 pp.
</ul></ul>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;This is a set of Matlab functions to interpolate scattered data with Radial Basis Functions (RBF).&lt;/p&gt;
</code></pre>
</div>

<p align="center">
  <img src="https://latex.codecogs.com/gif.latex?F%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29%20%3D%20%5Csum_%7Bj%3D1%7D%5EN%20%5Cgamma_j%20%5Cvarphi%20%5Cleft%28%20%5C%7C%20%5Cmathbf%7Bx%7D%20-%20%5Cmathbf%7Bx%7D_%7Bs%2C%20j%7D%20%5C%7C_%7B%5Cmathbb%7BR%7D%5Ed%7D%20%5Cright%29%20&plus;%20p%20%5Cleft%28%20%5Cmathbf%7Bx%7D%20%5Cright%29" />
</p>

<h2 id="getting-started">Getting Started</h2>

<pre><code class="language-Matlab">y = RBFinterp(xs, ys, x, RBFtype, R)
</code></pre>
<p>interpolates to find y, the values of the function y=f(x) at the points x.</p>

<p>Xs must be a matrix of size [N,Dx], with N the number of data points and Dx the dimension of the points in xs and x.</p>

<p>Ys must be a matrix of size [N,Dy], with N the number of known values at points in Xs, and Dy the dimension of the y values.</p>

<p>X must be a matrix of size [M,Dx], with M the number of query points.</p>

<p>RBFtype specifies the radial basis functions (RBF) to be used.</p>

<ul>
  <li>The available global support RBFs are:
    <ul>
      <li>‘R1’    - linear spline</li>
      <li>‘R3’    - cubic spline</li>
      <li>‘TPS2’  - thin plate spline</li>
      <li>‘Q’     - quadric</li>
      <li>‘MQ’    - multiquadric</li>
      <li>‘IMQ’   - inverse multiquadric</li>
      <li>‘IQ’    - inverse quadric</li>
      <li>‘GS’    - Gauss</li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">RBF name</th>
      <th style="text-align: center">Abbreviation</th>
      <th style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cvarphi%20%5Cleft%28%20r%20%5Cright%29" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Linear spline</td>
      <td style="text-align: center">R1</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cepsilon%20r" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Cubic splie</td>
      <td style="text-align: center">R3</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%5E3" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Thin plate spline</td>
      <td style="text-align: center">TPS2</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%5E2%20%5Clog%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%24" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Quadric</td>
      <td style="text-align: center">Q</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?1%20&plus;%20%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%5E2" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Multiquadric</td>
      <td style="text-align: center">MQ</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Csqrt%7B1%20&plus;%20%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%20%5E2%7D" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Inverse multiquadric</td>
      <td style="text-align: center">IMQ</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B%5Csqrt%7B1%20&plus;%20%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%20%5E2%7D%7D" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Inverse quadric</td>
      <td style="text-align: center">IQ</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B%201%20&plus;%20%5Cleft%28%20%5Cepsilon%20r%20%5Cright%29%20%5E2%20%7D" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Gauss</td>
      <td style="text-align: center">GS</td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?e%5E%7B-%5Cleft%28%5Cepsilon%20r%20%5Cright%29%5E2%7D" /></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>The available compact support RBFs are (see Wendland H., Konstruktion und Untersuchung radialer Basisfunktionen mit kompaktem Träger. PhD  thesis, Göttingen, Georg-August-Universität zu Göttingen, Diss, 1996):
    <ul>
      <li>‘CP_C0’</li>
      <li>‘CP_C2’</li>
      <li>‘CP_C4’</li>
      <li>‘CP_C6’</li>
      <li>‘CTPS_C0’</li>
      <li>‘CTPS_C1’</li>
      <li>‘CTPS_C2a’</li>
      <li>‘CTPS_C2b’</li>
    </ul>
  </li>
</ul>

<p>Compact support functions have the form</p>

<p align="center">
	<img src="https://latex.codecogs.com/gif.latex?%5Cvarphi%20%5Cleft%28%20%5Cxi%20%3D%20%5Cfrac%7Br%7D%7BR%7D%20%5Cright%29%20%3D%20%5Cbegin%7Bcases%7D%20f%20%5Cleft%28%20%5Cxi%20%5Cright%29%2C%20%26%200%20%5Cleq%20%5Cxi%20%5Cleq%201%20%5C%5C%200%2C%20%26%20%5Cxi%20%3E%201%20%5Cend%7Bcases%7D" />
</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">RBF name</th>
      <th style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cvarphi%20%5Cleft%28%20%5Cxi%20%5Cright%29" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCP%20%7D%20%5Cmathcal%7BC%7D%5E0" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%201%20-%20%5Cxi%20%5Cright%29%5E2" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCP%20%7D%20%5Cmathcal%7BC%7D%5E2" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%201%20-%20%5Cxi%20%5Cright%29%5E4%20%5Cleft%28%204%20%5Cxi%20&plus;%201%20%5Cright%29" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCP%20%7D%20%5Cmathcal%7BC%7D%5E4" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%201%20-%20%5Cxi%20%5Cright%29%5E6%20%5Cleft%28%20%5Cfrac%7B35%7D%7B3%7D%20%5Cxi%5E2%20&plus;%206%20%5Cxi%20&plus;%201%20%5Cright%29" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCP%20%7D%20%5Cmathcal%7BC%7D%5E6" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%201%20-%20%5Cxi%20%5Cright%29%5E8%20%5Cleft%28%2032%20%5Cxi%5E3%20&plus;%2025%20%5Cxi%5E2%20&plus;%208%20%5Cxi%20&plus;%201%20%5Cright%29" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCTPS%20%7D%20%5Cmathcal%7BC%7D%5E0" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Cleft%28%201%20-%20%5Cxi%20%5Cright%29%5E5" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCTPS%20%7D%20%5Cmathcal%7BC%7D%5E1" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?1%20&plus;%20%5Cfrac%7B80%7D%7B3%7D%20%5Cxi%5E2%20-%2040%20%5Cxi%5E3%20&plus;%2015%20%5Cxi%5E4%20-%20%5Cfrac%7B8%7D%7B3%7D%20%5Cxi%5E5%20&plus;%2020%20%5Cxi%5E2%20%5Clog%20%5Cxi" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCTPS%20%7D%20%5Cmathcal%7BC%7D%5E2_a" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?1%20-%2030%20%5Cxi%5E2%20-%2010%20%5Cxi%5E3%20&plus;%2045%20%5Cxi%5E4%20-%206%20%5Cxi%5E5%20-%2060%20%5Cxi%5E3%20%5Clog%20%5Cxi" /></td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?%5Ctext%7BCTPS%20%7D%20%5Cmathcal%7BC%7D%5E2_b" /></td>
      <td style="text-align: center"><img src="https://latex.codecogs.com/gif.latex?1%20-%2020%20%5Cxi%5E2%20&plus;%2080%20%5Cxi%5E3%20-%2045%20%5Cxi%5E4%20-%2016%20%5Cxi%5E5%20&plus;%2060%20%5Cxi%5E4%20%5Clog%20%5Cxi" /></td>
    </tr>
  </tbody>
</table>

<p>R is either the support radius for the compact support RBFs or a parameter to make the distance values dimensionless for the global support RBFs.</p>

<pre><code class="language-Matlab">[fPar, M] = RBFparam(xs, ys, RBFtype, R)
</code></pre>

<p>returns the weights in the RBF summation and the polynomial coefficients in a column vector fPar by solving a linear system</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7BM%7D%20%26%20%5Cmathbf%7BP%7D_s%20%5C%5C%20%5Cmathbf%7BP%7D_s%5ET%20%26%20%5Cmathbf%7B0%7D%20%5Cend%7Bpmatrix%7D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7B%5Cgamma%7D%20%5C%5C%20%5Cmathbf%7B%5Cbeta%7D%20%5Cend%7Bpmatrix%7D%20%3D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7Bf%7D_s%20%5C%5C%20%5Cmathbf%7B0%7D%20%5Cend%7Bpmatrix%7D" />
</p>

<pre><code class="language-Matlab">[y] = RBFeval(xs, x, fPar, RBFtype, R)
</code></pre>

<p>returns the values of the interpolation weighted function at points x by performing the matrix-vector product</p>

<p align="center">
    <img src="https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bf%7D%20%3D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7B%5Chat%7BM%7D%7D%20%26%20%5Cmathbf%7B%5Chat%7BP%7D%7D%20%5Cend%7Bpmatrix%7D%20%5Cbegin%7Bpmatrix%7D%20%5Cmathbf%7B%5Cgamma%7D%20%5C%5C%20%5Cmathbf%7B%5Cbeta%7D%20%5Cend%7Bpmatrix%7D" />
</p>

<h2 id="running-the-example">Running the example</h2>

<p>An example case can be run just by typing in the Matlab command line</p>

<pre><code class="language-Matlab">test
</code></pre>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/RBF-interp/master/test.png" />
</p>

<p align="center">
   <img src="https://raw.githubusercontent.com/ChairOfComputationalMathematics/RBF-interp/master/test2.png" />
</p>

<h2 id="references">References</h2>

<ul>
  <li>Beckert, Armin and Wendland, Holger. Multivariate interpolation for fluid-structure-interaction problems using radial basis functions. <em>Aerospace Science and Technology</em>, 5 (2), p. 125-134, 2001.</li>
  <li>Wendland, Holger. <em>Konstruktion und Untersuchung radialer Basisfunktionen mit kompaktem Träger}</em>. PhD thesis, Göttingen, Georg-August-Universität zu Göttingen, Diss, 1996.</li>
  <li>De Boer, A and Van der Schoot, MS and Bijl, Hester. Mesh deformation based on radial basis function interpolation. <em>Computers &amp; structures</em>, 85 (11-14), p. 784-795, 2007.</li>
  <li>Biancolini, Marco Evangelos. <em>Fast Radial Basis Functions for Engineering Applications</em>. Springer, 2018.</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;We design a LQR controller for stabilyzing the fractional reaction diffusion equation&lt;/p&gt;
</code></pre>
</div>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases} y_t + (-d_x^2)^s y-\delta y = u\chi_\omega, & (x,t) \in(-L,L)\times(0,T) \\ y = 0, & (x,t)\in [\mathbb{R}\setminus(-L,L)]\times(0,T) \\ y(x,0) = y_0(x), & x\in(-L,L), \end{cases} %]]></script>

<p>where $\delta&gt;0$ is a given constant, $\omega = (a,b)\subset(-L,L)$ and $(-d_x^2)^s$, $s\in(0,1)$ denotes the one-dimensional fractional Laplacian defined as</p>

<script type="math/tex; mode=display">(-d_x^2)^s y(x) = c(s) P.V. \int_{\mathbb{R}} \frac{y(x)-y(z)}{\vert x-z\vert^{1+2s}}dz,</script>

<p>with $c(s)$ an explicit normalization constant.</p>

<p>When considering this equation without the action of the the control $u$, we know that, depending on the value of $\delta$, the corresponding dynamics may become unstable. This is due to the fact that the eignenvalues of the associated elliptic problem are given by $\mu_k=c-\lambda_k$ ($\lambda_k$ being the eigenvalues of the fractional Laplacian on $(-L,L)$ with zero Dirichlet boundary conditions), and they are positive if $c&gt;\lambda_1$ (since, in addition, we know that $\lambda_1&lt;\lambda_k$ for all $K$). We are then intersted in designing a LQR control which is able to stabilyze this solution and prevent its blow-up.</p>

<p>The computation of the LQR control is carried out by means of the following procedure:</p>

<h2 id="step-1-discretization-of-the-equation">STEP 1. Discretization of the equation</h2>

<p>We start by discretizing our original system on a uniform mesh $x_i$, $i=1,\ldots,N$, thus obtaining a N-dimensional system of the type</p>

<script type="math/tex; mode=display">\begin{cases} \dot{y} = Ay+Bu \\ y(0) = y_0 \end{cases}</script>

<p>where:</p>

<ul>
  <li>
    <p>with some abuse of notation, we denoted $y\in\mathbb{R}^N$ as the   $N$-dimensional vector whose entries $y_i=y(x_i)$, $i=1,\ldots,N$ are   the evaluation of the function $y$ on the points of the mesh;</p>
  </li>
  <li>
    <p>the matrix $A$ is a discretization of the operator $-(-d_x^2)^s + I$,   $I$ denoting the identity;</p>
  </li>
  <li>
    <p>the matrix $B$ defines the action of the control.</p>
  </li>
</ul>

<p>The computation of the matrix requires the discretization of the fractional Laplacian $(-d_x^2)^s$. This is done by employing the function “fl_rigidity”, which implements a finite elements method on a uniform mesh discretizing the space interval $(-L,L)$ (complete details on this method may be found in [1]).</p>

<p>The function “fl_rigidity” works by requiring 3 input parameters:</p>

<ul>
  <li>
    <p>s: the order of the fractional Laplacian, which can be any real value      in the interval $(0,1)$;</p>
  </li>
  <li>
    <p>L: any real value, defining the extrema of the space interval $(-L,L)$;</p>
  </li>
  <li>
    <p>N: the number of discretization points in the mesh employed.</p>
  </li>
</ul>

<p>The outputs are:</p>

<ul>
  <li>
    <p>x: the vector containing the mesh;</p>
  </li>
  <li>
    <p>A: the matrix discretizing the fractional Laplacian.</p>
  </li>
</ul>

<p>The matrix B, instead, is constructed by employing the function “construction_matrix_B”, which takes in input</p>

<ul>
  <li>
    <p>the vector $x$ containing the mesh;</p>
  </li>
  <li>
    <p>the number of discretization points $N$;</p>
  </li>
  <li>
    <p>the characteristic function of the sub-interval $\omega$.</p>
  </li>
</ul>

<h2 id="step-2-definition-of-the-cost-functional-and-computation-of-the-control">STEP 2. Definition of the cost functional and computation of the control</h2>

<p>Once we have the semi-discretization of our original problem, the control we are looking for is computed by minimizing the following cost functional</p>

<script type="math/tex; mode=display">J_{\infty} = \int_{0}^{+\infty} \Big(y^TQy + u^TRu\Big)dt,</script>

<p>where $Q\geq 0$ and $R&gt;0$ are given matrices. Moreover, we know that this control is given in a feedback form by $u^*=-R^{-1}B^TPy$, where $P$ is the solution of the algebraic Riccati equation</p>

<script type="math/tex; mode=display">PA + A^TP-PBB^TP+Q = 0.</script>

<h2 id="implementation">Implementation</h2>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">clear</span> <span class="nb">all</span>
<span class="nb">clc</span>
</code></pre>
</div>

<p>We start by defining the parameter $s\in(0,1)$ (order of the fractional Laplacian), the size of the interval $(-L,L)$, the constant $\delta&gt; \lambda_1$ and the number $N$ of discretization points in our mesh.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="nb">pi</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mf">0.1</span><span class="p">;</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</code></pre>
</div>

<p>and we compute the corresponding approximation of the fractional Laplacian</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">FL</span><span class="p">]</span> <span class="o">=</span> <span class="n">fl_rigidity</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
</code></pre>
</div>

<p>We then use it for building the matrix $A$ describing the dynamics</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">D</span> <span class="o">=</span> <span class="n">d</span><span class="o">*</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">FL</span><span class="o">+</span><span class="n">D</span><span class="p">;</span>
</code></pre>
</div>

<p>Secondly, we use the function “construction_matrix_B” for computing the control operator $B$ on the interval $\omega=(-0.3,0.5)$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">matrix_B</span> <span class="o">=</span>  <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">interval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.5</span><span class="p">);</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">construction_matrix_B</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">matrix_B</span><span class="p">);</span>
</code></pre>
</div>

<p>Out of the matrices $A$ and $B$, we solve the algebraic Riccati equation by employing the specific function from the control systems toolbox of Matlab. For simplicity, we choose both $R$ and $Q$ as the identity, but other choices are possible in order to improve the efficiency of the method.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">R</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="n">Q</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="p">[</span><span class="n">P</span><span class="p">,</span><span class="n">cleig</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">report</span><span class="p">]</span> <span class="o">=</span> <span class="n">care</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="nb">eye</span><span class="p">(</span><span class="n">N</span><span class="p">));</span>
</code></pre>
</div>

<p>The output matrix $K=-R^{-1}B^TP$ is used for defining the action of the control and include it in our system</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">f_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="n">K</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">eq_ctr</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">f_ctr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</code></pre>
</div>

<p>Finally, we choose an initial datum</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">y0</span> <span class="o">=</span> <span class="nb">cos</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
</code></pre>
</div>

<p>and we solve our equation with and without control employing the “ode45” function of Matlab. For the equation without control we choose a relatively short time horizon, since we know that the unstable dynamics will rapidly diverge. For the equation with control, instead, we choose a longer time horizon in order to have enough time for stabilyzing the system.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="n">T1</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">T2</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
<span class="n">tspan1</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="n">tspan2</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">Nt</span><span class="p">);</span>
<span class="n">eq_free</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">[</span><span class="n">time1</span><span class="p">,</span> <span class="n">sol_free</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">eq_free</span><span class="p">,</span><span class="n">tspan1</span><span class="p">,</span><span class="n">y0</span><span class="p">);</span>
<span class="p">[</span><span class="n">time2</span><span class="p">,</span> <span class="n">sol_ctr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode45</span><span class="p">(</span><span class="n">eq_ctr</span><span class="p">,</span><span class="n">tspan2</span><span class="p">,</span><span class="n">y0</span><span class="p">);</span>
</code></pre>
</div>

<p>We then plot our results and compare them. Firstly, the free dynamics.</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">surf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">time1</span><span class="p">,</span><span class="n">sol_free</span><span class="p">)</span>
<span class="nb">colormap</span> <span class="n">jet</span>
<span class="n">msol_free</span> <span class="o">=</span> <span class="nb">floor</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">sol_free</span><span class="p">)));</span>
<span class="n">Msol_free</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">sol_free</span><span class="p">)));</span>
<span class="n">xticks</span><span class="p">([</span><span class="o">-</span><span class="n">L</span> <span class="n">L</span><span class="p">])</span>
<span class="n">yticks</span><span class="p">([</span><span class="mi">0</span> <span class="n">T1</span><span class="p">])</span>
<span class="n">zticks</span><span class="p">([</span><span class="n">msol_free</span> <span class="n">Msol_free</span><span class="p">])</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">135</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Free unstable dynamics'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0001/copiaRM_01.png" alt="" /></p>

<p>We clearly see the growth of the solution, already in the short time horizon [0,4]. When introducing the LQR control, instead, the problem is corrected and the equation is stabilyzed in time $T_2$</p>

<div class="language-matlab highlighter-rouge"><pre class="highlight"><code><span class="nb">surf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">time2</span><span class="p">,</span><span class="n">sol_ctr</span><span class="p">)</span>
<span class="nb">colormap</span> <span class="n">jet</span>
<span class="n">msol_ctr</span> <span class="o">=</span> <span class="nb">floor</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">sol_ctr</span><span class="p">)));</span>
<span class="n">Msol_ctr</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">sol_ctr</span><span class="p">)));</span>
<span class="n">xticks</span><span class="p">([</span><span class="o">-</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">])</span>
<span class="n">yticks</span><span class="p">([</span><span class="mi">0</span> <span class="n">T2</span><span class="p">])</span>
<span class="n">zticks</span><span class="p">([</span><span class="n">msol_ctr</span> <span class="n">Msol_ctr</span><span class="p">])</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">135</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Controlled dynamics'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="https://deustotech.github.io/DyCon-Blog/assets/imgs/DP00/P0001/copiaRM_02.png" alt="" /></p>

<h2 id="references">References</h2>

<p>[1] U. Biccari and V. Hernandez-Santamaria, “Controllability of a one-dimensional fractional heat equation: theoretical and nuerical aspects”, IMA J. Math. Control I. (2018).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3&gt;Featured Video&lt;/h3&gt;
</code></pre>
</div>

<p><i>Evolution of the controls and of the state for $y^0=1$, $y^1=5$, $M=20$ and the discretization parameters $N_x=30$, $N_t=450$ in the minimal computed time $T\simeq\mathtt{0.2093}$.</i></p>
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>

<h3>Introduction</h3>

<p>In this short tutorial we explain how to use IpOpt in order to solve time optimal control problems. We refer to [<a href="#cite1">1</a>,<a href="#cite4">4</a>,<a href="#cite5">5</a>] for a survey on numerical methods in optimal control and how to implement them efficiently according to the context.</p>
<h4>The tools</h4>
<ul>
 	<li><a href="https://projects.coin-or.org/Ipopt" target="_blank" rel="noopener noreferrer">IpOpt</a> is an interior-point optimization routine (see <a href="#IPOPT">[6]</a>).
Basically, it numerically solves optimisation problems of the form:                                   

$$
\begin{equation}\label{eq:P0}\tag{P0}
			\begin{array}{cl}
				\min &amp; f(x)\\
				 &amp; \begin{array}{l}
					x\in\mathbb{R}^n\, ,\\
					g(x)\leqslant 0\, ,\\
					h(x)=0\, .
				\end{array}
			\end{array}
		\end{equation}

$$

IpOpt can be used together with <a href="https://www.mathworks.com/products/matlab.html" target="_blank" rel="noopener noreferrer">Matlab</a>, <a href="http://www.freefem.org" target="_blank" rel="noopener noreferrer">FreeFem++</a>...and can be used directly in <strong>.cpp</strong> codes.</li>
 	<li><a href="http://ampl.com/" target="_blank" rel="noopener noreferrer">AMPL</a> is an automatic differentiation and the modelling language (see <a href="#AMPL">[2]</a>). The interest of using AMPL together with IpOpt is that, the gradient of the cost function and the constraints is automatically generated. Solving problems with IpOpt and AMPL can be made online through the <a href="https://neos-server.org/neos/solvers/nco:Ipopt/AMPL.html" target="_blank" rel="noopener noreferrer">NEOS</a> solvers.</li>
</ul>
<h4>Solving problem (P0)</h4>
<p>Let us write in AMPL language the problem (P0).</p>
<pre><span style="color: green;"># The variable of the problem</span>
<b>var</b> x {i in 1..n}
<span style="color: green;"># The cost function to be minimized</span>
<b>minimize</b> cost : f(x); 						 
<span style="color: green;"># The inequality constraints</span>
<b>subject to</b> inequality_constraints : g(x)&lt;=0;
<span style="color: green;"> # The equality constraints</span>
<b>subject to</b> equality_constraints: h(x)=0; 	
<span style="color: green;"> # Set IpOpt as solver</span>
<b>option solver</b> ipopt;						 
<span style="color: green;"># Set options for IpOpt, such as the maximal number of iterations</span>
<b>option</b> ipopt_options <span style="color: brown;">"max_iter=20000 linear_solver=mumps halt_on_ampl_error yes"</span>;
<span style="color: green;"># Solve the problem</span>
<b>solve</b>;
<span style="color: green;"># Display the cost value</span>
<b>printf</b> : <span style="color: brown;">"# cost = %24.16e\n"</span>, cost;		
<b>printf</b> : <span style="color: brown;">"# Data\n"</span>;
<span style="color: green;"># Display the optimal values of x</span>
<b>printf</b> {i in 0..n} : <span style="color: brown;">"%24.16e\n"</span>, x[i];		
<span style="color: green;"># Quit AMPL</span>
<b>end</b>;										
</pre>
<h4>Solving a time optimal control problem with constraints</h4>
<p>Let us now turn to a time optimal control problem.
Given a dynamical system,</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:1a}
\dot{y}=f(y,u)\, ,
\end{equation}</script>

<p>some initial condition $\mathrm{y}^0\in \mathbb{R}^n$ and some terminal condition $\mathrm{y}^1\in\mathbb{R}^n$ and some bound $M&gt;0$, the aim is to find the minimal time $T\geqslant 0$ such that there exist a control $u\in L^\infty(0,T)^m$ such that,</p>

<script type="math/tex; mode=display">\begin{equation}
|u_i(t)|\leqslant M  (t\in(0,T)\ \text{a.e.}\, ,\ i\in\{1,\dots,m\}),
\end{equation}</script>

<p>and the solution $y$ of (1) satisfies the constraint,</p>

<script type="math/tex; mode=display">\begin{equation}
g(y(t))\leqslant 0 (t\in(0,T)),
\end{equation}</script>

<p>and the terminal condition,</p>

<script type="math/tex; mode=display">\begin{equation}
y(T)=\mathrm{y}^1\, ,
\end{equation}</script>

<p>where $g$ is given and define constraints of the state variable $y$. Of course to be able to solve this system, one needs to have $g(\mathrm{y}^0)\leqslant0$ and $g(\mathrm{y}^1)\leqslant0$.
The above optimal control problem, can be recast as an optimisation problem under constraints similar to (P0). More precisely, it is</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array}{cl}
	\min & T\\
	 & \begin{array}{l}
		u\in L^\infty(0,T)^M\, ,\\
		\dot{y}=f(y,u)\, , y(0)=\mathrm{y}^0\, ,\\
		y(T)=\mathrm{y}^1\, ,\\
		g(y(t))\leqslant 0 (t\in(0,T)).
	\end{array}
\end{array} %]]></script>

<p>In order to handle numerically, this problem, we will use a time discretization. Let us explain it with the explicit Euler method. But any other time discretization can be used.
Fix some parameter $N_t\in\mathbb{N}^*$ (the number of time steps) and for $T&gt;0$ given, define $y_i$ the estimation of $y(iT/N_t)$ for $i\in{0,\dots,N_t}$. The explicit Euler scheme, gives the relation,</p>

<script type="math/tex; mode=display">y_{i+1}=y_i+\frac{T}{N_t}f(y_i,u_i)\, ,</script>

<p>with $u_i\simeq u(iT/N_t)$. Then the state and control constraints are replaced by:</p>

<script type="math/tex; mode=display">g(y_i)\leqslant 0 \text{and} |u_i|\leqslant M\, .</script>

<p>Consequently, in discretized version, we end up with a finite dimensional control problem under constraints, whose AMPL version is:</p>
<pre><span style="color: green;"># Define the parameters of the problem</span>
<span style="color: green;"># number of time step discretization points</span>
<b>param</b> Nt=100;
<span style="color: green;"># bound on the control</span>
<b>param</b> M =1;   
<span style="color: green;"># initial condition</span>
<b>param</b> y0=1;
<span style="color: green;"># final condition</span>
<b>param</b> y1=0;

<span style="color: green;"># Define variables of the problem</span>
<b>var</b> y {i in 0..Nt};
<span style="color: green;"># The control shall be in [-M,M]</span>
<b>var</b> u {i in 0..Nt} &gt;=M, &lt;=M;  
<span style="color: green;"># The time T shall be nonnegative</span>
<b>var</b> T &gt;=0;                    

<span style="color: green;"># The cost function is the time T</span>
<b>minimize</b> cost: T;
<span style="color: green;"># Set the constraints</span>
<span style="color: green;"># y is solution of (1)</span>
<b>subject to</b> y_dyn {i in 0..Nt-1} :                        
		y[i+1]=y[i]+T/Nt*f(y[i],u[i]);
<span style="color: green;"># y(0)=y0</span>
<b>subject to</b> y_init : y[0] =y0;                            
<span style="color: green;"># y(T)=y1</span>
<b>subject to</b> y_end  : y[Nt]=y1;                            
<span style="color: green;"># g(y(t))&lt;=0</span>
<b>subject to</b> state_constraint {i in 1..Nt-1} : g(y[i])&lt;=0;

<span style="color: green;"># Solve with IpOpt</span>
<b>option solver</b> ipopt;
<b>option</b> ipopt_options <span style="color: brown;">"max_iter=20000 linear_solver=mumps halt_on_ampl_error yes"</span>;
<b>solve</b>;
<span style="color: green;"># Display solution</span>
<b>printf</b> : <span style="color: brown;">"# T = %24.16e\n"</span>, T;
<b>printf</b> : <span style="color: brown;">"# Nt = %d\n"</span>, Nt;
<b>printf</b> : <span style="color: brown;">"# Data\n"</span>;
<b>printf</b> {i in 0..Nt} : <span style="color: brown;">" %24.16e\n"</span>, u[i];
<b>printf</b> {i in 0..Nt} : <span style="color: brown;">" %24.16e\n"</span>, y[i];
<b>end</b>;
</pre>
<h4>Application to the constrained heat equation</h4>
<p>Now we can turn to the control of the heat equation with nonnegative state constraint.
To this end, we consider the controlled 1D heat equation with Neumann boundary control.</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc2}
\left\{
\begin{array}{r@{\>}l@{}l}
\dot{y}(t,x)  =\partial_x^2y(t,x)  (t>0\, ,\ x\in(0,1)),\\[2mm]
\partial_xy(t,0)  =v_0(t)  (t>0),\\[2mm]
\partial_xy(t,1)  =v_1(t)  (t>0),
\end{array}
\right.
\end{equation}</script>

<p>To this problem, we add the control constraints,</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc2CC}
|v_0(t)|\leqslant M \text{and} |v_1(t)|\leqslant M (t>0\ \text{a.e.}),
\end{equation}</script>

<p>with some $M&gt;0$ given and we add the state constraint,</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc2SC}
y(t,x)\geqslant 0 ( (t,x)\in \mathbb{R}_+^*\times(0,1)\ \text{a.e.}).
\end{equation}</script>

<p>To the system (5) we add the initial condition</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc2IC}
y(0,x)=y^0(x) (x\in(0,1)),
\end{equation}</script>

<p>and the terminal condition</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc2TC}
y(T,x)=y^1(x) (x\in(0,1)).
\end{equation}</script>

<p>In <a href="#LTZheat">[3]</a>, it has been proved that every positive constant state $\mathrm{y}^0$ can be steered to some over positive constant state $\mathrm{y}^1$ in a large enough time $T$. Our goal here is to find numerically the minimal time $T$ such there exist controls satisfying (6) such that the corresponding solution $y$ of (5) and (8) satisfies the constraint (6) and the terminal condition (9), i.e.~ we aim to minimize</p>

<script type="math/tex; mode=display">\begin{array}{cl}
\min  T\\
  \begin{array}{l}
T>0\, ,\\
v_0,\, v_1\in L^\infty(0,T)\, ,
y \text{ solution of (5) and (8) satisfies}\\
 y(T,\cdot)=y^1 \text{and} y(t,x)\geqslant 0 (t>0,\ x\in(0,1)\ $\text{a.e.}$).
\end{array}
\end{array}</script>

<p>Firstly, we will use a space discretization to reduce the system (5). To this end, we define $N\in\mathbb{N}^*$ and for every $n\in{0,\dots,N}$, $x_n=\frac{n}{N}$. Based on this discretization of $[0,1]$, we will discretized (5) using centered finite differences. That is to say, given $V(t)=(v_0(t)\, ,\ v_1(t))^\top$ and $Y(t)\in \mathbb{R}^{N+1}$, a vector approaching $\bigl( y(t,x_0),\ \dots,\ y(t,x_N)\bigr)^\top$, $Y$ is solution of</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc3a}
	\dot{Y}=AY+BV (t>0)\, ,
\end{equation}</script>

<p>with the initial condition</p>

<script type="math/tex; mode=display">\begin{equation}
	Y(0)=\mathrm{y}^0e_{N+1}
\end{equation}</script>

<p>the target state,</p>

<script type="math/tex; mode=display">\begin{equation}
	Y(T)=\mathrm{y}^1e_{N+1}
\end{equation}</script>

<p>the state constraint,</p>

<script type="math/tex; mode=display">\begin{equation}
	Y(t)\geqslant 0  (t>0\ \text{a.e.})
\end{equation}</script>

<p>and the control constraint,</p>

<script type="math/tex; mode=display">\begin{equation}
	|V_0(t)|\leqslant M\text{and} |V_1(t)|\leqslant M (t>0\ \text{a.e.})\, ,
\end{equation}</script>

<p>where we have set $e_{N+1}=(1,\dots,1)^\top\in\mathbb{R}^{N+1}$,</p>

<script type="math/tex; mode=display">% <![CDATA[
A=N^2\begin{pmatrix}
2 & -2  & 0 & \hdots &\hdots & \hdots & 0\\
1 & -2  & 1 & 0  & \hdots &  \hdots & 0\\
0 & \ddots & \ddots &  \ddots &  \ddots  & \vdots\\
\vdots & \ddots & \ddots  & \ddots & \ddots & \ddots & \vdots\\
\vdots & \ddots & \ddots & \ddots  & \ddots & 0\\
0  & \hdots & \hdots & 0 & 1 & -2 & 1\\
0  & \hdots & \hdots & \hdots & 0  &2 & -2\\
\end{pmatrix}\in M_{N+1}(R)\text{and} B=2N\begin{pmatrix}
1 & 0\\
0 & \vdots\\
\vdots & \vdots\\
\vdots & \vdots\\
\vdots & \vdots\\
\vdots& 0\\
0  &  1
\end{pmatrix}\in M_{N+1,2}(\mathbb{R})\, . %]]></script>

<p>Now we can discretize (10) using explicit Euler scheme and similarly to the previous example, we obtain an optimisation problem of finite dimension with constraints whose AMPL formulation is</p>
<pre><span style="color: green;"># Parameters of the problem</span>
<b>param</b> Nx=30;   <span style="color: green;"># Number of space discretisation points</span>
<b>param</b> Nt=300;  <span style="color: green;"># Number of time discretisation points</span>
<span style="color: green;"># One have to check a posteriori that the number of time steps is large enough so that the</span>
<span style="color: green;"># CFL condition, T*Nx^2/Nt &lt;=1/2, is satisfied</span>
<b>param</b> dx=1/Nx; <span style="color: green;"># Space step</span>
<b>param</b> M =20;   <span style="color: green;"># Bound on the controls</span>

<span style="color: green;"># Variables of the system</span>
<span style="color: green;"># i stands for the time index and j for the space index</span>
<b>var</b> y {i in 0..Nt, j in 0..Nx} &gt;=0; <span style="color: green;"># State of the control problem</span>
<span style="color: green;"># Neuman controls in 0 and 1. The controls are in [-M,M].</span>
<b>var</b> v0 {i in 0..Nt} &gt;=-M, &lt;=M;
<b>var</b> v1 {i in 0..Nt} &gt;=-M, &lt;=M;
<b>var</b> T &gt;=0;      <span style="color: green;"># Control time</span>
<b>var</b> dt=T/Nt;    <span style="color: green;"># Time step</span>

<span style="color: green;"># Define the cost function</span>
<b>minimize</b> cost: T;

<span style="color: green;"># Define the constraints</span>
<span style="color: green;"># y is solution of the discretize system</span>
<b>subject to</b> y_dyn {i in 0..Nt-1, j in 1..Nx-1}:
	(y[i+1,j]-y[i,j])*(dx)^2=(y[i,j-1]-2*y[i,j]+y[i,j+1])*dt;
<span style="color: green;"># Neuman boundary conditions in 0 and 1</span>
<b>subject to</b> left_boundary  {i in 1..Nt-1}: y[i,1]-y[i,0]    =v0[i]*dx;
<b>subject to</b> right_boundary {i in 1..Nt-1}: y[i,Nx]-y[i,Nx-1]=v1[i]*dx;
<span style="color: green;"># y(0)=y0 and y(T)=y1</span>
<b>subject to</b> y_init {j in 0..Nx}: y[0,j] =5;
<b>subject to</b> y_end  {j in 0..Nx}: y[Nt,j]=1;

<span style="color: green;"># Solve with IpOpt</span>
<b>option solver</b> ipopt;
<b>option</b> ipopt_options <span style="color: brown;">"max_iter=2000 linear_solver=mumps halt_on_ampl_error yes"</span>;
<b>solve</b>;

<span style="color: green;"># Write the solution in the file out.txt</span>
<b>printf</b>: <span style="color: brown;">" # T = %24.16e\n"</span>, T &gt;  out.txt;
<b>printf</b>: <span style="color: brown;">" # Nx = %d\n"</span>, Nx    &gt;&gt; out.txt;
<b>printf</b>: <span style="color: brown;">" # Nt = %d\n"</span>, Nt    &gt;&gt; out.txt;
<b>printf</b>: <span style="color: brown;">" # Data\n"</span>           &gt;&gt; out.txt;
<b>printf</b> {i in 0..Nt}: <span style="color: brown;">" %24.16e\n"</span>, v0[i] &gt;&gt; out.txt;
<b>printf</b> {i in 0..Nt}: <span style="color: brown;">" %24.16e\n"</span>, v1[i] &gt;&gt; out.txt;
<b>printf</b> {i in 0..Nt, j in 0..Nx}: <span style="color: brown;">" %24.16e\n"</span>, y[i,j] &gt;&gt; out.txt;

<b>end</b>;
</pre>
<p>Once the file out.txt is written, it can be for instance read by <a name="scilab">Scilab</a> with the following code</p>
<pre>fid= <b>mopen</b>(<span style="color: brown;">'out.txt'</span>,<span style="color: brown;">'r'</span>);            <span style="color: green;">// Open out.txt</span>
T  = <b>mfscanf</b>(fid,<span style="color: brown;">'%s %s %s'</span>);         <span style="color: green;">// Read ``# T =''</span>
T  = <b>mfscanf</b>(fid,<span style="color: brown;">'%f'</span>);               <span style="color: green;">// Read value of T</span>
Nx = <b>mfscanf</b>(fid,<span style="color: brown;">'%s %s %s'</span>);         <span style="color: green;">// Read ``# Nx =''</span>
Nx = <b>mfscanf</b>(fid,<span style="color: brown;">'%d'</span>);               <span style="color: green;">// Read value of Nx</span>
Nt = <b>mfscanf</b>(fid,<span style="color: brown;">'%s %s %s'</span>);         <span style="color: green;">// Read ``# Nt =''</span>
Nt = <b>mfscanf</b>(fid,<span style="color: brown;">'%d'</span>);               <span style="color: green;">// Read value of Nt</span>
s  = <b>mfscanf</b>(fid,<span style="color: brown;">'%s %s'</span>); s=[];      <span style="color: green;">// Read ``# Data''</span>
v0 = <b>mfscanf</b>(Nt+1,fid,<span style="color: brown;">'%f'</span>); v0=v0';  <span style="color: green;">// Read the Nt+1 values of v0</span>
v1 = <b>mfscanf</b>(Nt+1,fid,<span style="color: brown;">'%f'</span>); v1=v1';  <span style="color: green;">// Read the Nt+1 values of v1</span>
y  = <b>mfscanf</b>((Nt+1)*(Nx+1),fid,<span style="color: brown;">'%f'</span>); <span style="color: green;">// Read the (Nt+1)*(Nx+1) values of y</span>
<b>mclose</b>(fid);                          <span style="color: green;">// Close out.txt</span>

y = <b>matrix</b>(y,Nx+1,Nt+1); y=y'; <span style="color: green;">// Reshape y as a matrix, line i is the solution at time i/Nt</span>
x = 0:1/Nx:1; t = 0:T/Nt:T;    <span style="color: green;">// Define the space and time discretisations</span>
<b>printf</b>(<span style="color: brown;">'time:\t%f\n'</span>,T);       <span style="color: green;">// Display the control time</span>
<b>plot</b>(t,[v0;v1]); <b>sleep</b>(2000); <b>clf</b>();               <span style="color: green;">// plot controls and wait 2s</span>
<b>plot2d</b>(x,y(1,:),rect=[0 0 1 10]); <b>sleep</b>(100);      <span style="color: green;">// plot the initial state and wait 0.1s</span>
<b>for</b> i=2:1:Nt,
	<b>plot</b>(x,y(i,:),rect=[0 0 1 10]); <b>sleep</b>(10); <span style="color: green;">// plot the state at each time instants</span>
<b>end</b>
<b>plot</b>(x,y(\$,:),rect=[0 0 1 10]);
<span style="color: green;">// plot the final state</span>
</pre>
<p>Based on these two codes, we obtain</p>
<ul>
 	<li>for $y^0=1$, $y^1=5$, $M=20$ and the discretization parameters $N_x=30$, $N_t=450$ the results displayed on the video:
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
(the minimal time obtained is $T\simeq\mathtt{0.2093}$);</li>
 	<li>for $y^0=5$, $y^1=1$, $M=800$ and the discretization parameters $N_x=30$, $N_t=450$ the results displayed on the video:
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N2.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/N2.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
(the minimal time obtained is $T\simeq\mathtt{0.1938}$).</li>
</ul>
<p>Similarly, we can consider the time optimal control problem,</p>

<script type="math/tex; mode=display">\begin{array}{cl}
\min  T\\
  \begin{array}{l}
T>0\, ,\\
u_0,\, u_1\in L^\infty(0,T)\\
u_0(t)\geqslant0\text{and} u_1(t)\geqslant 0  (t\in(0,T)\ \text{a.e.}),\\
y \text{ solution of (11) satisfies } y(T,\cdot)=y^1\, ,
\end{array}
\end{array}</script>

<p>with (11) given by,</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:doc4}
\left\{\begin{array}{r@{\>}l@{}l}
\dot{y}(t,x)  =\partial_x^2y(t,x)  (t>0\, ,\ x\in(0,1)),\\[2mm]
y(t,0)  =u_0(t)  (t>0),\\[2mm]
y(t,1)  =u_1(t)  (t>0),\\[2mm]
y(0,x)  =y^0(x)  (x\in(0,1).
\end{array}\right.
\end{equation}</script>

<p>Numerically, we obtain</p>
<ul>
 	<li>for $y^0=5$, $y^1=1$, $M=50$ and the discretization parameters $N_x=30$, $N_t=450$ the results displayed on the video:
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D1.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D1.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
(the minimal time obtained is $T\simeq\mathtt{0.1931}$);</li>
 	<li>for $y^0=1$, $y^1=5$, $M=50$ and the discretization parameters $N_x=20$, $N_t=200$ the results displayed on the video:
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D2.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D2.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
(the minimal time obtained is $T\simeq\mathtt{0.0498}$);</li>
 	<li>for $y^0=1$, $y^1=5$, $M=3000$ and the discretization parameters $N_x=20$, $N_t=200$ the results displayed on the video:
<video style="display: block; margin: 0 auto; width: 75%;" controls="">
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D3.ogg" type="video/ogg" />
<source src="https://cmc.deusto.eus/wp-content/uploads/2017/08/D3.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
(the minimal time obtained is $T\simeq\mathtt{0.0438}$).</li>
</ul>
<h3>Useful links</h3>
<ul>
 	<li>IpOpt project: <a href="https://projects.coin-or.org/Ipopt" target="_blank">https://projects.coin-or.org/Ipopt</a></li>
 	<li>AMPL project: <a href="http://ampl.com/products/ampl/" target="_blank">http://ampl.com/products/ampl/</a></li>
 	<li>NEOS solvers: <a href="https://neos-server.org/neos/solvers/" target="_blank">https://neos-server.org/neos/solvers/</a></li>
</ul>

<h6>References</h6>

<p><strong>[1]</strong> J. T. Betts. <a href="http://epubs.siam.org/doi/book/10.1137/1.9780898718577" name="cite1" target="_blank"><em>Practical methods for optimal control and estimation using nonlinear programming.</em></a> 2nd ed. Philadelphia, PA: Society for Industrial and Applied Mathematics (SIAM),2nd ed. edition, 2010.</p>

<p><strong>[2]</strong> R. Fourer, D. M. Gay, and B. W. Kernighan. <a href="http://ampl.com/resources/the-ampl-book/" name="cite2" target="_blank"><em>A modeling language for mathematical programming.</em></a> Manage. Sci., 36(5):519–554, 1990.</p>

<p><strong>[3]</strong> J. Lohéac, E. Trélat, and E. Zuazua. <a name="cite3" target="_blank"></a><em>Minimal controllability time for the heat equation under state constraints.</em> In preparation.</p>

<p><strong>[4]</strong> E. Trélat. <a href="https://www.ljll.math.upmc.fr/trelat/fichiers/livreopt.pdf" name="cite4" target="_blank"><em>Contrôle optimal. Théorie et applications.</em></a> Paris: Vuibert, 2005.</p>

<p><strong>[5]</strong> E. Trélat. <a href="https://www.ljll.math.upmc.fr/trelat/fichiers/contaero.pdf" name="cite5" target="_blank"><em>Optimal control and applications to aerospace: some results and challenges.</em></a> J.Optim. Theory Appl., 154(3):713–758, 2012.</p>

<p><strong>[6]</strong> A. Wächter and L. T. Biegler. <a href="http://link.springer.com/article/10.1007/s10107-004-0559-y" name="cite6" target="_blank"><em>On the implementation of an interior-point filter line-search algorithm for large-scale nonlinear programming.</em></a> Math. Program., 106(1 (A)):25–57, 2006.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3&gt;The problem&lt;/h3&gt;
</code></pre>
</div>
<p>We analyze a model tracking problem for a 1D scalar conservation law. It consists in optimizing the initial datum so to minimize a weighted distance to a given target during a given finite time horizon. To be more precise, given a finite time $T &gt; 0$,  a target function $u^d\in L^2(\mathbb R\times(0,T))$, and a positive weight  function $\rho\in L^\infty(\mathbb R\times(0,T))$ with compact support in $\mathbb R\times(0,T)$, we consider the functional cost  to be minimized $J$, over a suitable class of initial data $\mathcal{U}_{ad}$, defined by</p>

<script type="math/tex; mode=display">\begin{equation}\label{FunctionalJ}
J(u^0)=\frac 1 2\int_0^T\int_{\mathbb{R}}\rho(x,t)|u(x,t)-u^d(x,t)|^2dxdt,
\end{equation}</script>

<p>where  $u:\mathbb R_x\times\mathbb R_t\to \mathbb R$ is the unique entropy solution of the scalar conservation law</p>

<script type="math/tex; mode=display">\begin{equation}\label{conservativeEquation}
\partial_t u+\partial_x(f(u))=0,\; \textrm{in }\mathbb R \times(0,T); \;\;\; u(x,0)=u^0(x),\; x\in\mathbb R.
\end{equation}</script>

<p>Thus, the problem under consideration reads: To find $u^{0,min}\in\mathcal{U}_{ad}$ such that</p>

<script type="math/tex; mode=display">\begin{equation}\label{optimalProblem}
J(u^{0,min})=\min_{u^0\in\mathcal{U}_{ab}}J(u^0).
\end{equation}</script>

<p>Here the flux $f:\mathbb R\to\mathbb R$ is assumed to be  smooth:  $f\in C^1(\mathbb R,\mathbb R)$. The initial datum $u^0$ will be assumed to belong to a suitable admissible class $\mathcal{U}_{ad}$ to ensure the existence of a minimizer.</p>
<h5>Sensitivity of the state in the presence of shocks</h5>
<p>Inspired in several results on the sensitivity of  solutions of conservation laws in the presence of shocks in one-dimension  (see [<a href="#BressanMarson1995">7</a>, <a href="#BardosPironneau2002">4</a>, <a href="#BouchutJames1998">5</a>, <a href="#BouchutJames1999">6</a>, <a href="#Ulbrich2003">17</a>, <a href="#GodlewskiRaviart1999">13</a>]), we focus on the particular case of solutions having a single shock. But the analysis can be extended to consider more general one-dimensional systems of conservation laws with a finite number of noninteracting shocks. We introduce the following hypothesis:</p>

<p><strong>Hypothesis 1.1:</strong>
<i>Assume that $u(x,t)$ is a weak entropy solution of (\ref{conservativeEquation}) with a discontinuity along a regular curve $\Sigma={(\varphi(t),t),\;t\in(0,T)}$, which is Lipschitz continuous outside $\Sigma$. In particular, it satisfies the Rankine-Hugoniot condition on $\Sigma$</i></p>

<script type="math/tex; mode=display">\varphi'(t)[u]_{\Sigma^t}=[f(u)]_{\Sigma^t}.</script>

<p><i>Here we have used the notation: </i></p>

<script type="math/tex; mode=display">[v]_{\Sigma^t}=\lim\limits_{\varepsilon\searrow 0}v(\varphi(t)+\varepsilon,t) -v(\varphi(t)-\varepsilon,t)</script>

<p><i>for the jump at $\Sigma^t=(\varphi(t),t)$ of any piecewise continuous function $v$ with a discontinuity at $\Sigma^t$.
</i></p>

<p>Note that $\Sigma$ divides $\mathbb R \times (0, T )$ into two parts: $Q_-$ and $Q_+$ , the sub-domains of $\mathbb R \times (0, T)$ to the left and to the right of $\Sigma$ respectively.
As we will see, in the presence of shocks, to deal correctly with optimal control and design problems, the state of the system needs to be viewed as constituted by the pair $(u,\varphi)$ combining the solution of (\ref{conservativeEquation}) and the shock location $\varphi$. This is relevant in the analysis of sensitivity of functions below and when applying descent algorithms.
We adopt the functional framework based on the generalized tangent vectors (see [<a href="#BressanMarson1995">7</a>] and Definition 4.1 in [<a href="#castro2008alternating">8</a>]).
Let $u^0$ be the initial datum,  that we assume to be Lipschitz continuous to both sides of a single discontinuity located at $x = \varphi^0$, and consider a generalized tangent vector $(\delta u^0,\delta \varphi^0) \in L^1(\mathbb R) \times \mathbb R$ for all $0 \leq T$. Let $u^{0,\varepsilon}$ be a path which generates $(\delta u^0,\delta \varphi^0)$. For $\varepsilon$ sufficiently small, the solution $u^\varepsilon(\cdot,t)$ of (\ref{conservativeEquation}) is Lipschitz continuous with a single discontinuity at $x = \varphi^{\varepsilon}(t)$, for all $t \in [0,T]$. Therefore, $u^{\varepsilon}(\cdot, t)$ generates a generalized tangent vector $(\delta u(, t), \delta\varphi(t)) \in L^1(\mathbb R) \times \mathbb R$. Moreover, in [<a href="#castro2008alternating">8</a>] it is proved that it satisfies the following linearized system:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray}
\label{1DlinearizedSystem01}
\partial_t \delta u+\partial_x(f'(u)\delta u)&=&0,\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{in } Q_-\cup Q_+\\
\label{1DlinearizedSystem03}
\frac{d}{dt}\left([u]_{\Sigma^t}\delta\varphi\right)&=&[f'(u)\delta u]_{\Sigma^t}-[\delta u]_{\Sigma^t}\frac{d}{dt}\varphi,\;\; t\in(0,T)\\
\label{1DlinearizedSystem02}
\delta u(x,0)&=&\delta u^0(x),\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\{x<\varphi^0\}\cup\{x>\varphi^0\}\\
\label{1DlinearizedSystem04}
\delta\varphi(0)&=&\delta\varphi^0.
\end{eqnarray} %]]></script>

<h5>Sensitivity of the cost in the presence of shocks</h5>
<p>In this section we study  the sensitivity of the functional $J$ with respect to variations associated with the generalized tangent vectors defined in the previous section. We first define an appropriate generalization of the Gateaux derivative of $J$.</p>

<p><strong>Definition 1.2:</strong> <i>Let $J : L^1(\mathbb R) \to \mathbb R$ be a functional and $u^0 \in L^1(\mathbb R)$ be Lipschitz continuous with a discontinuity in  $\Sigma^0$, an initial datum for which the solution of (\ref{conservativeEquation}) satisfies hypothesis (1.1). $J$ is Gateaux differentiable at $u^0$ in a generalized sense if for any generalized tangent vector $(\delta u^0,\delta \varphi^0)$ and any family $u^{0,\varepsilon}$	associated to $(\delta u^0, \delta \varphi^0)$ the following limit exists,</i></p>

<script type="math/tex; mode=display">\delta J=\lim_{\varepsilon\to 0}\frac{J(u^{0,\varepsilon})-J(u^0)}{\varepsilon},</script>

<p>and it depends only on $(u^0,\varphi^0)$ and $(\delta u^0,\delta\varphi^0)$, i.e. it does not depend on the particular family $u^{0,\varepsilon}$ which generates $(\delta u^0,\delta\varphi^0)$. The limit is the generalized Gateux derivative of $J$ in the direction $(\delta u^0,\delta\varphi^0)$.
&lt;/i&gt;</p>

<p>The following result easily provides a characterization of the generalized Gateaux derivative of $J$ in terms of the solution of the associated adjoint system (\ref{1DSystemAdj}).</p>

<p><strong>Proposition 1.3:</strong> <em>The Gateaux derivative of $J$ can be written as follows</em></p>

<script type="math/tex; mode=display">\begin{equation}
\label{GateauxDerivativeJ02}
\delta J(u^0)[\delta u^0,\delta\varphi^0]=\int_{\RR}p(x,0)\delta u^0(x) dx-q(0)[u]_{\Sigma^0}\delta\varphi^0,
\end{equation}</script>

<p>where the adjoint state pair $(p,q)$ satisfies the system</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray}
\label{1DSystemAdj}
-\partial_t p-f'(u)\partial_x p&=&\rho\,(u-u^d),\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; \text{in } Q_-\cup Q_+\\  
\,[p]_{\Sigma^t}&=&0,\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; t\in(0,T) \label{1Dadjoint0202}\\
q(t)&=&p(\varphi(t),t),\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; t\in (0,T)\label{1Dadjoint0203}\\
-\frac{d}{dt}q&=&\frac{(1+(\dot{\varphi})^2)^{1/2}[\rho\,(u-u^d)^2]_{\Sigma^t}}{2[u]_{\Sigma^t}},\;\;\;\;\;\;\;\;\; t\in (0,T) \label{1Dadjoint03} \\
p(x,T)&=&0,\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\{x<\varphi(T)\}\cup\{x>\varphi(T)\} \label{1Dadjoint02}\\
q(T)&=&0. \label{1Dadjoint04}
\end{eqnarray} %]]></script>

<p>Let us briefly comment the result of Proposition 1.3 before giving its proof.
System (\ref{1DSystemAdj}) has a unique solution. In fact, to solve the backward system (\ref{1DSystemAdj}) we first define the solution $q$ on the shock $\Sigma$ from the conditions for $q$. This determines the value of $p$ along the shock. We then propagate this information to both sides of $\Sigma$, by characteristics (see Figure 1 where we illustrate this construction).</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/05/ConservationLawsShocksFig1.jpg" alt="Characteristic lines entering on a shock" width="600" /> Figure 1: Characteristic lines entering on a shock and how they may be used to build the solution of the adjoint system both away from the shock and on its region of influence.</p>

<p>Formula (\ref{GateauxDerivativeJ02}) provides an obvious way to compute a first descent direction of $J$ at $u^0$. We just take</p>

<script type="math/tex; mode=display">\begin{equation}\label{descentDirection01}
(\delta u^0,\delta \varphi^0)=(-p(\cdot,0),q(0)[u]_{\Sigma^0}).
\end{equation}</script>

<p>Here, the value of $\delta \varphi^0$ must be interpreted as the optimal infinitesimal displacement of the discontinuity of $u^0$.</p>

<p>In [<a href="#castro2008alternating">8</a>], when considering the inverse design problem, it was observed that the solution $p$ of the corresponding adjoint system at $t=0$ was discontinuous, with two discontinuities, one in each side of the original location of the discontinuity at $\Sigma^0$. This was a reason not to use this descent direction and  for introducing the alternating descent method. In the present setting, however, the adjoint state $p$ obtained is typically continuous. This is due to the fact that $p$ at both side of the discontinuity is defined by the method of characteristics and that, on the region of influence of the characteristics emanating from the shock, the continuity is preserved by the fact that, on one hand, $q=q(t)$ itself is continuous as the primitive of an integrable function and that the data for $p$ and $q$ at $t=T$ are continuous too. Despite of this, as we shall see, the implementation of the alternating descent direction method is worth since it significantly improves the results obtained by the purely discrete approach.</p>

<h3>Numerical Experiments</h3>
<p>In this section we present some numerical experiments which illustrate the results obtained in an optimization model problem with each one of the numerical methods described in the previous section.
We have chosen as computational domain the interval $(-4, 4)$ and we have taken as boundary conditions in the numerical scheme, at each time step $t = t^n$, the value of the initial data at the boundary. This can be justified if we assume that the initial datum $u^0$ is constant in a sufficiently large inner neighborhood of the boundary $x = \pm 4$ (which depends on the size of the $L^\infty$-norm of the data under consideration and the time horizon $T$), due to the finite speed of propagation. A similar procedure is employed for the adjoint equation.
We underline once more that the solutions obtained with each method may correspond to global minima or local ones since the gradient algorithm does not distinguish them.
In the experiments we consider the Burgers’ equation, i.e. $f(z)=z^2/2$,</p>

<script type="math/tex; mode=display">\begin{equation}\label{BurgerNumerica}
\partial_tu+\partial_x\left(\frac{u^2}{2}\right)=0,\;\;\; u(x,0)=u^0(x).
\end{equation}</script>

<p>The weight function $\rho$, under consideration in the experiments is given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\rho(x,t)=\left\{
\begin{array}{cl}
1 & t\in ( T/2,T)\\
0 & \text{otherwise.}
\end{array}
\right. %]]></script>

<p>And the  time horizon $T=1$.
To compare the efficiency of the different methods we consider a fixed $\Delta x = 1/20, \lambda = \Delta t /\Delta x = 2/3$ (which satisfies the CFL condition). We then analyze the number of  iterations that each method needs  to attain a prescribed value of the functional.</p>

<h5>Experiment 1</h5>
<p>We first consider a piecewise constant target profile $u^d$ given by the solution of \ref{BurgerNumerica} with the initial condition $(u^d)^0$ given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{E1u0minimoa}
(u^d)^0(x)=\left\{
\begin{array}{cl}
0.7 & x\in[-2,1]\\
0 & \text{otherwise.}
\end{array}
\right.
\end{equation} %]]></script>

<p>Note that, in this case,  \ref{E1u0minimoa} yields a particular solution of the optimization problem and the minimum value of $J$ vanishes.
We solve the optimization problem \ref{optimalProblem} with the above described different methods starting from the following initialization for $u^0$:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{Ep1u^0}
u^0(x)=\left\{
\begin{array}{cl}
0.5 & x\leq 0\\
-0.1 & x>0,
\end{array}
\right.
\end{equation} %]]></script>

<p>which also has a discontinuity but located on a different point.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/06/ConservationLawsShocksFig2.jpg" alt="Characteristic lines entering on a shock" width="600" /> Figure 2: Experiment 1. $\log (J)$ versus the number of iterations in the descent algorithm for the discrete  and the alternating descent methods.</p>

<p>In Figures 3 and 4, we present the minimizers  obtained by the methods above, and the associated solutions, Figures 5 and 6.
The initial datum $u^0$ obtained by the alternating descent method (Figures 4) is a good  approximation of \ref{E1u0minimoa}. The solution given by  the discrete approach (Figure 3) presents added spurious oscillations. Furthermore, the discrete method is much slower and does not achieve the same level of accuracy since the functional $J_\Delta$ does not decrease so much.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/06/ConservationLawsShocksFig3-6.jpg" alt="Experiment1 iterations and solutions" width="600" /> </p>

<h5>Experiment 2</h5>
<p>The previous experiment indicates that the alternating descent method performs significantly better. In order to show that this is a systematic fact, which arises independently of the initialization of the method, we consider the target $u^d$ given by the solution of \ref{BurgerNumerica} with the initial condition $(u^d)^0$ given by</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}\label{E2u0minimo}
(u^d)^0(x)=\left\{
\begin{array}{cl}
0.5 & x\leq 0.5\\
0 & \text{otherwise,}
\end{array}
\right.
\end{equation} %]]></script>

<p>but this time we compare the performance of both methods starting from different initializations.
The obtained numerical results are presented in Figure 7.
We see that, regardless the initialization considered, the alternating descent method performs significantly better.
We observe that in the five experiments the alternating descent method perfumes better ensuring the descent of the functional in much fewer iterations and yielding smoother, less oscillatory approximation of the minimizer.
Note also  that the discrete method, rather than yielding discontinuous approximations of the minimizer as the alternating descent method does, it produces an initial datum with a Lipschitz front. Observe that these are  two different configurations that can lead to the same evolution for the Burgers equation after some time, once the front develops the discontinuity. This is in agreement with the fact that the functional to be minimized is only active in the time-interval $T/2 \le t \le T$.</p>

<p><img src="https://cmc.deusto.eus/wp-content/uploads/2017/06/ConservationLawsShocksFig7.jpg" alt="Experiment2 comparision results" width="800" /> </p>

<h3>Bibliography</h3>

<p><strong>[1]</strong> A. Adimurthi, S.S. Ghoshal and V. Gowda <a name="adimurthi:hal-00805317"><em>Optimal controllability for scalar conservation laws with convex flux.</em></a> 12, Jan. 2012.</p>

<p><strong>[2]</strong> D. Auroux and J. Blum <a name="AB" href="http://www.sciencedirect.com/science/article/pii/S1631073X05002074"><em>Back and forth nudging algorithm for data assimilation problems.</em></a> Comptes Rendus Mathematique, 340(12):873 – 878, 2005.</p>

<p><strong>[3]</strong> D. Auroux and M. Nodet <a name="AN" href="https://arxiv.org/abs/0809.4838"><em>The back and forth nudging algorithm for data assimilation problems: theoretical results on transport equations.</em></a> ESAIM: Control, Optimisation and Calculus of Variations, 18(2):318–342, 7 2012.</p>

<p><strong>[4]</strong> C. Bardos and O. Pironneau <a name="BardosPironneau2002" href="http://www.sciencedirect.com/science/article/pii/S1631073X02025748"><em>A formalism for the differentiation of conservation laws.</em></a> C. R. Math. Acad. Sci. Paris, 335(10):839–845, 2002.</p>

<p><strong>[5]</strong> F. Bouchut and F. James <a name="BouchutJames1998" href="http://www.sciencedirect.com/science/article/pii/S1631073X02025748"><em>One-dimensional transport equations with discontinuous coefficients.</em></a> Nonlinear Anal., 32(7):891–933, 1998.</p>

<p><strong>[6]</strong> F. Bouchut and F. James <a name="BouchutJames1999" href="https://link.springer.com/chapter/10.1007/978-3-0348-8720-5_13"><em>Differentiability with respect to initial data for a scalar conservation law.</em></a> In Hyperbolic problems: theory, numerics, applications, Vol. I (Zürich, 1998), volume 129 of Internat. Ser. Numer.Math., pages 113–118. Birkhäuser, Basel, 1999.</p>

<p><strong>[7]</strong> A. Bressan and A. Marson <a name="BressanMarson1995" href="https://www.math.psu.edu/bressan/PSPDF/hyp-varcalculus.pdf"><em>A variational calculus for discontinuous solutions of systems of conservation laws.</em></a> Comm. Partial Differential Equations, 20(9-10):1491–1552, 1995.</p>

<p><strong>[8]</strong> C. Castro, F. Palacios and E. Zuazua <a name="castro2008alternating" href="https://www.newton.ac.uk/files/preprints/ni07040_0.pdf"><em> An alternating descent method for the optimal control of the inviscid burgers equation in the presence of shocks.</em></a> Mathematical Models and Methods in Applied Sciences, 18(03):369–416, 2008</p>

<p><strong>[9]</strong> C. Castro, F. Palacios and E. Zuazua <a name="Castro2010" href="http://adl.stanford.edu/papers/Integral_Methods_2010.pdf"><em> Optimal control and vanishing viscosity for the burgers equation.</em></a> Integral Methods in Science and Engineering, Volume 2, pages 65–90.Birkhäuser Boston, 2010.</p>

<p><strong>[10]</strong> C. Castro and E. Zuazua <a name="MR2813348" href="http://paginaspersonales.deusto.es/enrique.zuazua/documentos_public/archivos/publicaciones/fluxidrev.pdf"><em> Flux identification for 1-d scalar conservation laws in the presence of shocks.</em></a> Math. Comp., 80(276):2025–2070, 2011</p>

<p><strong>[11]</strong> S. Garreau, P. Guillaume and M. Masmoudi. <a name="Garreau:2000:TAP:587448.587670" href="http://epubs.siam.org/doi/abs/10.1137/S0363012900369538"><em>The topological asymptotic for pde systems: The elasticity case.</em></a> SIAM J. Control Optim., 39(6):1756–1778, Dec. 2000.</p>

<p><strong>[12]</strong> E. Godlewski and P. Raviart <a name="BookE.GodlewskiRaviart" href="https://books.google.es/books/about/Hyperbolic_systems_of_conservation_laws.html?id=hzvvAAAAMAAJ&amp;redir_esc=y"><em>Hyperbolic systems of conservation laws, Mathématiques and Applications</em></a> Ellipses, Paris, 1991.</p>

<p><strong>[13]</strong> E. Godlewski and P. Raviart <a name="GodlewskiRaviart1999"><em>The linearized stability of solutions of nonlinear hyperbolic systems of conservation laws. A general numerical approach.</em></a> Math. Comput. Simulation, 50(1-4):77–95, 1999. Modelling ’98 (Prague)</p>

<p><strong>[14]</strong> L. Gosse and F. James <a name="2000GosseJames" href="http://www.ams.org/journals/mcom/2000-69-231/S0025-5718-00-01185-6/"><em>Numerical approximations of one-dimensional linear conservation equations with discontinuous coefficients.</em></a> Mathematics of Computation, 69(231):pp. 987–1015, 2000.</p>

<p><strong>[15]</strong> S. N. Kružkov <a name="kruzkov" href="http://iopscience.iop.org/article/10.1070/SM1970v010n02ABEH002156/meta"><em>First order quasilinear equations with several independent variables.</em></a> Mat. Sb. (N.S.), 81 (123):228–255, 1970.</p>

<p><strong>[16]</strong> R. Lecaros and E. Zuazua <a name="RLEZ2014" href="http://www.ams.org/journals/mcom/2016-85-299/S0025-5718-2015-03015-4/"><em>Control of 2D scalar conservation laws in the presence of shocks.</em></a> Math. Comp. 85 (2016), 1183-1224</p>

<p><strong>[17]</strong> S. Ulbrich <a name="Ulbrich2003" href="http://www.sciencedirect.com/science/article/pii/S016769110200275X"><em>Adjoint-based derivative computations for the optimal control of discontinuous solutions of hyperbolic conservation laws.</em></a> Systems Control Lett., 48(3-4):313–328, 2003. Optimization and control of distributed systems.</p>

<p><strong>[18]</strong> X. Wen and S. Jin <a name="MR2378582" href="http://www.global-sci.org/jcm/freedownload/v26_1.pdf"><em>Convergence of an immersed interface upwind scheme for linear advection equations with piecewise constant coefficients I: $L^1$-error estimates.</em></a> J. Comput. Math., 26(1):1–22, 2008.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3&gt;Introduction&lt;/h3&gt;
</code></pre>
</div>
<p>In this work, we analyze the numerical approximation of the inverse design problem for the Burgers equation, both in the viscous and in the inviscid case:</p>

<script type="math/tex; mode=display">\begin{equation}
\min_{u_0} \mathcal{J}_\nu(u_0) =\min_{u_0} \frac12\int_\mathbb{R} \left(u^\nu(x,T)-u^\ast(x)\right)^2 dx,
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\mbox{subject to} \begin{cases}
\partial_t u^\nu+\partial_x \left(\frac{(u^\nu)^2}{2}\right)=\nu \partial_{xx} u^\nu, x\in\mathbb{R},\,t>0,\\[15pt]
u^\nu(x,0)=u_0(x), x\in\mathbb{R},
\end{cases}
\end{equation}</script>

<p>distinguishing the viscous, $\nu &gt;0$, and the inviscid case, $\nu=0$. Given a time $T&gt;0$ and a target function $u^\ast$ the aim is to identify the initial datum $u_0$ so that the solution, at time $t=T$, reaches the target $u^\ast$ or gets as close as possible to it. In particular, we focus on problems with large values of $T$, for which convergence of the numerical schemes in the classical sense of numerical analysis might not suffice to obtain accurate results.</p>

<p>This issue is motivated by the challenging problem of sonic-boom minimization for supersonic aircrafts, which is governed by a Burgers-like equation. The travel time of the signal to the ground is larger than the time scale of the initial disturbance by orders of magnitude and this motivates our study of large time control of the sonic-boom propagation.</p>

<h3>Description of the numerical algorithms</h3>
<p>To implement the problem numerically, we opt for a discretization of (2) using classical conservative schemes. Let us denote spatial nodes $x_{j+1/2}={\Delta x}(j+1/2)$, $j\in\mathbb{Z}$, and time instants $t_n=n{\Delta t}$, $n\in n \cup{0}$, where ${\Delta x},{\Delta t}&gt;0$ are the mesh size and time-step respectively. We approximate the solution $u$ of (2) by a piecewise constant function $u_\Delta$ such that</p>

<script type="math/tex; mode=display">u_\Delta(x,t)=u^n_j, x\in[x_{j-1/2},x_{j+1/2}),\,t\in[t_n,t_{n+1}),</script>

<p>where</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:scheme}
\begin{cases}
\displaystyle u^{n+1}_j=u^n_j-\frac{ {\Delta t} }{ {\Delta x} }(g^n_{j+1/2}-g^n_{j-1/2}) \\[15pt]
\displaystyle +\frac{\nu{\Delta t} }{ {\Delta x}^2}(u^n_{j-1}-2u^n_j+u^n_{j+1}),\ j\in\mathbb{Z},n=0,\dots,N, \\[20pt]
\displaystyle u^0_j=\frac{1}{ {\Delta x} }\int_{x_{j-1/2} }^{x_{j+1/2} } u_0(x)dx,\ j\in\mathbb{Z}.
\end{cases}
\end{equation}</script>

<p>Here, $N=\lceil T/{ {\Delta t} }\rceil$ is the number of time-steps needed to reach $T$. We denote $g^n_{j+1/2}=g(u^n_j,u^n_{j+1})$, where the function $g$ is the numerical flux. In this paper we compare two fluxes:</p>

<script type="math/tex; mode=display">\mbox{Engquist-Osher (EO): } g^{EO}(v,w)=\dfrac{v(v+|v|)}{4}+\dfrac{w(w-|w|)}{4}, \\[10pt]
\mbox{Modified Lax-Friedrichs (MLF): } g^{MLF}(v,w)=\dfrac{v^2+w^2}{4}-\dfrac{ {\Delta x} }{ {\Delta t} }\left(\dfrac{w-v}{4}\right)</script>

<p>In the simulations we follow the discrete approach to optimization. For the discretization of (1), we consider a simple quadrature rule:</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:funcdiscr}
\mathcal{J}_{\Delta}(u_\Delta^0)=\frac{ {\Delta x} }{2} \sum_\mathbb{Z} (u_j^N-u^\ast_j)^2,
\end{equation}</script>

<p>where the target function $u^\ast$ has been discretized in the same manner as the initial data $u_0$ in (3).</p>

<p>Regarding the optimization technique, we use the classical gradient descent method based on the adjoint methodology. Following the discrete approach, it is easy to obtain the corresponding discrete adjoint system for (3):</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:adjscheme}
\begin{cases}
\rho^{n}_j=\rho^{n+1}_j+\frac{ {\Delta t} }{ {\Delta x} }\Big(\partial_v g(u^n_j,u^n_{j+1}) \left(\rho^{n+1}_{j+1}-\rho^{n+1}_j\right) \\[15pt]
 +\partial_w g(u^n_{j-1},u^n_{j})\left(\rho^{n+1}_j-\rho^{n+1}_{j-1}\right)\Big) \\[15pt]
 +\frac{\nu{\Delta t} }{ {\Delta x}^2}(\rho^{n+1}_{j-1}-2\rho^{n+1}_j+\rho^{n+1}_{j+1}),  j\in\mathbb{Z},n=N-1\dots,0, \\[15pt]
\rho^N_j=u^N_j-u^\ast_j,  j\in\mathbb{Z},
\end{cases}
\end{equation}</script>

<p>To minimize (4), we will take the descent direction given by:</p>

<script type="math/tex; mode=display">\begin{equation*}
\delta u_j^0=-\rho^0_j,  j\in\mathbb{Z}.
\end{equation*}</script>

<p>This direction is straightforwardly obtained following the same arguments as for the continuous level. Thus, the new initial data $u_\Delta^{0,\varepsilon}$ will be given by</p>

<script type="math/tex; mode=display">\begin{equation*}
u^{0,\varepsilon}_j = u^0_j-\varepsilon \rho^0_j,  j\in\mathbb{Z}
\end{equation*}</script>

<p>for some $\varepsilon&gt;0$ small enough.</p>

<p>The pseudocode for the complete algorithm can be found in Algorithm 1. Note that it is valid both for the viscous and the inviscid case of the Burgers equation.</p>

<h3>Algorithm 1: Solve discrete optimization problem</h3>
<p><strong>Input:</strong></p>

<script type="math/tex; mode=display">\Delta x,\Delta t,N,\{u^0_j\}_{j=0,...,M},\{u^\ast_j\}_{j=0,...,M}</script>

<p><br /></p>
<ol>
<li><strong>for</strong> $j=0$ <strong>to</strong> $M$ <strong>do</strong></li>
<li>	<strong>set</strong> $u^{0,new}_j = u^0_j$</li>
<li><strong>end for</strong></li>
<li><strong>compute</strong> $\{u^n_j\}^{n=1,...,N}_{j=0,...,M}$ from $\{u^{new,0}_j\}_{j=0,...,M}$ using (3)</li>
<li><strong>compute</strong> functional $\mathcal{J}(u_\Delta^{0,new})$ using (4)</li>
<li><strong>while</strong> stopping criteria are not met <strong>do</strong></li>
<li>	<b>for</b> $j=0$ <strong>to</strong> $M$ <strong>do</strong></li>
<li>		<b>set</b> $u^{0,old}_j = u^{0,new}_j$</li>
<li>		<b>set</b> $\rho^N_j = u^N_j-u^\ast_j$</li>
<li>	<b>end for</b></li>
<li>	<strong>compute</strong> $\{\rho^0_j\}_{j=0,...,M}$ from $\{\rho^N_j\}_{j=0,...,M}$ and $\{u^n_j\}^{n=1,...,N}_{j=0,...,M}$ using (5)</li>
<li>	<strong>compute</strong> descending step-size $\varepsilon$</li>
<li>	<b>for</b> $j=0$ <strong>to</strong> $M$ <strong>do</strong></li>
<li>		<b>set</b> $u^{0,new}_j = u^{0,old}_j-\varepsilon \rho^0_j$</li>
<li>	<b>end for</b></li>
<li>	<strong>compute</strong> $\{u^n_j\}^{n=1,...,N}_{j=0,...,M}$ from $\{u^{new,0}_j\}_{j=0,...,M}$ using (3)</li>
<li>	<strong>compute</strong> functional $\mathcal{J}(u_\Delta^{0,new})$ using (4)</li>
<li><b>end while</b></li>
<li><b>for</b> $j=0$ <strong>to</strong> $M$ <strong>do</strong></li>
<li>	<b>set</b> $u^{*,0}_j = u^{0,new}_j$</li>
<li><b>end for</b></li>
</ol>
<p><strong>Output:</strong> Optimal solution</p>

<script type="math/tex; mode=display">\{u^{*,0}_j\}_{j=0,...,M}</script>

<h3>Numerical viscosity</h3>
<p>It is well known that (3) can be rewritten in its viscous form in the following manner:</p>

<script type="math/tex; mode=display">\begin{equation*}
\frac{u_{j}^{n+1}-u_j^n}{\Delta t}+\frac{(u_{j+1}^n)^2-(u_{j-1}^n)^2}{4\Delta x}=R(u_j^n,u_{j+1}^n)-R(u_{j-1}^n,u_{j}^n)+\frac{\nu}{ {\Delta x}^2}(u^n_{j-1}-2u^n_j+u^n_{j+1}),
\end{equation*}</script>

<p>where $R$ is uniquely defined by</p>

<script type="math/tex; mode=display">\begin{equation*}
R(u,v)=\frac{1}{2{\Delta x} } \Big(\frac{u^2}{2}+\frac{v^2}{2}-2g(u,v)\Big).
\end{equation*}</script>

<p>In the case of the numerical fluxes that we consider in this paper, we have:</p>

<script type="math/tex; mode=display">R^{MLF}(u,v)=\frac{v-u}{4{\Delta t} }, \\
 R^{EO}(u,v)=\frac{1}{4{\Delta x} }(v|v|-u|u|).</script>

<p>Both schemes are convergent in the classical sense of the numerical analysis. However, the large-time behavior of $u_\Delta$ depends on the degree of homogeneity of the term $R$. In other words, let us assume that there exists $\alpha\in R$ such that</p>

<script type="math/tex; mode=display">\begin{equation*}
R(\mu u, \mu v)=\mu^\alpha R(u,v), \forall u,v\in\mathbb{R} \mbox{ and } \forall \mu>0.
\end{equation*}</script>

<p>It is clear that $\alpha=2$ for Engquist-Osher and $\alpha=1$ for modified Lax-Friedrichs. Thus, the numerical viscosity inherent in MLF drives the system into a diffusive wave too early and, consequently, continuous metastable states are not reproduced numerically.</p>

<p><img class="size-full wp-image-1616" src="https://cmc.deusto.eus/wp-content/uploads/2017/05/scheme_compare.jpg" width="800" /> Figure 1: Solutions of (2) with $\nu=10^{-6}$ at $t=1$, $t=100$ and $t=5000$, using (3) with ${\Delta x}=0.2$, ${\Delta t}=0.5$ and numerical fluxes EO (blue) and MLF (red).</p>

<p>The main aim of our work is to emphasize that ignoring the dynamics of the continuous model at the numerical level can produce undesired results in optimal control problems in large time horizons. On one hand, we show that the gradient descent method performs successfully whenever the numerical flux and the mesh sizes are chosen appropriately. On the other hand, we present examples where excessive numerical viscosity dominates the physical one.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;p&gt;The turnpike property establishes that, when a general optimal control problem is settled in large time, for most of the time the optimal control and trajectories remain exponentially close to the optimal control and state of the corresponding steady-state or static optimal control problem.&lt;/p&gt;
</code></pre>
</div>

<h4>The turnpike property</h4>
<p><img class=" wp-image-1524" src="https://cmc.deusto.eus/wp-content/uploads/2017/03/dibujo4.png" alt="The turnpike property illustrated" width="500" /> Figure 1: When an optimal control problem satisfies the turnpike property, the solution remains close to certain path for most of the time, except maybe for an initial time interval $T_1$ and a final time interval $T_2$. In this Figure, $x(t,x_0,u(t))$ is solution of the optimal control problem (3) with the cost function (2), while $\bar{x}$ is the optimal solution of the stationary problem (5).</p>

<p>The origin of the term Turnpike is in the interpretation that Samuelson did of this phenomenon in [<a href="#dorfman1958linear">1</a>] : suppose we want to travel from city A to city B by car, the best way to do it, the optimal way, is to take the highway (namely, the turnpike) as near as we can from city A, and leave it when we are close to B. So, except nearby A and B, we are expected to be on the highway: in other words, the turnpike of the problem.
The turnpike property is very useful, since it gives us an idea of the nature of the optimal solution of a problem, without having to solve it analytically. In practice, the turnpike property allows performing a significant improvement of the numerical methods used to solve optimal control problems.</p>

<h4>The Turnpike property in the Linear Case</h4>
<p>Consider the finite-dimensional dynamical system</p>

<script type="math/tex; mode=display">\begin{equation}
\begin{cases}
\label{linearproblem}
 x_t + Ax = Bu\\
 x(0)=x_0 \in \mathbb{R}^{N}
\end{cases}
\end{equation}</script>

<p>where $A \in M(N,N)$, $B\in M(N,M)$, with control $u \in L^2 (0,T;\mathbb{R}^{N})$. Given a matrix $C \in M(N,N)$, and some $x^\ast  \in \mathbb{R}^{N}$, consider the optimal control problem</p>

<script type="math/tex; mode=display">\begin{equation}
\min_{u} J^T (u) = \frac{1}{2} \int_0^T \left( |u(t)|^2 + |C(x(t)-x^\ast )|^2 \right)dt.
\end{equation}</script>

<p>There exists a unique optimal control $u(t)$ in $ L^2 (0,T;\mathbb{R}^{M})$, characterized by the optimality condition</p>

<script type="math/tex; mode=display">u = - B^\ast p =
    \begin{cases}
    -p_t + A^\ast  p = C^\ast C( x-x^\ast ) \\
    p(T)=0 \in \mathbb{R}^N
    \end{cases}</script>

<p>Let formulate the same problem for the steady-state model</p>

<script type="math/tex; mode=display">\begin{equation}
Ax=Bu
\end{equation}</script>

<p>Then, there exists a unique minimum $\bar{u}$, and a unique optimal state $\bar{x}$, of the stationary optimal control problem</p>

<script type="math/tex; mode=display">\begin{equation}
%\nonumber
\left\lbrace
\begin{array}{clc}
 \min_{u} J_s (u) = \frac{1}{2} \left( |u|^2 + |C(x -x^\ast )|^2 \right). \
\\  subject \,\,\, to\,\,\, Ax=Bu
\end{array}
\right.
\end{equation}</script>

<p>Let assume that:</p>
<ol>
	<li>The pair $(A,B)$ is controllable.</li>
	<li>The pair $(A,C)$ is observable.</li>
</ol>
<p>Then, we have the following result (proved in [<a href="porretta2013long">2</a>])
<strong>Theorem:</strong> <em>there exist positive constants $\lambda$ and $K$, independent on $T$, such that $ \forall t \in [0,T]$</em></p>

<script type="math/tex; mode=display">|u(t) -\bar{u}| + |x(t) - \bar{x}| \leq K \left( e^{-\lambda t} + e{-\lambda (T-t)} \right) .</script>

<h4>Some results and extensions on the turnpike property</h4>
<ul>
	<li>Turnpike theorems were derived in the 60's for discrete-time optimal control problems arising in econometry [<a href="#mckenzie1976turnpike">3</a>] and references therein).</li>
	<li>See [<a href="#carlson2012infinite">4</a>], [<a href="#zaslavski2006turnpike">5</a>] and the references therein for an extensive overview of turnpike results</li>
	<li>In [<a href="#trelat2015turnpike">6</a>] they proved a turnpike theorem for nonlinear finite--dimensional systems, involving the state, the control and also the adjoint. Besides that, they explain how the turnpike can be used to improve certain numerical methods.</li>
	<li>A turnpike theorem for the 1-D wave equation with a homogeneous Dirichlet boundary condition at one side, and a Neumann boundary control action at the other can be found in [<a href="#gugat2016optimal">7</a>].</li>
	<li>A turnpike theorem for the two--dimensional Navier-Stokes Equation is proved in [<a href="#zamorano2016turnpike">8</a>], for both time depending and non-depending control.</li>
	<li>An application of the turnpike property to the Lotka-Volterra model can be found in [<a href="#ibanez2017optimal">9</a>]. The property is used to improve the single shooting method to solve the problem.</li>
</ul>
<p><img class=" wp-image-1536" src="https://cmc.deusto.eus/wp-content/uploads/2017/05/fig2-e1494492767300.jpg" alt="turnpike phenomenon in two species" width="482" height="361" /> Figure 2: The Lotka-Volterra equations model a biological ecosystem where two species interact: a prey and a predator. In [<a href="#ibanez2017optimal">9</a>] the control is introduced by hunting both species. In this figure we can see the turnpike phenomenon in both species ($x_1$ is the prey and $x_2$ is the predator species) and the control $u(t)$, which represents the hunting. In dashed blue, we have the evolution of each variable, and in black, the turnpike.</p>

<h4>Perspectives</h4>
<ul>
<li> The study of the periodic turnpike property for optimal control problems in Hilbert spaces (in progress, E.Tr&eacute;lat, C. Zhang and E. Zuazua)</li>
<li> Clarify the turnpike property for nonlinear PDE without smallness conditions on the target.</li>
<li> The turnpike property on multi-D wave equations.</li>
<li> Prove a turnpike theorem for a constrained control for linear and nonlinear finite--dimensional optimal control problems.</li>
<li> Develope the turnpike computational code to solve a wide range of problems as it has been done in [<a href="#ibanez2017optimal">9</a>] for the Lotka-Volterra model.</li>
</ul>

<h4>References</h4>

<p><strong>[1]</strong> Robert Dorfman, Paul Anthony Samuelson, and Robert M Solow <a name="dorfman1958linear"><em>Linear programming and economic analysis.</em></a> Courier Corporation, 1958.</p>

<p><strong>[2]</strong> Alessio Porretta and Enrique Zuazua. <a name="porretta2013long" href="http://epubs.siam.org/doi/abs/10.1137/130907239"><em>Long time versus steady state optimal control.</em></a> SIAM Journal on Control and Optimization, 51(6):4242–4273, 2013.</p>

<p><strong>[3]</strong> Lionel W McKenzie. <a name="mckenzie1976turnpike" href="http://www.dictionaryofeconomics.com/article?id=pde2012_T000259"><em>Turnpike theory.</em></a> Econometrica: Journal of the Econometric Society, pages 841–865, 1976.</p>

<p><strong>[4]</strong> Dean Carlson, Alain B Haurie, and Arie Leizarowitz. <a name="carlson2012infinite" href="http://www.springer.com/la/book/9783642767579"><em>Infinite horizon optimal control: deterministic and stochastic systems.</em></a> Springer Science &amp; Business Media, 2012.</p>

<p><strong>[5]</strong> Alexander Zaslavski. <a name="zaslavski2006turnpike" href="http://www.springer.com/us/book/9780387281551"><em>Turnpike properties in the calculus of variations and optimal control, volume 80.</em></a> Springer Science &amp; Business Media, 2006.</p>

<p><strong>[6]</strong> Emmanuel Trélat and Enrique Zuazua. <a name="trelat2015turnpike" href="http://www.sciencedirect.com/science/article/pii/S0022039614003568"><em>The turnpike property in finite-dimensional nonlinear optimal control</em></a> Journal of Differential Equations, 258(1):81–114, 2015.</p>

<p><strong>[7]</strong> Martin Gugat, Emmanuel Trélat, and Enrique Zuazua. <a name="gugat2016optimal" href="https://arxiv.org/abs/1505.05017"><em>Optimal Neumann control for the 1D wave equation: finite horizon, infinite horizon, boundary tracking terms and the turnpike property</em></a> Systems &amp; Control Letters, 90:61–70, 2016.</p>

<p><strong>[8]</strong> S Zamorano. <a name="zamorano2016turnpike" href="https://arxiv.org/abs/1601.04984"><em>The turnpike property for two-dimensional navier-stokes equations.</em></a> arXiv preprint arXiv:1601.04984, 2016.</p>

<p><strong>[9]</strong> Aitziber Ibañez. <a name="ibanez2017optimal" href="https://www.ncbi.nlm.nih.gov/pubmed/27642712"><em>Optimal control of the Lotka–Volterra system: turnpike property and numerical simulations.</em></a> Journal of Biological Dynamics, 11(1):25–41, 2017.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h3&gt;The problem&lt;/h3&gt;
</code></pre>
</div>
<p><img class="size-full" style="float: right;" src="https://cmc.deusto.eus/wp-content/uploads/2017/02/surrogate.png" alt="Surrogate" width="400" /><strong>Control of a parameter dependent system in a robust manner.</strong>
Fix a control time $T &gt; 0$, an arbitrary initial data $x^0$, and a final target $x^1 \in R^N$
Given $\varepsilon &gt; 0$ we aim at determining a family of parameters $\nu_1,…, , \nu_n$ in $\mathcal{N}$ so that the corresponding controls $u_1, …, u_n$ are such that for every $\nu \in \mathcal{N}$ there exists $u^\star_\nu \in {\rm span}{u_1,…, u_n}$ steering the system to the state $x_\nu^\star(T)$ within the $\varepsilon$ distance from the target $x^1$.</p>

<h3>The system</h3>
<p>A finite dimensional linear control system:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}
\begin{cases}
x'(t)=A( \nu)x(t)+Bu(t),\,0 < t < T,\\
x(0)=x^0
\end{cases}
\end{equation} %]]></script>

<ul>
	<li>$ A( \nu)$ is a $N \times N$−matrix,</li>
	<li>$B$ is a $N\times M$ control operator, $\,M \leq N$,</li>
	<li>$\nu$ is a parameter living in a compact set, $\,\mathcal{N}$ of $\mathbb{R}^d$</li>
</ul>
<p>Assumptions:</p>
<ul>
	<li>the system is (uniform) controllable for all $\nu \in N$,</li>
	<li>system dimension $\mathcal{N}$ is large</li>
</ul>
<h3>The greedy approach</h3>
<p>$X$ – a Banach space
$K\subset X$ – a compact subset.
The method approximates $K$ by a a series of finite dimensional linear spaces $V_n$ (a <strong>linear method</strong>).</p>
<h5 style="color:green">A general greedy algorithm</h5>
<ul><li><strong>The first step</strong>
Choose $x_1 \in K$ such that $$ { {\| x_1 \|}_{X}} = \max_{x \in K} { {\| x \|}_{X}} $$</li>
<li><strong>The general step</strong>
Having found $x_1 .. x_n$, denote

$$
V_n={\rm span} \{x_1, \ldots,x_n\}
$$

Choose the next element

$$
x_{n+1}:= \arg\!\max_{x \in K} {\rm dist}(x, V_n)
$$
</li>
<li><strong>The algorithm stops</strong> when $\sigma_n(K):= \max_{x \in K} {\rm dist}(x, V_n) $ becomes less than the given tolerance $\varepsilon$.</li>


<strong>The Kolmogorov $n$ width</strong>, $d_n(K) $ measures optimal approximation of $K$ by a $n$-dimensional subspace.
$$
d_n(K):=\inf_{\dim Y=n} \sup_{x\in K} \, \inf_{y\in Y} { {\| x-y \|}_{X}}\,.
$$
<strong>The greedy approximation rates have same decay as the Kolmogorov widths.</strong>

<img src="http://cmc.deusto.es/wp-content/uploads/2017/02/greedyControlFig1.jpg" alt="Evolution of last 5 system components and the approximate control" width="562" height="446" class="size-full wp-image-349" srcset="https://cmc.deusto.eus/wp-content/uploads/2017/02/greedyControlFig1.jpg 562w, https://cmc.deusto.eus/wp-content/uploads/2017/02/greedyControlFig1-300x238.jpg 300w, https://cmc.deusto.eus/wp-content/uploads/2017/02/greedyControlFig1-242x192.jpg 242w" sizes="(max-width: 562px) 100vw, 562px" />

Figure1: Evolution of a) last 5 system components and  b) the approximate control for $\nu=\pi$.

<h3>Greedy control</h3>
Each control can be uniquely determined by the relation
$$
u_{\bf \nu} = {\bf B}^\ast e^{(T-t){\bf A}_{\bf \nu}^\ast}  \varphi^0_{\bf \nu},
$$
where $\varphi^0_{\bf \nu}\in { {\bf R}}^N$ is the unique  minimiser of a  quadratic functional associated to the adjoint problem.
This minimiser can  be expressed as the solution of the linear system 
\begin{equation*}
\label{phi^0}
\Lambda_{\bf \nu}   \varphi^0_{\bf \nu} = {\sf x}^1 -  e^{T{\bf A}_{\bf \nu}} {\sf x}^0,
\end{equation*}
where $\Lambda_{\bf \nu} $  is the controllability Gramian 
\begin{equation*}
\Lambda_{\bf \nu}=\int_0^T e^{(T-t){\bf A}_{\bf \nu}}{\bf B}_{\bf \nu} {\bf B}_{\bf \nu}^\ast e^{(T-t){\bf A}_{\bf \nu}^\ast} dt\,.
\end{equation*}

Perform a greedy algorithm to the manifold $\varphi^0({\cal N})$:
$$
\nu \in {\cal N} \to \varphi^0_\nu \in  \bf{R}^N\,.
$$

The (unknown) quantity ${\rm dist} (\varphi^0_{\bf \nu}, \varphi_i^0)$ to be maximised by the greedy algorithm is replaced by a  <strong>surrogate</strong>:

$$
\begin{aligned}
{\rm dist} (\varphi^0_{\bf \nu}, \varphi_i^0)
&amp;\sim {\rm dist} (\Lambda_{\bf \nu}  \varphi^0_{\bf \nu}, \Lambda_{\bf \nu}  \varphi^0_i) \cr
&amp;= {\rm dist} ({\sf x}^1 -  e^{T{\bf A}_{\bf \nu}} {\bf x}^0, \Lambda_{\bf \nu}  \varphi^0_i) \,.\cr
\end{aligned}
$$

<img src="http://cmc.deusto.es/wp-content/uploads/2017/02/surrogate.png" alt="Surrogate" />
<strong>The greedy control algorithm  results in an optimal decay of the  approximation rates.</strong>
<h3>Numerical examples</h3>
<h5>Wave equation</h5>
We consider the system (1) with:

$$
  {\bf A}=\left(\begin{matrix}
  {\bf 0} &amp; -I\cr
  { \nu} ( N/2+1)^2 \tilde {\bf A} &amp; {\bf 0}\cr
  \end{matrix}\right),
$$
$$
    \tilde {\bf A}=\left(\begin{matrix}
    2 &amp; -1&amp; 0 &amp; \cdots &amp; 0\cr
    -1&amp;  2 &amp; -1&amp;  \cdots &amp; 0\cr
    0 &amp; -1&amp;  2 &amp;  \cdots &amp; 0\cr
    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\cr
        0 &amp;0&amp;  0 &amp; \cdots  &amp;2\cr
    \end{matrix}\right),
    \ \
     {\bf B}=\left(\begin{matrix}
       0\cr
       0\cr
       \vdots\cr
       0\cr
       1\cr
     \end{matrix}\right).
$$
The system corresponds to the discretisation of the wave equation problem with the control on the right boundary:

$$
\begin{equation}
		\begin{cases}
     	\partial_{tt} v -  \nu \partial_{xx} v=0 \ \ (t, x) \in \langle 0, T \rangle  \times \langle 0,1 \rangle \\
     	v(t, 0)=0 \ \ v(t, 1)=u(t) \\
     	v(0, x)=v_0 \ \ \partial_t v(x, 0)=v_1 
     	\end{cases}
\end{equation}
$$
We take the following values:
  $$T=3,\;  N=50,\;
  v_0=\sin(\pi x), \; v_1=0,\;
  x^1=0
  $$

  $$
  \nu \in [1,10]  = \mathcal{N}
  $$

The greedy control has been applied with $\varepsilon=0.5$ and the uniform discretisation of ${\cal N}$ in $k=100$ values.
The offline algorithm stopped after 24 iterations.
<strong>The 20-D controls manifold is  well approximated by a 10-D subspace:</strong>

<img src="https://cmc.deusto.eus/wp-content/uploads/2017/04/wave-online-3D-nu.jpg" alt="Evolution of the solution to the semi-discretised problem" width="562" height="446" class="size-full wp-image-350" /> 
Figure2: Evolution of the solution to the semi-discretised problem (2) governed by the approximate control $u_\nu^\star$ for $\nu=\pi$.

<h5>Heat equation</h5>
For  $   {\bf A}=( N+1)^2\tilde{\bf A}    $, with $\tilde{\bf A}$ given by:

$$
    \tilde {\bf A}=\left(\begin{matrix}
    2 &amp; -1&amp; 0 &amp; \cdots &amp; 0\cr
    -1&amp;  2 &amp; -1&amp;  \cdots &amp; 0\cr
    0 &amp; -1&amp;  2 &amp;  \cdots &amp; 0\cr
    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\cr
        0 &amp;0&amp;  0 &amp; \cdots  &amp;2\cr
    \end{matrix}\right)
$$

and the control operator $ {\bf B}= (0, \ldots,0, ( N+1)^2 )^\top,$ the system (1) corresponds to the space-discretisation of the heat equation problem with $N$ internal grid points and  the control on the right boundary:

$$
\begin{equation}
  \begin{cases}
     \partial_{t} v -  \nu \partial_{xx} v=0 \ \ (t, x) \in \langle 0, T \rangle  \times \langle 0, 1\rangle\\
     v(t, 0)=0 \ \ v(t, 1)=u_\nu(t),\\
      v(0, x)=v_0 \\
    \end{cases}
\end{equation}
$$

The parameter $\nu$ represents the diffusion coefficient and is supposed to range within the set $\mathcal{N}=[1,2]$.  
The system satisfies the Kalman's rank condition for any $\nu\in {\cal N}$ and any target time $T$.     
We aim to control the system  from the initial state $v_0(x)=\sin(\pi x)$ to zero in time $T=0.1$. 
The greedy control algorithm has been  applied for the system of dimension $N=50$ with  $\varepsilon=0.0001$, and the uniform discretisation of ${\cal N}$ in $k=100$ values. 
The algorithm stops after only three iterations.
<img src="https://cmc.deusto.eus/wp-content/uploads/2017/03/heat-online-3D.jpg" alt="Evolution of the solution to the semi-discretised problem for heat equation" width="562" class="size-full wp-image-350" /> Figure3: Evolution of the solution to the semi-discretised problem (3) governed by the approximate control $u_\nu^\star$ for $\nu=\sqrt 2$.


</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>Idriss Mazari is a visiting member of the DyCon team, is currently a PhD student of Yannick Privat and Grégoire Nadin in Paris Sorbonne Université. His works focus on shape and parametric optimization for reaction-diffusion equations. His main focus is the understanding of the influence of spatial heterogeneity on population dynamics.He mainly studies existence theorems for non-linear shape optimization problems, or quantitative results regarding spectral optimization. For instance, he investigated the maximal population size problem or the optimal survival of species problem.

In my research, I consider control systems and how they can be realized in numerical simulations. Particularly, I’m interested in infinite dimensional and differential-algebraic systems like the incompressible Navier-Stokes equation. In view of numerical implementations, I also investigate model reduction techniques for control systems.

Alexandre Santos Francisco holds a degree in Mechanical Engineering and a PhD degree in Nuclear Engineering. He is Professor of Fluid Mechanics at the Universidade Federal Fluminense in Brazil. On the next two months he will be a Visiting Professor at the ERC Advanced Grant project DyCon under the supervision of Prof. Enrique Zuazua (FAU, University of Deusto and Universidad Autónoma de Madrid). His main research interests are porous media, computational mathematics, and computational fluid mechanics.



&lt;p&gt;&lt;a href="https://cmc.deusto.eus/Carlos-Esteve-Yague/"&gt;&lt;strong&gt;Carlos Esteve Yagüe&lt;/strong&gt;&lt;/a&gt; holds a Postdoctoral position at the ERC Advanced Grant project DyCon under the supervision of Prof. Enrique Zuazua (UAM and DeustoTech). He earned his PhD in analysis of nonlinear parabolic partial differential equations under the supervision of Prof. Philippe Souplet (Université Paris 13). His main research interests are singularity formation for parabolic PDE, Hamilton-Jacobi equations, optimal control theory and differential games.&lt;/p&gt;

&lt;a name="NoburuSakamoto"&gt;&lt;/a&gt;Noboru Sakamoto&lt;/strong&gt; received the B.Sc. degree in mathematics from Hokkaido University and M.Sc. and Ph.D. degrees in aerospace engineering from Nagoya University, in 1991, 1993, and 1996, respectively. From 1996 until 2015, he held positions in the Graduate School of Engineering in Nagoya University. Currently, he is a Professor with the Science and Engineering of &lt;a href="http;//www.nanzan-u.ac.jp/English/index.html" target="_blank"&gt;Nanzan University&lt;/a&gt; in Nagoya, Japan. He has held a visiting research position at University of Groningen, The Netherlands, in 2005 and 2006. He received the SICE Best Paper Prizes in 1997, 2006, 2008 and 2011 and SICE Kimura Prize in 2016. His research interests include nonlinear control theory, control of chaotic systems, dynamical system theory and control applications for aerospace engineering.

&lt;strong&gt;Jérôme Lohéac&lt;/strong&gt; is a Senior Scientific Researcher at the &lt;a href="http://www.irccyn.ec-nantes.fr/en/"&gt;Institut de Recherche en Communications et Cybernétique de Nantes&lt;/a&gt;, a scientific institution linked to the &lt;a href='http://www.cnrs.fr/'&gt;CNRS&lt;/a&gt; in France. His fields of research are Swimming of microorganisms(1); Time optimal control for PDEs(2); Optimal control of finite dimensional systems with state constraints(3) and Controllability of parameter-dependent systems(4).

&lt;strong&gt;Martin Lazar&lt;/strong&gt; is a Research professor at &lt;a href='http://www.unidu.hr/' target='_blank'&gt;University of Dubrovnik&lt;/a&gt;, Croatia. His fields of research are Control of parameter dependent systems (greedy control, averaged control), optimal control of parabolic problems. Microlocal analysis; PDEs and homogenisation, velocity averaging, microlocal defect functionals (1-scale H-measures, semiclassical measures, H-distributions), and Geophysical fluid dynamics; analytical modelling in oceanography.

&lt;strong&gt;Césare Molinari&lt;/strong&gt; was PhD student in Applied Mathematics at &lt;a href='http://www.usm.cl/' target='_blank'&gt;Universidad Técnica Federico Santa María&lt;/a&gt; (Valparaíso, Chile). His scientific interests were related to numerical algorithms for maximal monotone variational inequalities and convex non-differentiable optimization. In this context, his research was focused on the design of the algorithms, on the analysis of the asymptotic properties and of the rate of convergence. This theory finds natural applications in sparse optimal control of PDEs and reconstruction of images. He was doing an internship in Control Theory under the joint supervision of professor Enrique Zuazua.

Navid Allahverdi's work focuses on simulation based engineering and application of scientific computing in engineering design and optimization.

Alejandro Pozo is a Post Doctoral researcher in Mathematics. He has a markedly applied profile, which is why he has oriented his career towards the field of technological innovation. In this sense, he understands that mathematics can add value and contribute significantly to the solution of the most diverse R &amp; D &amp; i problems.

&lt;a href='https://cmc.deusto.eus/umberto-biccari/'&gt;Umberto Biccari&lt;/a&gt;&lt;/strong&gt; is a PhD. Currently he holds a Postdoctoral position at the ERC Advanced Grant project &lt;a href='cmc.deusto.eus/dycon'&gt;DyCon&lt;/a&gt; under the supervision of &lt;a href='http://paginaspersonales.deusto.es/enrique.zuazua/'&gt;Prof. Enrique Zuazua&lt;/a&gt; (&lt;a href='https://www.uam.es/ss/Satellite/es/home.htm' target='_blank'&gt;UAM&lt;/a&gt; and &lt;a href='http://deustotech.deusto.es/cs/Satellite/ingenieria/es/deustotech' target='_blank'&gt;DeustoTech&lt;/a&gt;). In the past, he collaborated within the ERC research project &lt;a href='http://www.bcamath.org/projects/NUMERIWAVES/' target='_blank'&gt;NUMERIWAVES&lt;/a&gt;. His current research interests are related to the analysis of Partial Differential Equations, in particular from the point of view of control theory. During the years of his PhD he has been concerned with the study of controllability properties of hyperbolic (waves), parabolic (heat) and dispersive (Schrödinger) PDEs, involving non-local terms, singular inverse-square potentials, variable degenerate coefficients or dynamical boundary conditions. At the moment, he is getting interested in non-local transport problems, derived from models of collection behaviour.

&lt;strong&gt;Jesus Oroya&lt;/strong&gt; is the Software Expert in &lt;b&gt;&lt;a href='cmc.deusto.eus/dycon/'&gt;DyCon&amp;#58; Dynamic Control&lt;/a&gt;&lt;/b&gt;, the Advanced Research Project funded by the &lt;a href='https://erc.europa.eu/'&gt;European Research Council(ERC)&lt;/a&gt;. He got a BSc in Physics from the &lt;a href='https://www.ehu.eus/en/web/guest/en-home'&gt;University of the Basque Country&lt;/a&gt;, specializing in physical simulation. He has worked at CIC Nanogune for the company SIMUNE, looking for a method of optimization of atomic bases for calculations of electronic structure in the SIESTA code. In 2017, he worked at Accenture, managing and analyzing databases. He has also developed business applications for Liberty Seguros. Currently he is studying a MSc in Computational Engineering and Intelligent Systems in the &lt;a href='https://www.ehu.eus/en/web/guest/en-home'&gt;University of the Basque Country&lt;/a&gt;.

&lt;a href='http://deus.to/zuazua'&gt;&lt;strong&gt;Enrique Zuazua&lt;/strong&gt;&lt;/a&gt; is the Director of the Chair of Computational Mathematics at &lt;a class='rsst' href='http://deustotech.deusto.es/' target='_blank'&gt;DeustoTech&lt;/a&gt; Laboratory in the University of Deusto, Bilbao (Basque Country-Spain) where he leads the research team funded by the European Research Council Advanced Grant “&lt;a class='rsst' href='http://enzuazua.net/dycon/' target='_blank'&gt;DYCON; Dynamic Control&lt;/a&gt;”. He is also a Professor of the &lt;a class='rsst' href='http://verso.mat.uam.es/web/index.php/es/' target='_blank'&gt;Department of Mathematics&lt;/a&gt; Universidad Autónoma de Madrid where he holds a Chair in Applied Mathematics since 2001.

&lt;strong&gt;Alejandro B. Aceves&lt;/strong&gt; is a Professor of Applied Mathematics and Department Chair at the &lt;a href='http://www.smu.edu/dedman' target='_blank'&gt;Southern Methodist University&lt;/a&gt; (Dallas, United States). His research interests are related to Nonlinear Optics and Nonlinear Wave Propagation. Namely, he is now working on modeling of nonlinear optical pulse propagation in waveguide gratings, code development to solve Maxwell's equations in nonlinear dielectrics, noise effect due to manufacturing imperfections in the problem of light localization in nonlinear fiber arrays, modeling of intense laser light propagation in air, studying the spread of diseases, and the effect of thermal baths in dimers and oscillator chains.

&lt;strong&gt;&lt;a href='https://cmc.deusto.eus/victor-hernandez-santamaria'&gt;Víctor Hernández-Santamaría&lt;/a&gt;&lt;/strong&gt; earned his Ph.D. degree in the department of automatic control in &lt;a href='http://www.cinvestav.mx/' target='_blank'&gt;CINVESTAV&lt;/a&gt; (Mexico), under the supervision of Luz de Teresa (Instituto de Matemáticas, UNAM, México) and Alexander Poznyak (CINVESTAV). His research interests are related to control problems for coupled parabolic equations, especially, those arising in the insensitizing control and hierarchic control problems, both from a theoretical and numerical point of view. He holded a Postdoctoral position at the &lt;a href='http://cmc.deusto.eus/dycon'&gt;ERC DyCon Advanced Grant project&lt;/a&gt; under the supervision of &lt;a href='http://paginaspersonales.deusto.es/enrique.zuazua/'&gt;Prof. Enrique Zuazua&lt;/a&gt;.

&lt;strong&gt;&lt;a href='https://cmc.deusto.eus/jose-vicente-lorenzo/'&gt;José Vicente Lorenzo&lt;/a&gt;&lt;/strong&gt; was a PhD student at &lt;a href='http://www.uam.es' target='_blank'&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. He finished his MSc Industrial Engineering at the &lt;a href='http://en.us.es/eng' target='_blank'&gt;University of Seville&lt;/a&gt; in 2014. He has worked at &lt;a href='https://home.cern/' target='_blank'&gt;CERN&lt;/a&gt; in Superconducting Magnets group (Geneva, Switzerland) and Spanish organism for Research in Energy and Environment &lt;a href='http://www.ciemat.es/' target='_blank'&gt;CIEMAT&lt;/a&gt;.

&lt;strong&gt;&lt;a href='https://ananavarroquiles.wordpress.com'&gt;Ana Navarro&lt;/a&gt;&lt;/strong&gt; is a PhD. She held a Postdoctoral position at the ERC Advanced Grant project &lt;a href='cmc.deusto.eus/dycon'&gt;DyCon&lt;/a&gt; under the supervision of &lt;a href='http://paginaspersonales.deusto.es/enrique.zuazua/'&gt;Prof. Enrique Zuazua&lt;/a&gt; (&lt;a href='https://www.uam.es/ss/Satellite/es/home.htm' target='_blank'&gt;UAM&lt;/a&gt; and &lt;a href='http://deustotech.deusto.es/cs/Satellite/ingenieria/es/deustotech' target='_blank'&gt;DeustoTech&lt;/a&gt;). Before that, she had a Predoctoral position at the &lt;a href='https://www.upv.es/index-en.html' target='_blank'&gt;Instituto Universitario de Matemática Multidisciplinar&lt;/a&gt;, financed by the &lt;a href='http://www.imm.upv.es' target='_blank'&gt;Universitat Politècnica de València&lt;/a&gt;. Her main research interest is the study from a probabilistic point of view of different problems based on differential equations (ordinary or partial) with uncertainty in its formulation. Now, she is concerned to connect her recent research with Control Theory.

&lt;strong&gt;&lt;a href='https://cmc.deusto.eus/dario-pighin/'&gt;Dario Pighin&lt;/a&gt;&lt;/strong&gt; is a PhD Student at &lt;a href='http://www.uam.es' target='_blank'&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. He earned both the Bachelor's Degree and the Master's Degree in Mathematics at the &lt;a href='https://web.uniroma2.it/home/newlang/english' target='_blank'&gt;University of Rome Tor Vergata (Rome 2)&lt;/a&gt;. His &lt;a href='https://drive.google.com/file/d/0B1dHVFQGZucNajBwM2JqYkk5SkE/view?usp=sharing' target='_blank'&gt;Master's thesis&lt;/a&gt; is about the Turnpike Property in Optimal Control Theory. Currently, he is studying for his PhD in Control Theory, under the joint supervision of professor Enrique Zuazua.

&lt;strong&gt;Alejandro Cunillera&lt;/strong&gt; was a PhD Student at &lt;a href='http://www.uam.es' target='_blank'&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. He earned a Bachelor's Degree in Mathematics and Physics at the &lt;a href='https://www.ucm.es/english' target='_blank'&gt;Universidad Complutense de Madrid&lt;/a&gt; and a Master's Degree in Physics of Complex Systems at &lt;a href='https://ifisc.uib-csic.es/en/'&gt;IFISC, Instituto de Física Interdisciplinar y Sistemas Complejos (CSIC-UIB)&lt;/a&gt;.

&lt;strong&gt;Borjan Geshkovski&lt;/strong&gt;&lt;/a&gt; is a PhD student at &lt;a href='http://www.uam.es' target='_blank'&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. He earned a Master's degree in Mathematics at the &lt;a href='https://www.u-bordeaux.com/' target='_blank'&gt;University of Bordeaux&lt;/a&gt;. He first did an internship on parabolic variational inequalities, optimal control of obstacles and free boundary problems under the supervision of Professor Enrique Zuazua, before joining the team as a PhD student later.

&lt;strong&gt;Domènec Ruiz&lt;/strong&gt; is a PhD Student at &lt;a href='http://www.uam.es' target='_blank'&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. He earned a BSc in Mathematics and a BSc in Physics at the &lt;a href='https://www.ucm.es/english' target='_blank'&gt;Universitat Autònoma de Barcelona&lt;/a&gt;. Later he earned and a MSc in Applied Mathematics in an Erasmus Mundus program between the &lt;a href='http://www.univaq.it/en/index.php?&amp;lang_s=en'&gt;Università degli Studi dell'Aquila (UAQ)&lt;/a&gt; and &lt;a href='https://www.uni-hamburg.de/en.html'&gt;Universität Hamburg (UH)&lt;/a&gt;. His master thesis was about asymptotic analysis and control of kinetic Cucker-Smale models. Currently, he is studying for a PhD in Control Theory under the supervision of Professor Enrique Zuazua.

&lt;strong&gt;Charlotte Rodriguez&lt;/strong&gt; is a PhD Student at &lt;a href='https://www.fau.eu/' target='_blank'&gt;Friedrich-Alexander-University&lt;/a&gt;, Erlangen-Nurnberg, Germany. She finished her Master studies in Mathematics (Analysis, Partial Differential Equations, Probability) at the &lt;a href='https://www.u-bordeaux.com/'&gt;University of Bordeaux&lt;/a&gt; in 2018. Since then she has been working in Mathematical network modelling of nonlinear fluid structure interaction, model reduction and uncertainty quantification (Part of Marie Sklodowska-Curie ITN ConFlex) under the supervision of Prof Gunter Leugering. She was in Bilbao for a 2 month internship under the supervision of Professor Enrique Zuazua, working in Control theory.

&lt;strong&gt;Dongnam Ko&lt;/strong&gt; is a Postdoctoral researcher at the ERC Advanced Grant project &lt;a href='cmc.deusto.eus/dycon'&gt;DyCon&lt;/a&gt; under the supervision of &lt;a href='http://paginaspersonales.deusto.es/enrique.zuazua/'&gt;Prof. Enrique Zuazua&lt;/a&gt; (&lt;a href='https://www.uam.es/ss/Satellite/es/home.htm' target='_blank'&gt;Universidad Autónoma de Madrid&lt;/a&gt; and &lt;a href='http://deustotech.deusto.es/cs/Satellite/ingenieria/es/deustotech' target='_blank'&gt;DeustoTech&lt;/a&gt;). Before that, he was a Post-Doctoral researcher at the &lt;a href='http://hyke.snu.ac.kr/'&gt;Research Institute of Mathematics&lt;/a&gt;, &lt;a href='http://www.useoul.edu/'&gt;Seoul National University&lt;/a&gt;, Korea. His main research interests are the emergent dynamics of coupled particle networks, the Stochastic particle-path analysis on mean-field models and the numerical methods on kinetic dynamics.

&lt;strong&gt;Yacouba SIMPORE&lt;/strong&gt; is an Associate Professor at the &lt;a href='http://www.univ-ouaga.bf/spip.php?rubrique39' target='_blank'&gt;Université Ouaga 1 Professeur Joseph Ki Zerbo&lt;/a&gt;, Ouagadougou, Burkina Faso, where he obtained his PhD in Optimal Control in 2016. He visited the Chair of Computational Mathematics of DeustoTech during 3 months within the Senior Visitor Program of the &lt;strong&gt;&lt;a href='devcmc.deusto.es/dycon/'&gt; ERC Advanced Grant DyCon&amp;#58; Dynamic Control&lt;/a&gt;&lt;/strong&gt;.

&lt;strong&gt;Xinliang Liu&lt;/strong&gt; is a PhD Student at &lt;a href='https://www.fau.eu/' target='_blank'&gt;Shanghai Jiao Tong University&lt;/a&gt;, China. In the same university, he finished his Master studies in Applied Mathematics in 2017, with the thesis 'A variational framework to identify optimal approximation basis and its application to integral equation'. He was in Bilbao for a 2 month internship under the supervision of Professor Enrique Zuazua, working in Control theory.

Mehmet is currently an associate professor at the Université de Toulon (La Garde, France) and does his research at the Institut Mathématiques de Toulon (IMATH) -Équipe de Modélisation Numérique (MN). His fields of specialization and research interests include Non linear analysis of PDEs and Numerical analysis in fluid mechanics. Before joining the MN team, he was a postdoctoral researcher at the Basque Center for Applied Mathematics, Derio, Spain, directed by/in collaboration with Enrique Zuazua. He obtained his PhD in Applied Mathematics at the Laboratoire de Mathématiques-LAMA under the supervision of Christian Bourdarias &amp; Stéphane Gerbi, Université de Savoie (Chambéry, France) in 2010. He delivers Scientific Computing and Numerical Analysis courses at the Ecole d'Ingénieurs de l'Université de Toulon which offers the possibility to get high level skills.

Yuhua is a fourth-year Ph.D student in Department of Mathematics at University of Wisconsin-Madison. Her interests lie in uncertainty quantification in kinetic theory and Machine learning.

Swann MARX got his PhD in GIPSA-lab (Grenoble, France) under the supervision of Christophe Prieur and Vincent Andrieu. During the PhD he focused on the stabilization of PDEs whose control is subject to some amplitude constraints. Currently he is a post-doctoral researcher at LAAS-CNRS (Toulouse, France), working on polynomial optimization applied to nonlinear hyperbolic PDEs and he did an internship in the DyCon project, under the supervision of Prof. Enrique Zuazua.

Carlos Castro is a professor in the Mathematics and Informatics Department of &lt;a href="http://www.caminos.upm.es/default.asp" target="_blank"&gt;ETSI Caminos, Canales y Puertos, Universidad Politécnica de Madrid&lt;/a&gt; (Spain).

Miguel Cea is a Product Director in INCLAM. Msc. and Postgraduate in Mathematics from the Universidad Autónoma de Madrid, and PhD Candidate in Mathematics on Optimal Design Problems. Extensive experience in mathematical models and numerical methods. Currently, he is the Product Director of SUAT (Unified Early Warning Service), which is defined as a SaaS service that consists of a Web platform that generates alerts and management recommendations in real time based on hydro-meteorological variables.

Sorin is a professor at the Department of Mathematics in the Faculty of Sciences at the University of Craiova, Romania. His main research directions are Control and stabilization(1), Partial derivative equations(2) and Numerical analysis(3). The main purpose of his research activity is to show that innovative mathematical reasoning can lead to new perspectives on the studied phenomena and a deeper understanding of more and more complex physical models. His most important scientific contributions include the study of complex systems that couples vibrations of different natures (the so-called hybrid systems) in terms of their spectral properties, controllability, stabilization and existence of periodic solutions.

&lt;a href="http://math.univ-bpclermont.fr/~munch/" target="_blank"&gt;Arnaud&lt;/a&gt; is a professor at &lt;a href="https://en.uca.fr/english-version/" target="_blank"&gt;Clermont Auvergne University&lt;/a&gt;, Laboratoire de mathématiques Blaise Pascal, Clermont-Ferrand, France.

&lt;a href="https://scholar.google.com/citations?user=5EexYDAAAAAJ&amp;hl=es"&gt;Mihaela&lt;/a&gt; is a professor in Universidad Complutense de Madrid, Spain.

Aitziber Ibáñez was a PhD student at &lt;a href="http://www.uam.es/UAM/Home.htm?language=en" target="_blank"&gt;Universidad Autónoma de Madrid (UAM)&lt;/a&gt;. She finished her Bachelor’s degree in Mathematics at the &lt;a href="https://www.ehu.eus/en/web/guest/en-home" target="_blank"&gt;University of the Basque Country (UPV/EHU)&lt;/a&gt; in June 2009. She studied Master’s degree in Computational Engineering and Intelligent Systems, also in (UPV/EHU).

Emmanuel Trélat matriculated at École normale supérieure de Cachan (mathematics) in 1995 and obtained the agrégation in 1998. In 2000, he obtained a doctorate under the direction of Bernard Bonnard at the University of Burgundy at Dijon with thesis entitled Étude asymptotique et transcendance de la fonction valeur en contrôle optimal; catégorie log-exp en géométrie sous-Riemannienne dans le cas Martinet (Asymptotic study and transcendence of the value function in optimal control; category log-exp in sub-Riemannian geometry in the Martinet case).[1] In 2001 he was appointed a lecturer at the University of Paris-Sud, where he obtained in 2005 his habilitation Contrôle en dimension finie et infinie (Control in finite and infinite dimension). In 2006 he was appointed a professor at the University of Orleans. Since 2011 he has been a professor at Pierre and Marie Curie University at the Laboratoire Jacques-Louis Lions. Since 2015 he has been director of the Fondation sciences mathématiques de Paris

Computational Science and Engineering Division, Oak Ridge National Laboratory (Tennessee, United states).

University of Chile, Centro de Modelamiento Matemático (CMM).

Jiamin is currently a Post Doctoral researcher in Paris and Madrid, under the direction of Enrique Zuazua and Emmanuel Trélat, under the ANR-ICON Project (Control Interactions, Partial Differential Equations, and Numerical Analysis).

Former Marie S. Curie fellow, Research Center on Animal Cognition, Université Paul Sabatier, Toulouse (France).

&lt;strong&gt;Azahar Monge&lt;/strong&gt;&lt;/a&gt; holds a Postdoctoral position at the ERC Advanced Grant project DyCon under the supervision of &lt;a href="http://paginaspersonales.deusto.es/enrique.zuazua/" target="_blank"&gt;Prof. Enrique Zuazua&lt;/a&gt; (UAM and DeustoTech). Before that, she earned her PhD in Numerical Analysis at the Centre for Mathematical Sciences, &lt;a href="http://www.maths.lu.se/english/" target="_blank"&gt;Lund University&lt;/a&gt; (Sweden) under the supervision of Prof. Philipp Birken. Her thesis was focused on the numerical aspects around the partitioned approach for the simulation of time-dependent thermal fluid-structure interaction. Earlier, she was awarded an Erasmus Mundus scholarship to participate in the &lt;a href="http://www.mathmods.eu/" target="_blank"&gt;MSc programme MATHMODS&lt;/a&gt; (Mathematical Modelling in Engineering - Theory, Numerics, Applications). Her main research interests are domain decomposition methods, coupled problems, PDEs and time adaptive multirate time integration methods.&lt;/p&gt;&lt;ul class="list-nomarker"&gt;&lt;li&gt;&lt;i class="fa fa-envelope fa-blue"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href="mailto:azahar.monge@deusto.es"&gt;azahar.monge@deusto.es&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;i class="fa fa-phone fa-blue"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href="tel:34944139003,3282"&gt;(+34) 944 139 003 Ext. 3282&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;strong&gt;Jose Matias&lt;/strong&gt; – &lt;a href="https://www.ulisboa.pt/" target="_blank"&gt;Universidade de Lisboa&lt;/a&gt;, Lisboa, Portugal.

&lt;strong&gt;Marco Morandotti&lt;/strong&gt; &amp;#8211; &lt;a href="http://www.disma.polito.it/" target="_blank"&gt;Dipartimento di Scienze Matematiche&lt;/a&gt;, Politecnico di Torino, Italy.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Email &lt;a href="mailto:marco.morandotti@polito.it" target="_blank"&gt;marco.morandotti@polito.it&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Web page &lt;a href="http://marcomorandotti.weebly.com/" target="_blank"&gt;http://marcomorandotti.weebly.com&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

Mohammed Nor FRIOUI is a Phd student at Abou Bekr Belkaid University of Tlemcen, Algeria. He obtained a scholarship at the Autonomous university of Madrid in the framework of Erasmus program for a research and training intensification with professor Enrique Zuazua from march to july 2019.

&lt;p&gt;&lt;strong&gt;Debayan Maity&lt;/strong&gt; holds a Postdoctoral position at the ERC Advanced Grant project DyCon under the supervision of &lt;a href="http://paginaspersonales.deusto.es/enrique.zuazua/" target="_blank"&gt;Prof. Enrique Zuazua&lt;/a&gt; (UAM and DeustoTech). Before that, he was a Post-Doctoral researcher at the Institut de Mathématiques de BordeauxI under the supervision of Prof. Marius Tucsnak. His main research interests are the fluid-solid interaction problems and the control of partial differential equations, namely fluid motions, population dynamics models, etc.&lt;/p&gt;

&lt;strong&gt;Thibault Liard&lt;/strong&gt; holds a Postdoctoral position at the ERC Advanced Grant project DyCon under the supervision of &lt;a href="http://paginaspersonales.deusto.es/enrique.zuazua/" target="_blank"&gt;Prof. Enrique Zuazua&lt;/a&gt; (UAM and DeustoTech). He earned his PhD in observation and control for some conservative systems under the supervision of Alain Haraux and Yannick Privat. His previous Postdoctoral positions were focused on the study of strongly coupled PDE/ODE systems where the PDE consists of a system of conservation laws and the ODE represents the trajectory of particles. Therefore, his main research interests are control theory, calculus of variations, hybrid PDE/ODE, scalar conservation laws with constraints and Wave-front tracking methods.&lt;/p&gt;
</code></pre>
</div>


    <!-- Footer -->
<footer>
  <hr>
  <div class="container">
    <div class="row">
      <ul class="list-inline text-center">
        <li style="margin-right: 50px;">
          <img style="width: 250px;" src="/DyCon-Blog/img/logos/logo_DyCon.png " alt="">
        </li>
        <li style="padding-bottom: 5px;">
          <img style="width: 230px;" src="/DyCon-Blog/img/logos/logo_CCM_subDerecha_v002.png " alt="">
        </li>
      </ul>
    </div>
  </div>
</footer>

</body>
</html>
